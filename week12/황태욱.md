# State management

_Note_

If you have written a mobile app using Flutter and wonder why your app's state is lost on a restart, check out [Restore state on Android](https://docs.flutter.dev/platform-integration/android/restore-state-android) or [Restore state on iOS](https://docs.flutter.dev/platform-integration/ios/restore-state-ios).

_정보_

만약 Flutter로 모바일 앱을 개발하면서 앱의 상태가 재시작 시에 왜 사라지는지 궁금하다면, Android에서의 상태 복원 또는 iOS에서의 상태 복원에 대해 확인해 보세요.

_If you are already familiar with state management in reactive apps, you can skip this section, though you might want to review the [list of different approaches](https://docs.flutter.dev/data-and-backend/state-mgmt/options)._

만약 이미 반응형 앱의 상태 관리에 대해 익숙하다면 이 섹션을 건너뛰어도 좋습니다. 하지만 다양한 접근 방식을 검토해 보는 것도 좋을 것입니다.
![A short animated gif that shows the workings of a simple declarative state management system. This is explained in full in one of the following pages. Here it's just a decoration.](https://docs.flutter.dev/assets/images/docs/development/data-and-backend/state-mgmt/state-management-explainer.gif)

As you explore Flutter, there comes a time when you need to share application state between screens, across your app. There are many approaches you can take, and many questions to think about.

In the following pages, you will learn the basics of dealing with state in Flutter apps.

간단한 선언적 상태 관리 시스템의 작동 방식을 보여주는 짧은 애니메이션 GIF가 있습니다. 이것은 다음 페이지들 중 하나에서 자세히 설명될 것입니다. 여기서는 단순한 장식으로 사용되었습니다.
Flutter를 탐색하다 보면 앱 전반에 걸쳐 화면 간에 애플리케이션 상태를 공유해야 할 때가 옵니다. 이를 위해 사용할 수 있는 많은 접근 방식이 있으며, 생각해야 할 많은 질문이 있습니다.

다음 페이지들에서는 Flutter 앱에서 상태를 다루는 기본 사항을 배울 수 있습니다.

# Thinking declaratively
If you're coming to Flutter from an imperative framework (such as Android SDK or iOS UIKit), you need to start thinking about app development from a new perspective.

Many assumptions that you might have don't apply to Flutter. For example, in Flutter it's okay to rebuild parts of your UI from scratch instead of modifying it. Flutter is fast enough to do that, even on every frame if needed.

Flutter is _declarative_. This means that Flutter builds its user interface to reflect the current state of your app:

당신이 만약 명령형 프레임워크(예: Android SDK나 iOS UIKit)에서 Flutter로 전환하고 있다면, 앱 개발에 대해 새로운 관점에서 생각하기 시작해야 합니다.

당신이 가질 수 있는 많은 가정들이 Flutter에는 적용되지 않습니다. 예를 들어, Flutter에서는 UI의 일부를 수정하는 대신 처음부터 다시 만드는 것이 괜찮습니다. Flutter는 그것을 할 만큼 충분히 빠릅니다. 필요하다면 매 프레임마다 그렇게 할 수 있습니다.

Flutter는 **선언형**입니다. 이는 Flutter가 애플리케이션의 현재 상태를 반영하기 위해 사용자 인터페이스를 구축한다는 것을 의미합니다.
![A mathematical formula of UI = f(state). 'UI' is the layout on the screen. 'f' is your build methods. 'state' is the application state.](https://docs.flutter.dev/assets/images/docs/development/data-and-backend/state-mgmt/ui-equals-function-of-state.png)

When the state of your app changes (for example, the user flips a switch in the settings screen), you change the state, and that triggers a redraw of the user interface. There is no imperative changing of the UI itself (like `widget.setText`)—you change the state, and the UI rebuilds from scratch.

Read more about the declarative approach to UI programming in the [get started guide](https://docs.flutter.dev/get-started/flutter-for/declarative).

The declarative style of UI programming has many benefits. Remarkably, there is only one code path for any state of the UI. You describe what the UI should look like for any given state, once—and that is it.

At first, this style of programming might not seem as intuitive as the imperative style. This is why this section is here. Read on.

앱의 상태가 변경되면(예: 사용자가 설정 화면에서 스위치를 전환할 때) 상태를 변경하게 되며, 이는 사용자 인터페이스를 다시 그리게 합니다. UI 자체를 명령형으로 변경하지는 않습니다(예: `widget.setText`와 같은 것). 상태를 변경하면 UI가 처음부터 다시 빌드됩니다.

UI 프로그래밍의 선언적 접근 방식에 대해 더 알고 싶다면 시작 가이드를 읽어보세요.

UI 프로그래밍의 선언적 스타일에는 많은 이점이 있습니다. 특히, UI의 어떤 상태에도 단 하나의 코드 경로만 있습니다. 특정 상태에 대해 UI가 어떻게 보여야 하는지 한 번만 설명하면 그것으로 끝입니다.

처음에는 이러한 프로그래밍 스타일이 명령형 스타일만큼 직관적이지 않을 수 있습니다. 이것이 이 섹션이 존재하는 이유입니다. 계속 읽어보세요.

# Ephemeral vs app state

_This doc introduces app state, ephemeral state, and how you might manage each in a Flutter app._

In the broadest possible sense, the state of an app is everything that exists in memory when the app is running. This includes the app's assets, all the variables that the Flutter framework keeps about the UI, animation state, textures, fonts, and so on. While this broadest possible definition of state is valid, it's not very useful for architecting an app.

First, you don't even manage some state (like textures). The framework handles those for you. So a more useful definition of state is "whatever data you need in order to rebuild your UI at any moment in time". Second, the state that you _do_ manage yourself can be separated into two conceptual types: ephemeral state and app state.

_이 문서는 앱 상태, 일시적 상태, 그리고 Flutter 앱에서 각각을 어떻게 관리할 수 있는지 소개합니다._

가장 넓은 의미에서, 앱의 상태는 앱이 실행 중일 때 메모리에 존재하는 모든 것을 포함합니다. 여기에는 앱의 자산, Flutter 프레임워크가 UI에 대해 유지하는 모든 변수, 애니메이션 상태, 텍스처, 폰트 등이 포함됩니다. 이러한 가장 넓은 정의의 상태는 유효하긴 하지만, 앱 아키텍처를 설계하는 데에는 그다지 유용하지 않습니다.

첫째, 일부 상태(예: 텍스처)는 당신이 직접 관리하지 않습니다. 프레임워크가 이를 대신 처리합니다. 따라서 상태를 더 유용하게 정의하면 "언제든지 UI를 다시 빌드하는 데 필요한 데이터"라고 할 수 있습니다. 둘째, 당신이 직접 관리하는 상태는 개념적으로 두 가지 유형으로 나눌 수 있습니다: 일시적 상태와 앱 상태.

## Ephemeral state

## 일시적 상태

Ephemeral state (sometimes called _UI state_ or _local state_) is the state you can neatly contain in a single widget.

This is, intentionally, a vague definition, so here are a few examples.

일시적 상태(때때로 UI 상태 또는 로컬 상태라고도 함)는 단일 위젯에 깔끔하게 포함할 수 있는 상태입니다.

이것은 의도적으로 모호한 정의이므로, 몇 가지 예를 들면 다음과 같습니다.

- current page in a [`PageView`](https://api.flutter.dev/flutter/widgets/PageView-class.html)
- current progress of a complex animation
- current selected tab in a `BottomNavigationBar`

- PageView에서 현재 페이지
- 복잡한 애니메이션의 현재 진행 상태
- BottomNavigationBar에서 현재 선택된 탭

Other parts of the widget tree seldom need to access this kind of state. There is no need to serialize it, and it doesn't change in complex ways.

In other words, there is no need to use state management techniques (ScopedModel, Redux, etc.) on this kind of state. All you need is a `StatefulWidget`.

Below, you see how the currently selected item in a bottom navigation bar is held in the `_index` field of the `_MyHomepageState` class. In this example, `_index` is ephemeral state.

위젯 트리의 다른 부분에서는 이러한 종류의 상태에 접근할 필요가 거의 없습니다. 이 상태를 직렬화할 필요가 없으며, 복잡하게 변경되지도 않습니다.

다시 말해, 이러한 종류의 상태에는 상태 관리 기법(ScopedModel, Redux 등)을 사용할 필요가 없습니다. 필요한 것은 StatefulWidget뿐입니다.

아래에서 볼 수 있듯이, BottomNavigationBar에서 현재 선택된 항목은 `_MyHomepageState` 클래스의 `_index` 필드에 저장됩니다. 이 예제에서 `_index`는 일시적 상태입니다.


```dart
class MyHomepage extends StatefulWidget {
  const MyHomepage({super.key});

  @override
  State<MyHomepage> createState() => _MyHomepageState();
}

class _MyHomepageState extends State<MyHomepage> {
  int _index = 0;

  @override
  Widget build(BuildContext context) {
    return BottomNavigationBar(
      currentIndex: _index,
      onTap: (newIndex) {
        setState(() {
          _index = newIndex;
        });
      },
      // ... items ...
    );
  }
}
```

Here, using `setState()` and a field inside the StatefulWidget's State class is completely natural. No other part of your app needs to access `_index`. The variable only changes inside the `MyHomepage` widget. And, if the user closes and restarts the app, you don't mind that `_index` resets to zero.

여기에서는 `setState()`와 StatefulWidget의 `State` 클래스 내부의 필드를 사용하는 것이 매우 자연스럽습니다. 앱의 다른 부분에서는 `_index`에 접근할 필요가 없습니다. 이 변수는 오직 `MyHomepage` 위젯 내부에서만 변경됩니다. 또한, 사용자가 앱을 닫고 다시 시작해도 `_index`가 0으로 초기화되는 것에 신경 쓸 필요가 없습니다.

## App state

## 앱 상태

State that is not ephemeral, that you want to share across many parts of your app, and that you want to keep between user sessions, is what we call application state (sometimes also called shared state).

Examples of application state:

일시적이지 않고, 앱의 여러 부분에서 공유하고자 하며, 사용자 세션 사이에도 유지하고 싶은 상태를 우리는 애플리케이션 상태(때때로 공유 상태라고도 함)라고 부릅니다.

애플리케이션 상태의 예:

- User preferences
- Login info
- Notifications in a social networking app
- The shopping cart in an e-commerce app
- Read/unread state of articles in a news app

- 사용자 선호도
- 로그인 정보
- 소셜 네트워킹 앱의 알림
- 전자상거래 앱의 쇼핑 카트
- 뉴스 앱의 기사 읽음/읽지 않음 상태

For managing app state, you'll want to research your options. Your choice depends on the complexity and nature of your app, your team's previous experience, and many other aspects. Read on.

앱 상태를 관리하기 위해서는 다양한 옵션을 조사하는 것이 좋습니다. 선택은 앱의 복잡성과 특성, 팀의 이전 경험, 그리고 기타 여러 요인에 따라 달라질 수 있습니다. 계속 읽어보세요.
## There is no clear-cut rule

## 명확한 규칙은 없습니다

To be clear, you _can_ use `State` and `setState()` to manage all of the state in your app. In fact, the Flutter team does this in many simple app samples (including the starter app that you get with every `flutter create`).

It goes the other way, too. For example, you might decide that—in the context of your particular app—the selected tab in a bottom navigation bar is _not_ ephemeral state. You might need to change it from outside the class, keep it between sessions, and so on. In that case, the `_index` variable is app state.

There is no clear-cut, universal rule to distinguish whether a particular variable is ephemeral or app state. Sometimes, you'll have to refactor one into another. For example, you'll start with some clearly ephemeral state, but as your application grows in features, it might need to be moved to app state.

For that reason, take the following diagram with a large grain of salt:

명확히 하자면, 앱의 모든 상태를 관리하기 위해 `State`와 `setState()`를 사용할 수 있습니다. 실제로, Flutter 팀은 많은 간단한 앱 샘플(모든 `flutter create`로 생성되는 시작 앱 포함)에서 이렇게 합니다.

반대로, 특정 앱의 맥락에서는 BottomNavigationBar에서 선택된 탭이 일시적 상태가 아닐 수도 있습니다. 클래스 외부에서 변경해야 하거나, 세션 사이에 유지해야 할 수도 있습니다. 이 경우 `_index` 변수는 앱 상태가 됩니다.

특정 변수가 일시적 상태인지 앱 상태인지 구별하는 명확하고 보편적인 규칙은 없습니다. 때때로, 하나의 상태를 다른 상태로 리팩토링해야 할 수도 있습니다. 예를 들어, 처음에는 분명히 일시적 상태로 시작했지만, 애플리케이션이 기능이 늘어남에 따라 앱 상태로 이동해야 할 수도 있습니다.

이러한 이유로, 다음 다이어그램을 너무 절대적으로 받아들이지 마세요.

![A flow chart. Start with 'Data'. 'Who needs it?'. Three options: 'Most widgets', 'Some widgets' and 'Single widget'. The first two options both lead to 'App state'. The 'Single widget' option leads to 'Ephemeral state'.](https://docs.flutter.dev/assets/images/docs/development/data-and-backend/state-mgmt/ephemeral-vs-app-state.png)

When asked about React's setState versus Redux's store, the author of Redux, Dan Abramov, replied:

React의 `setState`와 Redux의 `store`에 대해 질문을 받았을 때, Redux의 저자 Dan Abramov는 다음과 같이 답했습니다:

> "The rule of thumb is: [Do whatever is less awkward](https://github.com/reduxjs/redux/issues/1287#issuecomment-175351978)."

> “일반적인 규칙은: 더 덜 어색한 것을 하라.”

In summary, there are two conceptual types of state in any Flutter app. Ephemeral state can be implemented using `State` and `setState()`, and is often local to a single widget. The rest is your app state. Both types have their place in any Flutter app, and the split between the two depends on your own preference and the complexity of the app.

요약하자면, 모든 Flutter 앱에는 두 가지 개념적인 상태 유형이 있습니다. 일시적 상태는 `State`와 `setState()`를 사용하여 구현할 수 있으며, 일반적으로 단일 위젯에 국한됩니다. 나머지는 앱 상태입니다. 두 가지 상태 유형 모두 Flutter 앱에서 필요하며, 이들 간의 구분은 자신의 선호와 앱의 복잡성에 따라 달라집니다.

# Simple app state management

Now that you know about [declarative UI programming](https://docs.flutter.dev/data-and-backend/state-mgmt/declarative) and the difference between [ephemeral and app state](https://docs.flutter.dev/data-and-backend/state-mgmt/ephemeral-vs-app), you are ready to learn about simple app state management.

On this page, we are going to be using the `provider` package. If you are new to Flutter and you don't have a strong reason to choose another approach (Redux, Rx, hooks, etc.), this is probably the approach you should start with. The `provider` package is easy to understand and it doesn't use much code. It also uses concepts that are applicable in every other approach.

That said, if you have a strong background in state management from other reactive frameworks, you can find packages and tutorials listed on the [options page](https://docs.flutter.dev/data-and-backend/state-mgmt/options).

이제 선언적 UI 프로그래밍과 일시적 상태와 앱 상태의 차이점에 대해 알게 되었으니, 간단한 앱 상태 관리에 대해 배울 준비가 되었습니다.

이 페이지에서는 `provider` 패키지를 사용할 것입니다. 만약 Flutter를 처음 사용하고 다른 접근 방식(예: Redux, Rx, hooks 등)을 선택할 강력한 이유가 없다면, 아마도 이 방법으로 시작하는 것이 좋습니다. `provider` 패키지는 이해하기 쉽고 코드가 많지 않습니다. 또한, 모든 다른 접근 방식에서도 적용할 수 있는 개념을 사용합니다.

그렇다고 하더라도, 다른 반응형 프레임워크에서 상태 관리에 대한 강력한 배경이 있다면, 옵션 페이지에서 패키지와 튜토리얼을 찾아볼 수 있습니다.

## Our example


![An animated gif showing a Flutter app in use. It starts with the user on a login screen. They log in and are taken to the catalog screen, with a list of items. The click on several items, and as they do so, the items are marked as "added". The user clicks on a button and gets taken to the cart view. They see the items there. They go back to the catalog, and the items they bought still show "added". End of animation.](https://docs.flutter.dev/assets/images/docs/development/data-and-backend/state-mgmt/model-shopper-screencast.gif)

For illustration, consider the following simple app.

The app has two separate screens: a catalog, and a cart (represented by the `MyCatalog`, and `MyCart` widgets, respectively). It could be a shopping app, but you can imagine the same structure in a simple social networking app (replace catalog for "wall" and cart for "favorites").

The catalog screen includes a custom app bar (`MyAppBar`) and a scrolling view of many list items (`MyListItems`).

Here's the app visualized as a widget tree.

예를 들어, 다음과 같은 간단한 앱을 고려해 보세요.

이 앱에는 두 개의 별도의 화면이 있습니다: 카탈로그와 장바구니 (각각 MyCatalog와 MyCart 위젯으로 표현됩니다). 이 앱은 쇼핑 앱일 수 있지만, 같은 구조를 간단한 소셜 네트워킹 앱에서도 상상할 수 있습니다 (카탈로그를 "벽"으로, 장바구니를 "즐겨찾기"로 교체해 보세요).

카탈로그 화면에는 사용자 정의 앱 바(MyAppBar)와 많은 리스트 항목을 스크롤할 수 있는 뷰(MyListItems)가 포함되어 있습니다.

다음은 위젯 트리로 시각화된 앱입니다.

![A widget tree with MyApp at the top, and  MyCatalog and MyCart below it. MyCart area leaf nodes, but MyCatalog have two children: MyAppBar and a list of MyListItems.](https://docs.flutter.dev/assets/images/docs/development/data-and-backend/state-mgmt/simple-widget-tree.png)

So we have at least 5 subclasses of `Widget`. Many of them need access to state that "belongs" elsewhere. For example, each `MyListItem` needs to be able to add itself to the cart. It might also want to see whether the currently displayed item is already in the cart.

This takes us to our first question: where should we put the current state of the cart?

따라서 우리는 최소한 5개의 `Widget` 하위 클래스를 가지고 있습니다. 이들 중 많은 위젯은 "다른 곳에 속하는" 상태에 접근할 필요가 있습니다. 예를 들어, 각 `MyListItem`은 자신을 장바구니에 추가할 수 있어야 합니다. 또한, 현재 표시된 항목이 이미 장바구니에 있는지 확인하고 싶어할 수도 있습니다.

이제 첫 번째 질문으로 넘어갑니다: 장바구니의 현재 상태를 어디에 두어야 할까요?
## Lifting state up

## 상태 올리기

In Flutter, it makes sense to keep the state above the widgets that use it.

Why? In declarative frameworks like Flutter, if you want to change the UI, you have to rebuild it. There is no easy way to have `MyCart.updateWith(somethingNew)`. In other words, it's hard to imperatively change a widget from outside, by calling a method on it. And even if you could make this work, you would be fighting the framework instead of letting it help you.

Flutter에서는 상태를 사용하는 위젯보다 위쪽에 유지하는 것이 합리적입니다.

왜일까요? Flutter와 같은 선언적 프레임워크에서는 UI를 변경하려면 UI를 다시 빌드해야 합니다. `MyCart.updateWith(somethingNew)`와 같은 방식으로 쉽게 변경할 수 없습니다. 즉, 외부에서 메서드를 호출하여 위젯을 명령형으로 변경하는 것이 어렵습니다. 그리고 이렇게 하려고 해도 프레임워크와 싸우는 것보다 프레임워크가 도와주는 방식을 사용하는 것이 좋습니다.

```dart
// BAD: DO NOT DO THIS
void myTapHandler() {
  var cartWidget = somehowGetMyCartWidget();
  cartWidget.updateWith(item);
}
```

Even if you get the above code to work, you would then have to deal with the following in the `MyCart` widget:

위의 코드가 작동하더라도, 이후에는 `MyCart` 위젯에서 다음과 같은 문제를 처리해야 할 것입니다:

```dart
// BAD: DO NOT DO THIS
Widget build(BuildContext context) {
  return SomeWidget(
    // The initial state of the cart.
  );
}

void updateWith(Item item) {
  // Somehow you need to change the UI from here.
}
```

You would need to take into consideration the current state of the UI and apply the new data to it. It's hard to avoid bugs this way.

In Flutter, you construct a new widget every time its contents change. Instead of `MyCart.updateWith(somethingNew)` (a method call) you use `MyCart(contents)` (a constructor). Because you can only construct new widgets in the build methods of their parents, if you want to change `contents`, it needs to live in `MyCart`'s parent or above.

현재 UI 상태를 고려하고 새로운 데이터를 적용해야 합니다. 이런 방식으로는 버그를 피하기 어렵습니다.

Flutter에서는 내용이 변경될 때마다 새로운 위젯을 생성합니다. `MyCart.updateWith(somethingNew)`(메서드 호출) 대신에 `MyCart(contents)`(생성자)를 사용합니다. 새로운 위젯은 오직 부모 위젯의 `build` 메서드에서만 생성할 수 있기 때문에, 내용을 변경하려면 그 내용이 `MyCart`의 부모 또는 그 위쪽에 있어야 합니다.

```dart
// GOOD
void myTapHandler(BuildContext context) {
  var cartModel = somehowGetMyCartModel(context);
  cartModel.add(item);
}
```

Now `MyCart` has only one code path for building any version of the UI.

이제 `MyCart`는 UI의 어떤 버전이든 구축할 수 있는 하나의 코드 경로만 갖게 됩니다.

```dart
// GOOD
Widget build(BuildContext context) {
  var cartModel = somehowGetMyCartModel(context);
  return SomeWidget(
    // Just construct the UI once, using the current state of the cart.
    // ···
  );
}
```

In our example, `contents` needs to live in `MyApp`. Whenever it changes, it rebuilds `MyCart` from above (more on that later). Because of this, `MyCart` doesn't need to worry about lifecycle—it just declares what to show for any given `contents`. When that changes, the old `MyCart` widget disappears and is completely replaced by the new one.

우리의 예제에서, `contents`는 `MyApp`에 있어야 합니다. `contents`가 변경될 때마다 `MyApp`에서 위로부터 `MyCart`를 다시 빌드합니다 (자세한 내용은 나중에 설명합니다). 이로 인해 `MyCart`는 라이프사이클에 대해 걱정할 필요가 없습니다. `MyCart`는 주어진 `contents`에 대해 무엇을 표시할지를 선언할 뿐입니다. `contents`가 변경되면, 기존의 `MyCart` 위젯은 사라지고 완전히 새로운 위젯으로 대체됩니다.

![Same widget tree as above, but now we show a small 'cart' badge next to MyApp, and there are two arrows here. One comes from one of the MyListItems to the 'cart', and another one goes from the 'cart' to the MyCart widget.](https://docs.flutter.dev/assets/images/docs/development/data-and-backend/state-mgmt/simple-widget-tree-with-cart.png)

This is what we mean when we say that widgets are immutable. They don't change—they get replaced.

Now that we know where to put the state of the cart, let's see how to access it.

이것이 우리가 위젯이 불변하다고 말할 때 의미하는 바입니다. 위젯은 변경되지 않고 교체됩니다.

이제 장바구니의 상태를 어디에 두어야 하는지 알았으니, 이를 어떻게 접근하는지 살펴보겠습니다.
## Accessing the state

## 상태 접근하기

When a user clicks on one of the items in the catalog, it's added to the cart. But since the cart lives above `MyListItem`, how do we do that?

A simple option is to provide a callback that `MyListItem` can call when it is clicked. Dart's functions are first class objects, so you can pass them around any way you want. So, inside `MyCatalog` you can define the following:

사용자가 카탈로그의 항목 중 하나를 클릭하면, 해당 항목이 장바구니에 추가됩니다. 그러나 장바구니는 `MyListItem` 위에 위치하므로, 어떻게 해야 할까요?

간단한 옵션은 `MyListItem`이 클릭될 때 호출할 수 있는 콜백을 제공하는 것입니다. Dart의 함수는 일급 객체이므로, 원하는 대로 전달할 수 있습니다. 따라서 `MyCatalog` 내부에서 다음과 같이 정의할 수 있습니다:

```dart
@override
Widget build(BuildContext context) {
  return SomeWidget(
    // Construct the widget, passing it a reference to the method above.
    MyListItem(myTapCallback),
  );
}

void myTapCallback(Item item) {
  print('user tapped on $item');
}
```

This works okay, but for an app state that you need to modify from many different places, you'd have to pass around a lot of callbacks—which gets old pretty quickly.

Fortunately, Flutter has mechanisms for widgets to provide data and services to their descendants (in other words, not just their children, but any widgets below them). As you would expect from Flutter, where _Everything is a Widget™_, these mechanisms are just special kinds of widgets—`InheritedWidget`, `InheritedNotifier`, `InheritedModel`, and more. We won't be covering those here, because they are a bit low-level for what we're trying to do.

Instead, we are going to use a package that works with the low-level widgets but is simple to use. It's called `provider`.

Before working with `provider`, don't forget to add the dependency on it to your `pubspec.yaml`.

To add the `provider` package as a dependency, run `flutter pub add`:

이 방법은 잘 작동하지만, 많은 다른 장소에서 수정해야 하는 앱 상태의 경우, 많은 콜백을 전달해야 하므로 금방 번거롭게 느껴질 수 있습니다.

다행히도, Flutter에는 위젯이 자손(즉, 자식뿐만 아니라 아래에 있는 모든 위젯)에게 데이터를 제공하고 서비스를 제공할 수 있는 메커니즘이 있습니다. Flutter에서는 모든 것이 위젯™이라는 점에서 이러한 메커니즘은 특별한 종류의 위젯입니다—`InheritedWidget`, `InheritedNotifier`, `InheritedModel` 등입니다. 여기에서는 이러한 메커니즘을 다루지 않을 것입니다. 왜냐하면 우리가 하려는 작업에는 다소 저수준이기 때문입니다.

대신, 저수준 위젯과 함께 작동하지만 사용하기 쉬운 패키지를 사용할 것입니다. 그것이 바로 `provider`입니다.

`provider`를 사용하기 전에, `pubspec.yaml`에 의존성을 추가하는 것을 잊지 마세요.

`provider` 패키지를 의존성으로 추가하려면, 다음 명령어를 실행하세요:

```
flutter pub add provider
```

Now you can `import 'package:provider/provider.dart';` and start building.

With `provider`, you don't need to worry about callbacks or `InheritedWidgets`. But you do need to understand 3 concepts:

이제 `package:provider/provider.dart`를 임포트하고 개발을 시작할 수 있습니다.

`provider`를 사용하면 콜백이나 `InheritedWidgets`에 대해 걱정할 필요가 없습니다. 그러나 다음 3가지 개념은 이해해야 합니다:

- ChangeNotifier
- ChangeNotifierProvider
- Consumer

## ChangeNotifier

`ChangeNotifier` is a simple class included in the Flutter SDK which provides change notification to its listeners. In other words, if something is a `ChangeNotifier`, you can subscribe to its changes. (It is a form of Observable, for those familiar with the term.)

In `provider`, `ChangeNotifier` is one way to encapsulate your application state. For very simple apps, you get by with a single `ChangeNotifier`. In complex ones, you'll have several models, and therefore several `ChangeNotifiers`. (You don't need to use `ChangeNotifier` with `provider` at all, but it's an easy class to work with.)

In our shopping app example, we want to manage the state of the cart in a `ChangeNotifier`. We create a new class that extends it, like so:

`ChangeNotifier`는 Flutter SDK에 포함된 간단한 클래스으로, 변경 사항을 구독자에게 알리는 기능을 제공합니다. 즉, 어떤 것이 `ChangeNotifier`라면, 그 변경 사항에 구독할 수 있습니다. (이는 `Observable`의 한 형태입니다.)

`provider`에서는 `ChangeNotifier`를 사용하여 애플리케이션 상태를 캡슐화할 수 있습니다. 아주 간단한 앱의 경우, 하나의 `ChangeNotifier`로 충분합니다. 복잡한 앱에서는 여러 모델과 따라서 여러 개의 `ChangeNotifier`가 필요할 수 있습니다. (`provider`와 함께 `ChangeNotifier`를 사용할 필요는 없지만, 다루기 쉬운 클래스입니다.)

우리의 쇼핑 앱 예제에서는 장바구니의 상태를 `ChangeNotifier`로 관리하고자 합니다. 다음과 같이 이를 확장하는 새로운 클래스를 만듭니다:

```dart
class CartModel extends ChangeNotifier {
  /// Internal, private state of the cart.
  final List<Item> _items = [];

  /// An unmodifiable view of the items in the cart.
  UnmodifiableListView<Item> get items => UnmodifiableListView(_items);

  /// The current total price of all items (assuming all items cost $42).
  int get totalPrice => _items.length * 42;

  /// Adds [item] to cart. This and [removeAll] are the only ways to modify the
  /// cart from the outside.
  void add(Item item) {
    _items.add(item);
    // This call tells the widgets that are listening to this model to rebuild.
    notifyListeners();
  }

  /// Removes all items from the cart.
  void removeAll() {
    _items.clear();
    // This call tells the widgets that are listening to this model to rebuild.
    notifyListeners();
  }
}
```

The only code that is specific to `ChangeNotifier` is the call to `notifyListeners()`. Call this method any time the model changes in a way that might change your app's UI. Everything else in `CartModel` is the model itself and its business logic.

`ChangeNotifier` is part of `flutter:foundation` and doesn't depend on any higher-level classes in Flutter. It's easily testable (you don't even need to use [widget testing](https://docs.flutter.dev/testing/overview#widget-tests) for it). For example, here's a simple unit test of `CartModel`:

`ChangeNotifier`에 특화된 유일한 코드는 `notifyListeners()`를 호출하는 것입니다. 모델이 앱의 UI를 변경할 수 있는 방식으로 변경될 때마다 이 메서드를 호출하세요. `CartModel`의 나머지 모든 부분은 모델 자체와 비즈니스 로직입니다.

`ChangeNotifier`는 `flutter:foundation`의 일부이며, Flutter의 더 높은 수준의 클래스에 의존하지 않습니다. 따라서 쉽게 테스트할 수 있습니다 (위젯 테스트를 사용할 필요도 없습니다). 예를 들어, `CartModel`의 간단한 단위 테스트는 다음과 같습니다:

```dart
test('adding item increases total cost', () {
  final cart = CartModel();
  final startingPrice = cart.totalPrice;
  var i = 0;
  cart.addListener(() {
    expect(cart.totalPrice, greaterThan(startingPrice));
    i++;
  });
  cart.add(Item('Dash'));
  expect(i, 1);
});
```
## ChangeNotifierProvider

`ChangeNotifierProvider` is the widget that provides an instance of a `ChangeNotifier` to its descendants. It comes from the `provider` package.

We already know where to put `ChangeNotifierProvider`: above the widgets that need to access it. In the case of `CartModel`, that means somewhere above both `MyCart` and `MyCatalog`.

You don't want to place `ChangeNotifierProvider` higher than necessary (because you don't want to pollute the scope). But in our case, the only widget that is on top of both `MyCart` and `MyCatalog` is `MyApp`.

`ChangeNotifierProvider`는 `ChangeNotifier`의 인스턴스를 자손 위젯들에게 제공하는 위젯입니다. 이는 `provider` 패키지에서 제공합니다.

`ChangeNotifierProvider`를 어디에 두어야 하는지는 이미 알고 있습니다: 그것을 접근할 필요가 있는 위젯들 위에 위치시킵니다. `CartModel`의 경우, 이는 `MyCart`와 `MyCatalog` 둘 다 위에 있어야 한다는 것을 의미합니다.

필요 이상의 높은 위치에 `ChangeNotifierProvider`를 배치하고 싶지 않습니다 (왜냐하면 범위를 오염시키고 싶지 않기 때문입니다). 하지만 우리의 경우, `MyCart`와 `MyCatalog` 둘 다 위에 위치할 수 있는 유일한 위젯은 `MyApp`입니다.

```dart
void main() {
  runApp(
    ChangeNotifierProvider(
      create: (context) => CartModel(),
      child: const MyApp(),
    ),
  );
}
```

Note that we're defining a builder that creates a new instance of `CartModel`. `ChangeNotifierProvider` is smart enough _not_ to rebuild `CartModel` unless absolutely necessary. It also automatically calls `dispose()` on `CartModel` when the instance is no longer needed.

If you want to provide more than one class, you can use `MultiProvider`:

여기서 `CartModel`의 새 인스턴스를 생성하는 빌더를 정의하고 있다는 점에 유의하세요. `ChangeNotifierProvider`는 절대적으로 필요한 경우가 아니면 `CartModel`을 다시 빌드하지 않을 만큼 스마트합니다. 또한 인스턴스가 더 이상 필요 없을 때 자동으로 `dispose()`를 호출합니다.

여러 개의 클래스를 제공하고 싶다면, `MultiProvider`를 사용할 수 있습니다:

```dart
void main() {
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (context) => CartModel()),
        Provider(create: (context) => SomeOtherClass()),
      ],
      child: const MyApp(),
    ),
  );
}
```

## Consumer

Now that `CartModel` is provided to widgets in our app through the `ChangeNotifierProvider` declaration at the top, we can start using it.

This is done through the `Consumer` widget.

이제 `ChangeNotifierProvider` 선언을 통해 `CartModel`이 앱의 위젯들에게 제공되므로, 이를 사용하기 시작할 수 있습니다.

이는 `Consumer` 위젯을 통해 이루어집니다.

```dart
return Consumer<CartModel>(
  builder: (context, cart, child) {
    return Text('Total price: ${cart.totalPrice}');
  },
);
```

We must specify the type of the model that we want to access. In this case, we want `CartModel`, so we write `Consumer<CartModel>`. If you don't specify the generic (`<CartModel>`), the `provider` package won't be able to help you. `provider` is based on types, and without the type, it doesn't know what you want.

The only required argument of the `Consumer` widget is the builder. Builder is a function that is called whenever the `ChangeNotifier` changes. (In other words, when you call `notifyListeners()` in your model, all the builder methods of all the corresponding `Consumer` widgets are called.)

The builder is called with three arguments. The first one is `context`, which you also get in every build method.

The second argument of the builder function is the instance of the `ChangeNotifier`. It's what we were asking for in the first place. You can use the data in the model to define what the UI should look like at any given point.

The third argument is `child`, which is there for optimization. If you have a large widget subtree under your `Consumer` that _doesn't_ change when the model changes, you can construct it once and get it through the builder.

우리가 접근하려는 모델의 타입을 지정해야 합니다. 이 경우에는 `CartModel`을 원하므로, `Consumer<CartModel>`이라고 작성합니다. 제네릭(`<CartModel>`)을 지정하지 않으면, `provider` 패키지가 당신을 도와줄 수 없습니다. `provider`는 타입에 기반하고 있으며, 타입이 없으면 무엇을 원하는지 알 수 없습니다.

`Consumer` 위젯의 유일한 필수 인자는 `builder`입니다. `builder`는 `ChangeNotifier`가 변경될 때마다 호출되는 함수입니다. (다시 말해, 모델에서 `notifyListeners()`를 호출하면, 모든 해당 `Consumer` 위젯의 `builder` 메서드가 호출됩니다.)

`builder`는 세 가지 인자를 받습니다. 첫 번째는 `context`로, 이는 모든 `build` 메서드에서 얻을 수 있습니다.

두 번째 인자는 `ChangeNotifier`의 인스턴스입니다. 이것이 우리가 처음에 요청한 것입니다. 모델의 데이터를 사용하여 UI가 특정 시점에 어떻게 보일지를 정의할 수 있습니다.

세 번째 인자는 `child`로, 이는 최적화를 위해 존재합니다. 모델이 변경될 때 변경되지 않는 큰 위젯 서브트리가 `Consumer` 아래에 있다면, 이를 한 번만 생성하고 `builder`를 통해 받을 수 있습니다.

```dart
return Consumer<CartModel>(
  builder: (context, cart, child) => Stack(
    children: [
      // Use SomeExpensiveWidget here, without rebuilding every time.
      if (child != null) child,
      Text('Total price: ${cart.totalPrice}'),
    ],
  ),
  // Build the expensive widget here.
  child: const SomeExpensiveWidget(),
);
```

It is best practice to put your `Consumer` widgets as deep in the tree as possible. You don't want to rebuild large portions of the UI just because some detail somewhere changed.

최대한 깊은 위젯 트리 안에 `Consumer` 위젯을 배치하는 것이 모범 사례입니다. UI의 일부 세부 사항이 변경되었다고 해서 UI의 큰 부분이 다시 빌드되는 것을 원하지 않기 때문입니다.

```dart
// DON'T DO THIS
return Consumer<CartModel>(
  builder: (context, cart, child) {
    return HumongousWidget(
      // ...
      child: AnotherMonstrousWidget(
        // ...
        child: Text('Total price: ${cart.totalPrice}'),
      ),
    );
  },
);
```

Instead:

대신에:

```dart
// DO THIS
return HumongousWidget(
  // ...
  child: AnotherMonstrousWidget(
    // ...
    child: Consumer<CartModel>(
      builder: (context, cart, child) {
        return Text('Total price: ${cart.totalPrice}');
      },
    ),
  ),
);
```
### Provider.of

Sometimes, you don't really need the _data_ in the model to change the UI but you still need to access it. For example, a `ClearCart` button wants to allow the user to remove everything from the cart. It doesn't need to display the contents of the cart, it just needs to call the `clear()` method.

We could use `Consumer<CartModel>` for this, but that would be wasteful. We'd be asking the framework to rebuild a widget that doesn't need to be rebuilt.

For this use case, we can use `Provider.of`, with the `listen` parameter set to `false`.

때때로, UI를 변경하기 위해 모델의 데이터가 필요하지 않지만 여전히 접근해야 하는 경우가 있습니다. 예를 들어, ClearCart 버튼은 사용자가 장바구니의 모든 항목을 제거할 수 있게 해줍니다. 장바구니의 내용을 표시할 필요는 없고, 단지 `clear()` 메서드를 호출하면 됩니다.

이 경우에는 `Consumer<CartModel>`을 사용할 수 있지만, 이는 비효율적입니다. 프레임워크에 필요 없는 위젯을 다시 빌드하라고 요청하게 됩니다.

이 용도에는 `Provider.of`를 사용하고 `listen` 매개변수를 `false`로 설정할 수 있습니다.

```dart
Provider.of<CartModel>(context, listen: false).removeAll();
```

Using the above line in a build method won't cause this widget to rebuild when `notifyListeners` is called.

위의 코드를 빌드 메서드에서 사용하면, `notifyListeners`가 호출될 때 이 위젯이 다시 빌드되지 않습니다.

## Putting it all together

## 모든 것을 종합하면

You can [check out the example](https://github.com/flutter/samples/tree/main/provider_shopper) covered in this article. If you want something simpler, see what the simple Counter app looks like when [built with `provider`](https://github.com/flutter/samples/tree/main/provider_counter).

By following along with these articles, you've greatly improved your ability to create state-based applications. Try building an application with `provider` yourself to master these skills.

이 기사에서 다룬 예제를 확인할 수 있습니다. 더 간단한 예제를 원하신다면, `provider`로 구축된 간단한 카운터 앱을 확인해 보세요.

이 기사들을 따라가면서 상태 기반 애플리케이션을 만드는 능력을 크게 향상시킬 수 있었습니다. 이러한 기술을 마스터하려면, 직접 `provider`를 사용하여 애플리케이션을 구축해 보세요.

# Options

# List of state management approaches

State management is a complex topic. If you feel that some of your questions haven't been answered, or that the approach described on these pages is not viable for your use cases, you are probably right.

Learn more at the following links, many of which have been contributed by the Flutter community:

상태 관리는 복잡한 주제입니다. 일부 질문이 답변되지 않았거나, 이 페이지에서 설명한 접근 방식이 사용 사례에 적합하지 않다고 느끼신다면, 아마도 맞습니다.

다음 링크에서 더 많은 정보를 확인해 보세요. 많은 링크가 Flutter 커뮤니티에서 기여한 것입니다:
## General overview

## 일반 개요

Things to review before selecting an approach.

- [Introduction to state management](https://docs.flutter.dev/data-and-backend/state-mgmt/intro), which is the beginning of this very section (for those of you who arrived directly to this _Options_ page and missed the previous pages)
- [Pragmatic State Management in Flutter](https://www.youtube.com/watch?v=d_m5csmrf7I), a video from Google I/O 2019
- [Flutter Architecture Samples](https://fluttersamples.com/), by Brian Egan

다음 사항들을 검토한 후 접근 방식을 선택하는 것이 좋습니다:

- 상태 관리에 대한 소개, 이 섹션의 시작 부분에 있는 내용 (이 옵션 페이지에 직접 도착하셨고 이전 페이지를 놓치신 분들을 위한 정보입니다)
- Google I/O 2019에서 발표된 "Pragmatic State Management in Flutter" 비디오
- Brian Egan의 "Flutter Architecture Samples"

## Provider

- [Simple app state management](https://docs.flutter.dev/data-and-backend/state-mgmt/simple), the previous page in this section
- [Provider package](https://pub.dev/packages/provider)

- 간단한 앱 상태 관리, 이 섹션의 이전 페이지
- Provider 패키지

## Riverpod

[#](https://docs.flutter.dev/data-and-backend/state-mgmt/options#riverpod)

Riverpod works in a similar fashion to Provider. It offers compile safety and testing without depending on the Flutter SDK.

- [Riverpod](https://riverpod.dev/) homepage
- [Getting started with Riverpod](https://riverpod.dev/docs/introduction/getting_started)

Riverpod은 Provider와 유사한 방식으로 작동합니다. 컴파일 안전성과 테스트 기능을 제공하며 Flutter SDK에 의존하지 않습니다.

- [Riverpod 홈페이지](https://riverpod.dev)
- Riverpod 시작하기

## setState

The low-level approach to use for widget-specific, ephemeral state.

- [Adding interactivity to your Flutter app](https://docs.flutter.dev/ui/interactivity), a Flutter tutorial
- [Basic state management in Google Flutter](https://medium.com/@agungsurya/basic-state-management-in-google-flutter-6ee73608f96d), by Agung Surya

위젯 특정, 일시적 상태를 위한 저수준 접근 방식:

- Flutter 앱에 상호작용 추가하기: Flutter 튜토리얼
- Google Flutter의 기본 상태 관리: Agung Surya 작성

## ValueNotifier & InheritedNotifier

An approach using only Flutter provided tooling to update state and notify the UI of changes.

- [State Management using ValueNotifier and InheritedNotifier](https://www.hungrimind.com/articles/flutter-state-management), by Tadas Petra

상태를 업데이트하고 UI에 변경 사항을 알리기 위해 Flutter에서 제공하는 도구만 사용하는 접근 방식:

- ValueNotifier와 InheritedNotifier를 사용한 상태 관리: Tadas Petra 작성

## InheritedWidget & InheritedModel

The low-level approach used to communicate between ancestors and children in the widget tree. This is what `provider` and many other approaches use under the hood.

The following instructor-led video workshop covers how to use `InheritedWidget`:

위젯 트리에서 조상과 자식 간의 통신을 위한 저수준 접근 방식입니다. 이는 Provider와 많은 다른 접근 방식이 내부적으로 사용하는 방식입니다.

다음은 InheritedWidget 사용법을 다룬 강사 주도의 비디오 워크숍입니다:

  

[How to manage application state using inherited widgets](https://www.youtube.com/watch/LFcGPS6cGrY "Open 'How to manage application state using inherited widgets' video in new tab")

Other useful docs include:

- [InheritedWidget docs](https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html)
- [Managing Flutter Application State With InheritedWidgets](https://medium.com/flutter/managing-flutter-application-state-with-inheritedwidgets-1140452befe1), by Hans Muller
- [Inheriting Widgets](https://medium.com/@mehmetf_71205/inheriting-widgets-b7ac56dbbeb1), by Mehmet Fidanboylu
- [Using Flutter Inherited Widgets Effectively](https://ericwindmill.com/articles/inherited_widget/), by Eric Windmill
- [Widget - State - Context - InheritedWidget](https://www.didierboelens.com/2018/06/widget---state---context---inheritedwidget/), by Didier Bolelens
- 
애플리케이션 상태를 InheritedWidget을 사용하여 관리하는 방법

기타 유용한 문서:

- InheritedWidget 문서
- Managing Flutter Application State With InheritedWidgets: Hans Muller 작성
- Inheriting Widgets: Mehmet Fidanboylu 작성
- Using Flutter Inherited Widgets Effectively: Eric Windmill 작성
- Widget - State - Context - InheritedWidget: Didier Bolelens 작성

## June

A lightweight and modern state management library that focuses on providing a pattern similar to Flutter's built-in state management.

- [june package](https://pub.dev/packages/june)

**June 패키지**는 Flutter의 기본 상태 관리와 유사한 패턴을 제공하는 가볍고 현대적인 상태 관리 라이브러리입니다.

## Redux

A state container approach familiar to many web developers.

- [Animation Management with Redux and Flutter](https://www.youtube.com/watch?v=9ZkLtr0Fbgk), a video from DartConf 2018 [Accompanying article on Medium](https://medium.com/flutter/animation-management-with-flutter-and-flux-redux-94729e6585fa)
- [Flutter Redux package](https://pub.dev/packages/flutter_redux)
- [Redux Saga Middleware Dart and Flutter](https://pub.dev/packages/redux_saga), by Bilal Uslu
- [Introduction to Redux in Flutter](https://blog.novoda.com/introduction-to-redux-in-flutter/), by Xavi Rigau
- [Flutter + Redux—How to make a shopping list app](https://hackernoon.com/flutter-redux-how-to-make-shopping-list-app-1cd315e79b65), by Paulina Szklarska on Hackernoon
- [Building a TODO application (CRUD) in Flutter with Redux—Part 1](https://www.youtube.com/watch?v=Wj216eSBBWs), a video by Tensor Programming
- [Flutter Redux Thunk, an example](https://medium.com/flutterpub/flutter-redux-thunk-27c2f2b80a3b), by Jack Wong
- [Building a (large) Flutter app with Redux](https://hillelcoren.com/2018/06/01/building-a-large-flutter-app-with-redux/), by Hillel Coren
- [Fish-Redux–An assembled flutter application framework based on Redux](https://github.com/alibaba/fish-redux/), by Alibaba
- [Async Redux–Redux without boilerplate. Allows for both sync and async reducers](https://pub.dev/packages/async_redux), by Marcelo Glasberg
- [Flutter meets Redux: The Redux way of managing Flutter applications state](https://medium.com/@thisisamir98/flutter-meets-redux-the-redux-way-of-managing-flutter-applications-state-f60ef693b509), by Amir Ghezelbash
- [Redux and epics for better-organized code in Flutter apps](https://medium.com/upday-devs/reduce-duplication-achieve-flexibility-means-success-for-the-flutter-app-e5e432839e61), by Nihad Delic
- [Flutter_Redux_Gen - VS Code Plugin to generate boiler plate code](https://marketplace.visualstudio.com/items?itemName=BalaDhruv.flutter-redux-gen), by Balamurugan Muthusamy (BalaDhruv)
- 
웹 개발자들에게 친숙한 상태 컨테이너 접근 방식.

- **Animation Management with Redux and Flutter**: DartConf 2018의 비디오 및 Medium에 동반된 기사
- **Flutter Redux 패키지**
- **Redux Saga Middleware Dart and Flutter**: Bilal Uslu 작성
- **Introduction to Redux in Flutter**: Xavi Rigau 작성
- **Flutter + Redux—How to make a shopping list app**: Paulina Szklarska의 Hackernoon 기사
- **Building a TODO application (CRUD) in Flutter with Redux—Part 1**: Tensor Programming의 비디오
- **Flutter Redux Thunk**: Jack Wong의 예제
- **Building a (large) Flutter app with Redux**: Hillel Coren 작성
- **Fish-Redux–An assembled flutter application framework based on Redux**: Alibaba 작성
- **Async Redux–Redux without boilerplate**: Marcelo Glasberg 작성
- **Flutter meets Redux: The Redux way of managing Flutter applications state**: Amir Ghezelbash 작성
- **Redux and epics for better-organized code in Flutter apps**: Nihad Delic 작성
- **Flutter_Redux_Gen**: VS Code 플러그인으로 보일러플레이트 코드 생성, Balamurugan Muthusamy (BalaDhruv) 작성

## Fish-Redux

Fish Redux is an assembled flutter application framework based on Redux state management. It is suitable for building medium and large applications.

- [Fish-Redux-Library](https://pub.dev/packages/fish_redux) package, by Alibaba
- [Fish-Redux-Source](https://github.com/alibaba/fish-redux), project code
- [Flutter-Movie](https://github.com/o1298098/Flutter-Movie), A non-trivial example demonstrating how to use Fish Redux, with more than 30 screens, graphql, payment api, and media player.

**Fish Redux**는 Redux 상태 관리를 기반으로 한 Flutter 애플리케이션 프레임워크입니다. 중형 및 대형 애플리케이션을 구축하는 데 적합합니다.

- **Fish-Redux-Library 패키지**: Alibaba에서 제공
- **Fish-Redux-Source**: 프로젝트 코드
- **Flutter-Movie**: 30개 이상의 화면, GraphQL, 결제 API 및 미디어 플레이어를 사용하는 Fish Redux의 비주얼 예제
## BLoC / Rx

A family of stream/observable based patterns.

- [Architect your Flutter project using BLoC pattern](https://medium.com/flutterpub/architecting-your-flutter-project-bd04e144a8f1), by Sagar Suri
- [BloC Library](https://felangel.github.io/bloc), by Felix Angelov
- [Reactive Programming - Streams - BLoC - Practical Use Cases](https://www.didierboelens.com/2018/12/reactive-programming---streams---bloc---practical-use-cases), by Didier Boelens

**BLoC (Business Logic Component)** 패턴과 관련된 스트림/옵저버블 기반 패턴의 가족입니다.

- **Flutter 프로젝트를 BLoC 패턴으로 설계하기**: Sagar Suri의 글
- **BLoC 라이브러리**: Felix Angelov의 라이브러리
- **반응형 프로그래밍 - 스트림 - BLoC - 실용 사례**: Didier Boelens의 글


## GetIt

A service locator based state management approach that doesn't need a `BuildContext`.

- [GetIt package](https://pub.dev/packages/get_it), the service locator. It can also be used together with BloCs.
- [GetIt Mixin package](https://pub.dev/packages/get_it_mixin), a mixin that completes `GetIt` to a full state management solution.
- [GetIt Hooks package](https://pub.dev/packages/get_it_hooks), same as the mixin in case you already use `flutter_hooks`.
- [Flutter state management for minimalists](https://medium.com/flutter-community/flutter-state-management-for-minimalists-4c71a2f2f0c1?sk=6f9cedfb550ca9cc7f88317e2e7055a0), by Suragch
- 
**서비스 위치 기반의 상태 관리 접근법으로, `BuildContext`가 필요 없는 방법입니다.**

- **GetIt 패키지**: 서비스 위치 지정자로, BloC와 함께 사용할 수도 있습니다.
- **GetIt Mixin 패키지**: GetIt을 완전한 상태 관리 솔루션으로 완성하는 믹스인입니다.
- **GetIt Hooks 패키지**: `flutter_hooks`를 이미 사용하는 경우, 믹스인과 동일한 기능을 제공합니다.
- **미니멀리스트를 위한 Flutter 상태 관리**: Suragch의 글
## MobX

A popular library based on observables and reactions.

- [MobX.dart, Hassle free state-management for your Dart and Flutter apps](https://github.com/mobxjs/mobx.dart)
- [Getting started with MobX.dart](https://mobx.netlify.app/getting-started)
- [Flutter: State Management with Mobx](https://www.youtube.com/watch?v=p-MUBLOEkCs), a video by Paul Halliday
- 
**옵저버블과 반응에 기반한 인기 라이브러리입니다.**

- **MobX.dart**: Dart와 Flutter 앱을 위한 간편한 상태 관리 라이브러리
- **MobX.dart 시작하기**: 시작 가이드
- **Flutter: MobX를 사용한 상태 관리**: Paul Halliday의 비디오

## Dart Board

A modular feature management framework for Flutter. Dart Board is designed to help encapsulate and isolate features, including examples/frameworks, small kernel, and many ready-to-use decoupled features such as debugging, logging, auth, redux, locator, particle system and more.

- [Dart Board Homepage + Demos](https://dart-board.io/)
- [Dart Board on pub.dev](https://pub.dev/packages/dart_board_core)
- [dart_board on GitHub](https://github.com/ahammer/dart_board)
- [Getting started with Dart Board](https://github.com/ahammer/dart_board/blob/master/GETTING_STARTED.md)

Flutter를 위한 모듈화된 기능 관리 프레임워크입니다. Dart Board는 기능을 캡슐화하고 분리하는 데 도움을 주며, 예제/프레임워크, 작은 커널, 디버깅, 로깅, 인증, Redux, 로케이터, 파티클 시스템 등 다양한 준비된 분리된 기능을 포함하고 있습니다.

- Dart Board 홈페이지 + 데모
- pub.dev에서 Dart Board
- Dart Board GitHub
- Dart Board 시작하기

## Flutter Commands

Reactive state management that uses the Command Pattern and is based on `ValueNotifiers`. Best in combination with [GetIt](https://docs.flutter.dev/data-and-backend/state-mgmt/options#getit), but can be used with `Provider` or other locators too.

- [Flutter Command package](https://pub.dev/packages/flutter_command)
- [RxCommand package](https://pub.dev/packages/rx_command), `Stream` based implementation.

명령 패턴을 사용하고 ValueNotifiers를 기반으로 하는 반응형 상태 관리입니다. GetIt과 함께 사용할 때 가장 좋지만, Provider나 다른 로케이터와 함께 사용할 수도 있습니다.

- Flutter Command 패키지

## Binder

A state management package that uses `InheritedWidget` at its core. Inspired in part by recoil. This package promotes the separation of concerns.

- [Binder package](https://pub.dev/packages/binder)
- [Binder examples](https://github.com/letsar/binder/tree/main/examples)
- [Binder snippets](https://marketplace.visualstudio.com/items?itemName=romain-rastel.flutter-binder-snippets), vscode snippets to be even more productive with Binder

상태 관리 패키지로, InheritedWidget을 핵심으로 사용합니다. 부분적으로 Recoil에서 영감을 받았으며, 관심사의 분리를 촉진합니다.

- Binder 패키지
- Binder 예제
- Binder 스니펫 (VSCode 스니펫으로 Binder와 함께 더 생산적으로 작업할 수 있습니다.)

## GetX

A simplified reactive state management solution.

- [GetX package](https://pub.dev/packages/get)
- [GetX Flutter Firebase Auth Example](https://medium.com/@jeffmcmorris/getx-flutter-firebase-auth-example-b383c1dd1de2), by Jeff McMorris

간소화된 반응형 상태 관리 솔루션입니다.

- GetX 패키지
- GetX Flutter Firebase Auth 예제 (Jeff McMorris 작성)

## states_rebuilder


An approach that combines state management with a dependency injection solution and an integrated router. For more information, see the following info:

- [States Rebuilder](https://github.com/GIfatahTH/states_rebuilder) project code
- [States Rebuilder documentation](https://github.com/GIfatahTH/states_rebuilder/wiki)

상태 관리와 의존성 주입 솔루션, 그리고 통합된 라우터를 결합한 접근 방식입니다. 더 많은 정보는 다음을 참조하세요:

- States Rebuilder 프로젝트 코드
- States Rebuilder 문서

## Triple Pattern (Segmented State Pattern)

Triple is a pattern for state management that uses `Streams` or `ValueNotifier`. This mechanism (nicknamed _triple_ because the stream always uses three values: `Error`, `Loading`, and `State`), is based on the [Segmented State pattern](https://triple.flutterando.com.br/docs/intro/overview#-segmented-state-pattern-ssp).

For more information, refer to the following resources:

- [Triple documentation](https://triple.flutterando.com.br/)
- [Flutter Triple package](https://pub.dev/packages/flutter_triple)
- [Triple Pattern: A new pattern for state management in Flutter](https://blog.flutterando.com.br/triple-pattern-um-novo-padr%C3%A3o-para-ger%C3%AAncia-de-estado-no-flutter-2e693a0f4c3e) (blog post written in Portuguese but can be auto-translated)
- [VIDEO: Flutter Triple Pattern by Kevlin Ossada](https://www.youtube.com/watch?v=dXc3tR15AoA) (recorded in English)

Triple은 Streams 또는 ValueNotifier를 사용하는 상태 관리 패턴입니다. 이 메커니즘은 항상 세 가지 값(에러, 로딩, 상태)을 사용하여 상태를 분리하는 방식으로, Segmented State 패턴을 기반으로 합니다.

자세한 정보는 다음 자료를 참고하세요:

- Triple 문서
- Flutter Triple 패키지
- Triple Pattern: Flutter에서의 새로운 상태 관리 패턴 (포르투갈어로 작성된 블로그 포스트, 자동 번역 가능)
- VIDEO: Flutter Triple Pattern by Kevlin Ossada (영어로 녹화된 영상)

## solidart

A simple but powerful state management solution inspired by SolidJS.

- [Official Documentation](https://docs.page/nank1ro/solidart)
- [solidart package](https://pub.dev/packages/solidart)
- [flutter_solidart package](https://pub.dev/packages/flutter_solidart)

간단하지만 강력한 상태 관리 솔루션으로, SolidJS에서 영감을 받았습니다.

- 공식 문서
- solidart 패키지
- flutter_solidart 패키지

## flutter_reactive_value

The `flutter_reactive_value` library might offer the least complex solution for state management in Flutter. It might help Flutter newcomers add reactivity to their UI, without the complexity of the mechanisms described before. The `flutter_reactive_value` library defines the `reactiveValue(BuildContext)` extension method on `ValueNotifier`. This extension allows a `Widget` to fetch the current value of the `ValueNotifier` and subscribe the `Widget` to changes in the value of the `ValueNotifier`. If the value of the `ValueNotifier` changes, `Widget` rebuilds.

- [`flutter_reactive_value`](https://github.com/lukehutch/flutter_reactive_value) source and documentation

`flutter_reactive_value` 라이브러리는 Flutter에서 상태 관리를 위한 가장 간단한 솔루션을 제공할 수 있습니다. 이 라이브러리는 Flutter의 새로운 사용자들이 앞서 설명된 복잡한 메커니즘 없이 UI에 반응성을 추가할 수 있도록 도와줍니다. `flutter_reactive_value` 라이브러리는 `ValueNotifier`에 `reactiveValue(BuildContext)` 확장 메서드를 정의합니다. 이 확장 메서드는 위젯이 `ValueNotifier`의 현재 값을 가져오고, `ValueNotifier` 값의 변화에 따라 위젯이 구독하도록 합니다. `ValueNotifier`의 값이 변경되면 위젯이 다시 빌드됩니다.

- `flutter_reactive_value`의 소스 코드와 문서
## Elementary

[#](https://docs.flutter.dev/data-and-backend/state-mgmt/options#elementary)

Elementary is a simple and reliable way to build applications with MVVM in Flutter. It offers a pure Flutter experience with clear code separation by responsibilities, efficient rebuilds, easy testability, and enhancing team productivity.

- [Elementary Documentation](https://documentation.elementaryteam.dev/)
- [Elementary Repository](https://github.com/Elementary-team/flutter-elementary)
- [Elementary package](https://pub.dev/packages/elementary)

Elementary는 Flutter에서 MVVM을 사용하여 애플리케이션을 간단하고 신뢰성 있게 구축할 수 있는 방법입니다. 이는 명확한 코드 책임 분리, 효율적인 리빌드, 쉬운 테스트 가능성, 팀 생산성 향상을 제공하는 순수 Flutter 경험을 제공합니다.

- Elementary 문서: [Elementary Documentation](https://example.com)
- Elementary 저장소: [Elementary Repository](https://github.com/your-repository/elementary)
- Elementary 패키지: Elementary package
