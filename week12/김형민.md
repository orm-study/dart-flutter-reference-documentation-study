
## Introduction

상태란 UI에 표시되는 변할 수 있는 데이터. 텍스트, 이미지, 버튼 등.

앱 전체에서 화면 간에 앱 상태를 공유해야 할 때, 상태를 관리해야 한다고 한다.

---

## Think declaratively

명령형 UI vs 선언형 UI

간단 설명

명령형 : 무엇을 나타낼 지보다 어떻게 나타낼 지 설명
선언형 : 어떻게 나타낼 지보다 무엇을 나타낼 지 설명

명령형 UI 예시 kotlin

```kotlin
b.setColor(red)
b.clearChildren()
ViewC c3 = new ViewC(...)
b.add(c3)
```

b의 변경을 각각 메서드 명령으로 설명
색은 red로 하라는 메서드
자식 위젯을 없애는 메서드
자식 위젯을 추가하는 메서드로 명령.

선언형 UI 예시

```dart
return ViewB(
  color: red,
  child: ViewC(...),
)
```

b의 변경을 새 위젯의 선언으로 설명
B의 새로운 모습의 컬러는 레드, 자식은 C라고 선언.

Flutter는 선언형 UI

주어진 상태에 대해 UI가 어떤 모습이어야 하는지 한번만 설명하면 된다

---

## Ephemeral vs app state

임시 상태

일시적이고 공유할 필요가 없는 상태

사용할만한 상황

- PageView의 현재 페이지

- 복잡한 애니메이션의 현재 진행 상황

- BottomNavigationBar에서 현재 선택된 탭

다른 화면이 위 상태에 접근할 일이 거의 없다. 복잡하게 변경되지도 않는다.

따라서 상태 관리가 필요 없다. StatefulWidget에서 setState를 사용하면 된다.

상태가 초기화되어도 상관없다.

앱 상태

유지되어야 하고 다른 화면과 공유해야 하는 상태

- 사용자 환경 설정

- 로그인 정보

- 소셜 네트워킹 앱의 알림

- 전자 상거래 앱의 장바구니

- 뉴스 앱의 기사 읽음/읽지 않음 상태

상태 관리에는 여러 옵션이 있다.

어떤 것을 사용할 것인지는 개발자 혹은 팀의 선택이다.

Redux(상태 관리 라이브러리)를 만든 사람은 익숙한 상태 관리를 쓰라고 말했다.

결론은 스스로 알아서 잘 하라는 것이다.

---

## simple app state management

플러터 공식문서에서는 상태 관리 패키지로 provider를 권장하는 뉘앙스로 말한다.

예시에서 provider를 사용하면서 사용하는 이유를 다음과 같이 설명하고 있다.

1. 이해하기 쉽고 코드를 적게 사용하기 때문이다.

2. 다른 상태 관리에도 적용할 수 있는 개념을 사용하기 때문이다.

공식문서는 앱 상태 관리 예시로 카탈로그와 카트 화면을 가진 쇼핑 앱을 들고 있다.

카탈로그는 하위 위젯을 가지고 있으며 앱의 위젯들은 서로 공유하는 상태가 필요하다.

아이템들은 카트에 담겨있는지 아닌지에 대한 상태. 등등

그렇다면 카트의 상태는 어디에 있어야 할까?

공식문서에 따르면 Flutter의 상태는 사용하는 위젯 위에서 유지하는 것이 합리적이라고 한다.

위젯 위에서 유지라는 것은 같은 상태를 공유하는 위젯들과 같거나 보다 상위 위젯에서 관리한다는 뜻이다.

왜 그렇게 해야 하냐면 상태가 변경되면 UI가 변경된다고 했다. UI 변경은 UI를 다시 빌드한다는 뜻이다.
즉, 상위 위젯에서 상태가 변경되면 상태를 전달하고 하위 위젯들이 변경된다. 상태 변화가 자연스럽게 UI에 적용된다는 뜻이다. 

외부나 하위에서 관리하는 것은 어렵고 프레임워크와 충돌한다.

예시에서는 MyApp에 상태가 있어야 한다. 상태가 바뀌면 MyCart도 바뀐다.

바뀐다는 것은 이전 위젯은 새로운 위젯으로 대체된다는 뜻이다. 이것이 위젯은 불변이라는 말의 의미이다.

상태에 접근하는 방법 중 간단한 것은 콜백 함수를 사용하는 것이다.
이 방법은 콜백 함수가 늘어날수록 상태 변경의 흐름 추적이 어렵다.
즉, 유지, 보수가 어렵다. 

InheritedWidget과 같은 것들이 있지만 로우 레벨이라 복잡하다.

그래서 사용이 간편한 provider를 사용하는 것이다. provider는 내부적으로 IneritedWidget을 사용하고 있다.

provider를 사용하기 위해선

- ChangeNotifier

- ChangeNotifierProvider

- Consumer

를 이해해야한다.

ChangeNotifier는 리스너에게 변경 알림을 제공하는 클래스이다. 변경 사항을 구독할 수 있다는 뜻이다. notifyListeners()는 구독하고 있는 위젯에게 다시 빌드하라고 지시하는 메서드이다.
모델 클래스는 이것을 확장한다.

ChangeNotifierProvider는 ChangeNotifier의 인스턴스를 하위 항목에 제공하는 위젯이다. ChangeNotifierProvider는 접근해야 하는 위젯 위에 두면 된다.
모델을 위젯에 제공한다는 뜻이다.

둘 이상의 클래스를 제공하려면 MultiProvider를 사용한다.

Consumer로 ChangeNotifier를 확장한 모델을 사용할 수 있다. 접근하려는 모델의 타입을 지정해야 한다. builder 함수의 두번째 인자로 모델을 받아서 모델의 데이터에 접근한다.
위젯을 트리 깊은 곳에 위치시켜 리빌드를 최소화 하는 것이 좋다.

Provider.of는 현재 위젯 트리에서 가장 가까운 Provider를 가져오고 그 값을 리턴하는 메서드이다.
이것으로 화면을 리빌드하지 않고 데이터만 변화시킬 수 있다.

---

옵션은 provider, riverpod, setState, GetX, BLoC등 스무 개가 있다.

궁금하면 공식 문서의 링크를 타고 각 사이트에서 설명을 보면 된다.
