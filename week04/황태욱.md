# Mixins

Mixins are a way of defining code that can be reused in multiple class hierarchies. They are intended to provide member implementations en masse.

To use a mixin, use the `with` keyword followed by one or more mixin names. The following example shows two classes that use (or, are subclasses of) mixins:

믹스인은 여러 클래스 계층에서 재사용될 수 있는 코드를 정의하는 방법이다. 그것들은 대량으로 멤버 구현을 제공하기 위해 의도되었다.

믹스인을 사용하려면, with 키워드를 사용하고 하나 이상의 믹스인 이름을 따른다. 다음 예제는 믹스인을 사용하는 (또는 믹스인의 서브클래스인) 두 클래스를 보여준다:

```dart
class Musician extends Performer with Musical {
  // ···
}

class Maestro extends Person with Musical, Aggressive, Demented {
  Maestro(String maestroName) {
    name = maestroName;
    canConduct = true;
  }
}
```

To define a mixin, use the `mixin` declaration. In the rare case where you need to define both a mixin _and_ a class, you can use the [`mixin class` declaration](https://dart.dev/language/mixins#class-mixin-or-mixin-class).

Mixins and mixin classes cannot have an `extends` clause, and must not declare any generative constructors.

For example:

믹스인을 정의하려면, mixin 선언을 사용해라. 믹스인과 클래스를 모두 정의해야 하는 드문 경우에는 mixin class 선언을 사용할 수 있다.

믹스인과 믹스인 클래스는 extends 절을 가질 수 없으며, 생성자를 선언해서는 안 된다.

예를 들어:

```dart
mixin Musical {
  bool canPlayPiano = false;
  bool canCompose = false;
  bool canConduct = false;

  void entertainMe() {
    if (canPlayPiano) {
      print('Playing piano');
    } else if (canConduct) {
      print('Waving hands');
    } else {
      print('Humming to self');
    }
  }
}
```
## Specify members a mixin can call on itself

Sometimes a mixin depends on being able to invoke a method or access fields, but can't define those members itself (because mixins can't use constructor parameters to instantiate their own fields).

The following sections cover different strategies for ensuring any subclass of a mixin defines any members the mixin's behavior depends on.

## 믹스인이 스스로 호출할 수 있는 멤버 지정

때때로 믹스인은 메서드를 호출하거나 필드에 접근할 수 있어야 하지만, 스스로 그 멤버들을 정의할 수는 없다(믹스인은 자신의 필드를 인스턴스화하기 위해 생성자 매개변수를 사용할 수 없기 때문이다).

다음 섹션에서는 믹스인의 동작이 의존하는 멤버를 믹스인을 사용하는 모든 서브클래스가 정의하도록 보장하는 다양한 전략을 다룬다.

### Define abstract members in the mixin

Declaring an abstract method in a mixin forces any type that uses the mixin to define the abstract method upon which its behavior depends.

### 믹스인에서 추상 멤버 정의

믹스인에서 추상 메서드를 선언하면, 믹스인을 사용하는 모든 타입이 그 동작이 의존하는 추상 메서드를 정의하도록 강제한다.

```dart
mixin Musician {
  void playInstrument(String instrumentName); // Abstract method.

  void playPiano() {
    playInstrument('Piano');
  }
  void playFlute() {
    playInstrument('Flute');
  }
}

class Virtuoso with Musician { 
  void playInstrument(String instrumentName) { // Subclass must define.
    print('Plays the $instrumentName beautifully');
  }  
}
```
#### Access state in the mixin's subclass

Declaring abstract members also allows you to access state on the subclass of a mixin, by calling getters which are defined as abstract on the mixin:

#### 믹스인의 서브클래스에서 상태에 접근

추상 멤버를 선언하면, 믹스인에서 추상으로 정의된 게터를 호출하여 믹스인의 서브클래스에서 상태에 접근할 수 있게 해준다:

```dart
/// Can be applied to any type with a [name] property and provides an
/// implementation of [hashCode] and operator `==` in terms of it.
mixin NameIdentity {
  String get name;

  int get hashCode => name.hashCode;
  bool operator ==(other) => other is NameIdentity && name == other.name;
}

class Person with NameIdentity {
  final String name;

  Person(this.name);
}
```
### Implement an interface

Similar to declaring the mixin abstract, putting an `implements` clause on the mixin while not actually implementing the interface will also ensure any member dependencies are defined for the mixin.

### 인터페이스 구현

믹스인을 추상으로 선언하는 것과 유사하게, 인터페이스를 실제로 구현하지 않고 믹스인에 implements 절을 추가하면 믹스인에 대한 모든 멤버 종속성이 정의되도록 보장할 수 있다.

```dart
abstract interface class Tuner {
  void tuneInstrument();
}

mixin Guitarist implements Tuner {
  void playSong() {
    tuneInstrument();

    print('Strums guitar majestically.');
  }
}

class PunkRocker with Guitarist {
  void tuneInstrument() {
    print("Don't bother, being out of tune is punk rock.");
  }
}
```
### Use the `on` clause to declare a superclass

The `on` clause exists to define the type that `super` calls are resolved against. So, you should only use it if you need to have a `super` call inside a mixin.

The `on` clause forces any class that uses a mixin to also be a subclass of the type in the `on` clause. If the mixin depends on members in the superclass, this ensures those members are available where the mixin is used:

### on 절을 사용하여 슈퍼클래스 선언

on 절은 슈퍼 호출이 해결되는 타입을 정의하기 위해 존재한다. 따라서 믹스인 내부에서 슈퍼 호출이 필요할 때만 사용해야 한다.

on 절은 믹스인을 사용하는 모든 클래스가 on 절에 있는 타입의 서브클래스가 되도록 강제한다. 믹스인이 슈퍼클래스의 멤버에 의존하는 경우, 이는 믹스인이 사용되는 곳에서 해당 멤버들이 사용 가능하도록 보장한다:

```dart
class Musician {
  musicianMethod() {
    print('Playing music!');
  }
}

mixin MusicalPerformer on Musician {
  perfomerMethod() {
    print('Performing music!');
    super.musicianMethod();
  }
}

class SingerDancer extends Musician with MusicalPerformer { }

main() {
  SingerDance().performerMethod();
}
```

In this example, only classes that extend or implement the `Musician` class can use the mixin `MusicalPerformer`. Because `SingerDancer` extends `Musician`, `SingerDancer` can mix in `MusicalPerformer`.

이 예제에서 Musician 클래스를 확장하거나 구현하는 클래스만 MusicalPerformer 믹스인을 사용할 수 있다. SingerDancer는 Musician을 확장하므로 MusicalPerformer를 믹스인할 수 있다.

## `class`, `mixin`, or `mixin class`?

A `mixin` declaration defines a mixin. A `class` declaration defines a [class](https://dart.dev/language/classes). A `mixin class` declaration defines a class that is usable as both a regular class and a mixin, with the same name and the same type.

mixin 선언은 믹스인을 정의한다. class 선언은 클래스를 정의한다. mixin class 선언은 일반 클래스와 믹스인으로 모두 사용할 수 있는 클래스를 동일한 이름과 동일한 타입으로 정의한다.

```dart
mixin class Musician {
  // ...
}

class Novice with Musician { // Use Musician as a mixin
  // ...
}

class Novice extends Musician { // Use Musician as a class
  // ...
}
```

Any restrictions that apply to classes or mixins also apply to mixin classes:

- Mixins can't have `extends` or `with` clauses, so neither can a `mixin class`.
- Classes can't have an `on` clause, so neither can a `mixin class`.

클래스나 믹스인에 적용되는 모든 제한사항은 믹스인 클래스에도 적용된다:

- 믹스인은 extends나 with 절을 가질 수 없으므로, 믹스인 클래스도 가질 수 없다.
- 클래스는 on 절을 가질 수 없으므로, 믹스인 클래스도 가질 수 없다.

# Enums

Enumerated types, often called _enumerations_ or _enums_, are a special kind of class used to represent a fixed number of constant values.

열거형(enum) 타입은 고정된 수의 상수 값을 나타내는 특별한 종류의 클래스로, 종종 열거형이라고 불린다.

_Note_

All enums automatically extend the [`Enum`](https://api.dart.dev/stable/dart-core/Enum-class.html) class. They are also sealed, meaning they cannot be subclassed, implemented, mixed in, or otherwise explicitly instantiated.

Abstract classes and mixins can explicitly implement or extend `Enum`, but unless they are then implemented by or mixed into an enum declaration, no objects can actually implement the type of that class or mixin.

_참고_

모든 열거형은 자동으로 Enum 클래스를 확장한다. 또한 sealed이기 때문에 서브클래스화, 구현, 믹스인 또는 명시적으로 인스턴스화될 수 없다.

추상 클래스와 믹스인은 Enum을 명시적으로 구현하거나 확장할 수 있지만, 그들이 열거형 선언에 의해 구현되거나 믹스인되지 않는 한, 해당 클래스나 믹스인의 타입을 실제로 구현하는 객체는 없다.


## Declaring simple enums

To declare a simple enumerated type, use the `enum` keyword and list the values you want to be enumerated:


## 단순한 열거형 선언하기

단순한 열거형 타입을 선언하려면 enum 키워드를 사용하고 열거할 값을 나열하면 된다:

```dart
enum Color { red, green, blue }
```

_Tip_

You can also use [trailing commas](https://dart.dev/language/collections#lists) when declaring an enumerated type to help prevent copy-paste errors.

_팁_

향상된 열거형을 선언할 때 열거형 타입 뒤에 쉼표를 사용하여 복사 및 붙여넣기 오류를 방지할 수 있습니다.

## Declaring enhanced enums

Dart also allows enum declarations to declare classes with fields, methods, and const constructors which are limited to a fixed number of known constant instances.

To declare an enhanced enum, follow a syntax similar to normal [classes](https://dart.dev/language/classes), but with a few extra requirements:

- Instance variables must be `final`, including those added by [mixins](https://dart.dev/language/mixins).
- All [generative constructors](https://dart.dev/language/constructors#constant-constructors) must be constant.
- [Factory constructors](https://dart.dev/language/constructors#factory-constructors) can only return one of the fixed, known enum instances.
- No other class can be extended as [`Enum`](https://api.dart.dev/stable/dart-core/Enum-class.html) is automatically extended.
- There cannot be overrides for `index`, `hashCode`, the equality operator `==`.
- A member named `values` cannot be declared in an enum, as it would conflict with the automatically generated static `values` getter.
- All instances of the enum must be declared in the beginning of the declaration, and there must be at least one instance declared.

Instance methods in an enhanced enum can use `this` to reference the current enum value.

Here is an example that declares an enhanced enum with multiple instances, instance variables, getters, and an implemented interface:

## 향상된 열거형 선언하기

Dart에서는 열거형 선언이 가능하며, 이는 필드, 메서드, 상수 생성자를 가진 클래스를 선언할 수 있습니다. 이 클래스는 알려진 상수 인스턴스의 고정된 수로 제한됩니다.

향상된 열거형을 선언하기 위해 일반 클래스와 유사한 구문을 사용하지만, 몇 가지 추가 요구 사항이 있습니다:

- 인스턴스 변수는 모두 final이어야 하며, 이는 믹스인을 추가할 때도 동일합니다.
- 모든 생성 생성자는 상수이어야 합니다.
- 팩토리 생성자는 고정된, 알려진 열거형 인스턴스 중 하나만 반환할 수 있습니다.
- 다른 클래스는 Enum이 자동으로 확장되기 때문에 확장할 수 없습니다.
- index, hashCode, 동등 연산자 \==를 재정의할 수 없습니다.
- values라는 이름의 멤버를 열거형에 선언할 수 없습니다. 이는 자동으로 생성되는 정적 values getter와 충돌할 수 있습니다.
- 열거형의 모든 인스턴스는 선언의 시작에서 선언되어야 하며, 적어도 하나의 인스턴스가 선언되어야 합니다.
- 향상된 열거형의 인스턴스 메서드는 this를 사용하여 현재 열거형 값을 참조할 수 있습니다.

다음은 여러 인스턴스, 인스턴스 변수, 게터를 포함하고 구현된 인터페이스를 가진 향상된 열거형을 선언하는 예제입니다:

```dart
enum Vehicle implements Comparable<Vehicle> {
  car(tires: 4, passengers: 5, carbonPerKilometer: 400),
  bus(tires: 6, passengers: 50, carbonPerKilometer: 800),
  bicycle(tires: 2, passengers: 1, carbonPerKilometer: 0);

  const Vehicle({
    required this.tires,
    required this.passengers,
    required this.carbonPerKilometer,
  });

  final int tires;
  final int passengers;
  final int carbonPerKilometer;

  int get carbonFootprint => (carbonPerKilometer / passengers).round();

  bool get isTwoWheeled => this == Vehicle.bicycle;

  @override
  int compareTo(Vehicle other) => carbonFootprint - other.carbonFootprint;
}
```
## Using enums

Access the enumerated values like any other [static variable](https://dart.dev/language/classes#class-variables-and-methods):

## 열거형 값에 접근하기

열거형 값은 다른 정적 변수와 마찬가지로 접근할 수 있습니다.

```dart
final favoriteColor = Color.blue;
if (favoriteColor == Color.blue) {
  print('Your favorite color is blue!');
}
```

Each value in an enum has an `index` getter, which returns the zero-based position of the value in the enum declaration. For example, the first value has index 0, and the second value has index 1.

각 열거형 값은 인덱스 getter를 가지고 있습니다. 이 getter는 열거형 선언에서 값의 제로베이스(0부터 시작하는) 위치를 반환합니다. 예를 들어, 첫 번째 값은 인덱스 0을 가지고 있고, 두 번째 값은 인덱스 1을 가집니다.

```dart
assert(Color.red.index == 0);
assert(Color.green.index == 1);
assert(Color.blue.index == 2);
```

To get a list of all the enumerated values, use the enum's `values` constant.

모든 열거형 값의 리스트를 가져오려면, 열거형의 values라는 상수를 사용하면 됩니다.

```dart
List<Color> colors = Color.values;
assert(colors[2] == Color.blue);
```

You can use enums in [switch statements](https://dart.dev/language/branches#switch), and you'll get a warning if you don't handle all of the enum's values:

열거형을 switch 문에서 사용할 수 있으며, 열거형의 모든 값을 처리하지 않으면 경고가 발생합니다.

```dart
var aColor = Color.blue;

switch (aColor) {
  case Color.red:
    print('Red as roses!');
  case Color.green:
    print('Green as grass!');
  default: // Without this, you see a WARNING.
    print(aColor); // 'Color.blue'
}
```

If you need to access the name of an enumerated value, such as `'blue'` from `Color.blue`, use the `.name` property:

만약 Color.blue와 같은 열거형 값의 이름('blue')에 접근해야 한다면, .name 속성을 사용하면 됩니다.

```dart
print(Color.blue.name); // 'blue'
```

You can access a member of an enum value like you would on a normal object:

열거형 값의 멤버에 접근할 때는 일반 객체처럼 접근할 수 있습니다.


```dart
print(Vehicle.car.carbonFootprint);
```

# Extension methods

Extension methods add functionality to existing libraries. You might use extension methods without even knowing it. For example, when you use code completion in an IDE, it suggests extension methods alongside regular methods.

Extension methods는 기존 라이브러리에 기능을 추가합니다. IDE에서 코드 완성을 사용할 때 일반 메서드와 함께 extension methods도 제안될 수 있습니다.
## Overview

When you're using someone else's API or when you implement a library that's widely used, it's often impractical or impossible to change the API. But you might still want to add some functionality.

For example, consider the following code that parses a string into an integer:

## 개요

다른 사람의 API를 사용하거나 널리 사용되는 라이브러리를 구현할 때 API를 변경하는 것은 종종 비현실적이거나 불가능할 수 있습니다. 그러나 여전히 몇 가지 기능을 추가하고 싶을 수 있습니다.

예를 들어, 다음은 문자열을 정수로 파싱하는 코드를 고려해 보겠습니다:

```dart
int.parse('42')
```

It might be nice—shorter and easier to use with tools—to have that functionality be on `String` instead:

그 기능을 String 자체에 추가하는 것이 더 간단하고 도구와 함께 사용하기 쉬울 수 있습니다:

```dart
'42'.parseInt()
```

To enable that code, you can import a library that contains an extension of the `String` class:

해당 기능을 활성화하려면 String 클래스의 확장(extension)을 포함하는 라이브러리를 가져와야 합니다.

```dart
import 'string_apis.dart';
// ···
print('42'.parseInt()); // Use an extension method.
```

Extensions can define not just methods, but also other members such as getter, setters, and operators. Also, extensions can have names, which can be helpful if an API conflict arises. Here's how you might implement the extension method `parseInt()`, using an extension (named `NumberParsing`) that operates on strings:

Extensions는 메서드뿐만 아니라 게터, 세터, 연산자와 같은 다른 멤버들도 정의할 수 있습니다. 또한, API 충돌이 발생할 경우 유용할 수 있는 이름을 가질 수도 있습니다. 아래는 확장(extension)인 NumberParsing을 사용하여 parseInt() 메서드를 구현하는 예시입니다:

```dart
//lib/string_apis.dart
extension NumberParsing on String {
  int parseInt() {
    return int.parse(this);
  }
  // ···
}
```

The next section describes how to _use_ extension methods. After that are sections about _implementing_ extension methods.

다음 섹션에서는 확장 메서드를 사용하는 방법에 대해 설명하고 있습니다. 그 다음으로는 확장 메서드를 구현하는 방법에 대한 섹션이 있습니다.
## Using extension methods

Like all Dart code, extension methods are in libraries. You've already seen how to use an extension method—just import the library it's in, and use it like an ordinary method:

## 확장 메서드 사용하기

확장 메서드도 모든 Dart 코드와 마찬가지로 라이브러리에 포함됩니다. 이미 확장 메서드를 사용하는 방법을 보셨습니다—그것이 포함된 라이브러리를 가져오고, 일반 메서드처럼 사용하면 됩니다:

```dart
// Import a library that contains an extension on String.
import 'string_apis.dart';
// ···
print('42'.padLeft(5)); // Use a String method.
print('42'.parseInt()); // Use an extension method.
```

That's all you usually need to know to use extension methods. As you write your code, you might also need to know how extension methods depend on static types (as opposed to `dynamic`) and how to resolve [API conflicts](https://dart.dev/language/extension-methods#api-conflicts).

보통 확장 메서드를 사용하는 데 필요한 정보는 여기까지입니다. 코드를 작성하면서 확장 메서드가 정적 타입(static types)에 어떻게 의존하는지와 API 충돌을 해결하는 방법도 알아야 할 수 있습니다.

### Static types and dynamic

You can't invoke extension methods on variables of type `dynamic`. For example, the following code results in a runtime exception:

### 정적 타입과 동적

동적(dynamic) 타입의 변수에는 확장 메서드를 호출할 수 없습니다. 예를 들어, 다음 코드는 런타임 예외를 발생시킵니다:

```dart
dynamic d = '2';
print(d.parseInt()); // Runtime exception: NoSuchMethodError
```

Extension methods _do_ work with Dart's type inference. The following code is fine because the variable `v` is inferred to have type `String`:

확장 메서드는 Dart의 타입 추론과 함께 작동합니다. 다음 코드는 v 변수가 String 타입으로 추론되기 때문에 잘 동작합니다:

```dart
var v = '2';
print(v.parseInt()); // Output: 2
```

The reason that `dynamic` doesn't work is that extension methods are resolved against the static type of the receiver. Because extension methods are resolved statically, they're as fast as calling a static function.

For more information about static types and `dynamic`, see [The Dart type system](https://dart.dev/language/type-system).

동적 타입(dynamic)에서 확장 메서드를 사용할 수 없는 이유는 확장 메서드가 수신자(receiver)의 정적 타입(static type)에 따라 해결되기 때문입니다. 확장 메서드는 정적으로 해결되기 때문에 정적 함수를 호출하는 것과 동일한 속도로 동작합니다.

정적 타입과 동적에 대한 더 자세한 정보는 Dart 타입 시스템을 참조하세요.

### API conflicts

If an extension member conflicts with an interface or with another extension member, then you have a few options.

One option is changing how you import the conflicting extension, using `show` or `hide` to limit the exposed API:

### API 충돌

확장 멤버가 인터페이스나 다른 확장 멤버와 충돌하는 경우, 몇 가지 옵션이 있습니다.

하나의 옵션은 충돌하는 확장을 가져올 때 show 또는 hide를 사용하여 노출된 API를 제한하는 것입니다:

```dart
// Defines the String extension method parseInt().
import 'string_apis.dart';

// Also defines parseInt(), but hiding NumberParsing2
// hides that extension method.
import 'string_apis_2.dart' hide NumberParsing2;

// ···
// Uses the parseInt() defined in 'string_apis.dart'.
print('42'.parseInt());
```

Another option is applying the extension explicitly, which results in code that looks as if the extension is a wrapper class:

또 다른 옵션은 확장을 명시적으로 적용하는 것입니다. 이는 확장이 래퍼 클래스처럼 보이는 코드를 생성합니다:

```dart
// Both libraries define extensions on String that contain parseInt(),
// and the extensions have different names.
import 'string_apis.dart'; // Contains NumberParsing extension.
import 'string_apis_2.dart'; // Contains NumberParsing2 extension.

// ···
// print('42'.parseInt()); // Doesn't work.
print(NumberParsing('42').parseInt());
print(NumberParsing2('42').parseInt());
```

If both extensions have the same name, then you might need to import using a prefix:

만약 두 확장(extension)이 동일한 이름을 가지고 있다면, 접두사(prefix)를 사용하여 가져와야 할 수 있습니다:

```dart
// Both libraries define extensions named NumberParsing
// that contain the extension method parseInt(). One NumberParsing
// extension (in 'string_apis_3.dart') also defines parseNum().
import 'string_apis.dart';
import 'string_apis_3.dart' as rad;

// ···
// print('42'.parseInt()); // Doesn't work.

// Use the ParseNumbers extension from string_apis.dart.
print(NumberParsing('42').parseInt());

// Use the ParseNumbers extension from string_apis_3.dart.
print(rad.NumberParsing('42').parseInt());

// Only string_apis_3.dart has parseNum().
print('42'.parseNum());
```

As the example shows, you can invoke extension methods implicitly even if you import using a prefix. The only time you need to use the prefix is to avoid a name conflict when invoking an extension explicitly.

예제에서 보여주듯이, 접두사(prefix)를 사용하여 가져온 경우에도 암시적으로 확장 메서드를 호출할 수 있습니다. 접두사를 사용해야 하는 유일한 경우는 확장을 명시적으로 호출할 때 이름 충돌을 피하기 위한 경우입니다.
## Implementing extension methods

Use the following syntax to create an extension:

## 구현 중인 확장 메서드

다음 구문을 사용하여 확장(extension)을 생성하세요:

```
extension <extension name>? on <type> { // <extension-name> is optional
  (<member definition>)* // Can provide one or more <member definition>.
}
```

For example, here's how you might implement an extension on the `String` class:

예를 들어, String 클래스에 확장(extension)을 구현하는 방법은 다음과 같습니다:

```dart
//lib/string_apis.dart
extension NumberParsing on String {
  int parseInt() {
    return int.parse(this);
  }

  double parseDouble() {
    return double.parse(this);
  }
}
```

The members of an extension can be methods, getters, setters, or operators. Extensions can also have static fields and static helper methods. To access static members outside the extension declaration, invoke them through the declaration name like [class variables and methods](https://dart.dev/language/classes#class-variables-and-methods).

확장(extension)의 멤버로는 메서드, 게터, 세터, 연산자가 포함될 수 있습니다. 또한 확장은 정적 필드(static fields)와 정적 도우미 메서드(static helper methods)를 가질 수 있습니다. 확장 외부에서 정적 멤버에 접근할 때는 클래스 변수와 메서드처럼 선언 이름을 통해 호출해야 합니다.
### Unnamed extensions

When declaring an extension, you can omit the name. Unnamed extensions are visible only in the library where they're declared. Since they don't have a name, they can't be explicitly applied to resolve [API conflicts](https://dart.dev/language/extension-methods#api-conflicts).

### 이름이 없는 확장

확장을 선언할 때 이름을 생략할 수도 있습니다. 이름이 없는 확장은 선언된 라이브러리에서만 보입니다. 이름이 없기 때문에 API 충돌을 해결하기 위해 명시적으로 적용할 수는 없습니다.

```dart
extension on String {
  bool get isBlank => trim().isEmpty;
}
```

_Note_

You can invoke an unnamed extension's static members only within the extension declaration.

_정보_

이름이 없는 확장의 정적 멤버는 확장 선언 내부에서만 호출할 수 있습니다.
## Implementing generic extensions

Extensions can have generic type parameters. For example, here's some code that extends the built-in `List<T>` type with a getter, an operator, and a method:

## 일반적인 확장 구현

확장은 제네릭 타입 매개변수를 가질 수 있습니다. 예를 들어, 내장된 List\<T> 타입을 getter, 연산자, 메서드로 확장하는 코드를 보여드리겠습니다:

```dart
extension MyFancyList<T> on List<T> {
  int get doubleLength => length * 2;
  List<T> operator -() => reversed.toList();
  List<List<T>> split(int at) => [sublist(0, at), sublist(at)];
}
```

The type `T` is bound based on the static type of the list that the methods are called on.

타입 `T`는 메서드가 호출된 리스트의 정적 타입에 따라 결정됩니다.
## Resources

For more information about extension methods, see the following:

- [Article: Dart Extension Methods Fundamentals](https://medium.com/dartlang/extension-methods-2d466cd8b308)
- [Feature specification](https://github.com/dart-lang/language/blob/main/accepted/2.7/static-extension-methods/feature-specification.md#dart-static-extension-methods-design)
- [Extension methods sample](https://github.com/dart-lang/samples/tree/main/extension_methods)
## 리소스

확장 메서드에 대해 더 알고 싶다면 다음을 참조하세요:

- 기사: Dart 확장 메서드 기초
- 기능 명세
- 확장 메서드 예제

# Extension types

An extension type is a compile-time abstraction that "wraps" an existing type with a different, static-only interface. They are a major component of [static JS interop](https://dart.dev/go/next-gen-js-interop) because they can easily modify an existing type's interface (crucial for any kind of interop) without incurring the cost of an actual wrapper.

Extension types enforce discipline on the set of operations (or interface) available to objects of an underlying type, called the _representation type_. When defining the interface of an extension type, you can choose to reuse some members of the representation type, omit others, replace others, and add new functionality.

The following example wraps the `int` type to create an extension type that only allows operations that make sense for ID numbers:

확장 타입은 기존 타입을 다른 정적 인터페이스로 "덮는" 컴파일 타임 추상화입니다. 이들은 실제 래퍼의 비용을 지불하지 않고도 중요한 상호 운용성을 위해 기존 타입의 인터페이스를 쉽게 수정할 수 있는 정적 JS 상호 운용성의 주요 구성 요소입니다.

확장 타입은 표현 타입이라고 불리는 기존 타입의 객체에 대해 사용 가능한 연산(또는 인터페이스)의 집합에 대한 규율을 부여합니다. 확장 타입의 인터페이스를 정의할 때, 표현 타입의 일부 멤버를 재사용하거나, 일부를 생략하거나, 일부를 대체하거나, 새로운 기능을 추가할 수 있습니다.

다음 예시는 ID 번호에 대해 의미 있는 연산만을 허용하는 확장 타입을 만들기 위해 int 타입을 래핑합니다:

```dart
extension type IdNumber(int id) {
  // Wraps the 'int' type's '<' operator:
  operator <(IdNumber other) => id < other.id;
  // Doesn't declare the '+' operator, for example,
  // because addition does not make sense for ID numbers.
}

void main() {
  // Without the discipline of an extension type,
  // 'int' exposes ID numbers to unsafe operations:
  int myUnsafeId = 42424242;
  myUnsafeId = myUnsafeId + 10; // This works, but shouldn't be allowed for IDs.

  var safeId = IdNumber(42424242);
  safeId + 10; // Compile-time error: No '+' operator.
  myUnsafeId = safeId; // Compile-time error: Wrong type.
  myUnsafeId = safeId as int; // OK: Run-time cast to representation type.
  safeId < IdNumber(42424241); // OK: Uses wrapped '<' operator.
}
```

_Note_

Extension types serve the same purpose as **wrapper classes**, but don't require the creation of an extra run-time object, which can get expensive when you need to wrap lots of objects. Because extension types are static-only and compiled away at run time, they are essentially zero cost.

[**Extension methods**](https://dart.dev/language/extension-methods) (also known just as "extensions") are a static abstraction similar to extension types. However, an extension method adds functionality _directly_ to every instance of its underlying type. Extension types are different; an extension type's interface _only_ applies to expressions whose static type is that extension type. They are distinct from the interface of their underlying type by default.

_정보_

확장 타입은 런타임 객체 생성 없이 기존 타입을 "래핑"하는 컴파일 타임 추상화입니다. 이는 많은 객체를 래핑할 때 발생할 수 있는 비용 문제를 해결합니다. 확장 타입은 정적으로만 존재하며 런타임에서는 컴파일되어 사라지므로 사실상 제로 비용으로 동작합니다.

확장 메소드(또는 단순히 "확장")는 확장 타입과 유사한 정적 추상화입니다. 그러나 확장 메소드는 직접적으로 기존 타입의 모든 인스턴스에 기능을 추가합니다. 확장 타입은 다릅니다; 확장 타입의 인터페이스는 해당 확장 타입의 정적 타입을 갖는 표현식에만 적용됩니다. 기본적으로 기존 타입의 인터페이스와는 다릅니다.
## Syntax

### Declaration

Define a new extension type with the `extension type` declaration and a name, followed by the _representation type declaration_ in parenthesis:

## 구문

### 선언

확장 타입 선언과 이름을 사용하여 새로운 확장 타입을 정의하고, 괄호 안에 표현 타입을 선언합니다:

```dart
extension type E(int i) {
  // Define set of operations.
}
```

The representation type declaration `(int i)` specifies that the underlying type of extension type `E` is `int`, and that the reference to the _representation object_ is named `i`. The declaration also introduces:

- An implicit getter for the representation object with the representation type as the return type: `int get i`.
- An implicit constructor: `E(int i) : i = i`.

The representation object gives the extension type access to an object at the underlying type. The object is in scope in the extension type body, and you can access it using its name as a getter:

- Within the extension type body using `i` (or `this.i` in a constructor).
- Outside with a property extraction using `e.i` (where `e` has the extension type as its static type).

Extension type declarations can also include [type parameters](https://dart.dev/language/generics) just like classes or extensions:

표현 타입 선언 (`int i`)은 확장 타입 E의 기본 타입이 int임을 명시하며, 표현 객체에 대한 참조를 i라는 이름으로 지정합니다. 이 선언은 다음과 같은 요소들을 도입합니다:

- 표현 객체의 암시적 getter: 이 getter의 반환 타입은 표현 타입입니다. `int get i`.
- 암시적 생성자: `E(int i) : i = i`.

표현 객체는 확장 타입에게 기본 타입의 객체에 접근할 수 있는 권한을 제공합니다. 이 객체는 확장 타입의 본문에서 유효하며, getter 이름을 사용하여 접근할 수 있습니다:

- 확장 타입 본문 내에서 `i`를 사용하여 접근합니다 (또는 생성자에서 `this.i`).
- 확장 타입의 정적 타입으로 `e`를 사용하여 속성 추출을 통해 접근합니다 (`e.i`).

확장 타입 선언은 클래스나 확장과 마찬가지로 타입 매개변수를 포함할 수 있습니다:

```dart
extension type E<T>(List<T> elements) {
  // ...
}
```
### Constructors

You can optionally declare [constructors](https://dart.dev/language/constructors) in an extension type's body. The representation declaration itself is an implicit constructor, so by default takes the place of an unnamed constructor for the extension type. Any additional non-redirecting generative constructors must initialize the representation object's instance variable using `this.i` in its initializer list or formal parameters.

### 생성자

확장 타입의 본문에 생성자를 선택적으로 선언할 수 있습니다. 표현 선언 자체가 암시적 생성자이므로, 기본적으로 확장 타입의 명명되지 않은 생성자의 역할을 합니다. 추가적인 비리다이렉트 생성자는 초기화 목록이나 형식 매개변수를 사용하여 표현 객체의 인스턴스 변수를 초기화해야 합니다.

```dart
extension type E(int i) {
  E.n(this.i);
  E.m(int j, String foo) : i = j + foo.length;
}

void main() {
  E(4); // Implicit unnamed constructor.
  E.n(3); // Named constructor.
  E.m(5, "Hello!"); // Named constructor with additional parameters.
}
```

Or, you can name the representation declaration constructor, in which case there is room for an unnamed constructor in the body:

또는 표현 선언 생성자에 이름을 지정할 수 있습니다. 이 경우 본문에 명명되지 않은 생성자가 있을 수 있습니다.

```dart
extension type const E._(int it) {
  E(): this._(42);
  E.otherName(this.it);
}

void main2() {
  E();
  const E._(2);
  E.otherName(3);
}
```

You can also completely hide the constructor, instead of just defining a new one, using the same private constructor syntax for classes, `_`. For example, if you only want clients constructing `E` with a `String`, even though the underlying type is `int`:

생성자를 완전히 숨길 수도 있습니다. 클래스에서와 같은 방식으로 private 생성자 구문을 사용하여 숨길 수 있습니다. 예를 들어, 내부 타입이 int일 때도 클라이언트가 문자열로만 E를 생성하도록 하려면 다음과 같이 할 수 있습니다:

```dart
extension type E._(int i) {
  E.fromString(String foo) : i = int.parse(foo);
}
```

You can also declare forwarding generative constructors, or [factory constructors](https://dart.dev/language/constructors#factory-constructors) (which can also forward to constructors of sub-extension types).

전달 생성자나 팩토리 생성자를 선언할 수도 있습니다. 이 생성자들은 서브 확장 타입의 생성자로 전달할 수도 있습니다.

### Members

Declare members in the body of an extension type to define its interface the same way you would for class members. Extension type members can be methods, getters, setters, or operators (non-[`external`](https://dart.dev/language/functions#external) [instance variables](https://dart.dev/language/classes#instance-variables) and [abstract members](https://dart.dev/language/methods#abstract-methods) are not allowed):

### 멤버

확장 타입의 멤버는 클래스 멤버와 동일한 방식으로 인터페이스를 정의하는 데 사용됩니다. 이 멤버들은 메서드, 게터, 세터, 연산자 등이 될 수 있습니다. 단, 외부 인스턴스 변수와 추상 멤버는 허용되지 않습니다.

```dart
extension type NumberE(int value) {
  // Operator:
  NumberE operator +(NumberE other) =>
      NumberE(value + other.value);
  // Getter:
  NumberE get myNum => this;
  // Method:
  bool isValid() => !value.isNegative;
}
```

Interface members of the representation type are not interface members of the extension type [by default](https://dart.dev/language/extension-types#transparency). To make a single member of the representation type available on the extension type, you must write a declaration for it in the extension type definition, like the `operator +` in `NumberE`. You also can define new members unrelated to the representation type, like the `i` getter and `isValid` method.

확장 타입의 인터페이스 멤버는 기본적으로 표현 타입의 인터페이스 멤버가 아닙니다. 확장 타입에서 표현 타입의 단일 멤버를 사용하려면 확장 타입 정의에서 해당 멤버에 대한 선언을 작성해야 합니다. 예를 들어, `NumberE`에서 `+` 연산자와 같은 멤버를 정의하는 것처럼 표현 타입의 멤버를 확장 타입에서 사용할 수 있습니다. 또한, `i` 게터와 `isValid` 메서드와 같이 표현 타입과 관련 없는 새로운 멤버들을 정의할 수도 있습니다.

### Implements

You can optionally use the `implements` clause to:

- Introduce a subtype relationship on an extension type, AND
- Add the members of the representation object to the extension type interface.
### Implements

`implements` 절을 사용하면 Dart의 확장 타입에서 다음과 같은 두 가지 주요 목적을 달성할 수 있습니다:

- 서브타입 관계 도입
- 표현 객체의 멤버를 확장 타입 인터페이스에 추가

The `implements` clause introduces an [applicability](https://github.com/dart-lang/language/blob/main/accepted/2.7/static-extension-methods/feature-specification.md#examples) relationship like the one between an [extension method](https://dart.dev/language/extension-methods) and its `on` type. Members that are applicable to the supertype are applicable to the subtype as well, unless the subtype has a declaration with the same member name.

An extension type can only implement:

`implements` 절을 사용하면 확장 타입에서 하위 타입 관계를 도입하고, 표현 객체의 멤버를 확장 타입 인터페이스에 추가할 수 있습니다. 이 절은 확장 메서드와 대상 타입 사이의 적용 관계를 도입합니다. 상위 타입에 적용 가능한 멤버는 하위 타입에도 적용 가능하며, 하위 타입에서 동일한 멤버 이름을 가진 선언이 있는 경우를 제외하고 적용됩니다.

확장 타입은 다음과 같은 타입만 구현할 수 있습니다:

- **Its representation type**. This makes all members of the representation type implicitly available to the extension type.

- **그 표현 유형의 특성입니다**. 이로 인해 표현 유형의 모든 구성원이 확장 유형에서 암시적으로 사용할 수 있게 됩니다.

  ```dart
   extension type NumberI(int i) 
   implements int{
   // 'NumberI' can invoke all members of 'int',
   // plus anything else it declares here.
  }
  ```

- **A supertype of its representation type**. This makes the members of the supertype available, while not necessarily all the members of representation type.

- **그 표현 유형의 상위 유형입니다**. 이로 인해 상위 유형의 구성원들은 사용 가능하지만, 반드시 모든 표현 유형의 구성원이 사용 가능한 것은 아닙니다.

 ```dart
   extension type Sequence<T>(List<T> _) implements Iterable<T> {
   // Better operations than List.
  }
  
 extension type Id(int _id) implements Object {
   // Makes the extension type non-nullable.
  static Id? tryParse(String source) => int.tryParse(source) as Id?;
  }
  ```

- **Another extension type** that is valid on the same representation type. This allows you to reuse operations across multiple extension types (similar to multiple inheritance).
-
- 같은 표현 유형에 대해 유효한 **다른 확장 유형**입니다. 이를 통해 여러 확장 유형 간에 작업을 재사용할 수 있게 됩니다 (다중 상속과 유사합니다).
 ```dart
  extension type const Opt<T>._(({T value})? _) { 
  const factory Opt(T value) = Val<T>;
  const factory Opt.none() = Non<T>;
  }
  extension type const Val<T>._(({T value}) _) implements Opt<T> { 
  const Val(T value) : this._((value: value));
  T get value => _.value;
  }
  extension type const Non<T>._(Null _) implements Opt<Never> {
   const Non() : this._(null);
  }
   ```


Read the [Usage](https://dart.dev/language/extension-types#usage) section to learn more about the effect of `implements` in different scenarios.

다양한 시나리오에서 implements의 효과에 대해 알아보려면 사용 방법 섹션을 읽어보세요.

#### `@redeclare`

Declaring an extension type member that shares a name with a member of a supertype is _not_ an override relationship like it is between classes, but rather a _redeclaration_. An extension type member declaration _completely replaces_ any supertype member with the same name. It's not possible to provide an alternative implementation for the same function.

You can use the `@redeclare` annotation to tell the compiler you are _knowingly_ choosing to use the same name as a supertype's member. The analyzer will then warn you if that's not actually true, for example if one of the names are mistyped.

#### `@redeclare`

클래스 간의 오버라이드 관계와 달리, 이름이 같은 상위 유형 멤버와 확장 유형 멤버를 선언하는 것은 재선언(redeclaration)입니다. 확장 유형 멤버 선언은 동일한 이름의 상위 유형 멤버를 완전히 대체합니다. 동일한 함수에 대한 대체 구현을 제공하는 것은 불가능합니다.

@redeclare 주석을 사용하여 컴파일러에게 이름을 의도적으로 상위 유형 멤버와 동일하게 사용하겠다고 알릴 수 있습니다. 이를 통해 이름이 잘못 입력되었을 경우 분석기가 경고를 표시하도록 할 수 있습니다.

```dart
extension type MyString(String _) implements String {
  // Replaces 'String.operator[]'
  @redeclare
  int operator [](int index) => codeUnitAt(index);
}
```

You can also enable the lint [`annotate_redeclares`](https://dart.dev/tools/linter-rules/annotate_redeclares) to get a warning if you declare an extension type method that hides a superinterface member and _isn't_ annotated with `@redeclare`.

`annotate_redeclares`를 활성화하면 확장 유형 메서드를 선언할 때 @redeclare 주석을 달지 않고 상위 인터페이스 멤버를 숨기면 경고를 받을 수 있습니다.
## Usage

To use an extension type, create an instance the same as you would with a class: by calling a constructor:

## 사용법

확장 유형을 사용하려면 클래스와 마찬가지로 생성자를 호출하여 인스턴스를 만들면 됩니다.

```dart
extension type NumberE(int value) {
  NumberE operator +(NumberE other) =>
      NumberE(value + other.value);

  NumberE get next => NumberE(value + 1);
  bool isValid() => !value.isNegative;
}

void testE() { 
  var num = NumberE(1);
}
```

Then, you can invoke members on the object as you would with a class object.

There are two equally valid, but substantially different core use cases for extension types:

1. Providing an _extended_ interface to an existing type.
2. Providing a _different_ interface to an existing type.

그럼 당신은 클래스 객체와 마찬가지로 객체의 멤버를 호출할 수 있습니다.

확장 유형에는 두 가지 동등하게 유효하지만 본질적으로 다른 핵심 사용 사례가 있습니다:

1. 기존 유형에 대한 확장된 인터페이스 제공하기.
2. 기존 유형에 대해 다른 인터페이스 제공하기.

_Note_

In any case, the representation type of an extension type is never its subtype, so a representation type can't be used interchangeably where the extension type is needed.

_정보_

어떤 경우에도, 확장 유형의 표현 유형은 절대 그 하위 유형이 될 수 없으므로, 표현 유형은 확장 유형이 필요한 곳에서 상호 교환하여 사용될 수 없습니다.
### 1. Provide an _extended_ interface to an existing type

When an extension type [implements](https://dart.dev/language/extension-types#implements) its representation type, you can consider it "transparent", because it allows the extension type to "see" the underlying type.

A transparent extension type can invoke all members of the representation type (that aren't [redeclared](https://dart.dev/language/extension-types#redeclare)), plus any auxillary members it defines. This creates a new, _extended_ interface for an existing type. The new interface is available to expressions whose static type is the extension type.

This means you _can_ invoke members of the representation type (unlike a [non-transparent](https://dart.dev/language/extension-types#2-provide-a-different-interface-to-an-existing-type) extension type), like so:

### 1. 기존 유형에 대한 확장된 인터페이스 제공하기

확장 유형이 자신의 표현 유형을 구현할 때, 이는 "투명"하다고 간주할 수 있습니다. 왜냐하면 이는 확장 유형이 기본 유형을 "볼 수 있게" 해주기 때문입니다.

투명한 확장 유형은 표현 유형의 모든 멤버(재선언되지 않은 멤버들)와 자체적으로 정의한 보조 멤버들을 호출할 수 있습니다. 이는 기존 유형에 대해 새로운 확장된 인터페이스를 생성합니다. 새로운 인터페이스는 확장 유형의 정적 유형이 되는 표현식에서 사용할 수 있습니다.

즉, 다음과 같이 표현 유형의 멤버들을 호출할 수 있습니다 (비투명한 확장 유형과는 달리):

```dart
extension type NumberT(int value) 
  implements int {
  // Doesn't explicitly declare any members of 'int'.
  NumberT get i => this;
}

void main () {
  // All OK: Transparency allows invoking `int` members on the extension type:
  var v1 = NumberT(1); // v1 type: NumberT
  int v2 = NumberT(2); // v2 type: int
  var v3 = v1.i - v1;  // v3 type: int
  var v4 = v2 + v1; // v4 type: int
  var v5 = 2 + v1; // v5 type: int
  // Error: Extension type interface is not available to representation type
  v2.i;
}
```

You can also have a "mostly-transparent" extension type that adds new members and adapts others by redeclaring a given member name from the supertype. This would allow you to use stricter types on some parameters of a method, or different default values, for example.

Another mostly-transparent extension type approach is to implement a type that is a supertype of the representation type. For example, if the representation type is private but its supertype defines the part of the interface that matters for clients.

"대체로 투명한" 확장 유형을 가질 수도 있습니다. 이는 새로운 멤버를 추가하고 다른 멤버들을 적응시키는 방식으로, 상위 유형에서 주어진 멤버 이름을 재선언함으로써 이루어질 수 있습니다. 이를 통해 메서드의 일부 매개변수에 보다 엄격한 유형을 사용하거나 다른 기본값을 지정하는 등의 작업이 가능합니다.

또 다른 대체로 투명한 확장 유형 접근 방식은 표현 유형의 상위 유형을 구현하는 것입니다. 예를 들어, 표현 유형이 비공개이지만 그 상위 유형이 클라이언트에 중요한 인터페이스 부분을 정의할 때 이를 구현할 수 있습니다.
### 2. Provide a _different_ interface to an existing type

An extension type that is not [transparent](https://dart.dev/language/extension-types#transparency) (that does not [`implement`](https://dart.dev/language/extension-types#implements) its representation type) is statically treated as a completely new type, distinct from its representation type. You can't assign it to its representation type, and it doesn't expose its representation type's members.

For example, take the `NumberE` extension type we declared under [Usage](https://dart.dev/language/extension-types#usage):

### 2. 기존 유형에 대해 다른 인터페이스 제공하기

투명하지 않은 확장 유형 (자신의 표현 유형을 구현하지 않는 경우)은 정적으로 완전히 새로운 유형으로 처리됩니다. 이는 표현 유형과 구분된 별도의 유형으로 취급됩니다. 이 유형은 표현 유형에 할당할 수 없으며, 표현 유형의 멤버들을 노출하지 않습니다.

예를 들어, 사용법에서 선언한 NumberE 확장 유형을 살펴봅시다:

```dart
void testE() { 
  var num1 = NumberE(1);
  int num2 = NumberE(2); // Error: Can't assign 'NumberE' to 'int'.
  
  num1.isValid(); // OK: Extension member invocation.
  num1.isNegative(); // Error: 'NumberE' does not define 'int' member 'isNegative'.
  
  var sum1 = num1 + num1; // OK: 'NumberE' defines '+'.
  var diff1 = num1 - num1; // Error: 'NumberE' does not define 'int' member '-'.
  var diff2 = num1.value - 2; // OK: Can access representation object with reference.
  var sum2 = num1 + 2; // Error: Can't assign 'int' to parameter type 'NumberE'. 
  
  List<NumberE> numbers = [
    NumberE(1), 
    num1.next, // OK: 'next' getter returns type 'NumberE'.
    1, // Error: Can't assign 'int' element to list type 'NumberE'.
  ];
}
```

You can use an extension type this way to _replace_ the interface of an existing type. This allows you to model an interface that is makes sense for the constraints of your new type (like the `IdNumber` example in the introduction), while also benefitting from the performance and convenience of a simple pre-defined type, like `int`.

This use case is as close as you can get to the complete encapsulation of a wrapper class (but is realistically only a [_somewhat_ protected](https://dart.dev/language/extension-types#type-considerations) abstraction).

확장 유형을 이렇게 사용하여 기존 유형의 인터페이스를 대체할 수 있습니다. 이를 통해 새 유형의 제약 조건에 맞는 인터페이스를 모델링할 수 있습니다 (예: 소개에서 소개된 IdNumber 예제), 동시에 int와 같은 간단하고 미리 정의된 유형의 성능과 편의성을 얻을 수 있습니다.

이 사용 사례는 완전한 래퍼 클래스 캡슐화에 가까운 방식으로, 실제로는 다소 보호된 추상화에 해당합니다.
## Type considerations

Extension types are a compile-time wrapping construct. At run time, there is absolutely no trace of the extension type. Any type query or similar run-time operations work on the representation type.

This makes extension types an _unsafe_ abstraction, because you can always find out the representation type at run time and access the underlying object.

Dynamic type tests (`e is T`), casts (`e as T`), and other run-time type queries (like `switch (e) ...` or `if (e case ...)`) all evaluate to the underlying representation object, and type check against that object's runtime type. That's true when the static type of `e` is an extension type, and when testing against an extension type (`case MyExtensionType(): ...`).

## 유형 고려 사항

확장 유형은 컴파일 시간에만 존재하는 래핑 구조입니다. 실행 시간에는 확장 유형에 대한 어떠한 흔적도 존재하지 않습니다. 모든 유형 쿼리나 비슷한 실행 시간 작업은 표현 유형을 기준으로 동작합니다.

이는 확장 유형을 안전하지 않은 추상화로 만듭니다. 왜냐하면 실행 시간에 언제든지 표현 유형을 찾아내고 해당 기본 객체에 접근할 수 있기 때문입니다.

동적 유형 검사 (e is T), 캐스트 (e as T) 및 다른 실행 시간 유형 쿼리 (예: switch (e) ... 또는 if (e case ...))는 모두 기본 표현 객체를 평가하고, 해당 객체의 실행 시간 유형에 대해 유형 검사를 수행합니다. 이는 e의 정적 유형이 확장 유형인 경우와 확장 유형을 테스트할 때 (case MyExtensionType(): ...) 모두 마찬가지입니다.

```dart
void main() {
  var n = NumberE(1);

  // Run-time type of 'n' is representation type 'int'.
  if (n is int) print(n.value); // Prints 1.

  // Can use 'int' methods on 'n' at run time.
  if (n case int x) print(x.toRadixString(10)); // Prints 1.
  switch (n) {
    case int(:var isEven): print("$n (${isEven ? "even" : "odd"})"); // Prints 1 (odd).
  }
}
```

Similarly, the static type of the matched value is that of the extension type in this example:

비슷하게, 이 예제에서 맞춰진 값의 정적 유형은 확장 유형과 같습니다:

```dart
void main() {
  int i = 2;
  if (i is NumberE) print("It is"); // Prints 'It is'.
  if (i case NumberE v) print("value: ${v.value}"); // Prints 'value: 2'.
  switch (i) {
    case NumberE(:var value): print("value: $value"); // Prints 'value: 2'.
  }
}
```

It's important to be aware of this quality when using extension types. Always keep in mind that an extension type exists and matters at compile time, but gets erased _during_ compilation.

For example, consider an expression `e` whose static type is the extension type `E`, and the representation type of `E` is `R`. Then, the run-time type of the value of `e` is a subtype of `R`. Even the type itself is erased; `List<E>` is exactly the same thing as `List<R>` at run time.

In other words, a real wrapper class can encapsulate a wrapped object, whereas an extension type is just a compile-time view on the wrapped object. While a real wrapper is safer, the trade-off is extension types give you the option to avoid wrapper objects, which can greatly improve performance in some scenarios.

확장 타입을 사용할 때 이러한 특성을 인지하는 것이 중요합니다. 확장 타입은 컴파일 시점에 존재하고 중요하지만, 컴파일 중에 사라진다는 것을 항상 명심하세요.

예를 들어, 정적 타입이 확장 타입 E인 표현식 e를 고려해보세요. E의 표현 타입이 R이라면, e의 값의 런타임 타입은 R의 하위 타입입니다. 타입 자체가 지워지더라도, List\<E>는 런타임에서 List\<R>과 정확히 동일한 것입니다.

다시 말해, 실제 래퍼 클래스는 래핑된 객체를 캡슐화할 수 있는 반면, 확장 타입은 래핑된 객체에 대한 컴파일 시점의 뷰일 뿐입니다. 실제 래퍼는 더 안전하지만, 확장 타입은 래퍼 객체를 피할 수 있는 옵션을 제공하여 특정 시나리오에서 성능을 크게 향상시킬 수 있다는 점에서 타협점이 됩니다.

# Callable object

To allow an instance of your Dart class to be called like a function, implement the `call()` method.

The `call()` method allows an instance of any class that defines it to emulate a function. This method supports the same functionality as normal [functions](https://dart.dev/language/functions) such as parameters and return types.

In the following example, the `WannabeFunction` class defines a `call()` function that takes three strings and concatenates them, separating each with a space, and appending an exclamation. Click **Run** to execute the code.

당신의 Dart 클래스 인스턴스를 함수처럼 호출할 수 있도록 하려면, call() 메서드를 구현하세요.

call() 메서드는 이를 정의하는 클래스의 인스턴스가 함수를 모방할 수 있게 해줍니다. 이 메서드는 파라미터와 반환 타입 같은 일반 함수와 동일한 기능을 지원합니다.

다음 예제에서 WannabeFunction 클래스는 세 개의 문자열을 받아 각 문자열을 공백으로 구분하고, 느낌표를 추가하여 연결하는 call() 함수를 정의합니다. 코드를 실행하려면 Run을 클릭하세요.

```dart
class WannabeFunction {
  String call(String a, String b, String c) => '$a $b $c!';
}

var wf = WannabeFunction();
var out = wf('Hi', 'there,', 'gang');

void main() => print(out);
```

```
Hi there, gang!
```
