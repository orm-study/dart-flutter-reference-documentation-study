🔗 [[페이지 링크]](https://dart.dev/language/mixins)

# Mixins 믹스인

**Mixins are a way of defining code that can be reused in multiple class hierarchies. They are intended to provide member implementations en masse.**

Mixins는 여러 클래스 계층에서 재사용할 수 있는 코드를 정의하는 방법이다. Mixins는 대량으로 멤버 구현을 제공하기 위해 사용된다.

-   **[Q] 대량으로 멤버를 구현하는게 뭐지?**
    
    “대량의 멤버 구현”은 여러 개의 메서드, 필드, getter, setter 등을 한 번에 제공하는 것을 의미합니다. 이는 코드의 재사용성을 높이고, 중복 코드를 줄이는 데 큰 도움을 줍니다. Mixins는 이런 멤버 구현들을 한 번에 제공하여 여러 클래스에서 이를 재사용할 수 있도록 합니다.
    
    예를 들어, 여러 클래스에서 공통적으로 사용되는 로깅 기능을 mixin으로 정의하고, 이를 필요로 하는 클래스에 쉽게 추가할 수 있습니다.
    

**To use a mixin, use the `with` keyword followed by one or more mixin names. The following example shows two classes that use (or, are subclasses of) mixins:**

믹스인을 사용하려면, with 키워드를 사용하고 그 뒤에 하나 이상의 믹스인 이름을 붙인다. 다음 예제는 믹스인을 사용하는(또는 믹스인의 서브클래스인) 두 클래스를 보여준다.

```dart
class Musician extends Performer with Musical {
  // ···
}

class Maestro extends Person with Musical, Aggressive, Demented {
  Maestro(String maestroName) {
    name = maestroName;
    canConduct = true;
  }
}

```

**To define a mixin, use the `mixin` declaration. In the rare case where you need to define both a mixin _and_ a class, you can use the [`mixin class` declaration](https://dart.dev/language/mixins#class-mixin-or-mixin-class).**

Mixins를 정의하려면, mixin 선언을 사용한다. Mixins와 클래스를 모두 정의해야 하는 드문 경우에는 mixin class 선언을 사용할 수 있다.

**Mixins and mixin classes cannot have an `extends` clause, and must not declare any generative constructors.**

Mixins와 mixin 클래스는 extends 절을 가질 수 없으며, 생성자를 선언해서는 안 된다.

**For example:**

예를 들어:

```dart
mixin Musical {
  bool canPlayPiano = false;
  bool canCompose = false;
  bool canConduct = false;

  void entertainMe() {
    if (canPlayPiano) {
      print('Playing piano');
    } else if (canConduct) {
      print('Waving hands');
    } else {
      print('Humming to self');
    }
  }
}

```


## **Specify members a mixin can call on itself**[#](https://dart.dev/language/mixins#specify-members-a-mixin-can-call-on-itself) 믹스인이 자체적으로 호출할 수 있는 멤버 지정하기

**Sometimes a mixin depends on being able to invoke a method or access fields, but can't define those members itself (because mixins can't use constructor parameters to instantiate their own fields).**

때때로 믹스인은 메서드를 호출하거나 필드에 접근할 수 있어야 하지만, 자체적으로 그 멤버를 정의할 수는 없다(믹스인은 자신의 필드를 인스턴스화하기 위해 생성자 매개변수를 사용할 수 없기 때문이다).

**The following sections cover different strategies for ensuring any subclass of a mixin defines any members the mixin's behavior depends on.**

다음 섹션에서는 믹스인의 동작이 의존하는 모든 멤버를 정의하도록 믹스인의 하위 클래스가 보장받을 수 있는 다양한 전략을 다룬다.

다음 섹션에서는 믹스인의 동작이 의존하는 모든 멤버를 믹스인의 서브클래스가 정의하도록 보장하기 위한 다양한 전략을 다룬다.



## **Define abstract members in the mixin**[#](https://dart.dev/language/mixins#define-abstract-members-in-the-mixin) 믹스인에 추상 멤버 정의하기

**Declaring an abstract method in a mixin forces any type that uses the mixin to define the abstract method upon which its behavior depends.**

믹스인에 추상 메서드를 선언하면, 믹스인을 사용하는 모든 타입이 그 동작에 의존하는 추상 메서드를 정의해야 한다.

```dart
mixin Musician {
  void playInstrument(String instrumentName); // Abstract method.

  void playPiano() {
    playInstrument('Piano');
  }
  void playFlute() {
    playInstrument('Flute');
  }
}

class Virtuoso with Musician { 
  void playInstrument(String instrumentName) { // Subclass must define.
    print('Plays the $instrumentName beautifully');
  }  
}

```



## **Access state in the mixin's subclass**[#](https://dart.dev/language/mixins#access-state-in-the-mixins-subclass) 믹스인의 서브클래스에서 상태에 접근하기

**Declaring abstract members also allows you to access state on the subclass of a mixin, by calling getters which are defined as abstract on the mixin:**

추상 멤버를 선언하면 믹스인에서 정의된 추상 getter를 호출하여 믹스인의 서브클래스에서 상태에 접근할 수 있다.

```dart
/// Can be applied to any type with a [name] property and provides an
/// implementation of [hashCode] and operator `==` in terms of it.
mixin NameIdentity {
  String get name;

  int get hashCode => name.hashCode;
  bool operator ==(other) => other is NameIdentity && name == other.name;
}

class Person with NameIdentity {
  final String name;

  Person(this.name);
}

```


## **Implement an interface**[#](https://dart.dev/language/mixins#implement-an-interface) 인터페이스 구현하기

**Similar to declaring the mixin abstract, putting an `implements` clause on the mixin while not actually implementing the interface will also ensure any member dependencies are defined for the mixin.**

믹스인을 추상적으로 선언하는 것과 유사하게, 믹스인에 implements 절을 추가하면서 실제로 인터페이스를 구현하지 않으면 믹스인에 필요한 모든 멤버 의존성이 정의되도록 할 수 있다.

```dart
abstract interface class Tuner {
  void tuneInstrument();
}

mixin Guitarist implements Tuner {
  void playSong() {
    tuneInstrument();

    print('Strums guitar majestically.');
  }
}

class PunkRocker with Guitarist {
  void tuneInstrument() {
    print("Don't bother, being out of tune is punk rock.");
  }
}

```


## **Use the `on` clause to declare a superclass[#](https://dart.dev/language/mixins#use-the-on-clause-to-declare-a-superclass)** on 절을 사용하여 슈퍼클래스를 선언하기

**The `on` clause exists to define the type that `super` calls are resolved against. So, you should only use it if you need to have a `super` call inside a mixin.**

on 절은 super 호출이 해결되는 타입을 정의하기 위해 존재한다. 따라서 믹스인 내부에서 super 호출이 필요할 때만 사용해야 한다.

**The `on` clause forces any class that uses a mixin to also be a subclass of the type in the `on` clause. If the mixin depends on members in the superclass, this ensures those members are available where the mixin is used:**

on 절은 믹스인을 사용하는 모든 클래스가 on 절에 있는 타입의 서브클래스가 되도록 강제한다. 믹스인이 슈퍼클래스의 멤버에 의존하는 경우, 이를 통해 믹스인이 사용되는 곳에서 해당 멤버가 사용 가능함을 보장할 수 있다.

```dart
class Musician {
  musicianMethod() {
    print('Playing music!');
  }
}

mixin MusicalPerformer on Musician {
  perfomerMethod() {
    print('Performing music!');
    super.musicianMethod();
  }
}

class SingerDancer extends Musician with MusicalPerformer { }

main() {
  SingerDance().performerMethod();
}

```

**In this example, only classes that extend or implement the `Musician` class can use the mixin `MusicalPerformer`. Because `SingerDancer` extends `Musician`, `SingerDancer` can mix in `MusicalPerformer`.**

이 예제에서는 Musician 클래스를 확장하거나 구현하는 클래스만 MusicalPerformer 믹스인을 사용할 수 있다. SingerDancer는 Musician을 확장하기 때문에 MusicalPerformer 믹스인을 사용할 수 있다.


## **class, mixin, or mixin class?[#](https://dart.dev/language/mixins#class-mixin-or-mixin-class)** 클래스, 믹스인, 또는 믹스인 클래스?

<aside> ℹ️ **Version note**

**The `mixin class` declaration requires a [language version](https://dart.dev/guides/language/evolution#language-versioning) of at least 3.0.**

mixin class 선언은 최소 3.0 버전 이상의 언어 버전이 필요하다.

</aside>

**A `mixin` declaration defines a mixin. A `class` declaration defines a [class](https://dart.dev/language/classes). A `mixin class` declaration defines a class that is usable as both a regular class and a mixin, with the same name and the same type.**

mixin 선언은 믹스인을 정의한다. class 선언은 클래스를 정의한다. mixin class 선언은 일반 클래스와 믹스인으로 모두 사용할 수 있는 클래스를 정의하며, 동일한 이름과 타입을 가진다.

```dart
mixin class Musician {
  // ...
}

class Novice with Musician { // Use Musician as a mixin
  // ...
}

class Novice extends Musician { // Use Musician as a class
  // ...
}

```

**Any restrictions that apply to classes or mixins also apply to mixin classes:**

클래스나 믹스인에 적용되는 모든 제한 사항은 믹스인 클래스에도 적용된다:

-   **Mixins can't have `extends` or `with` clauses, so neither can a `mixin class`.**
    
    믹스인은 extends나 with 절을 가질 수 없으므로, 믹스인 클래스도 가질 수 없다.
    
-   **Classes can't have an `on` clause, so neither can a `mixin class`.**
    
    클래스는 on 절을 가질 수 없으므로, 믹스인 클래스도 가질 수 없다.

---

🔗 [[페이지 링크]](https://dart.dev/language/enums)

# **Enumerated types** 열거형 타입

**Enumerated types, often called _enumerations_ or _enums_, are a special kind of class used to represent a fixed number of constant values.**

열거형 타입(종종 열거형 또는 enum이라고 불림)은 고정된 수의 상수 값을 나타내는 특수한 종류의 클래스이다.

<aside> ℹ️ **Note 참고**

**All enums automatically extend the [`Enum`](https://api.dart.dev/stable/dart-core/Enum-class.html) class. They are also sealed, meaning they cannot be subclassed, implemented, mixed in, or otherwise explicitly instantiated.**

모든 enum은 자동으로 Enum 클래스를 확장한다. 또한, enum은 sealed되어 있으므로 서브클래스화, 구현, 믹스인 또는 다른 방법으로 명시적으로 인스턴스화할 수 없다.

**Abstract classes and mixins can explicitly implement or extend `Enum`, but unless they are then implemented by or mixed into an enum declaration, no objects can actually implement the type of that class or mixin.**

추상 클래스와 믹스인은 명시적으로 Enum을 구현하거나 확장할 수 있지만, enum 선언에 의해 구현되거나 믹스인되지 않는 한 해당 클래스나 믹스인의 타입을 실제로 구현하는 객체는 존재할 수 없다.

</aside>


## **Declaring simple enums[#](https://dart.dev/language/enums#declaring-simple-enums)** 간단한 enum 선언하기

**To declare a simple enumerated type, use the `enum` keyword and list the values you want to be enumerated:**

간단한 열거형 타입을 선언하려면 enum 키워드를 사용하고 열거하려는 값을 나열하면 된다:

```dart
enum Color { red, green, blue }

```

<aside> ℹ️ **Tip**

**You can also use [trailing commas](https://dart.dev/language/collections#lists) when declaring an enumerated type to help prevent copy-paste errors.**

열거형 타입을 선언할 때 후행 쉼표를 사용하여 복사-붙여넣기 오류를 방지할 수 있다.

</aside>



## **Declaring enhanced enums[#](https://dart.dev/language/enums#declaring-enhanced-enums)** 향상된 enum 선언하기

**Dart also allows enum declarations to declare classes with fields, methods, and const constructors which are limited to a fixed number of known constant instances.**

Dart에서는 필드, 메서드, 고정된 수의 상수 인스턴스로 제한된 const 생성자를 가진 클래스를 선언할 수 있는 향상된 enum을 허용한다.

**To declare an enhanced enum, follow a syntax similar to normal [classes](https://dart.dev/language/classes), but with a few extra requirements:**

향상된 enum을 선언하려면 일반 클래스와 유사한 구문을 사용하지만, 몇 가지 추가 요구 사항이 있다:

-   **Instance variables must be `final`, including those added by [mixins](https://dart.dev/language/mixins).**
    
    인스턴스 변수는 final이어야 하며, 믹스인에 의해 추가된 변수도 포함된다.
    
-   **All [generative constructors](https://dart.dev/language/constructors#constant-constructors) must be constant.**
    
    모든 생성자는 상수 생성자여야 한다.
    
-   [**Factory constructors](https://dart.dev/language/constructors#factory-constructors) can only return one of the fixed, known enum instances.**
    
    팩토리 생성자는 고정된 상수 enum 인스턴스 중 하나만 반환할 수 있다.
    
-   **No other class can be extended as [`Enum`](https://api.dart.dev/stable/dart-core/Enum-class.html) is automatically extended.**
    
    다른 클래스를 확장할 수 없으며, Enum이 자동으로 확장된다.
    
-   **There cannot be overrides for `index`, `hashCode`, the equality operator `==`.**
    
    index, hashCode, 동등성 연산자 ==는 오버라이드할 수 없다.
    
-   **A member named `values` cannot be declared in an enum, as it would conflict with the automatically generated static `values` getter.**
    
    values라는 이름의 멤버는 선언할 수 없다. 이는 자동으로 생성되는 static values getter와 충돌하기 때문이다.
    
-   **All instances of the enum must be declared in the beginning of the declaration, and there must be at least one instance declared.**
    
    enum의 모든 인스턴스는 선언의 시작 부분에 선언되어야 하며, 적어도 하나의 인스턴스가 선언되어야 한다.
    

**Instance methods in an enhanced enum can use `this` to reference the current enum value.**

향상된 enum의 인스턴스 메서드는 this를 사용하여 현재 enum 값을 참조할 수 있다.

**Here is an example that declares an enhanced enum with multiple instances, instance variables, getters, and an implemented interface:**

다음은 여러 인스턴스, 인스턴스 변수, getter 및 구현된 인터페이스를 가진 향상된 enum을 선언하는 예시이다:

```dart
enum Vehicle implements Comparable<Vehicle> {
  car(tires: 4, passengers: 5, carbonPerKilometer: 400),
  bus(tires: 6, passengers: 50, carbonPerKilometer: 800),
  bicycle(tires: 2, passengers: 1, carbonPerKilometer: 0);

  const Vehicle({
    required this.tires,
    required this.passengers,
    required this.carbonPerKilometer,
  });

  final int tires;
  final int passengers;
  final int carbonPerKilometer;

  int get carbonFootprint => (carbonPerKilometer / passengers).round();

  bool get isTwoWheeled => this == Vehicle.bicycle;

  @override
  int compareTo(Vehicle other) => carbonFootprint - other.carbonFootprint;
}

```

<aside> ℹ️ **Version note**

**Enhanced enums require a [language version](https://dart.dev/guides/language/evolution#language-versioning) of at least 2.17.**

향상된 enum은 최소 2.17 버전 이상의 언어 버전이 필요하다.

</aside>


## **Using enums[#](https://dart.dev/language/enums#using-enums)** enum 사용하기

**Access the enumerated values like any other [static variable](https://dart.dev/language/classes#class-variables-and-methods):**

열거된 값을 다른 static 변수처럼 접근할 수 있다:

```dart
final favoriteColor = Color.blue;
if (favoriteColor == Color.blue) {
  print('Your favorite color is blue!');
}

```

**Each value in an enum has an `index` getter, which returns the zero-based position of the value in the enum declaration. For example, the first value has index 0, and the second value has index 1.**

enum의 각 값은 인덱스 getter를 가지며, 이는 enum 선언에서 값의 0부터 시작하는 위치를 반환한다. 예를 들어, 첫 번째 값은 인덱스 0을 가지며, 두 번째 값은 인덱스 1을 가진다.

```dart
assert(Color.red.index == 0);
assert(Color.green.index == 1);
assert(Color.blue.index == 2);

```

**To get a list of all the enumerated values, use the enum's `values` constant.**

열거된 모든 값을 가져오려면 enum의 values 상수를 사용한다.

```dart
List<Color> colors = Color.values;
assert(colors[2] == Color.blue);

```

**You can use enums in [switch statements](https://dart.dev/language/branches#switch), and you'll get a warning if you don't handle all of the enum's values:**

enum을 switch 문에서 사용할 수 있으며, 모든 enum 값을 처리하지 않으면 경고를 받는다:

```dart
var aColor = Color.blue;

switch (aColor) {
  case Color.red:
    print('Red as roses!');
  case Color.green:
    print('Green as grass!');
  default: // 이 없으면 경고가 표시된다.
    print(aColor); // 'Color.blue'
}

```

**If you need to access the name of an enumerated value, such as `'blue'` from `Color.blue`, use the `.name` property:**

Color.blue에서 ‘blue’와 같이 열거된 값의 이름에 접근해야 하는 경우, .name 속성을 사용한다:

```dart
print(Color.blue.name); // 'blue'

```

**You can access a member of an enum value like you would on a normal object:**

일반 객체에서 하듯이 enum 값의 멤버에 접근할 수 있다:

```dart
print(Vehicle.car.carbonFootprint);

```

---

🔗 [[페이지 링크]](https://dart.dev/language/extension-methods)

# **Extension methods** 확장 메서드

**Extension methods add functionality to existing libraries. You might use extension methods without even knowing it. For example, when you use code completion in an IDE, it suggests extension methods alongside regular methods.**

확장 메서드는 기존 라이브러리에 기능을 추가한다. 확장 메서드를 사용하는지 모르고 사용할 수도 있다. 예를 들어, IDE에서 코드 자동 완성을 사용할 때, 확장 메서드가 일반 메서드와 함께 제안된다.

**If watching videos helps you learn, check out this overview of extension methods.**

비디오 시청이 학습에 도움이 된다면, 확장 메서드에 대한 개요를 확인해보자.

🔗 [[youtube 링크]](https://www.youtube.com/watch?v=D3j0OSfT9ZI)



## **Overview[#](https://dart.dev/language/extension-methods#overview)** 개요

**When you're using someone else's API or when you implement a library that's widely used, it's often impractical or impossible to change the API. But you might still want to add some functionality.**

다른 사람의 API를 사용하거나 널리 사용되는 라이브러리를 구현할 때, API를 변경하는 것은 실용적이지 않거나 불가능한 경우가 많다. 하지만 여전히 기능을 추가하고 싶을 수 있다.

**For example, consider the following code that parses a string into an integer:**

예를 들어, 문자열을 정수로 파싱하는 다음 코드를 고려해보자:

```dart
int.parse('42')


```

**It might be nice—shorter and easier to use with tools—to have that functionality be on `String` instead:**

이 기능을 String 클래스에 추가하면 더 짧고 도구 사용이 쉬울 것이다:

```dart
'42'.parseInt()

```

**To enable that code, you can import a library that contains an extension of the `String` class:**

이 코드를 사용하려면 String 클래스를 확장하는 라이브러리를 임포트하면 된다:

```dart
import 'string_apis.dart';
// ···
print('42'.parseInt()); // 확장 메서드 사용.

```

**Extensions can define not just methods, but also other members such as getter, setters, and operators. Also, extensions can have names, which can be helpful if an API conflict arises. Here's how you might implement the extension method `parseInt()`, using an extension (named `NumberParsing`) that operates on strings:**

확장 메서드는 메서드뿐만 아니라 getter, setter, 연산자와 같은 다른 멤버도 정의할 수 있다. 또한, API 충돌이 발생할 경우 유용한 이름을 가질 수도 있다. 다음은 문자열에서 작동하는 NumberParsing이라는 이름의 확장을 사용하여 parseInt() 확장 메서드를 구현하는 방법이다:

```dart
**lib/string_apis.dart**

```

**The next section describes how to _use_ extension methods. After that are sections about _implementing_ extension methods.**

다음 섹션에서는 확장 메서드 사용 방법을 설명한다. 그 후에는 확장 메서드 구현에 대한 섹션이 이어진다.


## **Using extension methods[#](https://dart.dev/language/extension-methods#using-extension-methods)** 확장 메서드 사용하기

**Like all Dart code, extension methods are in libraries. You've already seen how to use an extension method—just import the library it's in, and use it like an ordinary method:**

모든 Dart 코드와 마찬가지로, 확장 메서드는 라이브러리 내에 있다. 이미 확장 메서드를 사용하는 방법을 보았을 것이다. 라이브러리가 포함된 파일을 임포트하고, 일반 메서드처럼 사용하면 된다:

```dart
// String에 대한 확장이 포함된 라이브러리를 임포트한다.
import 'string_apis.dart';
// ···
print('42'.padLeft(5)); // String 메서드 사용.
print('42'.parseInt()); // 확장 메서드 사용.

```

**That's all you usually need to know to use extension methods. As you write your code, you might also need to know how extension methods depend on static types (as opposed to `dynamic`) and how to resolve [API conflicts](https://dart.dev/language/extension-methods#api-conflicts).**

확장 메서드를 사용하려면 보통 이 정도만 알면 된다. 코드를 작성하면서, 확장 메서드가 정적 타입(동적 타입과 반대)에 의존하는 방법과 API 충돌을 해결하는 방법에 대해서도 알아야 할 수도 있다.

### **Static types and dynamic[#](https://dart.dev/language/extension-methods#static-types-and-dynamic)** 정적 타입과 동적 타입

**You can't invoke extension methods on variables of type `dynamic`. For example, the following code results in a runtime exception:**

동적 타입(dynamic)의 변수에서는 확장 메서드를 호출할 수 없다. 예를 들어, 다음 코드는 런타임 예외를 발생시킨다:

```dart
dynamic d = '2';
print(d.parseInt()); // 런타임 예외: NoSuchMethodError

```

**Extension methods _do_ work with Dart's type inference. The following code is fine because the variable `v` is inferred to have type `String`:**

확장 메서드는 Dart의 타입 추론과 함께 작동한다. 다음 코드는 변수 v가 String 타입으로 추론되기 때문에 문제가 없다:

```dart
var v = '2';
print(v.parseInt()); // 출력: 2

```

**The reason that `dynamic` doesn't work is that extension methods are resolved against the static type of the receiver. Because extension methods are resolved statically, they're as fast as calling a static function.**

동적 타입이 작동하지 않는 이유는 확장 메서드가 수신자의 정적 타입에 대해 해결되기 때문이다. 확장 메서드는 정적으로 해결되므로, 정적 함수 호출만큼 빠르다.

**For more information about static types and `dynamic`, see [The Dart type system](https://dart.dev/language/type-system).**

정적 타입과 동적 타입에 대한 자세한 내용은 Dart 타입 시스템을 참조하라.

### **API conflicts[#](https://dart.dev/language/extension-methods#api-conflicts)** API 충돌

**If an extension member conflicts with an interface or with another extension member, then you have a few options.**

확장 멤버가 인터페이스 또는 다른 확장 멤버와 충돌하는 경우, 몇 가지 선택 사항이 있다.

**One option is changing how you import the conflicting extension, using `show` or `hide` to limit the exposed API:**

하나의 방법은 show 또는 hide를 사용하여 노출된 API를 제한하면서 충돌하는 확장을 임포트하는 방법을 변경하는 것이다:

```dart
// String 확장 메서드 parseInt()를 정의한다.
import 'string_apis.dart';

// parseInt()도 정의하지만, NumberParsing2를 숨기면
// 해당 확장 메서드가 숨겨진다.
import 'string_apis_2.dart' hide NumberParsing2;

// ···
// 'string_apis.dart'에 정의된 parseInt()를 사용한다.
print('42'.parseInt());

```

**Another option is applying the extension explicitly, which results in code that looks as if the extension is a wrapper class:**

또 다른 방법은 확장을 명시적으로 적용하는 것으로, 확장이 래퍼 클래스인 것처럼 보이게 하는 것이다:

```dart
// 두 라이브러리 모두 String에 대한 확장을 정의하고,
// 각 확장에는 parseInt()가 포함되어 있다.
import 'string_apis.dart'; // NumberParsing 확장을 포함한다.
import 'string_apis_2.dart'; // NumberParsing2 확장을 포함한다.

// ···
// print('42'.parseInt()); // 작동하지 않는다.
print(NumberParsing('42').parseInt());
print(NumberParsing2('42').parseInt());

```

**If both extensions have the same name, then you might need to import using a prefix:**

두 확장이 같은 이름을 가지고 있다면, 접두어를 사용하여 임포트해야 할 수도 있다:

```dart
// 두 라이브러리 모두 NumberParsing이라는 이름의 확장을 정의하고
// 확장 메서드 parseInt()를 포함한다. 'string_apis_3.dart'의 한 NumberParsing
// 확장은 parseNum()도 정의한다.
import 'string_apis.dart';
import 'string_apis_3.dart' as rad;

// ···
// print('42'.parseInt()); // 작동하지 않는다.

// string_apis.dart의 NumberParsing 확장을 사용한다.
print(NumberParsing('42').parseInt());

// string_apis_3.dart의 NumberParsing 확장을 사용한다.
print(rad.NumberParsing('42').parseInt());

// string_apis_3.dart에만 parseNum()이 있다.
print('42'.parseNum());

```

**As the example shows, you can invoke extension methods implicitly even if you import using a prefix. The only time you need to use the prefix is to avoid a name conflict when invoking an extension explicitly.**

예시에서 볼 수 있듯이, 접두어를 사용하여 임포트해도 확장 메서드를 암시적으로 호출할 수 있다. 확장을 명시적으로 호출할 때 이름 충돌을 피하기 위해서만 접두어를 사용하면 된다.



## **Implementing extension methods[#](https://dart.dev/language/extension-methods#implementing-extension-methods)** 확장 메서드 구현하기

**Use the following syntax to create an extension:**

다음 구문을 사용하여 확장을 생성한다:

```dart
extension <확장 이름>? on <타입> { // <확장 이름>은 선택 사항이다.
  (<멤버 정의>)* // 하나 이상의 <멤버 정의>를 제공할 수 있다.
}

```

**For example, here's how you might implement an extension on the `String` class:**

**lib/string_apis.dart**

예를 들어, String 클래스에 대한 확장을 구현하는 방법은 다음과 같다:

```dart
lib/string_apis.dart
extension NumberParsing on String {
  int parseInt() {
    return int.parse(this);
  }

  double parseDouble() {
    return double.parse(this);
  }
}

```

**The members of an extension can be methods, getters, setters, or operators. Extensions can also have static fields and static helper methods. To access static members outside the extension declaration, invoke them through the declaration name like [class variables and methods](https://dart.dev/language/classes#class-variables-and-methods).**

확장의 멤버는 메서드, getter, setter 또는 연산자가 될 수 있다. 확장은 static 필드와 static 도우미 메서드도 가질 수 있다. 확장 선언 외부에서 static 멤버에 접근하려면 클래스 변수와 메서드처럼 선언 이름을 통해 호출한다.

### **Unnamed extensions[#](https://dart.dev/language/extension-methods#unnamed-extensions)** 이름 없는 확장

**When declaring an extension, you can omit the name. Unnamed extensions are visible only in the library where they're declared. Since they don't have a name, they can't be explicitly applied to resolve [API conflicts](https://dart.dev/language/extension-methods#api-conflicts).**

확장을 선언할 때 이름을 생략할 수 있다. 이름 없는 확장은 선언된 라이브러리 내에서만 보인다. 이름이 없기 때문에 API 충돌을 해결하기 위해 명시적으로 적용할 수 없다.

```dart
extension on String {
  bool get isBlank => trim().isEmpty;
}

```

<aside> ℹ️ **Note**

**You can invoke an unnamed extension's static members only within the extension declaration.**

이름 없는 확장의 static 멤버는 해당 확장 선언 내에서만 호출할 수 있다.

</aside>



## **Implementing generic extensions[#](https://dart.dev/language/extension-methods#implementing-generic-extensions)** 제네릭 확장 구현하기

**Extensions can have generic type parameters. For example, here's some code that extends the built-in `List<T>` type with a getter, an operator, and a method:**

확장은 제네릭 타입 매개변수를 가질 수 있다. 예를 들어, 내장된 List<T> 타입을 확장하여 getter, 연산자, 메서드를 추가하는 코드는 다음과 같다:

```dart
extension MyFancyList<T> on List<T> {
  int get doubleLength => length * 2;
  List<T> operator -() => reversed.toList();
  List<List<T>> split(int at) => [sublist(0, at), sublist(at)];
}

```

**The type `T` is bound based on the static type of the list that the methods are called on.**

타입 T는 메서드가 호출되는 리스트의 정적 타입을 기준으로 결정된다.



## **Resources[#](https://dart.dev/language/extension-methods#resources)** 리소스

**For more information about extension methods, see the following:**

확장 메서드에 대한 자세한 내용은 다음을 참조하라:

-   [**Article: Dart Extension Methods Fundamentals**](https://medium.com/dartlang/extension-methods-2d466cd8b308)
    
    기사: [Dart Extension Methods Fundamentals](https://dart.dev/guides/language/extension-methods)
    
-   [**Feature specification**](https://github.com/dart-lang/language/blob/main/accepted/2.7/static-extension-methods/feature-specification.md#dart-static-extension-methods-design)
    
    기능 명세
    
-   [**Extension methods sample**](https://github.com/dart-lang/samples/tree/main/extension_methods)
    
    확장 메서드 샘플

---

🔗 [[페이지 링크]](https://dart.dev/language/extension-types)

# **Extension types** 확장 타입

**An extension type is a compile-time abstraction that "wraps" an existing type with a different, static-only interface. They are a major component of [static JS interop](https://dart.dev/go/next-gen-js-interop) because they can easily modify an existing type's interface (crucial for any kind of interop) without incurring the cost of an actual wrapper.**

확장 타입은 기존 타입을 다른 정적 전용 인터페이스로 “감싸는” 컴파일 타임 추상화이다. 이는 실제 래퍼의 비용을 초래하지 않으면서 기존 타입의 인터페이스를 쉽게 수정할 수 있기 때문에, 정적 JS 상호 운용성의 주요 구성 요소이다.

**Extension types enforce discipline on the set of operations (or interface) available to objects of an underlying type, called the _representation type_. When defining the interface of an extension type, you can choose to reuse some members of the representation type, omit others, replace others, and add new functionality.**

확장 타입은 표현 타입이라고 하는 기본 타입의 객체에 사용 가능한 연산(또는 인터페이스) 집합에 대한 규율을 강제한다. 확장 타입의 인터페이스를 정의할 때, 표현 타입의 일부 멤버를 재사용하고, 다른 멤버를 생략하거나 교체하고, 새로운 기능을 추가할 수 있다.

**The following example wraps the `int` type to create an extension type that only allows operations that make sense for ID numbers:**

다음 예제는 int 타입을 감싸서 ID 번호에 의미 있는 연산만 허용하는 확장 타입을 생성한다:

```dart
extension type IdNumber(int id) {
  // 'int' 타입의 '<' 연산자를 감싼다:
  operator <(IdNumber other) => id < other.id;
  // '+' 연산자는 선언하지 않는다,
  // 예를 들어, 덧셈은 ID 번호에 의미가 없기 때문이다.
}

void main() {
  // 확장 타입의 규율 없이,
  // 'int'는 ID 번호를 안전하지 않은 연산에 노출시킨다:
  int myUnsafeId = 42424242;
  myUnsafeId = myUnsafeId + 10; // 이 작업은 가능하지만, ID에는 허용되지 않아야 한다.

  var safeId = IdNumber(42424242);
  safeId + 10; // 컴파일 타임 오류: '+' 연산자가 없음.
  myUnsafeId = safeId; // 컴파일 타임 오류: 잘못된 타입.
  myUnsafeId = safeId as int; // OK: 런타임에 표현 타입으로 캐스팅.
  safeId < IdNumber(42424241); // OK: 감싸진 '<' 연산자 사용.
}

```

<aside> ℹ️ **Note**

**Extension types serve the same purpose as wrapper classes, but don't require the creation of an extra run-time object, which can get expensive when you need to wrap lots of objects. Because extension types are static-only and compiled away at run time, they are essentially zero cost.**

확장 타입은 래퍼 클래스와 동일한 목적을 제공하지만, 추가적인 런타임 객체를 생성할 필요가 없다. 많은 객체를 래핑해야 할 때, 이는 비용이 많이 들 수 있다. 확장 타입은 정적 전용이고 런타임 시 컴파일되므로, 본질적으로 비용이 거의 없다.

**[Extension methods](https://dart.dev/language/extension-methods) (also known just as "extensions") are a static abstraction similar to extension types. However, an extension method adds functionality _directly_ to every instance of its underlying type. Extension types are different; an extension type's interface _only_ applies to expressions whose static type is that extension type. They are distinct from the interface of their underlying type by default.**

확장 메서드(또는 “확장”으로도 알려짐)는 확장 타입과 유사한 정적 추상화이다. 그러나 확장 메서드는 기본 타입의 모든 인스턴스에 직접 기능을 추가한다. 확장 타입은 다르다; 확장 타입의 인터페이스는 해당 확장 타입의 정적 타입인 표현식에만 적용된다. 기본 타입의 인터페이스와는 기본적으로 다르다.

</aside>


## **Syntax[#](https://dart.dev/language/extension-types#syntax)** 구문

### **Declaration[#](https://dart.dev/language/extension-types#declaration)** 선언

**Define a new extension type with the `extension type` declaration and a name, followed by the _representation type declaration_ in parenthesis:**

확장 타입 선언과 이름을 정의하고, 괄호 안에 표현 타입 선언을 추가하여 새로운 확장 타입을 정의한다:

```dart
extension type E(int i) {
  // 연산 집합 정의
}

```

**The representation type declaration `(int i)` specifies that the underlying type of extension type `E` is `int`, and that the reference to the _representation object_ is named `i`. The declaration also introduces:**

표현 타입 선언(int i)은 확장 타입 E의 기본 타입이 int이며, 표현 객체에 대한 참조가 i라는 이름임을 지정한다. 선언에는 다음도 포함된다:

-   **An implicit getter for the representation object with the representation type as the return type: `int get i`.**
    
    표현 객체에 대한 암시적 getter로, 반환 타입은 표현 타입이다: int get i.
    
-   **An implicit constructor: `E(int i) : i = i`.**
    
    암시적 생성자: E(int i) : i = i.
    

**The representation object gives the extension type access to an object at the underlying type. The object is in scope in the extension type body, and you can access it using its name as a getter:**

표현 객체는 확장 타입이 기본 타입의 객체에 접근할 수 있게 한다. 객체는 확장 타입 본문 내에서 범위에 있으며, getter로서 그 이름을 사용하여 접근할 수 있다:

-   **Within the extension type body using `i` (or `this.i` in a constructor).**
    
    확장 타입 본문 내에서는 i (또는 생성자에서 this.i)를 사용하여 접근할 수 있다.
    
-   **Outside with a property extraction using `e.i` (where `e` has the extension type as its static type).**
    
    외부에서는 속성 추출을 통해 e.i (여기서 e는 확장 타입으로 정적 타입을 가진다)를 사용하여 접근할 수 있다.
    

**Extension type declarations can also include [type parameters](https://dart.dev/language/generics) just like classes or extensions:**

확장 타입 선언은 클래스나 확장처럼 타입 매개변수를 포함할 수도 있다:

```dart
extension type E<T>(List<T> elements) {
  // ...
}

```

### **Constructors[#](https://dart.dev/language/extension-types#constructors)** 생성자

**You can optionally declare [constructors](https://dart.dev/language/constructors) in an extension type's body. The representation declaration itself is an implicit constructor, so by default takes the place of an unnamed constructor for the extension type. Any additional non-redirecting generative constructors must initialize the representation object's instance variable using `this.i` in its initializer list or formal parameters.**

확장 타입의 본문에 생성자를 선택적으로 선언할 수 있다. 표현 선언 자체가 암시적 생성자이므로, 기본적으로 확장 타입의 이름 없는 생성자의 자리를 대신한다. 추가적인 비리디렉팅 생성자는 이니셜라이저 목록이나 형식 매개변수에서 this.i를 사용하여 표현 객체의 인스턴스 변수를 초기화해야 한다.

```dart
extension type E(int i) {
  E.n(this.i);
  E.m(int j, String foo) : i = j + foo.length;
}

void main() {
  E(4); // 암시적 이름 없는 생성자.
  E.n(3); // 이름 있는 생성자.
  E.m(5, "Hello!"); // 추가 매개변수가 있는 이름 있는 생성자.
}

```

**Or, you can name the representation declaration constructor, in which case there is room for an unnamed constructor in the body:**

또는, 표현 선언 생성자에 이름을 붙여 본문에 이름 없는 생성자를 넣을 공간을 만들 수 있다:

```dart
extension type const E._(int it) {
  E() : this._(42);
  E.otherName(this.it);
}

void main2() {
  E();
  const E._(2);
  E.otherName(3);
}

```

**You can also completely hide the constructor, instead of just defining a new one, using the same private constructor syntax for classes, `_`. For example, if you only want clients constructing `E` with a `String`, even though the underlying type is `int`:**

또한, 클래스를 위해 사용하는 동일한 비공개 생성자 구문인 _을 사용하여 생성자를 완전히 숨길 수도 있다. 예를 들어, 기본 타입이 int이지만 String으로만 E를 생성하도록 클라이언트를 제한하려면:

```dart
extension type E._(int i) {
  E.fromString(String foo) : i = int.parse(foo);
}

```

**You can also declare forwarding generative constructors, or [factory constructors](https://dart.dev/language/constructors#factory-constructors) (which can also forward to constructors of sub-extension types).**

또한, 포워딩 생성자나 팩토리 생성자를 선언할 수도 있으며, 이는 하위 확장 타입의 생성자로 포워딩할 수도 있다.

### **Members[#](https://dart.dev/language/extension-types#members)** 멤버

**Declare members in the body of an extension type to define its interface the same way you would for class members. Extension type members can be methods, getters, setters, or operators (non-[`external`](https://dart.dev/language/functions#external) [instance variables](https://dart.dev/language/classes#instance-variables) and [abstract members](https://dart.dev/language/methods#abstract-methods) are not allowed):**

확장 타입의 본문에 멤버를 선언하여 클래스 멤버와 동일한 방식으로 인터페이스를 정의할 수 있다. 확장 타입 멤버는 메서드, getter, setter, 연산자가 될 수 있으며 (외부 인스턴스 변수가 아닌 멤버와 추상 멤버는 허용되지 않는다):

```dart
extension type NumberE(int value) {
  // 연산자:
  NumberE operator +(NumberE other) => NumberE(value + other.value);
  // Getter:
  NumberE get myNum => this;
  // 메서드:
  bool isValid() => !value.isNegative;
}

```

**Interface members of the representation type are not interface members of the extension type [by default](https://dart.dev/language/extension-types#transparency). To make a single member of the representation type available on the extension type, you must write a declaration for it in the extension type definition, like the `operator +` in `NumberE`. You also can define new members unrelated to the representation type, like the `i` getter and `isValid` method.**

기본적으로 표현 타입의 인터페이스 멤버는 확장 타입의 인터페이스 멤버가 아니다. 표현 타입의 단일 멤버를 확장 타입에서 사용할 수 있게 하려면, 확장 타입 정의에서 선언을 작성해야 한다. 예를 들어, NumberE의 + 연산자처럼. 또한, i getter 및 isValid 메서드와 같이 표현 타입과 관련이 없는 새로운 멤버를 정의할 수도 있다.

### **Implements[#](https://dart.dev/language/extension-types#implements)** 구현

**You can optionally use the `implements` clause to:**

implements 절을 사용하여 다음을 수행할 수 있다:

-   **Introduce a subtype relationship on an extension type, AND**
    
    확장 타입에 서브타입 관계를 도입한다.
    
-   **Add the members of the representation object to the extension type interface.**
    
    표현 객체의 멤버를 확장 타입 인터페이스에 추가한다.
    

**The `implements` clause introduces an [applicability](https://github.com/dart-lang/language/blob/main/accepted/2.7/static-extension-methods/feature-specification.md#examples) relationship like the one between an [extension method](https://dart.dev/language/extension-methods) and its `on` type. Members that are applicable to the supertype are applicable to the subtype as well, unless the subtype has a declaration with the same member name.**

implements 절은 확장 메서드와 그 on 타입 간의 관계와 유사한 적용 관계를 도입한다. 슈퍼타입에 적용 가능한 멤버는 서브타입에도 적용되며, 서브타입에 동일한 멤버 이름으로 선언이 없는 한 그렇다.

**An extension type can only implement:**

확장 타입은 다음만을 구현할 수 있다:

-   **Its representation type. This makes all members of the representation type implicitly available to the extension type.**
    
    표현 타입: 이는 표현 타입의 모든 멤버를 확장 타입에서 암시적으로 사용할 수 있게 한다.
    
    ```dart
    extension type NumberI(int i) implements int {
      // 'NumberI'는 'int'의 모든 멤버를 호출할 수 있으며,
      // 여기서 선언한 다른 것들도 호출할 수 있다.
    }
    
    ```
    
-   **A supertype of its representation type. This makes the members of the supertype available, while not necessarily all the members of representation type.**
    
    표현 타입의 슈퍼타입: 이는 슈퍼타입의 멤버를 사용할 수 있게 하지만, 반드시 표현 타입의 모든 멤버를 포함하지는 않는다.
    
    ```dart
    extension type Sequence<T>(List<T> _) implements Iterable<T> {
      // List보다 더 나은 연산들.
    }
    
    extension type Id(int _id) implements Object {
      // 확장 타입을 널이 될 수 없게 만든다.
      static Id? tryParse(String source) => int.tryParse(source) as Id?;
    }
    
    ```
    
-   **Another extension type that is valid on the same representation type. This allows you to reuse operations across multiple extension types (similar to multiple inheritance).**
    
    동일한 표현 타입에 유효한 다른 확장 타입: 이는 여러 확장 타입에서 연산을 재사용할 수 있게 한다 (다중 상속과 유사).
    
    ```dart
    extension type const Opt<T>._(({T value})? _) { 
      const factory Opt(T value) = Val<T>;
      const factory Opt.none() = Non<T>;
    }
    extension type const Val<T>._(({T value}) _) implements Opt<T> { 
      const Val(T value) : this._((value: value));
      T get value => _.value;
    }
    extension type const Non<T>._(Null _) implements Opt<Never> {
      const Non() : this._(null);
    }
    
    ```
    

**Read the [Usage](https://dart.dev/language/extension-types#usage) section to learn more about the effect of `implements` in different scenarios.**

각기 다른 시나리오에서 implements의 효과에 대해 더 알아보려면 사용법 섹션을 참조하라.

### **`@redeclare`[#](https://dart.dev/language/extension-types#redeclare)**

**Declaring an extension type member that shares a name with a member of a supertype is _not_ an override relationship like it is between classes, but rather a _redeclaration_. An extension type member declaration _completely replaces_ any supertype member with the same name. It's not possible to provide an alternative implementation for the same function.**

슈퍼타입의 멤버와 이름을 공유하는 확장 타입 멤버를 선언하는 것은 클래스 간의 오버라이드 관계가 아니라 재선언 관계이다. 확장 타입 멤버 선언은 동일한 이름을 가진 슈퍼타입 멤버를 완전히 대체한다. 동일한 함수에 대한 대체 구현을 제공할 수 없다.

**You can use the `@redeclare` annotation to tell the compiler you are _knowingly_ choosing to use the same name as a supertype's member. The analyzer will then warn you if that's not actually true, for example if one of the names are mistyped.**

@redeclare 애너테이션을 사용하여 컴파일러에게 슈퍼타입의 멤버와 동일한 이름을 사용하기로 의도적으로 선택했음을 알릴 수 있다. 그러면 분석기는 실제로 그렇지 않은 경우, 예를 들어 이름 중 하나가 잘못 입력된 경우 경고를 표시한다.

```dart
extension type MyString(String _) implements String {
  // 'String.operator[]'을 대체
  @redeclare
  int operator [](int index) => codeUnitAt(index);
}

```

**You can also enable the lint [`annotate_redeclares`](https://dart.dev/tools/linter-rules/annotate_redeclares) to get a warning if you declare an extension type method that hides a superinterface member and _isn't_ annotated with `@redeclare`.**

또한, @redeclare로 애너테이트되지 않은 슈퍼인터페이스 멤버를 숨기는 확장 타입 메서드를 선언할 경우 경고를 받기 위해 lint annotate_redeclares를 활성화할 수 있다.


## **Usage[#](https://dart.dev/language/extension-types#usage)** 사용법

**To use an extension type, create an instance the same as you would with a class: by calling a constructor:**

확장 타입을 사용하려면, 클래스를 사용할 때와 마찬가지로 생성자를 호출하여 인스턴스를 생성한다:

```dart
extension type NumberE(int value) {
  NumberE operator +(NumberE other) =>
      NumberE(value + other.value);

  NumberE get next => NumberE(value + 1);
  bool isValid() => !value.isNegative;
}

void testE() { 
  var num = NumberE(1);
}

```

**Then, you can invoke members on the object as you would with a class object.**

그런 다음 클래스 객체와 마찬가지로 객체의 멤버를 호출할 수 있다.

**There are two equally valid, but substantially different core use cases for extension types:**

확장 타입의 두 가지 주요 사용 사례는 다음과 같다:

1.  **Providing an _extended_ interface to an existing type.**
    
    기존 타입에 확장된 인터페이스를 제공하기.
    
2.  **Providing a _different_ interface to an existing type.**
    
    기존 타입에 다른 인터페이스를 제공하기.
    

<aside> ℹ️ **Note**

**In any case, the representation type of an extension type is never its subtype, so a representation type can't be used interchangeably where the extension type is needed.**

어떤 경우든, 확장 타입의 표현 타입은 절대로 그 서브타입이 아니므로, 확장 타입이 필요한 곳에서 표현 타입을 교체하여 사용할 수 없다.

</aside>

### **1. Provide an _extended_ interface to an existing type[#](https://dart.dev/language/extension-types#1-provide-an-extended-interface-to-an-existing-type)**

1.  기존 타입에 확장된 인터페이스 제공

**When an extension type [implements](https://dart.dev/language/extension-types#implements) its representation type, you can consider it "transparent", because it allows the extension type to "see" the underlying type.**

확장 타입이 그 표현 타입을 구현할 때, 이를 “투명”하다고 간주할 수 있다. 이는 확장 타입이 기본 타입을 “볼 수 있게” 하기 때문이다.

**A transparent extension type can invoke all members of the representation type (that aren't [redeclared](https://dart.dev/language/extension-types#redeclare)), plus any auxillary members it defines. This creates a new, _extended_ interface for an existing type. The new interface is available to expressions whose static type is the extension type.**

투명 확장 타입은 표현 타입의 모든 멤버(재선언되지 않은 멤버)를 호출할 수 있으며, 그 외에 정의된 보조 멤버들도 호출할 수 있다. 이는 기존 타입에 대한 새로운 확장된 인터페이스를 생성한다. 새로운 인터페이스는 확장 타입의 정적 타입을 가진 표현식에 대해 사용할 수 있다.

**This means you _can_ invoke members of the representation type (unlike a [non-transparent](https://dart.dev/language/extension-types#2-provide-a-different-interface-to-an-existing-type) extension type), like so:**

이는 다음과 같이 표현 타입의 멤버를 호출할 수 있음을 의미한다(비투명 확장 타입과 달리):

```dart
extension type NumberT(int value) implements int {
  // 'int'의 멤버를 명시적으로 선언하지 않는다.
  NumberT get i => this;
}

void main() {
  // 모두 OK: 투명성 덕분에 확장 타입에서 `int` 멤버를 호출할 수 있다:
  var v1 = NumberT(1); // v1 타입: NumberT
  int v2 = NumberT(2); // v2 타입: int
  var v3 = v1.i - v1;  // v3 타입: int
  var v4 = v2 + v1; // v4 타입: int
  var v5 = 2 + v1; // v5 타입: int
  // 오류: 표현 타입에서는 확장 타입의 인터페이스를 사용할 수 없다.
  v2.i;
}

```

**You can also have a "mostly-transparent" extension type that adds new members and adapts others by redeclaring a given member name from the supertype. This would allow you to use stricter types on some parameters of a method, or different default values, for example.**

“대부분 투명한” 확장 타입을 사용하여 새로운 멤버를 추가하고, 슈퍼타입의 주어진 멤버 이름을 재선언하여 다른 멤버를 적응시킬 수도 있다. 이는 예를 들어 메서드의 일부 매개변수에 대해 더 엄격한 타입을 사용하거나, 다른 기본값을 사용할 수 있게 한다.

**Another mostly-transparent extension type approach is to implement a type that is a supertype of the representation type. For example, if the representation type is private but its supertype defines the part of the interface that matters for clients.**

또 다른 “대부분 투명한” 확장 타입 접근법은 표현 타입의 슈퍼타입을 구현하는 것이다. 예를 들어, 표현 타입이 비공개이지만 슈퍼타입이 클라이언트에게 중요한 인터페이스의 일부를 정의하는 경우이다.

### **2. Provide a _different_ interface to an existing type[#](https://dart.dev/language/extension-types#2-provide-a-different-interface-to-an-existing-type)**

1.  기존 타입에 다른 인터페이스 제공

**An extension type that is not [transparent](https://dart.dev/language/extension-types#transparency) (that does not [`implement`](https://dart.dev/language/extension-types#implements) its representation type) is statically treated as a completely new type, distinct from its representation type. You can't assign it to its representation type, and it doesn't expose its representation type's members.**

투명하지 않은 확장 타입(표현 타입을 구현하지 않는)은 정적으로 완전히 새로운 타입으로 취급되며, 표현 타입과는 구별된다. 이를 표현 타입에 할당할 수 없으며, 표현 타입의 멤버를 노출하지 않는다.

**For example, take the `NumberE` extension type we declared under [Usage](https://dart.dev/language/extension-types#usage):**

예를 들어, Usage에서 선언한 NumberE 확장 타입을 고려해보자:

```dart
void testE() { 
  var num1 = NumberE(1);
  int num2 = NumberE(2); // 오류: 'NumberE'를 'int'에 할당할 수 없음.
  
  num1.isValid(); // OK: 확장 멤버 호출.
  num1.isNegative(); // 오류: 'NumberE'는 'int' 멤버 'isNegative'를 정의하지 않음.
  
  var sum1 = num1 + num1; // OK: 'NumberE'는 '+'를 정의함.
  var diff1 = num1 - num1; // 오류: 'NumberE'는 'int' 멤버 '-'를 정의하지 않음.
  var diff2 = num1.value - 2; // OK: 참조를 통해 표현 객체에 접근할 수 있음.
  var sum2 = num1 + 2; // 오류: 'int'를 매개변수 타입 'NumberE'에 할당할 수 없음.
  
  List<NumberE> numbers = [
    NumberE(1), 
    num1.next, // OK: 'next' getter는 'NumberE' 타입을 반환함.
    1, // 오류: 'int' 요소를 리스트 타입 'NumberE'에 할당할 수 없음.
  ];
}

```

**You can use an extension type this way to _replace_ the interface of an existing type. This allows you to model an interface that is makes sense for the constraints of your new type (like the `IdNumber` example in the introduction), while also benefitting from the performance and convenience of a simple pre-defined type, like `int`.**

확장 타입을 이렇게 사용하여 기존 타입의 인터페이스를 대체할 수 있다. 이는 새로운 타입의 제약에 맞는 인터페이스를 모델링할 수 있게 하며(int와 같은 간단한 미리 정의된 타입의 성능과 편리함을 누리면서), 새로운 타입의 제약에 맞는 인터페이스를 모델링할 수 있게 한다(IdNumber 예시처럼).

**This use case is as close as you can get to the complete encapsulation of a wrapper class (but is realistically only a [_somewhat_ protected](https://dart.dev/language/extension-types#type-considerations) abstraction).**

이 사용 사례는 래퍼 클래스의 완전한 캡슐화에 가장 근접한 방법이지만, 현실적으로는 다소 보호된 추상화일 뿐이다.


## **Type considerations[#](https://dart.dev/language/extension-types#type-considerations)** 타입 고려사항

**Extension types are a compile-time wrapping construct. At run time, there is absolutely no trace of the extension type. Any type query or similar run-time operations work on the representation type.**

확장 타입은 컴파일 타임 래핑 구성 요소이다. 런타임에는 확장 타입의 흔적이 전혀 없다. 모든 타입 쿼리나 유사한 런타임 연산은 표현 타입에서 작동한다.

**This makes extension types an _unsafe_ abstraction, because you can always find out the representation type at run time and access the underlying object.**

이로 인해 확장 타입은 안전하지 않은 추상화가 된다. 런타임에 항상 표현 타입을 찾아내고 기본 객체에 접근할 수 있기 때문이다.

**Dynamic type tests (`e is T`), casts (`e as T`), and other run-time type queries (like `switch (e) ...` or `if (e case ...)`) all evaluate to the underlying representation object, and type check against that object's runtime type. That's true when the static type of `e` is an extension type, and when testing against an extension type (`case MyExtensionType(): ...`).**

동적 타입 테스트 (e is T), 캐스트 (e as T), 기타 런타임 타입 쿼리 (switch (e) ... 또는 if (e case ...) 등)는 모두 기본 표현 객체를 평가하고, 그 객체의 런타임 타입에 대해 타입을 검사한다. 이는 e의 정적 타입이 확장 타입인 경우와 확장 타입에 대해 테스트하는 경우 (case MyExtensionType(): ...) 모두 사실이다.

```dart
void main() {
  var n = NumberE(1);

  // 'n'의 런타임 타입은 표현 타입 'int'이다.
  if (n is int) print(n.value); // 1을 출력.

  // 런타임에 'n'에서 'int' 메서드를 사용할 수 있다.
  if (n case int x) print(x.toRadixString(10)); // 1을 출력.
  switch (n) {
    case int(:var isEven): print("$n (${isEven ? "even" : "odd"})"); // 1 (odd)를 출력.
  }
}

```

**Similarly, the static type of the matched value is that of the extension type in this example:**

마찬가지로, 매치된 값의 정적 타입은 이 예시에서 확장 타입의 타입이다:

```dart
void main() {
  int i = 2;
  if (i is NumberE) print("It is"); // 'It is'를 출력.
  if (i case NumberE v) print("value: ${v.value}"); // 'value: 2'를 출력.
  switch (i) {
    case NumberE(:var value): print("value: $value"); // 'value: 2'를 출력.
  }
}

```

**It's important to be aware of this quality when using extension types. Always keep in mind that an extension type exists and matters at compile time, but gets erased _during_ compilation.**

확장 타입을 사용할 때 이러한 특성을 인식하는 것이 중요하다. 확장 타입은 컴파일 타임에 존재하고 중요하지만, 컴파일 중에 사라진다는 점을 항상 염두에 두어야 한다.

**For example, consider an expression `e` whose static type is the extension type `E`, and the representation type of `E` is `R`. Then, the run-time type of the value of `e` is a subtype of `R`. Even the type itself is erased; `List<E>` is exactly the same thing as `List<R>` at run time.**

예를 들어, 정적 타입이 확장 타입 E인 표현식 e를 고려해보자. E의 표현 타입이 R이라면, e의 값의 런타임 타입은 R의 서브타입이다. 타입 자체가 삭제되기 때문에, List<E>는 런타임에 List<R>와 정확히 동일한 것이다.

**In other words, a real wrapper class can encapsulate a wrapped object, whereas an extension type is just a compile-time view on the wrapped object. While a real wrapper is safer, the trade-off is extension types give you the option to avoid wrapper objects, which can greatly improve performance in some scenarios.**

다시 말해, 실제 래퍼 클래스는 감싸진 객체를 캡슐화할 수 있는 반면, 확장 타입은 감싸진 객체에 대한 컴파일 타임 뷰일 뿐이다. 실제 래퍼는 더 안전하지만, 확장 타입은 래퍼 객체를 피할 수 있는 옵션을 제공하여 일부 시나리오에서 성능을 크게 향상시킬 수 있다.

---

🔗 [[페이지 링크]](https://dart.dev/language/callable-objects)

# **Callable objects** 호출 가능한 객체

**To allow an instance of your Dart class to be called like a function, implement the `call()` method.**

Dart 클래스의 인스턴스를 함수처럼 호출할 수 있게 하려면, call() 메서드를 구현한다.

**The `call()` method allows an instance of any class that defines it to emulate a function. This method supports the same functionality as normal [functions](https://dart.dev/language/functions) such as parameters and return types.**

call() 메서드는 이를 정의한 클래스의 인스턴스가 함수처럼 동작할 수 있게 한다. 이 메서드는 매개변수와 반환 타입 같은 일반 함수의 기능을 지원한다.

**In the following example, the `WannabeFunction` class defines a `call()` function that takes three strings and concatenates them, separating each with a space, and appending an exclamation. Click Run to execute the code.**

다음 예제에서 WannabeFunction 클래스는 세 개의 문자열을 받아서 각 문자열을 공백으로 구분하고, 느낌표를 추가하여 연결하는 call() 함수를 정의한다. 코드를 실행하려면 ‘Run’을 클릭한다.

```dart
class WannabeFunction {
  String call(String a, String b, String c) => '$a $b $c!';
}

var wf = WannabeFunction();
var out = wf('Hi', 'there,', 'gang');

void main() => print(out);

```

```dart
// 출력 결과
Hi there, gang!

```
