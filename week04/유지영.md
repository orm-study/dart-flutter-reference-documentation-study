ğŸ”— [[í˜ì´ì§€ ë§í¬]](https://dart.dev/language/mixins)

# Mixins ë¯¹ìŠ¤ì¸

**Mixins are a way of defining code that can be reused in multiple class hierarchies. They are intended to provide member implementations en masse.**

MixinsëŠ” ì—¬ëŸ¬ í´ë˜ìŠ¤ ê³„ì¸µì—ì„œ ì¬ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì½”ë“œë¥¼ ì •ì˜í•˜ëŠ” ë°©ë²•ì´ë‹¤. MixinsëŠ” ëŒ€ëŸ‰ìœ¼ë¡œ ë©¤ë²„ êµ¬í˜„ì„ ì œê³µí•˜ê¸° ìœ„í•´ ì‚¬ìš©ëœë‹¤.

-   **[Q] ëŒ€ëŸ‰ìœ¼ë¡œ ë©¤ë²„ë¥¼ êµ¬í˜„í•˜ëŠ”ê²Œ ë­ì§€?**
    
    â€œëŒ€ëŸ‰ì˜ ë©¤ë²„ êµ¬í˜„â€ì€ ì—¬ëŸ¬ ê°œì˜ ë©”ì„œë“œ, í•„ë“œ, getter, setter ë“±ì„ í•œ ë²ˆì— ì œê³µí•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì´ëŠ” ì½”ë“œì˜ ì¬ì‚¬ìš©ì„±ì„ ë†’ì´ê³ , ì¤‘ë³µ ì½”ë“œë¥¼ ì¤„ì´ëŠ” ë° í° ë„ì›€ì„ ì¤ë‹ˆë‹¤. MixinsëŠ” ì´ëŸ° ë©¤ë²„ êµ¬í˜„ë“¤ì„ í•œ ë²ˆì— ì œê³µí•˜ì—¬ ì—¬ëŸ¬ í´ë˜ìŠ¤ì—ì„œ ì´ë¥¼ ì¬ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
    
    ì˜ˆë¥¼ ë“¤ì–´, ì—¬ëŸ¬ í´ë˜ìŠ¤ì—ì„œ ê³µí†µì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë¡œê¹… ê¸°ëŠ¥ì„ mixinìœ¼ë¡œ ì •ì˜í•˜ê³ , ì´ë¥¼ í•„ìš”ë¡œ í•˜ëŠ” í´ë˜ìŠ¤ì— ì‰½ê²Œ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    

**To use a mixin, use the `with` keyword followed by one or more mixin names. The following example shows two classes that use (or, are subclasses of) mixins:**

ë¯¹ìŠ¤ì¸ì„ ì‚¬ìš©í•˜ë ¤ë©´, with í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ê³  ê·¸ ë’¤ì— í•˜ë‚˜ ì´ìƒì˜ ë¯¹ìŠ¤ì¸ ì´ë¦„ì„ ë¶™ì¸ë‹¤. ë‹¤ìŒ ì˜ˆì œëŠ” ë¯¹ìŠ¤ì¸ì„ ì‚¬ìš©í•˜ëŠ”(ë˜ëŠ” ë¯¹ìŠ¤ì¸ì˜ ì„œë¸Œí´ë˜ìŠ¤ì¸) ë‘ í´ë˜ìŠ¤ë¥¼ ë³´ì—¬ì¤€ë‹¤.

```dart
class Musician extends Performer with Musical {
  // Â·Â·Â·
}

class Maestro extends Person with Musical, Aggressive, Demented {
  Maestro(String maestroName) {
    name = maestroName;
    canConduct = true;
  }
}

```

**To define a mixin, use the `mixin` declaration. In the rare case where you need to define both a mixin _and_ a class, you can use the [`mixin class` declaration](https://dart.dev/language/mixins#class-mixin-or-mixin-class).**

Mixinsë¥¼ ì •ì˜í•˜ë ¤ë©´, mixin ì„ ì–¸ì„ ì‚¬ìš©í•œë‹¤. Mixinsì™€ í´ë˜ìŠ¤ë¥¼ ëª¨ë‘ ì •ì˜í•´ì•¼ í•˜ëŠ” ë“œë¬¸ ê²½ìš°ì—ëŠ” mixin class ì„ ì–¸ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

**Mixins and mixin classes cannot have an `extends` clause, and must not declare any generative constructors.**

Mixinsì™€ mixin í´ë˜ìŠ¤ëŠ” extends ì ˆì„ ê°€ì§ˆ ìˆ˜ ì—†ìœ¼ë©°, ìƒì„±ìë¥¼ ì„ ì–¸í•´ì„œëŠ” ì•ˆ ëœë‹¤.

**For example:**

ì˜ˆë¥¼ ë“¤ì–´:

```dart
mixin Musical {
  bool canPlayPiano = false;
  bool canCompose = false;
  bool canConduct = false;

  void entertainMe() {
    if (canPlayPiano) {
      print('Playing piano');
    } else if (canConduct) {
      print('Waving hands');
    } else {
      print('Humming to self');
    }
  }
}

```


## **Specify members a mixin can call on itself**[#](https://dart.dev/language/mixins#specify-members-a-mixin-can-call-on-itself) ë¯¹ìŠ¤ì¸ì´ ìì²´ì ìœ¼ë¡œ í˜¸ì¶œí•  ìˆ˜ ìˆëŠ” ë©¤ë²„ ì§€ì •í•˜ê¸°

**Sometimes a mixin depends on being able to invoke a method or access fields, but can't define those members itself (because mixins can't use constructor parameters to instantiate their own fields).**

ë•Œë•Œë¡œ ë¯¹ìŠ¤ì¸ì€ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ê±°ë‚˜ í•„ë“œì— ì ‘ê·¼í•  ìˆ˜ ìˆì–´ì•¼ í•˜ì§€ë§Œ, ìì²´ì ìœ¼ë¡œ ê·¸ ë©¤ë²„ë¥¼ ì •ì˜í•  ìˆ˜ëŠ” ì—†ë‹¤(ë¯¹ìŠ¤ì¸ì€ ìì‹ ì˜ í•„ë“œë¥¼ ì¸ìŠ¤í„´ìŠ¤í™”í•˜ê¸° ìœ„í•´ ìƒì„±ì ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì´ë‹¤).

**The following sections cover different strategies for ensuring any subclass of a mixin defines any members the mixin's behavior depends on.**

ë‹¤ìŒ ì„¹ì…˜ì—ì„œëŠ” ë¯¹ìŠ¤ì¸ì˜ ë™ì‘ì´ ì˜ì¡´í•˜ëŠ” ëª¨ë“  ë©¤ë²„ë¥¼ ì •ì˜í•˜ë„ë¡ ë¯¹ìŠ¤ì¸ì˜ í•˜ìœ„ í´ë˜ìŠ¤ê°€ ë³´ì¥ë°›ì„ ìˆ˜ ìˆëŠ” ë‹¤ì–‘í•œ ì „ëµì„ ë‹¤ë£¬ë‹¤.

ë‹¤ìŒ ì„¹ì…˜ì—ì„œëŠ” ë¯¹ìŠ¤ì¸ì˜ ë™ì‘ì´ ì˜ì¡´í•˜ëŠ” ëª¨ë“  ë©¤ë²„ë¥¼ ë¯¹ìŠ¤ì¸ì˜ ì„œë¸Œí´ë˜ìŠ¤ê°€ ì •ì˜í•˜ë„ë¡ ë³´ì¥í•˜ê¸° ìœ„í•œ ë‹¤ì–‘í•œ ì „ëµì„ ë‹¤ë£¬ë‹¤.



## **Define abstract members in the mixin**[#](https://dart.dev/language/mixins#define-abstract-members-in-the-mixin) ë¯¹ìŠ¤ì¸ì— ì¶”ìƒ ë©¤ë²„ ì •ì˜í•˜ê¸°

**Declaring an abstract method in a mixin forces any type that uses the mixin to define the abstract method upon which its behavior depends.**

ë¯¹ìŠ¤ì¸ì— ì¶”ìƒ ë©”ì„œë“œë¥¼ ì„ ì–¸í•˜ë©´, ë¯¹ìŠ¤ì¸ì„ ì‚¬ìš©í•˜ëŠ” ëª¨ë“  íƒ€ì…ì´ ê·¸ ë™ì‘ì— ì˜ì¡´í•˜ëŠ” ì¶”ìƒ ë©”ì„œë“œë¥¼ ì •ì˜í•´ì•¼ í•œë‹¤.

```dart
mixin Musician {
  void playInstrument(String instrumentName); // Abstract method.

  void playPiano() {
    playInstrument('Piano');
  }
  void playFlute() {
    playInstrument('Flute');
  }
}

class Virtuoso with Musician { 
  void playInstrument(String instrumentName) { // Subclass must define.
    print('Plays the $instrumentName beautifully');
  }  
}

```



## **Access state in the mixin's subclass**[#](https://dart.dev/language/mixins#access-state-in-the-mixins-subclass) ë¯¹ìŠ¤ì¸ì˜ ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ ìƒíƒœì— ì ‘ê·¼í•˜ê¸°

**Declaring abstract members also allows you to access state on the subclass of a mixin, by calling getters which are defined as abstract on the mixin:**

ì¶”ìƒ ë©¤ë²„ë¥¼ ì„ ì–¸í•˜ë©´ ë¯¹ìŠ¤ì¸ì—ì„œ ì •ì˜ëœ ì¶”ìƒ getterë¥¼ í˜¸ì¶œí•˜ì—¬ ë¯¹ìŠ¤ì¸ì˜ ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ ìƒíƒœì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.

```dart
/// Can be applied to any type with a [name] property and provides an
/// implementation of [hashCode] and operator `==` in terms of it.
mixin NameIdentity {
  String get name;

  int get hashCode => name.hashCode;
  bool operator ==(other) => other is NameIdentity && name == other.name;
}

class Person with NameIdentity {
  final String name;

  Person(this.name);
}

```


## **Implement an interface**[#](https://dart.dev/language/mixins#implement-an-interface) ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„í•˜ê¸°

**Similar to declaring the mixin abstract, putting an `implements` clause on the mixin while not actually implementing the interface will also ensure any member dependencies are defined for the mixin.**

ë¯¹ìŠ¤ì¸ì„ ì¶”ìƒì ìœ¼ë¡œ ì„ ì–¸í•˜ëŠ” ê²ƒê³¼ ìœ ì‚¬í•˜ê²Œ, ë¯¹ìŠ¤ì¸ì— implements ì ˆì„ ì¶”ê°€í•˜ë©´ì„œ ì‹¤ì œë¡œ ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ì§€ ì•Šìœ¼ë©´ ë¯¹ìŠ¤ì¸ì— í•„ìš”í•œ ëª¨ë“  ë©¤ë²„ ì˜ì¡´ì„±ì´ ì •ì˜ë˜ë„ë¡ í•  ìˆ˜ ìˆë‹¤.

```dart
abstract interface class Tuner {
  void tuneInstrument();
}

mixin Guitarist implements Tuner {
  void playSong() {
    tuneInstrument();

    print('Strums guitar majestically.');
  }
}

class PunkRocker with Guitarist {
  void tuneInstrument() {
    print("Don't bother, being out of tune is punk rock.");
  }
}

```


## **Use the `on` clause to declare a superclass[#](https://dart.dev/language/mixins#use-the-on-clause-to-declare-a-superclass)** on ì ˆì„ ì‚¬ìš©í•˜ì—¬ ìŠˆí¼í´ë˜ìŠ¤ë¥¼ ì„ ì–¸í•˜ê¸°

**The `on` clause exists to define the type that `super` calls are resolved against. So, you should only use it if you need to have a `super` call inside a mixin.**

on ì ˆì€ super í˜¸ì¶œì´ í•´ê²°ë˜ëŠ” íƒ€ì…ì„ ì •ì˜í•˜ê¸° ìœ„í•´ ì¡´ì¬í•œë‹¤. ë”°ë¼ì„œ ë¯¹ìŠ¤ì¸ ë‚´ë¶€ì—ì„œ super í˜¸ì¶œì´ í•„ìš”í•  ë•Œë§Œ ì‚¬ìš©í•´ì•¼ í•œë‹¤.

**The `on` clause forces any class that uses a mixin to also be a subclass of the type in the `on` clause. If the mixin depends on members in the superclass, this ensures those members are available where the mixin is used:**

on ì ˆì€ ë¯¹ìŠ¤ì¸ì„ ì‚¬ìš©í•˜ëŠ” ëª¨ë“  í´ë˜ìŠ¤ê°€ on ì ˆì— ìˆëŠ” íƒ€ì…ì˜ ì„œë¸Œí´ë˜ìŠ¤ê°€ ë˜ë„ë¡ ê°•ì œí•œë‹¤. ë¯¹ìŠ¤ì¸ì´ ìŠˆí¼í´ë˜ìŠ¤ì˜ ë©¤ë²„ì— ì˜ì¡´í•˜ëŠ” ê²½ìš°, ì´ë¥¼ í†µí•´ ë¯¹ìŠ¤ì¸ì´ ì‚¬ìš©ë˜ëŠ” ê³³ì—ì„œ í•´ë‹¹ ë©¤ë²„ê°€ ì‚¬ìš© ê°€ëŠ¥í•¨ì„ ë³´ì¥í•  ìˆ˜ ìˆë‹¤.

```dart
class Musician {
  musicianMethod() {
    print('Playing music!');
  }
}

mixin MusicalPerformer on Musician {
  perfomerMethod() {
    print('Performing music!');
    super.musicianMethod();
  }
}

class SingerDancer extends Musician with MusicalPerformer { }

main() {
  SingerDance().performerMethod();
}

```

**In this example, only classes that extend or implement the `Musician` class can use the mixin `MusicalPerformer`. Because `SingerDancer` extends `Musician`, `SingerDancer` can mix in `MusicalPerformer`.**

ì´ ì˜ˆì œì—ì„œëŠ” Musician í´ë˜ìŠ¤ë¥¼ í™•ì¥í•˜ê±°ë‚˜ êµ¬í˜„í•˜ëŠ” í´ë˜ìŠ¤ë§Œ MusicalPerformer ë¯¹ìŠ¤ì¸ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. SingerDancerëŠ” Musicianì„ í™•ì¥í•˜ê¸° ë•Œë¬¸ì— MusicalPerformer ë¯¹ìŠ¤ì¸ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.


## **class, mixin, or mixin class?[#](https://dart.dev/language/mixins#class-mixin-or-mixin-class)** í´ë˜ìŠ¤, ë¯¹ìŠ¤ì¸, ë˜ëŠ” ë¯¹ìŠ¤ì¸ í´ë˜ìŠ¤?

<aside> â„¹ï¸ **Version note**

**The `mixin class` declaration requires a [language version](https://dart.dev/guides/language/evolution#language-versioning) of at least 3.0.**

mixin class ì„ ì–¸ì€ ìµœì†Œ 3.0 ë²„ì „ ì´ìƒì˜ ì–¸ì–´ ë²„ì „ì´ í•„ìš”í•˜ë‹¤.

</aside>

**A `mixin` declaration defines a mixin. A `class` declaration defines a [class](https://dart.dev/language/classes). A `mixin class` declaration defines a class that is usable as both a regular class and a mixin, with the same name and the same type.**

mixin ì„ ì–¸ì€ ë¯¹ìŠ¤ì¸ì„ ì •ì˜í•œë‹¤. class ì„ ì–¸ì€ í´ë˜ìŠ¤ë¥¼ ì •ì˜í•œë‹¤. mixin class ì„ ì–¸ì€ ì¼ë°˜ í´ë˜ìŠ¤ì™€ ë¯¹ìŠ¤ì¸ìœ¼ë¡œ ëª¨ë‘ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” í´ë˜ìŠ¤ë¥¼ ì •ì˜í•˜ë©°, ë™ì¼í•œ ì´ë¦„ê³¼ íƒ€ì…ì„ ê°€ì§„ë‹¤.

```dart
mixin class Musician {
  // ...
}

class Novice with Musician { // Use Musician as a mixin
  // ...
}

class Novice extends Musician { // Use Musician as a class
  // ...
}

```

**Any restrictions that apply to classes or mixins also apply to mixin classes:**

í´ë˜ìŠ¤ë‚˜ ë¯¹ìŠ¤ì¸ì— ì ìš©ë˜ëŠ” ëª¨ë“  ì œí•œ ì‚¬í•­ì€ ë¯¹ìŠ¤ì¸ í´ë˜ìŠ¤ì—ë„ ì ìš©ëœë‹¤:

-   **Mixins can't have `extends` or `with` clauses, so neither can a `mixin class`.**
    
    ë¯¹ìŠ¤ì¸ì€ extendsë‚˜ with ì ˆì„ ê°€ì§ˆ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ, ë¯¹ìŠ¤ì¸ í´ë˜ìŠ¤ë„ ê°€ì§ˆ ìˆ˜ ì—†ë‹¤.
    
-   **Classes can't have an `on` clause, so neither can a `mixin class`.**
    
    í´ë˜ìŠ¤ëŠ” on ì ˆì„ ê°€ì§ˆ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ, ë¯¹ìŠ¤ì¸ í´ë˜ìŠ¤ë„ ê°€ì§ˆ ìˆ˜ ì—†ë‹¤.

---

ğŸ”— [[í˜ì´ì§€ ë§í¬]](https://dart.dev/language/enums)

# **Enumerated types** ì—´ê±°í˜• íƒ€ì…

**Enumerated types, often called _enumerations_ or _enums_, are a special kind of class used to represent a fixed number of constant values.**

ì—´ê±°í˜• íƒ€ì…(ì¢…ì¢… ì—´ê±°í˜• ë˜ëŠ” enumì´ë¼ê³  ë¶ˆë¦¼)ì€ ê³ ì •ëœ ìˆ˜ì˜ ìƒìˆ˜ ê°’ì„ ë‚˜íƒ€ë‚´ëŠ” íŠ¹ìˆ˜í•œ ì¢…ë¥˜ì˜ í´ë˜ìŠ¤ì´ë‹¤.

<aside> â„¹ï¸ **Note ì°¸ê³ **

**All enums automatically extend the [`Enum`](https://api.dart.dev/stable/dart-core/Enum-class.html) class. They are also sealed, meaning they cannot be subclassed, implemented, mixed in, or otherwise explicitly instantiated.**

ëª¨ë“  enumì€ ìë™ìœ¼ë¡œ Enum í´ë˜ìŠ¤ë¥¼ í™•ì¥í•œë‹¤. ë˜í•œ, enumì€ sealedë˜ì–´ ìˆìœ¼ë¯€ë¡œ ì„œë¸Œí´ë˜ìŠ¤í™”, êµ¬í˜„, ë¯¹ìŠ¤ì¸ ë˜ëŠ” ë‹¤ë¥¸ ë°©ë²•ìœ¼ë¡œ ëª…ì‹œì ìœ¼ë¡œ ì¸ìŠ¤í„´ìŠ¤í™”í•  ìˆ˜ ì—†ë‹¤.

**Abstract classes and mixins can explicitly implement or extend `Enum`, but unless they are then implemented by or mixed into an enum declaration, no objects can actually implement the type of that class or mixin.**

ì¶”ìƒ í´ë˜ìŠ¤ì™€ ë¯¹ìŠ¤ì¸ì€ ëª…ì‹œì ìœ¼ë¡œ Enumì„ êµ¬í˜„í•˜ê±°ë‚˜ í™•ì¥í•  ìˆ˜ ìˆì§€ë§Œ, enum ì„ ì–¸ì— ì˜í•´ êµ¬í˜„ë˜ê±°ë‚˜ ë¯¹ìŠ¤ì¸ë˜ì§€ ì•ŠëŠ” í•œ í•´ë‹¹ í´ë˜ìŠ¤ë‚˜ ë¯¹ìŠ¤ì¸ì˜ íƒ€ì…ì„ ì‹¤ì œë¡œ êµ¬í˜„í•˜ëŠ” ê°ì²´ëŠ” ì¡´ì¬í•  ìˆ˜ ì—†ë‹¤.

</aside>


## **Declaring simple enums[#](https://dart.dev/language/enums#declaring-simple-enums)** ê°„ë‹¨í•œ enum ì„ ì–¸í•˜ê¸°

**To declare a simple enumerated type, use the `enum` keyword and list the values you want to be enumerated:**

ê°„ë‹¨í•œ ì—´ê±°í˜• íƒ€ì…ì„ ì„ ì–¸í•˜ë ¤ë©´ enum í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ê³  ì—´ê±°í•˜ë ¤ëŠ” ê°’ì„ ë‚˜ì—´í•˜ë©´ ëœë‹¤:

```dart
enum Color { red, green, blue }

```

<aside> â„¹ï¸ **Tip**

**You can also use [trailing commas](https://dart.dev/language/collections#lists) when declaring an enumerated type to help prevent copy-paste errors.**

ì—´ê±°í˜• íƒ€ì…ì„ ì„ ì–¸í•  ë•Œ í›„í–‰ ì‰¼í‘œë¥¼ ì‚¬ìš©í•˜ì—¬ ë³µì‚¬-ë¶™ì—¬ë„£ê¸° ì˜¤ë¥˜ë¥¼ ë°©ì§€í•  ìˆ˜ ìˆë‹¤.

</aside>



## **Declaring enhanced enums[#](https://dart.dev/language/enums#declaring-enhanced-enums)** í–¥ìƒëœ enum ì„ ì–¸í•˜ê¸°

**Dart also allows enum declarations to declare classes with fields, methods, and const constructors which are limited to a fixed number of known constant instances.**

Dartì—ì„œëŠ” í•„ë“œ, ë©”ì„œë“œ, ê³ ì •ëœ ìˆ˜ì˜ ìƒìˆ˜ ì¸ìŠ¤í„´ìŠ¤ë¡œ ì œí•œëœ const ìƒì„±ìë¥¼ ê°€ì§„ í´ë˜ìŠ¤ë¥¼ ì„ ì–¸í•  ìˆ˜ ìˆëŠ” í–¥ìƒëœ enumì„ í—ˆìš©í•œë‹¤.

**To declare an enhanced enum, follow a syntax similar to normal [classes](https://dart.dev/language/classes), but with a few extra requirements:**

í–¥ìƒëœ enumì„ ì„ ì–¸í•˜ë ¤ë©´ ì¼ë°˜ í´ë˜ìŠ¤ì™€ ìœ ì‚¬í•œ êµ¬ë¬¸ì„ ì‚¬ìš©í•˜ì§€ë§Œ, ëª‡ ê°€ì§€ ì¶”ê°€ ìš”êµ¬ ì‚¬í•­ì´ ìˆë‹¤:

-   **Instance variables must be `final`, including those added by [mixins](https://dart.dev/language/mixins).**
    
    ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ëŠ” finalì´ì–´ì•¼ í•˜ë©°, ë¯¹ìŠ¤ì¸ì— ì˜í•´ ì¶”ê°€ëœ ë³€ìˆ˜ë„ í¬í•¨ëœë‹¤.
    
-   **All [generative constructors](https://dart.dev/language/constructors#constant-constructors) must be constant.**
    
    ëª¨ë“  ìƒì„±ìëŠ” ìƒìˆ˜ ìƒì„±ìì—¬ì•¼ í•œë‹¤.
    
-   [**Factory constructors](https://dart.dev/language/constructors#factory-constructors) can only return one of the fixed, known enum instances.**
    
    íŒ©í† ë¦¬ ìƒì„±ìëŠ” ê³ ì •ëœ ìƒìˆ˜ enum ì¸ìŠ¤í„´ìŠ¤ ì¤‘ í•˜ë‚˜ë§Œ ë°˜í™˜í•  ìˆ˜ ìˆë‹¤.
    
-   **No other class can be extended as [`Enum`](https://api.dart.dev/stable/dart-core/Enum-class.html) is automatically extended.**
    
    ë‹¤ë¥¸ í´ë˜ìŠ¤ë¥¼ í™•ì¥í•  ìˆ˜ ì—†ìœ¼ë©°, Enumì´ ìë™ìœ¼ë¡œ í™•ì¥ëœë‹¤.
    
-   **There cannot be overrides for `index`, `hashCode`, the equality operator `==`.**
    
    index, hashCode, ë™ë“±ì„± ì—°ì‚°ì ==ëŠ” ì˜¤ë²„ë¼ì´ë“œí•  ìˆ˜ ì—†ë‹¤.
    
-   **A member named `values` cannot be declared in an enum, as it would conflict with the automatically generated static `values` getter.**
    
    valuesë¼ëŠ” ì´ë¦„ì˜ ë©¤ë²„ëŠ” ì„ ì–¸í•  ìˆ˜ ì—†ë‹¤. ì´ëŠ” ìë™ìœ¼ë¡œ ìƒì„±ë˜ëŠ” static values getterì™€ ì¶©ëŒí•˜ê¸° ë•Œë¬¸ì´ë‹¤.
    
-   **All instances of the enum must be declared in the beginning of the declaration, and there must be at least one instance declared.**
    
    enumì˜ ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ëŠ” ì„ ì–¸ì˜ ì‹œì‘ ë¶€ë¶„ì— ì„ ì–¸ë˜ì–´ì•¼ í•˜ë©°, ì ì–´ë„ í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ ì„ ì–¸ë˜ì–´ì•¼ í•œë‹¤.
    

**Instance methods in an enhanced enum can use `this` to reference the current enum value.**

í–¥ìƒëœ enumì˜ ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œëŠ” thisë¥¼ ì‚¬ìš©í•˜ì—¬ í˜„ì¬ enum ê°’ì„ ì°¸ì¡°í•  ìˆ˜ ìˆë‹¤.

**Here is an example that declares an enhanced enum with multiple instances, instance variables, getters, and an implemented interface:**

ë‹¤ìŒì€ ì—¬ëŸ¬ ì¸ìŠ¤í„´ìŠ¤, ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜, getter ë° êµ¬í˜„ëœ ì¸í„°í˜ì´ìŠ¤ë¥¼ ê°€ì§„ í–¥ìƒëœ enumì„ ì„ ì–¸í•˜ëŠ” ì˜ˆì‹œì´ë‹¤:

```dart
enum Vehicle implements Comparable<Vehicle> {
  car(tires: 4, passengers: 5, carbonPerKilometer: 400),
  bus(tires: 6, passengers: 50, carbonPerKilometer: 800),
  bicycle(tires: 2, passengers: 1, carbonPerKilometer: 0);

  const Vehicle({
    required this.tires,
    required this.passengers,
    required this.carbonPerKilometer,
  });

  final int tires;
  final int passengers;
  final int carbonPerKilometer;

  int get carbonFootprint => (carbonPerKilometer / passengers).round();

  bool get isTwoWheeled => this == Vehicle.bicycle;

  @override
  int compareTo(Vehicle other) => carbonFootprint - other.carbonFootprint;
}

```

<aside> â„¹ï¸ **Version note**

**Enhanced enums require a [language version](https://dart.dev/guides/language/evolution#language-versioning) of at least 2.17.**

í–¥ìƒëœ enumì€ ìµœì†Œ 2.17 ë²„ì „ ì´ìƒì˜ ì–¸ì–´ ë²„ì „ì´ í•„ìš”í•˜ë‹¤.

</aside>


## **Using enums[#](https://dart.dev/language/enums#using-enums)** enum ì‚¬ìš©í•˜ê¸°

**Access the enumerated values like any other [static variable](https://dart.dev/language/classes#class-variables-and-methods):**

ì—´ê±°ëœ ê°’ì„ ë‹¤ë¥¸ static ë³€ìˆ˜ì²˜ëŸ¼ ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤:

```dart
final favoriteColor = Color.blue;
if (favoriteColor == Color.blue) {
  print('Your favorite color is blue!');
}

```

**Each value in an enum has an `index` getter, which returns the zero-based position of the value in the enum declaration. For example, the first value has index 0, and the second value has index 1.**

enumì˜ ê° ê°’ì€ ì¸ë±ìŠ¤ getterë¥¼ ê°€ì§€ë©°, ì´ëŠ” enum ì„ ì–¸ì—ì„œ ê°’ì˜ 0ë¶€í„° ì‹œì‘í•˜ëŠ” ìœ„ì¹˜ë¥¼ ë°˜í™˜í•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì²« ë²ˆì§¸ ê°’ì€ ì¸ë±ìŠ¤ 0ì„ ê°€ì§€ë©°, ë‘ ë²ˆì§¸ ê°’ì€ ì¸ë±ìŠ¤ 1ì„ ê°€ì§„ë‹¤.

```dart
assert(Color.red.index == 0);
assert(Color.green.index == 1);
assert(Color.blue.index == 2);

```

**To get a list of all the enumerated values, use the enum's `values` constant.**

ì—´ê±°ëœ ëª¨ë“  ê°’ì„ ê°€ì ¸ì˜¤ë ¤ë©´ enumì˜ values ìƒìˆ˜ë¥¼ ì‚¬ìš©í•œë‹¤.

```dart
List<Color> colors = Color.values;
assert(colors[2] == Color.blue);

```

**You can use enums in [switch statements](https://dart.dev/language/branches#switch), and you'll get a warning if you don't handle all of the enum's values:**

enumì„ switch ë¬¸ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©°, ëª¨ë“  enum ê°’ì„ ì²˜ë¦¬í•˜ì§€ ì•Šìœ¼ë©´ ê²½ê³ ë¥¼ ë°›ëŠ”ë‹¤:

```dart
var aColor = Color.blue;

switch (aColor) {
  case Color.red:
    print('Red as roses!');
  case Color.green:
    print('Green as grass!');
  default: // ì´ ì—†ìœ¼ë©´ ê²½ê³ ê°€ í‘œì‹œëœë‹¤.
    print(aColor); // 'Color.blue'
}

```

**If you need to access the name of an enumerated value, such as `'blue'` from `Color.blue`, use the `.name` property:**

Color.blueì—ì„œ â€˜blueâ€™ì™€ ê°™ì´ ì—´ê±°ëœ ê°’ì˜ ì´ë¦„ì— ì ‘ê·¼í•´ì•¼ í•˜ëŠ” ê²½ìš°, .name ì†ì„±ì„ ì‚¬ìš©í•œë‹¤:

```dart
print(Color.blue.name); // 'blue'

```

**You can access a member of an enum value like you would on a normal object:**

ì¼ë°˜ ê°ì²´ì—ì„œ í•˜ë“¯ì´ enum ê°’ì˜ ë©¤ë²„ì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤:

```dart
print(Vehicle.car.carbonFootprint);

```

---

ğŸ”— [[í˜ì´ì§€ ë§í¬]](https://dart.dev/language/extension-methods)

# **Extension methods** í™•ì¥ ë©”ì„œë“œ

**Extension methods add functionality to existing libraries. You might use extension methods without even knowing it. For example, when you use code completion in an IDE, it suggests extension methods alongside regular methods.**

í™•ì¥ ë©”ì„œë“œëŠ” ê¸°ì¡´ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ê¸°ëŠ¥ì„ ì¶”ê°€í•œë‹¤. í™•ì¥ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ëŠ”ì§€ ëª¨ë¥´ê³  ì‚¬ìš©í•  ìˆ˜ë„ ìˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, IDEì—ì„œ ì½”ë“œ ìë™ ì™„ì„±ì„ ì‚¬ìš©í•  ë•Œ, í™•ì¥ ë©”ì„œë“œê°€ ì¼ë°˜ ë©”ì„œë“œì™€ í•¨ê»˜ ì œì•ˆëœë‹¤.

**If watching videos helps you learn, check out this overview of extension methods.**

ë¹„ë””ì˜¤ ì‹œì²­ì´ í•™ìŠµì— ë„ì›€ì´ ëœë‹¤ë©´, í™•ì¥ ë©”ì„œë“œì— ëŒ€í•œ ê°œìš”ë¥¼ í™•ì¸í•´ë³´ì.

ğŸ”— [[youtube ë§í¬]](https://www.youtube.com/watch?v=D3j0OSfT9ZI)



## **Overview[#](https://dart.dev/language/extension-methods#overview)** ê°œìš”

**When you're using someone else's API or when you implement a library that's widely used, it's often impractical or impossible to change the API. But you might still want to add some functionality.**

ë‹¤ë¥¸ ì‚¬ëŒì˜ APIë¥¼ ì‚¬ìš©í•˜ê±°ë‚˜ ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ êµ¬í˜„í•  ë•Œ, APIë¥¼ ë³€ê²½í•˜ëŠ” ê²ƒì€ ì‹¤ìš©ì ì´ì§€ ì•Šê±°ë‚˜ ë¶ˆê°€ëŠ¥í•œ ê²½ìš°ê°€ ë§ë‹¤. í•˜ì§€ë§Œ ì—¬ì „íˆ ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ê³  ì‹¶ì„ ìˆ˜ ìˆë‹¤.

**For example, consider the following code that parses a string into an integer:**

ì˜ˆë¥¼ ë“¤ì–´, ë¬¸ìì—´ì„ ì •ìˆ˜ë¡œ íŒŒì‹±í•˜ëŠ” ë‹¤ìŒ ì½”ë“œë¥¼ ê³ ë ¤í•´ë³´ì:

```dart
int.parse('42')


```

**It might be niceâ€”shorter and easier to use with toolsâ€”to have that functionality be on `String` instead:**

ì´ ê¸°ëŠ¥ì„ String í´ë˜ìŠ¤ì— ì¶”ê°€í•˜ë©´ ë” ì§§ê³  ë„êµ¬ ì‚¬ìš©ì´ ì‰¬ìš¸ ê²ƒì´ë‹¤:

```dart
'42'.parseInt()

```

**To enable that code, you can import a library that contains an extension of the `String` class:**

ì´ ì½”ë“œë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ String í´ë˜ìŠ¤ë¥¼ í™•ì¥í•˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì„í¬íŠ¸í•˜ë©´ ëœë‹¤:

```dart
import 'string_apis.dart';
// Â·Â·Â·
print('42'.parseInt()); // í™•ì¥ ë©”ì„œë“œ ì‚¬ìš©.

```

**Extensions can define not just methods, but also other members such as getter, setters, and operators. Also, extensions can have names, which can be helpful if an API conflict arises. Here's how you might implement the extension method `parseInt()`, using an extension (named `NumberParsing`) that operates on strings:**

í™•ì¥ ë©”ì„œë“œëŠ” ë©”ì„œë“œë¿ë§Œ ì•„ë‹ˆë¼ getter, setter, ì—°ì‚°ìì™€ ê°™ì€ ë‹¤ë¥¸ ë©¤ë²„ë„ ì •ì˜í•  ìˆ˜ ìˆë‹¤. ë˜í•œ, API ì¶©ëŒì´ ë°œìƒí•  ê²½ìš° ìœ ìš©í•œ ì´ë¦„ì„ ê°€ì§ˆ ìˆ˜ë„ ìˆë‹¤. ë‹¤ìŒì€ ë¬¸ìì—´ì—ì„œ ì‘ë™í•˜ëŠ” NumberParsingì´ë¼ëŠ” ì´ë¦„ì˜ í™•ì¥ì„ ì‚¬ìš©í•˜ì—¬ parseInt() í™•ì¥ ë©”ì„œë“œë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì´ë‹¤:

```dart
**lib/string_apis.dart**

```

**The next section describes how to _use_ extension methods. After that are sections about _implementing_ extension methods.**

ë‹¤ìŒ ì„¹ì…˜ì—ì„œëŠ” í™•ì¥ ë©”ì„œë“œ ì‚¬ìš© ë°©ë²•ì„ ì„¤ëª…í•œë‹¤. ê·¸ í›„ì—ëŠ” í™•ì¥ ë©”ì„œë“œ êµ¬í˜„ì— ëŒ€í•œ ì„¹ì…˜ì´ ì´ì–´ì§„ë‹¤.


## **Using extension methods[#](https://dart.dev/language/extension-methods#using-extension-methods)** í™•ì¥ ë©”ì„œë“œ ì‚¬ìš©í•˜ê¸°

**Like all Dart code, extension methods are in libraries. You've already seen how to use an extension methodâ€”just import the library it's in, and use it like an ordinary method:**

ëª¨ë“  Dart ì½”ë“œì™€ ë§ˆì°¬ê°€ì§€ë¡œ, í™•ì¥ ë©”ì„œë“œëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ ë‚´ì— ìˆë‹¤. ì´ë¯¸ í™•ì¥ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ë³´ì•˜ì„ ê²ƒì´ë‹¤. ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ í¬í•¨ëœ íŒŒì¼ì„ ì„í¬íŠ¸í•˜ê³ , ì¼ë°˜ ë©”ì„œë“œì²˜ëŸ¼ ì‚¬ìš©í•˜ë©´ ëœë‹¤:

```dart
// Stringì— ëŒ€í•œ í™•ì¥ì´ í¬í•¨ëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì„í¬íŠ¸í•œë‹¤.
import 'string_apis.dart';
// Â·Â·Â·
print('42'.padLeft(5)); // String ë©”ì„œë“œ ì‚¬ìš©.
print('42'.parseInt()); // í™•ì¥ ë©”ì„œë“œ ì‚¬ìš©.

```

**That's all you usually need to know to use extension methods. As you write your code, you might also need to know how extension methods depend on static types (as opposed to `dynamic`) and how to resolve [API conflicts](https://dart.dev/language/extension-methods#api-conflicts).**

í™•ì¥ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ë³´í†µ ì´ ì •ë„ë§Œ ì•Œë©´ ëœë‹¤. ì½”ë“œë¥¼ ì‘ì„±í•˜ë©´ì„œ, í™•ì¥ ë©”ì„œë“œê°€ ì •ì  íƒ€ì…(ë™ì  íƒ€ì…ê³¼ ë°˜ëŒ€)ì— ì˜ì¡´í•˜ëŠ” ë°©ë²•ê³¼ API ì¶©ëŒì„ í•´ê²°í•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ì„œë„ ì•Œì•„ì•¼ í•  ìˆ˜ë„ ìˆë‹¤.

### **Static types and dynamic[#](https://dart.dev/language/extension-methods#static-types-and-dynamic)** ì •ì  íƒ€ì…ê³¼ ë™ì  íƒ€ì…

**You can't invoke extension methods on variables of type `dynamic`. For example, the following code results in a runtime exception:**

ë™ì  íƒ€ì…(dynamic)ì˜ ë³€ìˆ˜ì—ì„œëŠ” í™•ì¥ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ìˆ˜ ì—†ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ë‹¤ìŒ ì½”ë“œëŠ” ëŸ°íƒ€ì„ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¨ë‹¤:

```dart
dynamic d = '2';
print(d.parseInt()); // ëŸ°íƒ€ì„ ì˜ˆì™¸: NoSuchMethodError

```

**Extension methods _do_ work with Dart's type inference. The following code is fine because the variable `v` is inferred to have type `String`:**

í™•ì¥ ë©”ì„œë“œëŠ” Dartì˜ íƒ€ì… ì¶”ë¡ ê³¼ í•¨ê»˜ ì‘ë™í•œë‹¤. ë‹¤ìŒ ì½”ë“œëŠ” ë³€ìˆ˜ vê°€ String íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ ë˜ê¸° ë•Œë¬¸ì— ë¬¸ì œê°€ ì—†ë‹¤:

```dart
var v = '2';
print(v.parseInt()); // ì¶œë ¥: 2

```

**The reason that `dynamic` doesn't work is that extension methods are resolved against the static type of the receiver. Because extension methods are resolved statically, they're as fast as calling a static function.**

ë™ì  íƒ€ì…ì´ ì‘ë™í•˜ì§€ ì•ŠëŠ” ì´ìœ ëŠ” í™•ì¥ ë©”ì„œë“œê°€ ìˆ˜ì‹ ìì˜ ì •ì  íƒ€ì…ì— ëŒ€í•´ í•´ê²°ë˜ê¸° ë•Œë¬¸ì´ë‹¤. í™•ì¥ ë©”ì„œë“œëŠ” ì •ì ìœ¼ë¡œ í•´ê²°ë˜ë¯€ë¡œ, ì •ì  í•¨ìˆ˜ í˜¸ì¶œë§Œí¼ ë¹ ë¥´ë‹¤.

**For more information about static types and `dynamic`, see [The Dart type system](https://dart.dev/language/type-system).**

ì •ì  íƒ€ì…ê³¼ ë™ì  íƒ€ì…ì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ Dart íƒ€ì… ì‹œìŠ¤í…œì„ ì°¸ì¡°í•˜ë¼.

### **API conflicts[#](https://dart.dev/language/extension-methods#api-conflicts)** API ì¶©ëŒ

**If an extension member conflicts with an interface or with another extension member, then you have a few options.**

í™•ì¥ ë©¤ë²„ê°€ ì¸í„°í˜ì´ìŠ¤ ë˜ëŠ” ë‹¤ë¥¸ í™•ì¥ ë©¤ë²„ì™€ ì¶©ëŒí•˜ëŠ” ê²½ìš°, ëª‡ ê°€ì§€ ì„ íƒ ì‚¬í•­ì´ ìˆë‹¤.

**One option is changing how you import the conflicting extension, using `show` or `hide` to limit the exposed API:**

í•˜ë‚˜ì˜ ë°©ë²•ì€ show ë˜ëŠ” hideë¥¼ ì‚¬ìš©í•˜ì—¬ ë…¸ì¶œëœ APIë¥¼ ì œí•œí•˜ë©´ì„œ ì¶©ëŒí•˜ëŠ” í™•ì¥ì„ ì„í¬íŠ¸í•˜ëŠ” ë°©ë²•ì„ ë³€ê²½í•˜ëŠ” ê²ƒì´ë‹¤:

```dart
// String í™•ì¥ ë©”ì„œë“œ parseInt()ë¥¼ ì •ì˜í•œë‹¤.
import 'string_apis.dart';

// parseInt()ë„ ì •ì˜í•˜ì§€ë§Œ, NumberParsing2ë¥¼ ìˆ¨ê¸°ë©´
// í•´ë‹¹ í™•ì¥ ë©”ì„œë“œê°€ ìˆ¨ê²¨ì§„ë‹¤.
import 'string_apis_2.dart' hide NumberParsing2;

// Â·Â·Â·
// 'string_apis.dart'ì— ì •ì˜ëœ parseInt()ë¥¼ ì‚¬ìš©í•œë‹¤.
print('42'.parseInt());

```

**Another option is applying the extension explicitly, which results in code that looks as if the extension is a wrapper class:**

ë˜ ë‹¤ë¥¸ ë°©ë²•ì€ í™•ì¥ì„ ëª…ì‹œì ìœ¼ë¡œ ì ìš©í•˜ëŠ” ê²ƒìœ¼ë¡œ, í™•ì¥ì´ ë˜í¼ í´ë˜ìŠ¤ì¸ ê²ƒì²˜ëŸ¼ ë³´ì´ê²Œ í•˜ëŠ” ê²ƒì´ë‹¤:

```dart
// ë‘ ë¼ì´ë¸ŒëŸ¬ë¦¬ ëª¨ë‘ Stringì— ëŒ€í•œ í™•ì¥ì„ ì •ì˜í•˜ê³ ,
// ê° í™•ì¥ì—ëŠ” parseInt()ê°€ í¬í•¨ë˜ì–´ ìˆë‹¤.
import 'string_apis.dart'; // NumberParsing í™•ì¥ì„ í¬í•¨í•œë‹¤.
import 'string_apis_2.dart'; // NumberParsing2 í™•ì¥ì„ í¬í•¨í•œë‹¤.

// Â·Â·Â·
// print('42'.parseInt()); // ì‘ë™í•˜ì§€ ì•ŠëŠ”ë‹¤.
print(NumberParsing('42').parseInt());
print(NumberParsing2('42').parseInt());

```

**If both extensions have the same name, then you might need to import using a prefix:**

ë‘ í™•ì¥ì´ ê°™ì€ ì´ë¦„ì„ ê°€ì§€ê³  ìˆë‹¤ë©´, ì ‘ë‘ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì„í¬íŠ¸í•´ì•¼ í•  ìˆ˜ë„ ìˆë‹¤:

```dart
// ë‘ ë¼ì´ë¸ŒëŸ¬ë¦¬ ëª¨ë‘ NumberParsingì´ë¼ëŠ” ì´ë¦„ì˜ í™•ì¥ì„ ì •ì˜í•˜ê³ 
// í™•ì¥ ë©”ì„œë“œ parseInt()ë¥¼ í¬í•¨í•œë‹¤. 'string_apis_3.dart'ì˜ í•œ NumberParsing
// í™•ì¥ì€ parseNum()ë„ ì •ì˜í•œë‹¤.
import 'string_apis.dart';
import 'string_apis_3.dart' as rad;

// Â·Â·Â·
// print('42'.parseInt()); // ì‘ë™í•˜ì§€ ì•ŠëŠ”ë‹¤.

// string_apis.dartì˜ NumberParsing í™•ì¥ì„ ì‚¬ìš©í•œë‹¤.
print(NumberParsing('42').parseInt());

// string_apis_3.dartì˜ NumberParsing í™•ì¥ì„ ì‚¬ìš©í•œë‹¤.
print(rad.NumberParsing('42').parseInt());

// string_apis_3.dartì—ë§Œ parseNum()ì´ ìˆë‹¤.
print('42'.parseNum());

```

**As the example shows, you can invoke extension methods implicitly even if you import using a prefix. The only time you need to use the prefix is to avoid a name conflict when invoking an extension explicitly.**

ì˜ˆì‹œì—ì„œ ë³¼ ìˆ˜ ìˆë“¯ì´, ì ‘ë‘ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì„í¬íŠ¸í•´ë„ í™•ì¥ ë©”ì„œë“œë¥¼ ì•”ì‹œì ìœ¼ë¡œ í˜¸ì¶œí•  ìˆ˜ ìˆë‹¤. í™•ì¥ì„ ëª…ì‹œì ìœ¼ë¡œ í˜¸ì¶œí•  ë•Œ ì´ë¦„ ì¶©ëŒì„ í”¼í•˜ê¸° ìœ„í•´ì„œë§Œ ì ‘ë‘ì–´ë¥¼ ì‚¬ìš©í•˜ë©´ ëœë‹¤.



## **Implementing extension methods[#](https://dart.dev/language/extension-methods#implementing-extension-methods)** í™•ì¥ ë©”ì„œë“œ êµ¬í˜„í•˜ê¸°

**Use the following syntax to create an extension:**

ë‹¤ìŒ êµ¬ë¬¸ì„ ì‚¬ìš©í•˜ì—¬ í™•ì¥ì„ ìƒì„±í•œë‹¤:

```dart
extension <í™•ì¥ ì´ë¦„>? on <íƒ€ì…> { // <í™•ì¥ ì´ë¦„>ì€ ì„ íƒ ì‚¬í•­ì´ë‹¤.
  (<ë©¤ë²„ ì •ì˜>)* // í•˜ë‚˜ ì´ìƒì˜ <ë©¤ë²„ ì •ì˜>ë¥¼ ì œê³µí•  ìˆ˜ ìˆë‹¤.
}

```

**For example, here's how you might implement an extension on the `String` class:**

**lib/string_apis.dart**

ì˜ˆë¥¼ ë“¤ì–´, String í´ë˜ìŠ¤ì— ëŒ€í•œ í™•ì¥ì„ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ë‹¤:

```dart
lib/string_apis.dart
extension NumberParsing on String {
  int parseInt() {
    return int.parse(this);
  }

  double parseDouble() {
    return double.parse(this);
  }
}

```

**The members of an extension can be methods, getters, setters, or operators. Extensions can also have static fields and static helper methods. To access static members outside the extension declaration, invoke them through the declaration name like [class variables and methods](https://dart.dev/language/classes#class-variables-and-methods).**

í™•ì¥ì˜ ë©¤ë²„ëŠ” ë©”ì„œë“œ, getter, setter ë˜ëŠ” ì—°ì‚°ìê°€ ë  ìˆ˜ ìˆë‹¤. í™•ì¥ì€ static í•„ë“œì™€ static ë„ìš°ë¯¸ ë©”ì„œë“œë„ ê°€ì§ˆ ìˆ˜ ìˆë‹¤. í™•ì¥ ì„ ì–¸ ì™¸ë¶€ì—ì„œ static ë©¤ë²„ì— ì ‘ê·¼í•˜ë ¤ë©´ í´ë˜ìŠ¤ ë³€ìˆ˜ì™€ ë©”ì„œë“œì²˜ëŸ¼ ì„ ì–¸ ì´ë¦„ì„ í†µí•´ í˜¸ì¶œí•œë‹¤.

### **Unnamed extensions[#](https://dart.dev/language/extension-methods#unnamed-extensions)** ì´ë¦„ ì—†ëŠ” í™•ì¥

**When declaring an extension, you can omit the name. Unnamed extensions are visible only in the library where they're declared. Since they don't have a name, they can't be explicitly applied to resolve [API conflicts](https://dart.dev/language/extension-methods#api-conflicts).**

í™•ì¥ì„ ì„ ì–¸í•  ë•Œ ì´ë¦„ì„ ìƒëµí•  ìˆ˜ ìˆë‹¤. ì´ë¦„ ì—†ëŠ” í™•ì¥ì€ ì„ ì–¸ëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë‚´ì—ì„œë§Œ ë³´ì¸ë‹¤. ì´ë¦„ì´ ì—†ê¸° ë•Œë¬¸ì— API ì¶©ëŒì„ í•´ê²°í•˜ê¸° ìœ„í•´ ëª…ì‹œì ìœ¼ë¡œ ì ìš©í•  ìˆ˜ ì—†ë‹¤.

```dart
extension on String {
  bool get isBlank => trim().isEmpty;
}

```

<aside> â„¹ï¸ **Note**

**You can invoke an unnamed extension's static members only within the extension declaration.**

ì´ë¦„ ì—†ëŠ” í™•ì¥ì˜ static ë©¤ë²„ëŠ” í•´ë‹¹ í™•ì¥ ì„ ì–¸ ë‚´ì—ì„œë§Œ í˜¸ì¶œí•  ìˆ˜ ìˆë‹¤.

</aside>



## **Implementing generic extensions[#](https://dart.dev/language/extension-methods#implementing-generic-extensions)** ì œë„¤ë¦­ í™•ì¥ êµ¬í˜„í•˜ê¸°

**Extensions can have generic type parameters. For example, here's some code that extends the built-in `List<T>` type with a getter, an operator, and a method:**

í™•ì¥ì€ ì œë„¤ë¦­ íƒ€ì… ë§¤ê°œë³€ìˆ˜ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ë‚´ì¥ëœ List<T> íƒ€ì…ì„ í™•ì¥í•˜ì—¬ getter, ì—°ì‚°ì, ë©”ì„œë“œë¥¼ ì¶”ê°€í•˜ëŠ” ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤:

```dart
extension MyFancyList<T> on List<T> {
  int get doubleLength => length * 2;
  List<T> operator -() => reversed.toList();
  List<List<T>> split(int at) => [sublist(0, at), sublist(at)];
}

```

**The type `T` is bound based on the static type of the list that the methods are called on.**

íƒ€ì… TëŠ” ë©”ì„œë“œê°€ í˜¸ì¶œë˜ëŠ” ë¦¬ìŠ¤íŠ¸ì˜ ì •ì  íƒ€ì…ì„ ê¸°ì¤€ìœ¼ë¡œ ê²°ì •ëœë‹¤.



## **Resources[#](https://dart.dev/language/extension-methods#resources)** ë¦¬ì†ŒìŠ¤

**For more information about extension methods, see the following:**

í™•ì¥ ë©”ì„œë“œì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ ë‹¤ìŒì„ ì°¸ì¡°í•˜ë¼:

-   [**Article: Dart Extension Methods Fundamentals**](https://medium.com/dartlang/extension-methods-2d466cd8b308)
    
    ê¸°ì‚¬: [Dart Extension Methods Fundamentals](https://dart.dev/guides/language/extension-methods)
    
-   [**Feature specification**](https://github.com/dart-lang/language/blob/main/accepted/2.7/static-extension-methods/feature-specification.md#dart-static-extension-methods-design)
    
    ê¸°ëŠ¥ ëª…ì„¸
    
-   [**Extension methods sample**](https://github.com/dart-lang/samples/tree/main/extension_methods)
    
    í™•ì¥ ë©”ì„œë“œ ìƒ˜í”Œ

---

ğŸ”— [[í˜ì´ì§€ ë§í¬]](https://dart.dev/language/extension-types)

# **Extension types** í™•ì¥ íƒ€ì…

**An extension type is a compile-time abstraction that "wraps" an existing type with a different, static-only interface. They are a major component of [static JS interop](https://dart.dev/go/next-gen-js-interop) because they can easily modify an existing type's interface (crucial for any kind of interop) without incurring the cost of an actual wrapper.**

í™•ì¥ íƒ€ì…ì€ ê¸°ì¡´ íƒ€ì…ì„ ë‹¤ë¥¸ ì •ì  ì „ìš© ì¸í„°í˜ì´ìŠ¤ë¡œ â€œê°ì‹¸ëŠ”â€ ì»´íŒŒì¼ íƒ€ì„ ì¶”ìƒí™”ì´ë‹¤. ì´ëŠ” ì‹¤ì œ ë˜í¼ì˜ ë¹„ìš©ì„ ì´ˆë˜í•˜ì§€ ì•Šìœ¼ë©´ì„œ ê¸°ì¡´ íƒ€ì…ì˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‰½ê²Œ ìˆ˜ì •í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, ì •ì  JS ìƒí˜¸ ìš´ìš©ì„±ì˜ ì£¼ìš” êµ¬ì„± ìš”ì†Œì´ë‹¤.

**Extension types enforce discipline on the set of operations (or interface) available to objects of an underlying type, called the _representation type_. When defining the interface of an extension type, you can choose to reuse some members of the representation type, omit others, replace others, and add new functionality.**

í™•ì¥ íƒ€ì…ì€ í‘œí˜„ íƒ€ì…ì´ë¼ê³  í•˜ëŠ” ê¸°ë³¸ íƒ€ì…ì˜ ê°ì²´ì— ì‚¬ìš© ê°€ëŠ¥í•œ ì—°ì‚°(ë˜ëŠ” ì¸í„°í˜ì´ìŠ¤) ì§‘í•©ì— ëŒ€í•œ ê·œìœ¨ì„ ê°•ì œí•œë‹¤. í™•ì¥ íƒ€ì…ì˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•  ë•Œ, í‘œí˜„ íƒ€ì…ì˜ ì¼ë¶€ ë©¤ë²„ë¥¼ ì¬ì‚¬ìš©í•˜ê³ , ë‹¤ë¥¸ ë©¤ë²„ë¥¼ ìƒëµí•˜ê±°ë‚˜ êµì²´í•˜ê³ , ìƒˆë¡œìš´ ê¸°ëŠ¥ì„ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.

**The following example wraps the `int` type to create an extension type that only allows operations that make sense for ID numbers:**

ë‹¤ìŒ ì˜ˆì œëŠ” int íƒ€ì…ì„ ê°ì‹¸ì„œ ID ë²ˆí˜¸ì— ì˜ë¯¸ ìˆëŠ” ì—°ì‚°ë§Œ í—ˆìš©í•˜ëŠ” í™•ì¥ íƒ€ì…ì„ ìƒì„±í•œë‹¤:

```dart
extension type IdNumber(int id) {
  // 'int' íƒ€ì…ì˜ '<' ì—°ì‚°ìë¥¼ ê°ì‹¼ë‹¤:
  operator <(IdNumber other) => id < other.id;
  // '+' ì—°ì‚°ìëŠ” ì„ ì–¸í•˜ì§€ ì•ŠëŠ”ë‹¤,
  // ì˜ˆë¥¼ ë“¤ì–´, ë§ì…ˆì€ ID ë²ˆí˜¸ì— ì˜ë¯¸ê°€ ì—†ê¸° ë•Œë¬¸ì´ë‹¤.
}

void main() {
  // í™•ì¥ íƒ€ì…ì˜ ê·œìœ¨ ì—†ì´,
  // 'int'ëŠ” ID ë²ˆí˜¸ë¥¼ ì•ˆì „í•˜ì§€ ì•Šì€ ì—°ì‚°ì— ë…¸ì¶œì‹œí‚¨ë‹¤:
  int myUnsafeId = 42424242;
  myUnsafeId = myUnsafeId + 10; // ì´ ì‘ì—…ì€ ê°€ëŠ¥í•˜ì§€ë§Œ, IDì—ëŠ” í—ˆìš©ë˜ì§€ ì•Šì•„ì•¼ í•œë‹¤.

  var safeId = IdNumber(42424242);
  safeId + 10; // ì»´íŒŒì¼ íƒ€ì„ ì˜¤ë¥˜: '+' ì—°ì‚°ìê°€ ì—†ìŒ.
  myUnsafeId = safeId; // ì»´íŒŒì¼ íƒ€ì„ ì˜¤ë¥˜: ì˜ëª»ëœ íƒ€ì….
  myUnsafeId = safeId as int; // OK: ëŸ°íƒ€ì„ì— í‘œí˜„ íƒ€ì…ìœ¼ë¡œ ìºìŠ¤íŒ….
  safeId < IdNumber(42424241); // OK: ê°ì‹¸ì§„ '<' ì—°ì‚°ì ì‚¬ìš©.
}

```

<aside> â„¹ï¸ **Note**

**Extension types serve the same purpose as wrapper classes, but don't require the creation of an extra run-time object, which can get expensive when you need to wrap lots of objects. Because extension types are static-only and compiled away at run time, they are essentially zero cost.**

í™•ì¥ íƒ€ì…ì€ ë˜í¼ í´ë˜ìŠ¤ì™€ ë™ì¼í•œ ëª©ì ì„ ì œê³µí•˜ì§€ë§Œ, ì¶”ê°€ì ì¸ ëŸ°íƒ€ì„ ê°ì²´ë¥¼ ìƒì„±í•  í•„ìš”ê°€ ì—†ë‹¤. ë§ì€ ê°ì²´ë¥¼ ë˜í•‘í•´ì•¼ í•  ë•Œ, ì´ëŠ” ë¹„ìš©ì´ ë§ì´ ë“¤ ìˆ˜ ìˆë‹¤. í™•ì¥ íƒ€ì…ì€ ì •ì  ì „ìš©ì´ê³  ëŸ°íƒ€ì„ ì‹œ ì»´íŒŒì¼ë˜ë¯€ë¡œ, ë³¸ì§ˆì ìœ¼ë¡œ ë¹„ìš©ì´ ê±°ì˜ ì—†ë‹¤.

**[Extension methods](https://dart.dev/language/extension-methods) (also known just as "extensions") are a static abstraction similar to extension types. However, an extension method adds functionality _directly_ to every instance of its underlying type. Extension types are different; an extension type's interface _only_ applies to expressions whose static type is that extension type. They are distinct from the interface of their underlying type by default.**

í™•ì¥ ë©”ì„œë“œ(ë˜ëŠ” â€œí™•ì¥â€ìœ¼ë¡œë„ ì•Œë ¤ì§)ëŠ” í™•ì¥ íƒ€ì…ê³¼ ìœ ì‚¬í•œ ì •ì  ì¶”ìƒí™”ì´ë‹¤. ê·¸ëŸ¬ë‚˜ í™•ì¥ ë©”ì„œë“œëŠ” ê¸°ë³¸ íƒ€ì…ì˜ ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ì— ì§ì ‘ ê¸°ëŠ¥ì„ ì¶”ê°€í•œë‹¤. í™•ì¥ íƒ€ì…ì€ ë‹¤ë¥´ë‹¤; í™•ì¥ íƒ€ì…ì˜ ì¸í„°í˜ì´ìŠ¤ëŠ” í•´ë‹¹ í™•ì¥ íƒ€ì…ì˜ ì •ì  íƒ€ì…ì¸ í‘œí˜„ì‹ì—ë§Œ ì ìš©ëœë‹¤. ê¸°ë³¸ íƒ€ì…ì˜ ì¸í„°í˜ì´ìŠ¤ì™€ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë‹¤ë¥´ë‹¤.

</aside>


## **Syntax[#](https://dart.dev/language/extension-types#syntax)** êµ¬ë¬¸

### **Declaration[#](https://dart.dev/language/extension-types#declaration)** ì„ ì–¸

**Define a new extension type with the `extension type` declaration and a name, followed by the _representation type declaration_ in parenthesis:**

í™•ì¥ íƒ€ì… ì„ ì–¸ê³¼ ì´ë¦„ì„ ì •ì˜í•˜ê³ , ê´„í˜¸ ì•ˆì— í‘œí˜„ íƒ€ì… ì„ ì–¸ì„ ì¶”ê°€í•˜ì—¬ ìƒˆë¡œìš´ í™•ì¥ íƒ€ì…ì„ ì •ì˜í•œë‹¤:

```dart
extension type E(int i) {
  // ì—°ì‚° ì§‘í•© ì •ì˜
}

```

**The representation type declaration `(int i)` specifies that the underlying type of extension type `E` is `int`, and that the reference to the _representation object_ is named `i`. The declaration also introduces:**

í‘œí˜„ íƒ€ì… ì„ ì–¸(int i)ì€ í™•ì¥ íƒ€ì… Eì˜ ê¸°ë³¸ íƒ€ì…ì´ intì´ë©°, í‘œí˜„ ê°ì²´ì— ëŒ€í•œ ì°¸ì¡°ê°€ ië¼ëŠ” ì´ë¦„ì„ì„ ì§€ì •í•œë‹¤. ì„ ì–¸ì—ëŠ” ë‹¤ìŒë„ í¬í•¨ëœë‹¤:

-   **An implicit getter for the representation object with the representation type as the return type: `int get i`.**
    
    í‘œí˜„ ê°ì²´ì— ëŒ€í•œ ì•”ì‹œì  getterë¡œ, ë°˜í™˜ íƒ€ì…ì€ í‘œí˜„ íƒ€ì…ì´ë‹¤: int get i.
    
-   **An implicit constructor: `E(int i) : i = i`.**
    
    ì•”ì‹œì  ìƒì„±ì: E(int i) : i = i.
    

**The representation object gives the extension type access to an object at the underlying type. The object is in scope in the extension type body, and you can access it using its name as a getter:**

í‘œí˜„ ê°ì²´ëŠ” í™•ì¥ íƒ€ì…ì´ ê¸°ë³¸ íƒ€ì…ì˜ ê°ì²´ì— ì ‘ê·¼í•  ìˆ˜ ìˆê²Œ í•œë‹¤. ê°ì²´ëŠ” í™•ì¥ íƒ€ì… ë³¸ë¬¸ ë‚´ì—ì„œ ë²”ìœ„ì— ìˆìœ¼ë©°, getterë¡œì„œ ê·¸ ì´ë¦„ì„ ì‚¬ìš©í•˜ì—¬ ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤:

-   **Within the extension type body using `i` (or `this.i` in a constructor).**
    
    í™•ì¥ íƒ€ì… ë³¸ë¬¸ ë‚´ì—ì„œëŠ” i (ë˜ëŠ” ìƒì„±ìì—ì„œ this.i)ë¥¼ ì‚¬ìš©í•˜ì—¬ ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.
    
-   **Outside with a property extraction using `e.i` (where `e` has the extension type as its static type).**
    
    ì™¸ë¶€ì—ì„œëŠ” ì†ì„± ì¶”ì¶œì„ í†µí•´ e.i (ì—¬ê¸°ì„œ eëŠ” í™•ì¥ íƒ€ì…ìœ¼ë¡œ ì •ì  íƒ€ì…ì„ ê°€ì§„ë‹¤)ë¥¼ ì‚¬ìš©í•˜ì—¬ ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.
    

**Extension type declarations can also include [type parameters](https://dart.dev/language/generics) just like classes or extensions:**

í™•ì¥ íƒ€ì… ì„ ì–¸ì€ í´ë˜ìŠ¤ë‚˜ í™•ì¥ì²˜ëŸ¼ íƒ€ì… ë§¤ê°œë³€ìˆ˜ë¥¼ í¬í•¨í•  ìˆ˜ë„ ìˆë‹¤:

```dart
extension type E<T>(List<T> elements) {
  // ...
}

```

### **Constructors[#](https://dart.dev/language/extension-types#constructors)** ìƒì„±ì

**You can optionally declare [constructors](https://dart.dev/language/constructors) in an extension type's body. The representation declaration itself is an implicit constructor, so by default takes the place of an unnamed constructor for the extension type. Any additional non-redirecting generative constructors must initialize the representation object's instance variable using `this.i` in its initializer list or formal parameters.**

í™•ì¥ íƒ€ì…ì˜ ë³¸ë¬¸ì— ìƒì„±ìë¥¼ ì„ íƒì ìœ¼ë¡œ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤. í‘œí˜„ ì„ ì–¸ ìì²´ê°€ ì•”ì‹œì  ìƒì„±ìì´ë¯€ë¡œ, ê¸°ë³¸ì ìœ¼ë¡œ í™•ì¥ íƒ€ì…ì˜ ì´ë¦„ ì—†ëŠ” ìƒì„±ìì˜ ìë¦¬ë¥¼ ëŒ€ì‹ í•œë‹¤. ì¶”ê°€ì ì¸ ë¹„ë¦¬ë””ë ‰íŒ… ìƒì„±ìëŠ” ì´ë‹ˆì…œë¼ì´ì € ëª©ë¡ì´ë‚˜ í˜•ì‹ ë§¤ê°œë³€ìˆ˜ì—ì„œ this.ië¥¼ ì‚¬ìš©í•˜ì—¬ í‘œí˜„ ê°ì²´ì˜ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”í•´ì•¼ í•œë‹¤.

```dart
extension type E(int i) {
  E.n(this.i);
  E.m(int j, String foo) : i = j + foo.length;
}

void main() {
  E(4); // ì•”ì‹œì  ì´ë¦„ ì—†ëŠ” ìƒì„±ì.
  E.n(3); // ì´ë¦„ ìˆëŠ” ìƒì„±ì.
  E.m(5, "Hello!"); // ì¶”ê°€ ë§¤ê°œë³€ìˆ˜ê°€ ìˆëŠ” ì´ë¦„ ìˆëŠ” ìƒì„±ì.
}

```

**Or, you can name the representation declaration constructor, in which case there is room for an unnamed constructor in the body:**

ë˜ëŠ”, í‘œí˜„ ì„ ì–¸ ìƒì„±ìì— ì´ë¦„ì„ ë¶™ì—¬ ë³¸ë¬¸ì— ì´ë¦„ ì—†ëŠ” ìƒì„±ìë¥¼ ë„£ì„ ê³µê°„ì„ ë§Œë“¤ ìˆ˜ ìˆë‹¤:

```dart
extension type const E._(int it) {
  E() : this._(42);
  E.otherName(this.it);
}

void main2() {
  E();
  const E._(2);
  E.otherName(3);
}

```

**You can also completely hide the constructor, instead of just defining a new one, using the same private constructor syntax for classes, `_`. For example, if you only want clients constructing `E` with a `String`, even though the underlying type is `int`:**

ë˜í•œ, í´ë˜ìŠ¤ë¥¼ ìœ„í•´ ì‚¬ìš©í•˜ëŠ” ë™ì¼í•œ ë¹„ê³µê°œ ìƒì„±ì êµ¬ë¬¸ì¸ _ì„ ì‚¬ìš©í•˜ì—¬ ìƒì„±ìë¥¼ ì™„ì „íˆ ìˆ¨ê¸¸ ìˆ˜ë„ ìˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ê¸°ë³¸ íƒ€ì…ì´ intì´ì§€ë§Œ Stringìœ¼ë¡œë§Œ Eë¥¼ ìƒì„±í•˜ë„ë¡ í´ë¼ì´ì–¸íŠ¸ë¥¼ ì œí•œí•˜ë ¤ë©´:

```dart
extension type E._(int i) {
  E.fromString(String foo) : i = int.parse(foo);
}

```

**You can also declare forwarding generative constructors, or [factory constructors](https://dart.dev/language/constructors#factory-constructors) (which can also forward to constructors of sub-extension types).**

ë˜í•œ, í¬ì›Œë”© ìƒì„±ìë‚˜ íŒ©í† ë¦¬ ìƒì„±ìë¥¼ ì„ ì–¸í•  ìˆ˜ë„ ìˆìœ¼ë©°, ì´ëŠ” í•˜ìœ„ í™•ì¥ íƒ€ì…ì˜ ìƒì„±ìë¡œ í¬ì›Œë”©í•  ìˆ˜ë„ ìˆë‹¤.

### **Members[#](https://dart.dev/language/extension-types#members)** ë©¤ë²„

**Declare members in the body of an extension type to define its interface the same way you would for class members. Extension type members can be methods, getters, setters, or operators (non-[`external`](https://dart.dev/language/functions#external) [instance variables](https://dart.dev/language/classes#instance-variables) and [abstract members](https://dart.dev/language/methods#abstract-methods) are not allowed):**

í™•ì¥ íƒ€ì…ì˜ ë³¸ë¬¸ì— ë©¤ë²„ë¥¼ ì„ ì–¸í•˜ì—¬ í´ë˜ìŠ¤ ë©¤ë²„ì™€ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•  ìˆ˜ ìˆë‹¤. í™•ì¥ íƒ€ì… ë©¤ë²„ëŠ” ë©”ì„œë“œ, getter, setter, ì—°ì‚°ìê°€ ë  ìˆ˜ ìˆìœ¼ë©° (ì™¸ë¶€ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ê°€ ì•„ë‹Œ ë©¤ë²„ì™€ ì¶”ìƒ ë©¤ë²„ëŠ” í—ˆìš©ë˜ì§€ ì•ŠëŠ”ë‹¤):

```dart
extension type NumberE(int value) {
  // ì—°ì‚°ì:
  NumberE operator +(NumberE other) => NumberE(value + other.value);
  // Getter:
  NumberE get myNum => this;
  // ë©”ì„œë“œ:
  bool isValid() => !value.isNegative;
}

```

**Interface members of the representation type are not interface members of the extension type [by default](https://dart.dev/language/extension-types#transparency). To make a single member of the representation type available on the extension type, you must write a declaration for it in the extension type definition, like the `operator +` in `NumberE`. You also can define new members unrelated to the representation type, like the `i` getter and `isValid` method.**

ê¸°ë³¸ì ìœ¼ë¡œ í‘œí˜„ íƒ€ì…ì˜ ì¸í„°í˜ì´ìŠ¤ ë©¤ë²„ëŠ” í™•ì¥ íƒ€ì…ì˜ ì¸í„°í˜ì´ìŠ¤ ë©¤ë²„ê°€ ì•„ë‹ˆë‹¤. í‘œí˜„ íƒ€ì…ì˜ ë‹¨ì¼ ë©¤ë²„ë¥¼ í™•ì¥ íƒ€ì…ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•˜ë ¤ë©´, í™•ì¥ íƒ€ì… ì •ì˜ì—ì„œ ì„ ì–¸ì„ ì‘ì„±í•´ì•¼ í•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´, NumberEì˜ + ì—°ì‚°ìì²˜ëŸ¼. ë˜í•œ, i getter ë° isValid ë©”ì„œë“œì™€ ê°™ì´ í‘œí˜„ íƒ€ì…ê³¼ ê´€ë ¨ì´ ì—†ëŠ” ìƒˆë¡œìš´ ë©¤ë²„ë¥¼ ì •ì˜í•  ìˆ˜ë„ ìˆë‹¤.

### **Implements[#](https://dart.dev/language/extension-types#implements)** êµ¬í˜„

**You can optionally use the `implements` clause to:**

implements ì ˆì„ ì‚¬ìš©í•˜ì—¬ ë‹¤ìŒì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤:

-   **Introduce a subtype relationship on an extension type, AND**
    
    í™•ì¥ íƒ€ì…ì— ì„œë¸Œíƒ€ì… ê´€ê³„ë¥¼ ë„ì…í•œë‹¤.
    
-   **Add the members of the representation object to the extension type interface.**
    
    í‘œí˜„ ê°ì²´ì˜ ë©¤ë²„ë¥¼ í™•ì¥ íƒ€ì… ì¸í„°í˜ì´ìŠ¤ì— ì¶”ê°€í•œë‹¤.
    

**The `implements` clause introduces an [applicability](https://github.com/dart-lang/language/blob/main/accepted/2.7/static-extension-methods/feature-specification.md#examples) relationship like the one between an [extension method](https://dart.dev/language/extension-methods) and its `on` type. Members that are applicable to the supertype are applicable to the subtype as well, unless the subtype has a declaration with the same member name.**

implements ì ˆì€ í™•ì¥ ë©”ì„œë“œì™€ ê·¸ on íƒ€ì… ê°„ì˜ ê´€ê³„ì™€ ìœ ì‚¬í•œ ì ìš© ê´€ê³„ë¥¼ ë„ì…í•œë‹¤. ìŠˆí¼íƒ€ì…ì— ì ìš© ê°€ëŠ¥í•œ ë©¤ë²„ëŠ” ì„œë¸Œíƒ€ì…ì—ë„ ì ìš©ë˜ë©°, ì„œë¸Œíƒ€ì…ì— ë™ì¼í•œ ë©¤ë²„ ì´ë¦„ìœ¼ë¡œ ì„ ì–¸ì´ ì—†ëŠ” í•œ ê·¸ë ‡ë‹¤.

**An extension type can only implement:**

í™•ì¥ íƒ€ì…ì€ ë‹¤ìŒë§Œì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤:

-   **Its representation type. This makes all members of the representation type implicitly available to the extension type.**
    
    í‘œí˜„ íƒ€ì…: ì´ëŠ” í‘œí˜„ íƒ€ì…ì˜ ëª¨ë“  ë©¤ë²„ë¥¼ í™•ì¥ íƒ€ì…ì—ì„œ ì•”ì‹œì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•œë‹¤.
    
    ```dart
    extension type NumberI(int i) implements int {
      // 'NumberI'ëŠ” 'int'ì˜ ëª¨ë“  ë©¤ë²„ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆìœ¼ë©°,
      // ì—¬ê¸°ì„œ ì„ ì–¸í•œ ë‹¤ë¥¸ ê²ƒë“¤ë„ í˜¸ì¶œí•  ìˆ˜ ìˆë‹¤.
    }
    
    ```
    
-   **A supertype of its representation type. This makes the members of the supertype available, while not necessarily all the members of representation type.**
    
    í‘œí˜„ íƒ€ì…ì˜ ìŠˆí¼íƒ€ì…: ì´ëŠ” ìŠˆí¼íƒ€ì…ì˜ ë©¤ë²„ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•˜ì§€ë§Œ, ë°˜ë“œì‹œ í‘œí˜„ íƒ€ì…ì˜ ëª¨ë“  ë©¤ë²„ë¥¼ í¬í•¨í•˜ì§€ëŠ” ì•ŠëŠ”ë‹¤.
    
    ```dart
    extension type Sequence<T>(List<T> _) implements Iterable<T> {
      // Listë³´ë‹¤ ë” ë‚˜ì€ ì—°ì‚°ë“¤.
    }
    
    extension type Id(int _id) implements Object {
      // í™•ì¥ íƒ€ì…ì„ ë„ì´ ë  ìˆ˜ ì—†ê²Œ ë§Œë“ ë‹¤.
      static Id? tryParse(String source) => int.tryParse(source) as Id?;
    }
    
    ```
    
-   **Another extension type that is valid on the same representation type. This allows you to reuse operations across multiple extension types (similar to multiple inheritance).**
    
    ë™ì¼í•œ í‘œí˜„ íƒ€ì…ì— ìœ íš¨í•œ ë‹¤ë¥¸ í™•ì¥ íƒ€ì…: ì´ëŠ” ì—¬ëŸ¬ í™•ì¥ íƒ€ì…ì—ì„œ ì—°ì‚°ì„ ì¬ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•œë‹¤ (ë‹¤ì¤‘ ìƒì†ê³¼ ìœ ì‚¬).
    
    ```dart
    extension type const Opt<T>._(({T value})? _) { 
      const factory Opt(T value) = Val<T>;
      const factory Opt.none() = Non<T>;
    }
    extension type const Val<T>._(({T value}) _) implements Opt<T> { 
      const Val(T value) : this._((value: value));
      T get value => _.value;
    }
    extension type const Non<T>._(Null _) implements Opt<Never> {
      const Non() : this._(null);
    }
    
    ```
    

**Read the [Usage](https://dart.dev/language/extension-types#usage) section to learn more about the effect of `implements` in different scenarios.**

ê°ê¸° ë‹¤ë¥¸ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ implementsì˜ íš¨ê³¼ì— ëŒ€í•´ ë” ì•Œì•„ë³´ë ¤ë©´ ì‚¬ìš©ë²• ì„¹ì…˜ì„ ì°¸ì¡°í•˜ë¼.

### **`@redeclare`[#](https://dart.dev/language/extension-types#redeclare)**

**Declaring an extension type member that shares a name with a member of a supertype is _not_ an override relationship like it is between classes, but rather a _redeclaration_. An extension type member declaration _completely replaces_ any supertype member with the same name. It's not possible to provide an alternative implementation for the same function.**

ìŠˆí¼íƒ€ì…ì˜ ë©¤ë²„ì™€ ì´ë¦„ì„ ê³µìœ í•˜ëŠ” í™•ì¥ íƒ€ì… ë©¤ë²„ë¥¼ ì„ ì–¸í•˜ëŠ” ê²ƒì€ í´ë˜ìŠ¤ ê°„ì˜ ì˜¤ë²„ë¼ì´ë“œ ê´€ê³„ê°€ ì•„ë‹ˆë¼ ì¬ì„ ì–¸ ê´€ê³„ì´ë‹¤. í™•ì¥ íƒ€ì… ë©¤ë²„ ì„ ì–¸ì€ ë™ì¼í•œ ì´ë¦„ì„ ê°€ì§„ ìŠˆí¼íƒ€ì… ë©¤ë²„ë¥¼ ì™„ì „íˆ ëŒ€ì²´í•œë‹¤. ë™ì¼í•œ í•¨ìˆ˜ì— ëŒ€í•œ ëŒ€ì²´ êµ¬í˜„ì„ ì œê³µí•  ìˆ˜ ì—†ë‹¤.

**You can use the `@redeclare` annotation to tell the compiler you are _knowingly_ choosing to use the same name as a supertype's member. The analyzer will then warn you if that's not actually true, for example if one of the names are mistyped.**

@redeclare ì• ë„ˆí…Œì´ì…˜ì„ ì‚¬ìš©í•˜ì—¬ ì»´íŒŒì¼ëŸ¬ì—ê²Œ ìŠˆí¼íƒ€ì…ì˜ ë©¤ë²„ì™€ ë™ì¼í•œ ì´ë¦„ì„ ì‚¬ìš©í•˜ê¸°ë¡œ ì˜ë„ì ìœ¼ë¡œ ì„ íƒí–ˆìŒì„ ì•Œë¦´ ìˆ˜ ìˆë‹¤. ê·¸ëŸ¬ë©´ ë¶„ì„ê¸°ëŠ” ì‹¤ì œë¡œ ê·¸ë ‡ì§€ ì•Šì€ ê²½ìš°, ì˜ˆë¥¼ ë“¤ì–´ ì´ë¦„ ì¤‘ í•˜ë‚˜ê°€ ì˜ëª» ì…ë ¥ëœ ê²½ìš° ê²½ê³ ë¥¼ í‘œì‹œí•œë‹¤.

```dart
extension type MyString(String _) implements String {
  // 'String.operator[]'ì„ ëŒ€ì²´
  @redeclare
  int operator [](int index) => codeUnitAt(index);
}

```

**You can also enable the lint [`annotate_redeclares`](https://dart.dev/tools/linter-rules/annotate_redeclares) to get a warning if you declare an extension type method that hides a superinterface member and _isn't_ annotated with `@redeclare`.**

ë˜í•œ, @redeclareë¡œ ì• ë„ˆí…Œì´íŠ¸ë˜ì§€ ì•Šì€ ìŠˆí¼ì¸í„°í˜ì´ìŠ¤ ë©¤ë²„ë¥¼ ìˆ¨ê¸°ëŠ” í™•ì¥ íƒ€ì… ë©”ì„œë“œë¥¼ ì„ ì–¸í•  ê²½ìš° ê²½ê³ ë¥¼ ë°›ê¸° ìœ„í•´ lint annotate_redeclaresë¥¼ í™œì„±í™”í•  ìˆ˜ ìˆë‹¤.


## **Usage[#](https://dart.dev/language/extension-types#usage)** ì‚¬ìš©ë²•

**To use an extension type, create an instance the same as you would with a class: by calling a constructor:**

í™•ì¥ íƒ€ì…ì„ ì‚¬ìš©í•˜ë ¤ë©´, í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•  ë•Œì™€ ë§ˆì°¬ê°€ì§€ë¡œ ìƒì„±ìë¥¼ í˜¸ì¶œí•˜ì—¬ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•œë‹¤:

```dart
extension type NumberE(int value) {
  NumberE operator +(NumberE other) =>
      NumberE(value + other.value);

  NumberE get next => NumberE(value + 1);
  bool isValid() => !value.isNegative;
}

void testE() { 
  var num = NumberE(1);
}

```

**Then, you can invoke members on the object as you would with a class object.**

ê·¸ëŸ° ë‹¤ìŒ í´ë˜ìŠ¤ ê°ì²´ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ê°ì²´ì˜ ë©¤ë²„ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆë‹¤.

**There are two equally valid, but substantially different core use cases for extension types:**

í™•ì¥ íƒ€ì…ì˜ ë‘ ê°€ì§€ ì£¼ìš” ì‚¬ìš© ì‚¬ë¡€ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤:

1.  **Providing an _extended_ interface to an existing type.**
    
    ê¸°ì¡´ íƒ€ì…ì— í™•ì¥ëœ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•˜ê¸°.
    
2.  **Providing a _different_ interface to an existing type.**
    
    ê¸°ì¡´ íƒ€ì…ì— ë‹¤ë¥¸ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•˜ê¸°.
    

<aside> â„¹ï¸ **Note**

**In any case, the representation type of an extension type is never its subtype, so a representation type can't be used interchangeably where the extension type is needed.**

ì–´ë–¤ ê²½ìš°ë“ , í™•ì¥ íƒ€ì…ì˜ í‘œí˜„ íƒ€ì…ì€ ì ˆëŒ€ë¡œ ê·¸ ì„œë¸Œíƒ€ì…ì´ ì•„ë‹ˆë¯€ë¡œ, í™•ì¥ íƒ€ì…ì´ í•„ìš”í•œ ê³³ì—ì„œ í‘œí˜„ íƒ€ì…ì„ êµì²´í•˜ì—¬ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.

</aside>

### **1. Provide an _extended_ interface to an existing type[#](https://dart.dev/language/extension-types#1-provide-an-extended-interface-to-an-existing-type)**

1.  ê¸°ì¡´ íƒ€ì…ì— í™•ì¥ëœ ì¸í„°í˜ì´ìŠ¤ ì œê³µ

**When an extension type [implements](https://dart.dev/language/extension-types#implements) its representation type, you can consider it "transparent", because it allows the extension type to "see" the underlying type.**

í™•ì¥ íƒ€ì…ì´ ê·¸ í‘œí˜„ íƒ€ì…ì„ êµ¬í˜„í•  ë•Œ, ì´ë¥¼ â€œíˆ¬ëª…â€í•˜ë‹¤ê³  ê°„ì£¼í•  ìˆ˜ ìˆë‹¤. ì´ëŠ” í™•ì¥ íƒ€ì…ì´ ê¸°ë³¸ íƒ€ì…ì„ â€œë³¼ ìˆ˜ ìˆê²Œâ€ í•˜ê¸° ë•Œë¬¸ì´ë‹¤.

**A transparent extension type can invoke all members of the representation type (that aren't [redeclared](https://dart.dev/language/extension-types#redeclare)), plus any auxillary members it defines. This creates a new, _extended_ interface for an existing type. The new interface is available to expressions whose static type is the extension type.**

íˆ¬ëª… í™•ì¥ íƒ€ì…ì€ í‘œí˜„ íƒ€ì…ì˜ ëª¨ë“  ë©¤ë²„(ì¬ì„ ì–¸ë˜ì§€ ì•Šì€ ë©¤ë²„)ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆìœ¼ë©°, ê·¸ ì™¸ì— ì •ì˜ëœ ë³´ì¡° ë©¤ë²„ë“¤ë„ í˜¸ì¶œí•  ìˆ˜ ìˆë‹¤. ì´ëŠ” ê¸°ì¡´ íƒ€ì…ì— ëŒ€í•œ ìƒˆë¡œìš´ í™•ì¥ëœ ì¸í„°í˜ì´ìŠ¤ë¥¼ ìƒì„±í•œë‹¤. ìƒˆë¡œìš´ ì¸í„°í˜ì´ìŠ¤ëŠ” í™•ì¥ íƒ€ì…ì˜ ì •ì  íƒ€ì…ì„ ê°€ì§„ í‘œí˜„ì‹ì— ëŒ€í•´ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

**This means you _can_ invoke members of the representation type (unlike a [non-transparent](https://dart.dev/language/extension-types#2-provide-a-different-interface-to-an-existing-type) extension type), like so:**

ì´ëŠ” ë‹¤ìŒê³¼ ê°™ì´ í‘œí˜„ íƒ€ì…ì˜ ë©¤ë²„ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆìŒì„ ì˜ë¯¸í•œë‹¤(ë¹„íˆ¬ëª… í™•ì¥ íƒ€ì…ê³¼ ë‹¬ë¦¬):

```dart
extension type NumberT(int value) implements int {
  // 'int'ì˜ ë©¤ë²„ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì„ ì–¸í•˜ì§€ ì•ŠëŠ”ë‹¤.
  NumberT get i => this;
}

void main() {
  // ëª¨ë‘ OK: íˆ¬ëª…ì„± ë•ë¶„ì— í™•ì¥ íƒ€ì…ì—ì„œ `int` ë©¤ë²„ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆë‹¤:
  var v1 = NumberT(1); // v1 íƒ€ì…: NumberT
  int v2 = NumberT(2); // v2 íƒ€ì…: int
  var v3 = v1.i - v1;  // v3 íƒ€ì…: int
  var v4 = v2 + v1; // v4 íƒ€ì…: int
  var v5 = 2 + v1; // v5 íƒ€ì…: int
  // ì˜¤ë¥˜: í‘œí˜„ íƒ€ì…ì—ì„œëŠ” í™•ì¥ íƒ€ì…ì˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.
  v2.i;
}

```

**You can also have a "mostly-transparent" extension type that adds new members and adapts others by redeclaring a given member name from the supertype. This would allow you to use stricter types on some parameters of a method, or different default values, for example.**

â€œëŒ€ë¶€ë¶„ íˆ¬ëª…í•œâ€ í™•ì¥ íƒ€ì…ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆë¡œìš´ ë©¤ë²„ë¥¼ ì¶”ê°€í•˜ê³ , ìŠˆí¼íƒ€ì…ì˜ ì£¼ì–´ì§„ ë©¤ë²„ ì´ë¦„ì„ ì¬ì„ ì–¸í•˜ì—¬ ë‹¤ë¥¸ ë©¤ë²„ë¥¼ ì ì‘ì‹œí‚¬ ìˆ˜ë„ ìˆë‹¤. ì´ëŠ” ì˜ˆë¥¼ ë“¤ì–´ ë©”ì„œë“œì˜ ì¼ë¶€ ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•´ ë” ì—„ê²©í•œ íƒ€ì…ì„ ì‚¬ìš©í•˜ê±°ë‚˜, ë‹¤ë¥¸ ê¸°ë³¸ê°’ì„ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•œë‹¤.

**Another mostly-transparent extension type approach is to implement a type that is a supertype of the representation type. For example, if the representation type is private but its supertype defines the part of the interface that matters for clients.**

ë˜ ë‹¤ë¥¸ â€œëŒ€ë¶€ë¶„ íˆ¬ëª…í•œâ€ í™•ì¥ íƒ€ì… ì ‘ê·¼ë²•ì€ í‘œí˜„ íƒ€ì…ì˜ ìŠˆí¼íƒ€ì…ì„ êµ¬í˜„í•˜ëŠ” ê²ƒì´ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í‘œí˜„ íƒ€ì…ì´ ë¹„ê³µê°œì´ì§€ë§Œ ìŠˆí¼íƒ€ì…ì´ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì¤‘ìš”í•œ ì¸í„°í˜ì´ìŠ¤ì˜ ì¼ë¶€ë¥¼ ì •ì˜í•˜ëŠ” ê²½ìš°ì´ë‹¤.

### **2. Provide a _different_ interface to an existing type[#](https://dart.dev/language/extension-types#2-provide-a-different-interface-to-an-existing-type)**

1.  ê¸°ì¡´ íƒ€ì…ì— ë‹¤ë¥¸ ì¸í„°í˜ì´ìŠ¤ ì œê³µ

**An extension type that is not [transparent](https://dart.dev/language/extension-types#transparency) (that does not [`implement`](https://dart.dev/language/extension-types#implements) its representation type) is statically treated as a completely new type, distinct from its representation type. You can't assign it to its representation type, and it doesn't expose its representation type's members.**

íˆ¬ëª…í•˜ì§€ ì•Šì€ í™•ì¥ íƒ€ì…(í‘œí˜„ íƒ€ì…ì„ êµ¬í˜„í•˜ì§€ ì•ŠëŠ”)ì€ ì •ì ìœ¼ë¡œ ì™„ì „íˆ ìƒˆë¡œìš´ íƒ€ì…ìœ¼ë¡œ ì·¨ê¸‰ë˜ë©°, í‘œí˜„ íƒ€ì…ê³¼ëŠ” êµ¬ë³„ëœë‹¤. ì´ë¥¼ í‘œí˜„ íƒ€ì…ì— í• ë‹¹í•  ìˆ˜ ì—†ìœ¼ë©°, í‘œí˜„ íƒ€ì…ì˜ ë©¤ë²„ë¥¼ ë…¸ì¶œí•˜ì§€ ì•ŠëŠ”ë‹¤.

**For example, take the `NumberE` extension type we declared under [Usage](https://dart.dev/language/extension-types#usage):**

ì˜ˆë¥¼ ë“¤ì–´, Usageì—ì„œ ì„ ì–¸í•œ NumberE í™•ì¥ íƒ€ì…ì„ ê³ ë ¤í•´ë³´ì:

```dart
void testE() { 
  var num1 = NumberE(1);
  int num2 = NumberE(2); // ì˜¤ë¥˜: 'NumberE'ë¥¼ 'int'ì— í• ë‹¹í•  ìˆ˜ ì—†ìŒ.
  
  num1.isValid(); // OK: í™•ì¥ ë©¤ë²„ í˜¸ì¶œ.
  num1.isNegative(); // ì˜¤ë¥˜: 'NumberE'ëŠ” 'int' ë©¤ë²„ 'isNegative'ë¥¼ ì •ì˜í•˜ì§€ ì•ŠìŒ.
  
  var sum1 = num1 + num1; // OK: 'NumberE'ëŠ” '+'ë¥¼ ì •ì˜í•¨.
  var diff1 = num1 - num1; // ì˜¤ë¥˜: 'NumberE'ëŠ” 'int' ë©¤ë²„ '-'ë¥¼ ì •ì˜í•˜ì§€ ì•ŠìŒ.
  var diff2 = num1.value - 2; // OK: ì°¸ì¡°ë¥¼ í†µí•´ í‘œí˜„ ê°ì²´ì— ì ‘ê·¼í•  ìˆ˜ ìˆìŒ.
  var sum2 = num1 + 2; // ì˜¤ë¥˜: 'int'ë¥¼ ë§¤ê°œë³€ìˆ˜ íƒ€ì… 'NumberE'ì— í• ë‹¹í•  ìˆ˜ ì—†ìŒ.
  
  List<NumberE> numbers = [
    NumberE(1), 
    num1.next, // OK: 'next' getterëŠ” 'NumberE' íƒ€ì…ì„ ë°˜í™˜í•¨.
    1, // ì˜¤ë¥˜: 'int' ìš”ì†Œë¥¼ ë¦¬ìŠ¤íŠ¸ íƒ€ì… 'NumberE'ì— í• ë‹¹í•  ìˆ˜ ì—†ìŒ.
  ];
}

```

**You can use an extension type this way to _replace_ the interface of an existing type. This allows you to model an interface that is makes sense for the constraints of your new type (like the `IdNumber` example in the introduction), while also benefitting from the performance and convenience of a simple pre-defined type, like `int`.**

í™•ì¥ íƒ€ì…ì„ ì´ë ‡ê²Œ ì‚¬ìš©í•˜ì—¬ ê¸°ì¡´ íƒ€ì…ì˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ ëŒ€ì²´í•  ìˆ˜ ìˆë‹¤. ì´ëŠ” ìƒˆë¡œìš´ íƒ€ì…ì˜ ì œì•½ì— ë§ëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ ëª¨ë¸ë§í•  ìˆ˜ ìˆê²Œ í•˜ë©°(intì™€ ê°™ì€ ê°„ë‹¨í•œ ë¯¸ë¦¬ ì •ì˜ëœ íƒ€ì…ì˜ ì„±ëŠ¥ê³¼ í¸ë¦¬í•¨ì„ ëˆ„ë¦¬ë©´ì„œ), ìƒˆë¡œìš´ íƒ€ì…ì˜ ì œì•½ì— ë§ëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ ëª¨ë¸ë§í•  ìˆ˜ ìˆê²Œ í•œë‹¤(IdNumber ì˜ˆì‹œì²˜ëŸ¼).

**This use case is as close as you can get to the complete encapsulation of a wrapper class (but is realistically only a [_somewhat_ protected](https://dart.dev/language/extension-types#type-considerations) abstraction).**

ì´ ì‚¬ìš© ì‚¬ë¡€ëŠ” ë˜í¼ í´ë˜ìŠ¤ì˜ ì™„ì „í•œ ìº¡ìŠí™”ì— ê°€ì¥ ê·¼ì ‘í•œ ë°©ë²•ì´ì§€ë§Œ, í˜„ì‹¤ì ìœ¼ë¡œëŠ” ë‹¤ì†Œ ë³´í˜¸ëœ ì¶”ìƒí™”ì¼ ë¿ì´ë‹¤.


## **Type considerations[#](https://dart.dev/language/extension-types#type-considerations)** íƒ€ì… ê³ ë ¤ì‚¬í•­

**Extension types are a compile-time wrapping construct. At run time, there is absolutely no trace of the extension type. Any type query or similar run-time operations work on the representation type.**

í™•ì¥ íƒ€ì…ì€ ì»´íŒŒì¼ íƒ€ì„ ë˜í•‘ êµ¬ì„± ìš”ì†Œì´ë‹¤. ëŸ°íƒ€ì„ì—ëŠ” í™•ì¥ íƒ€ì…ì˜ í”ì ì´ ì „í˜€ ì—†ë‹¤. ëª¨ë“  íƒ€ì… ì¿¼ë¦¬ë‚˜ ìœ ì‚¬í•œ ëŸ°íƒ€ì„ ì—°ì‚°ì€ í‘œí˜„ íƒ€ì…ì—ì„œ ì‘ë™í•œë‹¤.

**This makes extension types an _unsafe_ abstraction, because you can always find out the representation type at run time and access the underlying object.**

ì´ë¡œ ì¸í•´ í™•ì¥ íƒ€ì…ì€ ì•ˆì „í•˜ì§€ ì•Šì€ ì¶”ìƒí™”ê°€ ëœë‹¤. ëŸ°íƒ€ì„ì— í•­ìƒ í‘œí˜„ íƒ€ì…ì„ ì°¾ì•„ë‚´ê³  ê¸°ë³¸ ê°ì²´ì— ì ‘ê·¼í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.

**Dynamic type tests (`e is T`), casts (`e as T`), and other run-time type queries (like `switch (e) ...` or `if (e case ...)`) all evaluate to the underlying representation object, and type check against that object's runtime type. That's true when the static type of `e` is an extension type, and when testing against an extension type (`case MyExtensionType(): ...`).**

ë™ì  íƒ€ì… í…ŒìŠ¤íŠ¸ (e is T), ìºìŠ¤íŠ¸ (e as T), ê¸°íƒ€ ëŸ°íƒ€ì„ íƒ€ì… ì¿¼ë¦¬ (switch (e) ... ë˜ëŠ” if (e case ...) ë“±)ëŠ” ëª¨ë‘ ê¸°ë³¸ í‘œí˜„ ê°ì²´ë¥¼ í‰ê°€í•˜ê³ , ê·¸ ê°ì²´ì˜ ëŸ°íƒ€ì„ íƒ€ì…ì— ëŒ€í•´ íƒ€ì…ì„ ê²€ì‚¬í•œë‹¤. ì´ëŠ” eì˜ ì •ì  íƒ€ì…ì´ í™•ì¥ íƒ€ì…ì¸ ê²½ìš°ì™€ í™•ì¥ íƒ€ì…ì— ëŒ€í•´ í…ŒìŠ¤íŠ¸í•˜ëŠ” ê²½ìš° (case MyExtensionType(): ...) ëª¨ë‘ ì‚¬ì‹¤ì´ë‹¤.

```dart
void main() {
  var n = NumberE(1);

  // 'n'ì˜ ëŸ°íƒ€ì„ íƒ€ì…ì€ í‘œí˜„ íƒ€ì… 'int'ì´ë‹¤.
  if (n is int) print(n.value); // 1ì„ ì¶œë ¥.

  // ëŸ°íƒ€ì„ì— 'n'ì—ì„œ 'int' ë©”ì„œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
  if (n case int x) print(x.toRadixString(10)); // 1ì„ ì¶œë ¥.
  switch (n) {
    case int(:var isEven): print("$n (${isEven ? "even" : "odd"})"); // 1 (odd)ë¥¼ ì¶œë ¥.
  }
}

```

**Similarly, the static type of the matched value is that of the extension type in this example:**

ë§ˆì°¬ê°€ì§€ë¡œ, ë§¤ì¹˜ëœ ê°’ì˜ ì •ì  íƒ€ì…ì€ ì´ ì˜ˆì‹œì—ì„œ í™•ì¥ íƒ€ì…ì˜ íƒ€ì…ì´ë‹¤:

```dart
void main() {
  int i = 2;
  if (i is NumberE) print("It is"); // 'It is'ë¥¼ ì¶œë ¥.
  if (i case NumberE v) print("value: ${v.value}"); // 'value: 2'ë¥¼ ì¶œë ¥.
  switch (i) {
    case NumberE(:var value): print("value: $value"); // 'value: 2'ë¥¼ ì¶œë ¥.
  }
}

```

**It's important to be aware of this quality when using extension types. Always keep in mind that an extension type exists and matters at compile time, but gets erased _during_ compilation.**

í™•ì¥ íƒ€ì…ì„ ì‚¬ìš©í•  ë•Œ ì´ëŸ¬í•œ íŠ¹ì„±ì„ ì¸ì‹í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤. í™•ì¥ íƒ€ì…ì€ ì»´íŒŒì¼ íƒ€ì„ì— ì¡´ì¬í•˜ê³  ì¤‘ìš”í•˜ì§€ë§Œ, ì»´íŒŒì¼ ì¤‘ì— ì‚¬ë¼ì§„ë‹¤ëŠ” ì ì„ í•­ìƒ ì—¼ë‘ì— ë‘ì–´ì•¼ í•œë‹¤.

**For example, consider an expression `e` whose static type is the extension type `E`, and the representation type of `E` is `R`. Then, the run-time type of the value of `e` is a subtype of `R`. Even the type itself is erased; `List<E>` is exactly the same thing as `List<R>` at run time.**

ì˜ˆë¥¼ ë“¤ì–´, ì •ì  íƒ€ì…ì´ í™•ì¥ íƒ€ì… Eì¸ í‘œí˜„ì‹ eë¥¼ ê³ ë ¤í•´ë³´ì. Eì˜ í‘œí˜„ íƒ€ì…ì´ Rì´ë¼ë©´, eì˜ ê°’ì˜ ëŸ°íƒ€ì„ íƒ€ì…ì€ Rì˜ ì„œë¸Œíƒ€ì…ì´ë‹¤. íƒ€ì… ìì²´ê°€ ì‚­ì œë˜ê¸° ë•Œë¬¸ì—, List<E>ëŠ” ëŸ°íƒ€ì„ì— List<R>ì™€ ì •í™•íˆ ë™ì¼í•œ ê²ƒì´ë‹¤.

**In other words, a real wrapper class can encapsulate a wrapped object, whereas an extension type is just a compile-time view on the wrapped object. While a real wrapper is safer, the trade-off is extension types give you the option to avoid wrapper objects, which can greatly improve performance in some scenarios.**

ë‹¤ì‹œ ë§í•´, ì‹¤ì œ ë˜í¼ í´ë˜ìŠ¤ëŠ” ê°ì‹¸ì§„ ê°ì²´ë¥¼ ìº¡ìŠí™”í•  ìˆ˜ ìˆëŠ” ë°˜ë©´, í™•ì¥ íƒ€ì…ì€ ê°ì‹¸ì§„ ê°ì²´ì— ëŒ€í•œ ì»´íŒŒì¼ íƒ€ì„ ë·°ì¼ ë¿ì´ë‹¤. ì‹¤ì œ ë˜í¼ëŠ” ë” ì•ˆì „í•˜ì§€ë§Œ, í™•ì¥ íƒ€ì…ì€ ë˜í¼ ê°ì²´ë¥¼ í”¼í•  ìˆ˜ ìˆëŠ” ì˜µì…˜ì„ ì œê³µí•˜ì—¬ ì¼ë¶€ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ ì„±ëŠ¥ì„ í¬ê²Œ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆë‹¤.

---

ğŸ”— [[í˜ì´ì§€ ë§í¬]](https://dart.dev/language/callable-objects)

# **Callable objects** í˜¸ì¶œ ê°€ëŠ¥í•œ ê°ì²´

**To allow an instance of your Dart class to be called like a function, implement the `call()` method.**

Dart í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ í•¨ìˆ˜ì²˜ëŸ¼ í˜¸ì¶œí•  ìˆ˜ ìˆê²Œ í•˜ë ¤ë©´, call() ë©”ì„œë“œë¥¼ êµ¬í˜„í•œë‹¤.

**The `call()` method allows an instance of any class that defines it to emulate a function. This method supports the same functionality as normal [functions](https://dart.dev/language/functions) such as parameters and return types.**

call() ë©”ì„œë“œëŠ” ì´ë¥¼ ì •ì˜í•œ í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ í•¨ìˆ˜ì²˜ëŸ¼ ë™ì‘í•  ìˆ˜ ìˆê²Œ í•œë‹¤. ì´ ë©”ì„œë“œëŠ” ë§¤ê°œë³€ìˆ˜ì™€ ë°˜í™˜ íƒ€ì… ê°™ì€ ì¼ë°˜ í•¨ìˆ˜ì˜ ê¸°ëŠ¥ì„ ì§€ì›í•œë‹¤.

**In the following example, the `WannabeFunction` class defines a `call()` function that takes three strings and concatenates them, separating each with a space, and appending an exclamation. Click Run to execute the code.**

ë‹¤ìŒ ì˜ˆì œì—ì„œ WannabeFunction í´ë˜ìŠ¤ëŠ” ì„¸ ê°œì˜ ë¬¸ìì—´ì„ ë°›ì•„ì„œ ê° ë¬¸ìì—´ì„ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•˜ê³ , ëŠë‚Œí‘œë¥¼ ì¶”ê°€í•˜ì—¬ ì—°ê²°í•˜ëŠ” call() í•¨ìˆ˜ë¥¼ ì •ì˜í•œë‹¤. ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë ¤ë©´ â€˜Runâ€™ì„ í´ë¦­í•œë‹¤.

```dart
class WannabeFunction {
  String call(String a, String b, String c) => '$a $b $c!';
}

var wf = WannabeFunction();
var out = wf('Hi', 'there,', 'gang');

void main() => print(out);

```

```dart
// ì¶œë ¥ ê²°ê³¼
Hi there, gang!

```
