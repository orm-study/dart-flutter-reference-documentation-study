# The Dart type system íƒ€ì… ì‹œìŠ¤í…œ

ğŸ”— [í˜ì´ì§€ ë§í¬]

**The Dart language is type safe: it uses a combination of static type checking and [runtime checks](https://dart.dev/language/type-system#runtime-checks) to ensure that a variable's value always matches the variable's static type, sometimes referred to as sound typing. Although _types_ are mandatory, type _annotations_ are optional because of [type inference](https://dart.dev/language/type-system#type-inference).**

Dart ì–¸ì–´ëŠ” íƒ€ì… ì•ˆì „(type safe)í•œë‹¤. ì´ëŠ” ì •ì  íƒ€ì…(static type) ê²€ì‚¬ì™€ ëŸ°íƒ€ì„(runtime) ê²€ì‚¬ë¥¼ ì¡°í•©í•˜ì—¬ ë³€ìˆ˜ì˜ ê°’ì´ í•­ìƒ ë³€ìˆ˜ì˜ ì •ì  íƒ€ì…ê³¼ ì¼ì¹˜í•˜ë„ë¡ ë³´ì¥í•œë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•˜ë©°, ì´ëŠ” ì¢…ì¢… â€™íƒ€ì…ì˜ ì¼ê´€ì„±(sound typing)â€™ì´ë¼ê³ ë„ ë§í•œë‹¤. íƒ€ì…ì€ í•„ìˆ˜ì ì´ì§€ë§Œ, íƒ€ì… ì¶”ë¡ (type inference) ë•ë¶„ì— íƒ€ì… ì–´ë…¸í…Œì´ì…˜ì€ ì„ íƒ ì‚¬í•­ì´ë‹¤.

-   **[Q] íƒ€ì…ì˜ ì¼ê´€ì„±(sound typing) ?**
    
    ----------
    
    íƒ€ì…ì˜ ì¼ê´€ì„±(sound typing)ì€ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì˜ íƒ€ì… ì‹œìŠ¤í…œì´ íƒ€ì… ì˜¤ë¥˜ë¥¼ ë°©ì§€í•˜ê³  í”„ë¡œê·¸ë¨ì´ ì˜¬ë°”ë¥´ê²Œ ì‹¤í–‰ë˜ë„ë¡ ë³´ì¥í•˜ëŠ” íŠ¹ì„±ì´ë‹¤. ì´ëŠ” íƒ€ì… ì‹œìŠ¤í…œì´ ì •ì  íƒ€ì…(ì»´íŒŒì¼ íƒ€ì„ì— ê²°ì •ëœ íƒ€ì…)ê³¼ ëŸ°íƒ€ì„ì— ì‚¬ìš©ë˜ëŠ” ì‹¤ì œ ê°’ì˜ íƒ€ì…ì´ í•­ìƒ ì¼ì¹˜í•˜ë„ë¡ ê°•ì œí•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. ì˜¤ë¥˜ë¥¼ ë°©ì§€í•˜ê³  ì½”ë“œì˜ ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì„ í–¥ìƒì‹œí‚¤ëŠ” ë° ì¤‘ìš”í•œ ì—­í• ì„ í•œë‹¤.
    
    **ì£¼ìš” ê°œë…**
    
    -   **íƒ€ì… ì•ˆì „ì„±**
        
        íƒ€ì… ì•ˆì „ì„±ì€ íƒ€ì… ë¶ˆì¼ì¹˜ë¡œ ì¸í•´ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì˜¤ë¥˜ë¥¼ ë°©ì§€í•œë‹¤. íƒ€ì… ì•ˆì „í•œ ì–¸ì–´ì—ì„œëŠ” ë³€ìˆ˜ì— í• ë‹¹ëœ ê°’ì˜ íƒ€ì…ì´ ë³€ìˆ˜ì˜ ì„ ì–¸ëœ íƒ€ì…ê³¼ ì¼ì¹˜í•´ì•¼ í•œë‹¤.
        
    -   **ì •ì  íƒ€ì… ê²€ì‚¬**
        
        ì»´íŒŒì¼ íƒ€ì„ì— íƒ€ì… ì˜¤ë¥˜ë¥¼ ë°œê²¬í•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ë¬¸ìì—´ì„ ì •ìˆ˜ ë³€ìˆ˜ì— í• ë‹¹í•˜ë ¤ê³  í•˜ë©´ ì»´íŒŒì¼ íƒ€ì„ì— ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.
        
    -   **ëŸ°íƒ€ì„ íƒ€ì… ê²€ì‚¬**
        
        ëŸ°íƒ€ì„ì— íƒ€ì…ì´ ì˜¬ë°”ë¥´ê²Œ ì‚¬ìš©ë˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ê°ì²´ë¥¼ íŠ¹ì • íƒ€ì…ìœ¼ë¡œ ìºìŠ¤íŒ…í•  ë•Œ ì‹¤ì œë¡œ í•´ë‹¹ íƒ€ì…ì¸ì§€ í™•ì¸í•œë‹¤.
        
    
    ```dart
    void main() {
      // ì»´íŒŒì¼ íƒ€ì„ì— ì˜¤ë¥˜ë¥¼ ë°œê²¬
      int number = 42;
      // number = "hello"; // A value of type 'String' can't be assigned to a variable of type 'int'.
    
      // ëŸ°íƒ€ì„ì— ìºìŠ¤íŒ… ì˜¤ë¥˜ë¥¼ ë°©ì§€
      dynamic value = "hello";
      try {
        int number = value as int;
      } catch (e) {
        print('ìºìŠ¤íŒ… ì˜¤ë¥˜: $e');
      }
    }
    
    ```
    
    ```dart
    // ì¶œë ¥ ê²°ê³¼
    ìºìŠ¤íŒ… ì˜¤ë¥˜: type 'String' is not a subtype of type 'int' in type cast
    
    ```
    
    
-   **[Q] íƒ€ì… ì–´ë…¸í…Œì´ì…˜(type annotations) ?**
    

    
    íƒ€ì… ì–´ë…¸í…Œì´ì…˜(type annotations)ì€ **ë³€ìˆ˜, í•¨ìˆ˜, ë§¤ê°œë³€ìˆ˜ ë“±ì— ëª…ì‹œì ìœ¼ë¡œ íƒ€ì…ì„ ì§€ì •í•˜ëŠ” ê²ƒ**ì„ ì˜ë¯¸í•œë‹¤. Dartì—ì„œëŠ” íƒ€ì… ì¶”ë¡ ì´ ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì— íƒ€ì… ì–´ë…¸í…Œì´ì…˜ì€ ì„ íƒ ì‚¬í•­ì´ì§€ë§Œ, ëª…ì‹œì ìœ¼ë¡œ íƒ€ì…ì„ ì§€ì •í•˜ë©´ ì½”ë“œì˜ ê°€ë…ì„±ê³¼ ì•ˆì •ì„±ì„ ë†’ì¼ ìˆ˜ ìˆë‹¤.
    
    **ì¥ì **
    
    -   **ê°€ë…ì„± í–¥ìƒ**: ì½”ë“œì˜ íƒ€ì… ì •ë³´ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ë‚˜íƒ€ë‚´ì–´, ì½”ë“œ ì½ê¸°ê°€ ë” ì‰½ë‹¤.
    -   **íƒ€ì… ì•ˆì „ì„±**: íƒ€ì… ì–´ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ë©´ íƒ€ì… ë¶ˆì¼ì¹˜ ì˜¤ë¥˜ë¥¼ ì»´íŒŒì¼ íƒ€ì„ì— ë°œê²¬í•  ìˆ˜ ìˆì–´, ëŸ°íƒ€ì„ ì˜¤ë¥˜ë¥¼ ì¤„ì¼ ìˆ˜ ìˆë‹¤.
    -   **ì½”ë“œ ì™„ì„± ì§€ì›**: IDEì—ì„œ íƒ€ì… ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì½”ë“œ ì™„ì„±ì„ ì œê³µí•˜ì—¬, ë” ë¹ ë¥´ê³  ì •í™•í•˜ê²Œ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.
    
    ----------
    

**One benefit of static type checking is the ability to find bugs at compile time using Dart's [static analyzer.](https://dart.dev/tools/analysis)**

ì •ì  íƒ€ì… ê²€ì‚¬ì˜ í•œ ê°€ì§€ ì´ì ì€ Dartì˜ ì •ì  ë¶„ì„ê¸°ë¥¼ ì‚¬ìš©í•˜ì—¬ ì»´íŒŒì¼ ì‹œê°„ì— ë²„ê·¸ë¥¼ ì°¾ì„ ìˆ˜ ìˆë‹¤ëŠ” ì ì´ë‹¤.

**You can fix most static analysis errors by adding type annotations to generic classes. The most common generic classes are the collection types `List<T>` and `Map<K,V>`.**

ëŒ€ë¶€ë¶„ì˜ ì •ì  ë¶„ì„ ì˜¤ë¥˜ëŠ” ì œë„¤ë¦­ í´ë˜ìŠ¤ì— íƒ€ì… ì–´ë…¸í…Œì´ì…˜ì„ ì¶”ê°€í•˜ì—¬ ìˆ˜ì •í•  ìˆ˜ ìˆë‹¤. ê°€ì¥ ì¼ë°˜ì ì¸ ì œë„¤ë¦­ í´ë˜ìŠ¤ëŠ” List<T>ì™€ Map<K,V>ì™€ ê°™ì€ ì»¬ë ‰ì…˜ íƒ€ì…ì´ë‹¤.

**For example, in the following code the `printInts()` function prints an integer list, and `main()` creates a list and passes it to `printInts()`.**

ì˜ˆë¥¼ ë“¤ì–´, ë‹¤ìŒ ì½”ë“œì—ì„œ printInts() í•¨ìˆ˜ëŠ” ì •ìˆ˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¶œë ¥í•˜ë©°, main() í•¨ìˆ˜ëŠ” ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•˜ì—¬ printInts() í•¨ìˆ˜ì— ì „ë‹¬í•œë‹¤.

```dart
//âœ— static analysis: failure

void printInts(List<int> a) => print(a);

void main() {
  final list = [];
  list.add(1);
  list.add('2');
  printInts(list);
}

```

```dart
// ì¶œë ¥ ê²°ê³¼
// List<dynamic> íƒ€ì…ì„ List<int> íƒ€ì…ì˜ ë§¤ê°œë³€ìˆ˜ì— í• ë‹¹í•  ìˆ˜ ì—†ìŒ
Error: The argument type 'List<dynamic>' can't be assigned to the parameter type 'List<int>'.

```

**The preceding code results in a type error on `list` (highlighted above) at the call of `printInts(list)`:**

ìœ„ì˜ ì½”ë“œëŠ” printInts(list) í˜¸ì¶œ ì‹œ listì—ì„œ íƒ€ì… ì˜¤ë¥˜ë¥¼ ë°œìƒí‚¨ë‹¤.

**The error highlights an unsound implicit cast from `List<dynamic>` to `List<int>`. The `list` variable has static type `List<dynamic>`. This is because the initializing declaration `var list = []` doesn't provide the analyzer with enough information for it to infer a type argument more specific than `dynamic`. The `printInts()` function expects a parameter of type `List<int>`, causing a mismatch of types.**

ì˜¤ë¥˜ëŠ” List<dynamic>ì—ì„œ List<int>ë¡œì˜ ë¶ˆì•ˆì „í•œ ì•”ì‹œì  ìºìŠ¤íŠ¸ë¥¼ ê°•ì¡°í•œë‹¤. list ë³€ìˆ˜ì˜ ì •ì  íƒ€ì…ì€ List<dynamic>ì…ë‹ˆë‹¤. ì´ëŠ” ì´ˆê¸° ì„ ì–¸ var list = []ê°€ ë¶„ì„ê¸°ì—ê²Œ dynamicë³´ë‹¤ êµ¬ì²´ì ì¸ íƒ€ì… ì¸ìˆ˜ë¥¼ ì¶”ë¡ í•  ìˆ˜ ìˆëŠ” ì¶©ë¶„í•œ ì •ë³´ë¥¼ ì œê³µí•˜ì§€ ì•Šê¸° ë•Œë¬¸ì´ë‹¤. printInts() í•¨ìˆ˜ëŠ” List<int> íƒ€ì…ì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ê¸°ëŒ€í•˜ë¯€ë¡œ íƒ€ì… ë¶ˆì¼ì¹˜ê°€ ë°œìƒí•œë‹¤.

**When adding a type annotation (`<int>`) on creation of the list (highlighted below) the analyzer complains that a string argument can't be assigned to an `int` parameter. Removing the quotes in `list.add('2')` results in code that passes static analysis and runs with no errors or warnings.**

ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•  ë•Œ íƒ€ì… ì–´ë…¸í…Œì´ì…˜(<int>)ì„ ì¶”ê°€í•˜ë©´, ë¶„ì„ê¸°ëŠ” ë¬¸ìì—´ ì¸ìˆ˜ë¥¼ int ë§¤ê°œë³€ìˆ˜ì— í• ë‹¹í•  ìˆ˜ ì—†ë‹¤ê³  ê²½ê³ í•œë‹¤. list.add('2')ì˜ ë”°ì˜´í‘œë¥¼ ì œê±°í•˜ë©´, ì •ì  ë¶„ì„ì„ í†µê³¼í•˜ê³  ì˜¤ë¥˜ë‚˜ ê²½ê³  ì—†ì´ ì‹¤í–‰ë˜ëŠ” ì½”ë“œê°€ ëœë‹¤.

```dart
// âœ” static analysis: success

void printInts(List<int> a) => print(a);

void main() {
  final list = <int>[];
  list.add(1);
  list.add(2);
  printInts(list);
}

```

-   **[code] ìˆ˜ì •í•œ ì½”ë“œ ì£¼ì„**
    
    ```dart
    void main() {
    	// final list = []; Type: List<dynamic>
    	// íƒ€ì… ì–´ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ì—¬ ë³€ìˆ˜ì˜ íƒ€ì…ì„ ëª…ì‹œì ìœ¼ë¡œ í‘œí˜„
      final list = <int>[];
      
      list.add(1);
      // list.add('2'); ì»´íŒŒì¼ ì˜¤ë¥˜: String íƒ€ì…ì„ int íƒ€ì…ì˜ ë§¤ê°œë³€ìˆ˜ì— í• ë‹¹í•  ìˆ˜ ì—†ìŒ
      list.add(2);
      
      printInts(list);
    }
    
    ```
    
    ```dart
    // ì¶œë ¥ ê²°ê³¼
    [1, 2]
    
    ```
    

----------

## What is soundness?[#](https://dart.dev/language/type-system#what-is-soundness) **Soundnessë€ ë¬´ì—‡ì¸ê°€?**

**_Soundness_ is about ensuring your program can't get into certain invalid states. A sound _type system_ means you can never get into a state where an expression evaluates to a value that doesn't match the expression's static type. For example, if an expression's static type is `String`, at runtime you are guaranteed to only get a string when you evaluate it.**

íƒ€ì…ì˜ ì¼ê´€ì„±(soundness)ì€ í”„ë¡œê·¸ë¨ì´ íŠ¹ì • ì˜ëª»ëœ ìƒíƒœì— ë¹ ì§€ì§€ ì•Šë„ë¡ ë³´ì¥í•˜ëŠ” ê²ƒì´ë‹¤. íƒ€ì… ì‹œìŠ¤í…œì˜ ì¼ê´€ì„±(sound typing)ì´ë€ í‘œí˜„ì‹ì´ ì •ì  íƒ€ì…ê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠëŠ” ê°’ìœ¼ë¡œ í‰ê°€ë˜ëŠ” ìƒíƒœì— ì ˆëŒ€ ë„ë‹¬í•  ìˆ˜ ì—†ìŒì„ ì˜ë¯¸í•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í‘œí˜„ì‹ì˜ ì •ì  íƒ€ì…ì´ Stringì¸ ê²½ìš°, ëŸ°íƒ€ì„ì— í•´ë‹¹ í‘œí˜„ì‹ì„ í‰ê°€í•  ë•Œ ë°˜ë“œì‹œ ë¬¸ìì—´ì„ ì–»ì„ ìˆ˜ ìˆìŒì„ ë³´ì¥í•œë‹¤.

**Dart's type system, like the type systems in Java and C#, is sound. It enforces that soundness using a combination of static checking (compile-time errors) and runtime checks. For example, assigning a `String` to `int` is a compile-time error. Casting an object to a `String` using `as String` fails with a runtime error if the object isn't a `String`.**

Dartì˜ íƒ€ì… ì‹œìŠ¤í…œì€ Javaì™€ C#ì˜ íƒ€ì… ì‹œìŠ¤í…œì²˜ëŸ¼ ì¼ê´€ì„±ì´ ìˆë‹¤. ì´ëŠ” ì •ì  ê²€ì‚¬(ì»´íŒŒì¼ íƒ€ì„ ì˜¤ë¥˜)ì™€ ëŸ°íƒ€ì„ ê²€ì‚¬ë¥¼ ì¡°í•©í•˜ì—¬ ì¼ê´€ì„±ì„ ê°•ì œí•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ë¬¸ìì—´ì„ ì •ìˆ˜ì— í• ë‹¹í•˜ë ¤ê³  í•˜ë©´ ì»´íŒŒì¼ íƒ€ì„ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤. ê°ì²´ë¥¼ as Stringì„ ì‚¬ìš©í•˜ì—¬ ë¬¸ìì—´ë¡œ ìºìŠ¤íŒ…í•˜ë ¤ê³  í•  ë•Œ í•´ë‹¹ ê°ì²´ê°€ ë¬¸ìì—´ì´ ì•„ë‹ˆë©´ ëŸ°íƒ€ì„ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.

----------

## **The benefits of soundness[#](https://dart.dev/language/type-system#the-benefits-of-soundness) Soundnessì˜ ì´ì **

**A sound type system has several benefits:**

ì¼ê´€ëœ íƒ€ì… ì‹œìŠ¤í…œì—ëŠ” ì—¬ëŸ¬ ê°€ì§€ ì´ì ì´ ìˆë‹¤:

1.  **Revealing type-related bugs at compile time.**
    
    ì»´íŒŒì¼ íƒ€ì„ì— íƒ€ì… ê´€ë ¨ ë²„ê·¸ë¥¼ ë°œê²¬í•œë‹¤.
    
    -   **A sound type system forces code to be unambiguous about its types, so type-related bugs that might be tricky to find at runtime are revealed at compile time.**
        
        ì¼ê´€ëœ íƒ€ì… ì‹œìŠ¤í…œì€ ì½”ë“œê°€ íƒ€ì…ì— ëŒ€í•´ ëª…í™•í•˜ì§€ ì•Šìœ¼ë©´ ì•ˆë˜ë¯€ë¡œ, ëŸ°íƒ€ì„ì— ì°¾ê¸° ì–´ë ¤ìš´ íƒ€ì… ê´€ë ¨ ë²„ê·¸ë¥¼ ì»´íŒŒì¼ íƒ€ì„ì— ë“œëŸ¬ë‚˜ê²Œ í•œë‹¤.
        
2.  **More readable code.**
    
    ë³´ë‹¤ ì½ê¸° ì‰¬ìš´ ì½”ë“œ.
    
    -   **Code is easier to read because you can rely on a value actually having the specified type. In sound Dart, types can't lie.**
        
        ê°’ì´ ì‹¤ì œë¡œ ì§€ì •ëœ íƒ€ì…ì„ ê°€ì§€ê³  ìˆê¸° ë•Œë¬¸ì— ì½”ë“œë¥¼ ë” ì½ê¸° ì‰½ê²Œ í•  ìˆ˜ ìˆë‹¤. ì¼ê´€ëœ Dartì—ì„œëŠ” íƒ€ì…ì´ ê±°ì§“ë§ì„ í•  ìˆ˜ ì—†ë‹¤.
        
3.  **More maintainable code.**
    
    ìœ ì§€ë³´ìˆ˜ì— ìš©ì´í•œ ì½”ë“œ.
    
    -   **With a sound type system, when you change one piece of code, the type system can warn you about the other pieces of code that just broke.**
        
        ì¼ê´€ëœ íƒ€ì… ì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ë©´, ì½”ë“œì˜ ì¼ë¶€ë¶„ì„ ë³€ê²½í•  ë•Œ íƒ€ì… ì‹œìŠ¤í…œì´ ë‹¤ë¥¸ ê¹¨ì§„ ì½”ë“œ ì¡°ê°ì— ëŒ€í•´ ê²½ê³ í•  ìˆ˜ ìˆë‹¤.
        
4.  **Better ahead of time (AOT) compilation.**
    
    í–¥ìƒëœ ì‚¬ì „ ì»´íŒŒì¼(AOT) ì„±ëŠ¥.
    
    -   **While AOT compilation is possible without types, the generated code is much less efficient.**
        
        íƒ€ì… ì—†ì´ë„ AOT ì»´íŒŒì¼ì´ ê°€ëŠ¥í•˜ì§€ë§Œ, ìƒì„±ëœ ì½”ë“œëŠ” í›¨ì”¬ ë¹„íš¨ìœ¨ì ì´ë‹¤.
        


## **Tips for passing static analysis**[#](https://dart.dev/language/type-system#tips-for-passing-static-analysis) **ì •ì  ë¶„ì„ì„ í†µê³¼í•˜ê¸° ìœ„í•œ íŒ**

**Most of the rules for static types are easy to understand. Here are some of the less obvious rules:**

ëŒ€ë¶€ë¶„ì˜ ì •ì  íƒ€ì… ê·œì¹™ì€ ì´í•´í•˜ê¸° ì‰½ë‹¤. ì—¬ê¸°ì— ëœ ëª…í™•í•œ ëª‡ ê°€ì§€ ê·œì¹™ì´ ìˆë‹¤:

-   **Use sound return types when overriding methods.**
    
    ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œ ì¼ê´€ëœ ë°˜í™˜ íƒ€ì…ì„ ì‚¬ìš©í•˜ë¼.
    
-   **Use sound parameter types when overriding methods.**
    
    ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œ ì¼ê´€ëœ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì„ ì‚¬ìš©í•˜ë¼.
    
-   **Don't use a dynamic list as a typed list.**
    
    ë™ì  ë¦¬ìŠ¤íŠ¸ë¥¼ íƒ€ì…ì´ ì§€ì •ëœ ë¦¬ìŠ¤íŠ¸ë¡œ ì‚¬ìš©í•˜ì§€ ë§ì•„ë¼.
    

**Let's see these rules in detail, with examples that use the following type hierarchy:**

ë‹¤ìŒ íƒ€ì… ê³„ì¸µ êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ëŠ” ì˜ˆì œì™€ í•¨ê»˜ ì´ëŸ¬í•œ ê·œì¹™ì„ ìì„¸íˆ ì‚´í´ë³´ì:

![[dart.dev ê³µì‹ë¬¸ì„œ ì´ë¯¸ì§€]](https://prod-files-secure.s3.us-west-2.amazonaws.com/9db5672d-4cb3-4971-8e51-08c5e31b5395/e177ffa6-d01e-4616-9d19-c02e0a6b2b07/Untitled.png)

[dart.dev ê³µì‹ë¬¸ì„œ ì´ë¯¸ì§€]

-   **[note] ê¸°ë³¸ ê°œë…**
    
    
    **ìŠˆí¼í´ë˜ìŠ¤ (Superclass)**
    
    -   ë‹¤ë¥¸ í´ë˜ìŠ¤ì— ì˜í•´ ìƒì†ë˜ëŠ” í´ë˜ìŠ¤. ê¸°ë³¸ í´ë˜ìŠ¤ ë˜ëŠ” ë¶€ëª¨ í´ë˜ìŠ¤ë¼ê³ ë„ í•œë‹¤.
    -   ê³µí†µëœ ì†ì„±(í•„ë“œ)ê³¼ ë™ì‘(ë©”ì„œë“œ)ì„ ì •ì˜í•˜ì—¬ ì„œë¸Œí´ë˜ìŠ¤ê°€ ì´ë¥¼ ìƒì†ë°›ì•„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
    
    **ì„œë¸Œí´ë˜ìŠ¤ (Subclass)**
    
    -   ìŠˆí¼í´ë˜ìŠ¤ë¥¼ ìƒì†ë°›ëŠ” í´ë˜ìŠ¤ íŒŒìƒ í´ë˜ìŠ¤ ë˜ëŠ” ìì‹ í´ë˜ìŠ¤ë¼ê³ ë„ í•œë‹¤.
    -   ìŠˆí¼í´ë˜ìŠ¤ì˜ ì†ì„±ê³¼ ë™ì‘ì„ ìƒì†ë°›ì•„ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©°, í•„ìš”ì— ë”°ë¼ ì¶”ê°€ì ì¸ ì†ì„±ì´ë‚˜ ë™ì‘ì„ ì •ì˜í•˜ê±°ë‚˜, ìŠˆí¼í´ë˜ìŠ¤ì˜ ë™ì‘ì„ ì¬ì •ì˜(ì˜¤ë²„ë¼ì´ë“œ)í•  ìˆ˜ ìˆë‹¤.
    
    **ë§¤ê°œë³€ìˆ˜ íƒ€ì…**
    
    -   ë©”ì„œë“œì˜ ì¸ìë¡œ ì‚¬ìš©ë˜ëŠ” íƒ€ì….
    
    ----------
    

### **Use sound return types when overriding methods**[#](https://dart.dev/language/type-system#use-sound-return-types-when-overriding-methods) **ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œ ì¼ê´€ëœ ë°˜í™˜ íƒ€ì…ì„ ì‚¬ìš©í•˜ê¸°**

**The return type of a method in a subclass must be the same type or a subtype of the return type of the method in the superclass. Consider the getter method in the `Animal` class:**

ì„œë¸Œí´ë˜ìŠ¤ì˜ ë©”ì„œë“œ ë°˜í™˜ íƒ€ì…ì€ ìŠˆí¼í´ë˜ìŠ¤ì˜ ë©”ì„œë“œ ë°˜í™˜ íƒ€ì…ê³¼ ê°™ê±°ë‚˜ ê·¸ ì„œë¸Œíƒ€ì…ì´ì–´ì•¼ í•œë‹¤. ë‹¤ìŒì€ Animal í´ë˜ìŠ¤ì˜ getter ë©”ì„œë“œë¥¼ ì˜ˆë¡œ ë“¤ì–´ ì„¤ëª…í•œë‹¤:

```dart
class Animal {
  void chase(Animal a) { ... }
  Animal get parent => ...
}

```

**The `parent` getter method returns an `Animal`. In the `HoneyBadger` subclass, you can replace the getter's return type with `HoneyBadger` (or any other subtype of `Animal`), but an unrelated type is not allowed.**

ë¶€ëª¨ getter ë©”ì„œë“œëŠ” Animalì„ ë°˜í™˜í•œë‹¤. HoneyBadger ì„œë¸Œí´ë˜ìŠ¤ì—ì„œëŠ” getterì˜ ë°˜í™˜ íƒ€ì…ì„ HoneyBadger(ë˜ëŠ” Animalì˜ ë‹¤ë¥¸ ì„œë¸Œíƒ€ì…)ë¡œ ëŒ€ì²´í•  ìˆ˜ ìˆì§€ë§Œ, ê´€ë ¨ ì—†ëŠ” íƒ€ì…ìœ¼ë¡œ ëŒ€ì²´í•˜ëŠ” ê²ƒì€ í—ˆìš©ë˜ì§€ ì•ŠëŠ”ë‹¤.

```dart
// âœ” static analysis: success

class HoneyBadger extends Animal {
  @override
  void chase(Animal a) { ... }

  @override
  HoneyBadger get parent => ...
}

```

```dart
// âœ— static analysis: failure

class HoneyBadger extends Animal {
  @override
  void chase(Animal a) { ... }

  @override
  Root get parent => ...
}

```

### **Use sound parameter types when overriding methods[#](https://dart.dev/language/type-system#use-sound-parameter-types-when-overriding-methods) ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œ ì¼ê´€ëœ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì„ ì‚¬ìš©í•˜ê¸°**

**The parameter of an overridden method must have either the same type or a supertype of the corresponding parameter in the superclass. Don't "tighten" the parameter type by replacing the type with a subtype of the original parameter.**

ì¬ì •ì˜ëœ ë©”ì„œë“œì˜ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì€ ìŠˆí¼í´ë˜ìŠ¤ì˜ í•´ë‹¹ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ê³¼ ê°™ê±°ë‚˜ ê·¸ ìŠˆí¼íƒ€ì…ì´ì–´ì•¼ í•œë‹¤. ì›ë˜ ë§¤ê°œë³€ìˆ˜ì˜ íƒ€ì…ì„ ì„œë¸Œíƒ€ì…ìœ¼ë¡œ ëŒ€ì²´í•˜ì—¬ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì„ â€œì¢íˆì§€â€ ë§ì•„ë¼.

<aside> â„¹ï¸ **Note ì£¼ì˜**

**If you have a valid reason to use a subtype, you can use the [`covariant` keyword](https://dart.dev/guides/language/sound-problems#the-covariant-keyword).**

ë§Œì•½ ì„œë¸Œíƒ€ì…ì„ ì‚¬ìš©í•´ì•¼ í•˜ëŠ” íƒ€ë‹¹í•œ ì´ìœ ê°€ ìˆë‹¤ë©´, covariant í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

</aside>

-   **[Q] covariant í‚¤ì›Œë“œ ?**
    
    ----------
    
    ë©”ì„œë“œë‚˜ ìƒì„±ìì˜ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì„ ì„œë¸Œíƒ€ì…ìœ¼ë¡œ ì œí•œí•˜ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©í•œë‹¤. íŠ¹íˆ ìƒì† êµ¬ì¡°ì—ì„œ ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œ ìœ ìš©í•˜ë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì„ ë” êµ¬ì²´ì ì¸ íƒ€ì…ìœ¼ë¡œ ë³€ê²½í•˜ëŠ” ê²ƒì€ í—ˆìš©ë˜ì§€ ì•Šì§€ë§Œ, covariant í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ë©´ ì´ë¥¼ í—ˆìš©í•  ìˆ˜ ìˆë‹¤.
    
    covariant í‚¤ì›Œë“œëŠ” ìŠˆí¼í´ë˜ìŠ¤ ë©”ì„œë“œë‚˜ ì„œë¸Œí´ë˜ìŠ¤ ë©”ì„œë“œ ì–´ëŠ ê³³ì—ë‚˜ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ë³´í†µ ìŠˆí¼í´ë˜ìŠ¤ ë©”ì„œë“œì— ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ê°€ì¥ ì¢‹ë‹¤. covariant í‚¤ì›Œë“œëŠ” ë‹¨ì¼ ë§¤ê°œë³€ìˆ˜ì— ì ìš©ë˜ë©°, setterì™€ í•„ë“œì—ì„œë„ ì§€ì›ëœë‹¤.
    
    ```dart
    class Animal {
      void chase(covariant Animal a) {
        print('Chasing an animal');
      }
    }
    
    class Dog extends Animal {
      @override
      void chase(covariant Dog d) {
        print('Chasing a dog');
      }
    }
    
    void main() {
      Animal animal = Animal();
      Dog dog = Dog();
      
      animal.chase(animal);
      dog.chase(dog);
    }
    
    ```
    
    ```dart
    // ì¶œë ¥ ê²°ê³¼
    Chasing an animal
    Chasing a dog
    
    ```
    
    ----------
    

**Consider the `chase(Animal)` method for the `Animal` class:**

ë‹¤ìŒì€ Animal í´ë˜ìŠ¤ì˜ chase(Animal) ë©”ì„œë“œë¥¼ ì˜ˆë¡œ ë“¤ì–´ ì„¤ëª…í•œë‹¤:

```dart
class Animal {
  void chase(Animal a) { ... }
  Animal get parent => ...
}

```

**The `chase()` method takes an `Animal`. A `HoneyBadger` chases anything. It's OK to override the `chase()` method to take anything (`Object`).**

chase() ë©”ì„œë“œëŠ” Animalì„ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ëŠ”ë‹¤. HoneyBadgerëŠ” ëª¨ë“  ê²ƒì„ ì«“ëŠ”ë‹¤. chase() ë©”ì„œë“œë¥¼ ëª¨ë“  ê²ƒì„ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ë„ë¡(Object)ë¡œ ì¬ì •ì˜í•˜ëŠ” ê²ƒì€ ê´œì°®ë‹¤.

```dart
// âœ” static analysis: success

class HoneyBadger extends Animal {
  @override
  void chase(Object a) { ... }

  @override
  Animal get parent => ...
}

```

**The following code tightens the parameter on the `chase()` method from `Animal` to `Mouse`, a subclass of `Animal`.**

ë‹¤ìŒ ì½”ë“œëŠ” chase() ë©”ì„œë“œì˜ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì„ Animalì—ì„œ Mouseë¡œ ì¢íˆê³  ìˆë‹¤. MouseëŠ” Animalì˜ ì„œë¸Œí´ë˜ìŠ¤ì´ë‹¤.

```dart
// âœ— static analysis: failure

class Mouse extends Animal { ... }

class Cat extends Animal {
  @override
  void chase(Mouse a) { ... }
}

```

**This code is not type safe because it would then be possible to define a cat and send it after an alligator:**

ì´ ì½”ë“œëŠ” íƒ€ì… ì•ˆì „í•˜ì§€ ì•ŠëŠ”ë‹¤. ì™œëƒí•˜ë©´ ì´ë¥¼ í†µí•´ ê³ ì–‘ì´ë¥¼ ì •ì˜í•˜ê³  ì•…ì–´ë¥¼ ì«“ë„ë¡ í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤:

```dart
Animal a = Cat();
a.chase(Alligator()); // Not type safe or feline safe.

```

-   **[Q] ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì„ ì¢íˆëŠ” ê²ƒê³¼ ì¢íˆë©´ ì•ˆë˜ëŠ” ì´ìœ ì— ëŒ€í•œ ì¶”ê°€ ë‚´ìš©**
    
    ----------
    
    ì—¬ê¸°ì„œ Cat í´ë˜ìŠ¤ëŠ” chase ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•˜ë©´ì„œ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì„ Mouseë¡œ ì¢í˜”ë‹¤. MouseëŠ” Animalì˜ ì„œë¸Œí´ë˜ìŠ¤ì´ë‹¤. ì´ë ‡ê²Œ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì„ ë” êµ¬ì²´ì ì¸ ì„œë¸Œíƒ€ì…ìœ¼ë¡œ ë³€ê²½í•˜ëŠ” ê²ƒì„ â€œíƒ€ì…ì„ ì¢íˆëŠ” ê²ƒ(tighten the parameter type)â€œì´ë¼ê³  í•œë‹¤.
    
    ê·¸ëŸ¬ë‚˜ ì´ëŠ” í—ˆìš©ë˜ì§€ ì•ŠëŠ”ë‹¤. ì™œëƒí•˜ë©´ ìŠˆí¼í´ë˜ìŠ¤ì˜ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ë³´ë‹¤ ë” êµ¬ì²´ì ì¸ íƒ€ì…ìœ¼ë¡œ ì¬ì •ì˜í•˜ë©´ íƒ€ì… ì•ˆì „ì„±ì„ ë³´ì¥í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì´ë‹¤.
    
    ```dart
    Animal a = Cat();
    a.chase(Alligator()); // Not type safe or feline safe.
    
    ```
    
    ìœ„ ì½”ë“œì—ì„œ Animal íƒ€ì…ì˜ ë³€ìˆ˜ aëŠ” Cat ê°ì²´ë¥¼ ì°¸ì¡°í•œë‹¤. ê·¸ëŸ°ë° chase ë©”ì„œë“œê°€ Animalì„ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ëŠ” ëŒ€ì‹  Mouseë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ë„ë¡ ì¬ì •ì˜ ë˜ì–´ìˆë‹¤. ì´ ê²½ìš°, Alligator ê°ì²´ë¥¼ chase ë©”ì„œë“œì˜ ì¸ìë¡œ ë„˜ê¸°ë©´ íƒ€ì… ë¶ˆì¼ì¹˜ê°€ ë°œìƒí•©ë‹ˆë‹¤. AlligatorëŠ” Mouseì˜ ì„œë¸Œíƒ€ì…ì´ ì•„ë‹ˆê¸° ë•Œë¬¸ì—, ì´ëŠ” íƒ€ì… ì•ˆì „í•˜ì§€ ëª»í•œ ê²ƒì´ë‹¤.
    
    **ìš”ì•½**
    
    -   **ìŠˆí¼í´ë˜ìŠ¤ì˜ ë§¤ê°œë³€ìˆ˜ íƒ€ì…**ë³´ë‹¤ **ë” êµ¬ì²´ì ì¸ ì„œë¸Œíƒ€ì…**ìœ¼ë¡œ ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•˜ë©´ ì•ˆëœë‹¤.
    -   ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì€ ìŠˆí¼í´ë˜ìŠ¤ì˜ íƒ€ì…ê³¼ ê°™ê±°ë‚˜ ë” ìƒìœ„ íƒ€ì…ì´ì–´ì•¼ í•œë‹¤.
    -   ì´ë ‡ê²Œ í•´ì•¼ íƒ€ì… ì•ˆì „ì„±ì„ ë³´ì¥í•  ìˆ˜ ìˆë‹¤.
    
    ----------
    

### **Don't use a dynamic list as a typed list[#](https://dart.dev/language/type-system#dont-use-a-dynamic-list-as-a-typed-list) ë™ì  ë¦¬ìŠ¤íŠ¸ë¥¼ íƒ€ì…ì´ ì§€ì •ëœ ë¦¬ìŠ¤íŠ¸ë¡œ ì‚¬ìš©í•˜ì§€ ë§ˆì„¸ìš”**

**A `dynamic` list is good when you want to have a list with different kinds of things in it. However, you can't use a `dynamic` list as a typed list.**

ë™ì  ë¦¬ìŠ¤íŠ¸ëŠ” ë‹¤ì–‘í•œ ì¢…ë¥˜ì˜ ìš”ì†Œë¥¼ í¬í•¨í•˜ëŠ” ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ê³ ì í•  ë•Œ ìœ ìš©í•˜ë‹¤. ê·¸ëŸ¬ë‚˜ ë™ì (dynamic) ë¦¬ìŠ¤íŠ¸ë¥¼ íƒ€ì…ì´ ì§€ì •ëœ ë¦¬ìŠ¤íŠ¸ë¡œ ì‚¬ìš©í•  ìˆ˜ëŠ” ì—†ë‹¤.

**This rule also applies to instances of generic types.**

ì´ ê·œì¹™ì€ ì œë„¤ë¦­ íƒ€ì…ì˜ ì¸ìŠ¤í„´ìŠ¤ì—ë„ ì ìš©ëœë‹¤.

**The following code creates a `dynamic` list of `Dog`, and assigns it to a list of type `Cat`, which generates an error during static analysis.**

ë‹¤ìŒ ì½”ë“œëŠ” Dog íƒ€ì…ì˜ ë™ì  ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•˜ê³  ì´ë¥¼ Cat íƒ€ì…ì˜ ë¦¬ìŠ¤íŠ¸ì— í• ë‹¹í•˜ì—¬ ì •ì  ë¶„ì„ ì‹œ ì˜¤ë¥˜ë¥¼ ë°œìƒì‹œí‚¨ë‹¤.

```dart
// âœ— static analysis: failure

void main() {
  List<Cat> foo = <dynamic>[Dog()]; // Error
  List<dynamic> bar = <dynamic>[Dog(), Cat()]; // OK
}

```

----------

## **Runtime checks[#](https://dart.dev/language/type-system#runtime-checks) ëŸ°íƒ€ì„ ê²€ì‚¬**

**Runtime checks deal with type safety issues that can't be detected at compile time.**

ëŸ°íƒ€ì„ ê²€ì‚¬ëŠ” ì»´íŒŒì¼ íƒ€ì„ì— ê°ì§€í•  ìˆ˜ ì—†ëŠ” íƒ€ì… ì•ˆì „ì„± ë¬¸ì œë¥¼ ì²˜ë¦¬í•œë‹¤.

**For example, the following code throws an exception at runtime because it's an error to cast a list of dogs to a list of cats:**

ì˜ˆë¥¼ ë“¤ì–´, ë‹¤ìŒ ì½”ë“œëŠ” ê°œì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ê³ ì–‘ì´ì˜ ë¦¬ìŠ¤íŠ¸ë¡œ ìºìŠ¤íŒ…í•˜ë ¤ê³  í•  ë•Œ ëŸ°íƒ€ì„ì— ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¨ë‹¤:

```dart
// âœ— runtime: failure

void main() {
  List<Animal> animals = <Dog>[Dog()];
  List<Cat> cats = animals as List<Cat>;
}

```

-   **[Q] ìœ„ ì½”ë“œì—ì„œ íƒ€ì…ìºìŠ¤íŒ…ì´ ì•ˆë˜ëŠ” ì´ìœ ?**
    
    ----------
    
    -   Dartì—ì„œ ì œë„¤ë¦­ íƒ€ì…ì„ ì˜ëª»ëœ íƒ€ì…ìœ¼ë¡œ ìºìŠ¤íŒ…í•˜ë ¤ê³  í•˜ë©´ ëŸ°íƒ€ì„ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.
    -   ì´ëŠ” íƒ€ì… ì•ˆì „ì„±ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ ì œë„¤ë¦­ íƒ€ì… ì •ë³´ë¥¼ ëŸ°íƒ€ì„ì— ìœ ì§€í•˜ê³ , ì˜ëª»ëœ ìºìŠ¤íŒ…ì„ ê°ì§€í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë™ì‘í•œë‹¤.
    -   íƒ€ì… ìºìŠ¤íŒ…ì„ ì˜¬ë°”ë¥´ê²Œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” ìƒìœ„ íƒ€ì…ìœ¼ë¡œ ì—…ìºìŠ¤íŒ…í•˜ê±°ë‚˜, ë™ì¼í•œ íƒ€ì…ì„ ìœ ì§€í•´ì•¼ í•œë‹¤.
    

## **Type inference[#](https://dart.dev/language/type-system#type-inference) íƒ€ì… ì¶”ë¡ **

**The analyzer can infer types for fields, methods, local variables, and most generic type arguments. When the analyzer doesn't have enough information to infer a specific type, it uses the `dynamic` type.**

ë¶„ì„ê¸°ëŠ” í•„ë“œ, ë©”ì„œë“œ, ë¡œì»¬ ë³€ìˆ˜, ëŒ€ë¶€ë¶„ì˜ ì œë„¤ë¦­ íƒ€ì… ì¸ìˆ˜ì— ëŒ€í•œ íƒ€ì…ì„ ì¶”ë¡ í•  ìˆ˜ ìˆë‹¤. ë¶„ì„ê¸°ê°€ íŠ¹ì • íƒ€ì…ì„ ì¶”ë¡ í•˜ê¸°ì— ì¶©ë¶„í•œ ì •ë³´ê°€ ì—†ìœ¼ë©´, dynamic íƒ€ì…ì„ ì‚¬ìš©í•œë‹¤.

**Here's an example of how type inference works with generics. In this example, a variable named `arguments` holds a map that pairs string keys with values of various types.**

ë‹¤ìŒì€ ì œë„¤ë¦­ê³¼ í•¨ê»˜ íƒ€ì… ì¶”ë¡ ì´ ì–´ë–»ê²Œ ì‘ë™í•˜ëŠ”ì§€ ë³´ì—¬ì£¼ëŠ” ì˜ˆì œì´ë‹¤. ì´ ì˜ˆì œì—ì„œ argumentsë¼ëŠ” ë³€ìˆ˜ëŠ” ë¬¸ìì—´ í‚¤ì™€ ë‹¤ì–‘í•œ íƒ€ì…ì˜ ê°’ë“¤ì„ ìŒìœ¼ë¡œ ê°€ì§€ëŠ” ë§µì„ ì €ì¥í•œë‹¤.

**If you explicitly type the variable, you might write this:**

ë³€ìˆ˜ì˜ íƒ€ì…ì„ ëª…ì‹œì ìœ¼ë¡œ ì§€ì •í•˜ë ¤ë©´ ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•  ìˆ˜ ìˆë‹¤:

```dart
Map<String, dynamic> arguments = {'argA': 'hello', 'argB': 42};

```

**Alternatively, you can use `var` or `final` and let Dart infer the type:**

ë˜ëŠ” varë‚˜ finalì„ ì‚¬ìš©í•˜ì—¬ Dartê°€ íƒ€ì…ì„ ì¶”ë¡ í•˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```dart
var arguments = {'argA': 'hello', 'argB': 42}; // Map<String, Object>

```

**The map literal infers its type from its entries, and then the variable infers its type from the map literal's type. In this map, the keys are both strings, but the values have different types (`String` and `int`, which have the upper bound `Object`). So the map literal has the type `Map<String, Object>`, and so does the `arguments` variable.**

ë§µ ë¦¬í„°ëŸ´ì€ í•­ëª©ë“¤ë¡œë¶€í„° íƒ€ì…ì„ ì¶”ë¡ í•˜ê³ , ë³€ìˆ˜ëŠ” ë§µ ë¦¬í„°ëŸ´ì˜ íƒ€ì…ìœ¼ë¡œë¶€í„° ìì‹ ì˜ íƒ€ì…ì„ ì¶”ë¡ í•œë‹¤. ì´ ë§µì—ì„œ í‚¤ëŠ” ëª¨ë‘ ë¬¸ìì—´ì´ì§€ë§Œ, ê°’ì€ ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ì„ ê°€ì§„ë‹¤(ë¬¸ìì—´ê³¼ ì •ìˆ˜ëŠ” ìƒìœ„ íƒ€ì…ì´ Objectì…ë‹ˆë‹¤). ë”°ë¼ì„œ ë§µ ë¦¬í„°ëŸ´ì€ Map<String, Object> íƒ€ì…ì„ ê°€ì§€ë©°, arguments ë³€ìˆ˜ë„ ë™ì¼í•œ íƒ€ì…ì„ ê°–ê²Œ ëœë‹¤.

### **Field and method inference[#](https://dart.dev/language/type-system#field-and-method-inference)

í•„ë“œì™€ ë©”ì„œë“œ ì¶”ë¡ **

**A field or method that has no specified type and that overrides a field or method from the superclass, inherits the type of the superclass method or field.**

íƒ€ì…ì´ ëª…ì‹œë˜ì§€ ì•Šê³  ìŠˆí¼í´ë˜ìŠ¤ì˜ í•„ë“œë‚˜ ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•˜ëŠ” í•„ë“œë‚˜ ë©”ì„œë“œëŠ” ìŠˆí¼í´ë˜ìŠ¤ ë©”ì„œë“œë‚˜ í•„ë“œì˜ íƒ€ì…ì„ ìƒì†ë°›ëŠ”ë‹¤.

-   **[code] ìŠˆí¼í´ë˜ìŠ¤ ë©”ì„œë“œ ì¬ì •ì˜ ì˜ˆì‹œ ì½”ë“œ ì‘ì„±**
    
    SpiderMan í´ë˜ìŠ¤ëŠ” Hero í´ë˜ìŠ¤ì˜ attack ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•œë‹¤. attack ë©”ì„œë“œì˜ íƒ€ì…ì„ ëª…ì‹œì ìœ¼ë¡œ ì§€ì •í•˜ì§€ ì•Šì•˜ì§€ë§Œ, Hero í´ë˜ìŠ¤ì—ì„œ ìƒì†ëœ void íƒ€ì…ì„ ìœ ì§€í•œë‹¤.
    
    ```dart
    class Hero {
      void attack() {
        print('ê³µê²©í–ˆë‹¤.');
      }
    }
    
    class SpiderMan extends Hero {
    	// ìŠˆí¼í´ë˜ìŠ¤ì˜ ë©”ì„œë“œë¥¼ ì¬ì •ì˜
    	// íƒ€ì…ì„ ëª…ì‹œí•˜ì§€ ì•Šì•„ë„ ìŠˆí¼í´ë˜ìŠ¤ì˜ íƒ€ì…ì„ ìƒì†
      @override
      attack() {
        print('ìŠ¤íŒŒì´ë”ë§¨ì´ ê³µê²©í–ˆë‹¤.');
      }
    }
    
    void main() {
      Hero spiderMan = SpiderMan();
      spiderMan.attack();
      print(spiderMan.attack.runtimeType);
    }
    
    ```
    
    ```dart
    // ì¶œë ¥ ê²°ê³¼
    
    ìŠ¤íŒŒì´ë”ë§¨ì´ ê³µê²©í–ˆë‹¤.
    () => void
    
    ```
    

**A field that does not have a declared or inherited type but that is declared with an initial value, gets an inferred type based on the initial value.**

ì„ ì–¸ëœ íƒ€ì…ì´ë‚˜ ìƒì†ëœ íƒ€ì…ì´ ì—†ì§€ë§Œ ì´ˆê¸° ê°’ì´ ìˆëŠ” í•„ë“œëŠ” ì´ˆê¸° ê°’ì„ ê¸°ë°˜ìœ¼ë¡œ íƒ€ì…ì„ ì¶”ë¡ í•œë‹¤.

-   **[code] ì´ˆê¸° ê°’ ê¸°ë°˜ íƒ€ì… ì¶”ë¡  ì˜ˆì‹œ ì½”ë“œ ì‘ì„±**
    
    Student í´ë˜ìŠ¤ì˜ nameê³¼ age í•„ë“œëŠ” ì´ˆê¸° ê°’ì— ê¸°ë°˜í•˜ì—¬ ê°ê° Stringê³¼ int íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ ë©ë‹ˆë‹¤. ë©”ì„œë“œ startStudyingì€ dynamicì„ ë°˜í™˜í•˜ë„ë¡ ëª…ì‹œë˜ì—ˆì§€ë§Œ, ì‹¤ì œë¡œëŠ” String ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    
    ```dart
    class Student {
      // ì´ˆê¸° ê°’ì„ ê°€ì§„ í•„ë“œì˜ íƒ€ì… ì¶”ë¡ 
      var name = 'ê¹€í•™ìƒ'; // String íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ 
      var age = 15; // int íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ 
    
      // íƒ€ì…ì„ ëª…ì‹œí•˜ì§€ ì•Šê³  ì´ˆê¸° ê°’ì„ ê°€ì§„ ë©”ì„œë“œ
      dynamic startStudying() {
        return 'ê³µë¶€ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.';
      }
    }
    
    void main() {
      var student = Student();
      print(student.name);
      print('student.name.runtimeType: ${student.name.runtimeType}');
      print(student.age);
      print('student.age.runtimeType: ${student.age.runtimeType}');
      print(student.startStudying());
      print('student.startStudying(student.name).runtimeType: ${student.startStudying().runtimeType}');
    }
    
    ```
    
    ```dart
    // ì¶œë ¥ ê²°ê³¼
    
    ê¹€í•™ìƒ
    student.name.runtimeType: String
    15
    student.age.runtimeType: int
    ê³µë¶€ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.
    student.startStudying(student.name).runtimeType: String
    
    ```
    

### **Static field inference[#](https://dart.dev/language/type-system#static-field-inference) ì •ì  í•„ë“œ ì¶”ë¡ **

**Static fields and variables get their types inferred from their initializer. Note that inference fails if it encounters a cycle (that is, inferring a type for the variable depends on knowing the type of that variable).**

ì •ì  í•„ë“œì™€ ë³€ìˆ˜ëŠ” ì´ˆê¸° ê°’ìœ¼ë¡œë¶€í„° íƒ€ì…ì„ ì¶”ë¡ í•œë‹¤. ì¶”ë¡  ì¤‘ì— ìˆœí™˜ ì°¸ì¡°(ë³€ìˆ˜ì˜ íƒ€ì…ì„ ì¶”ë¡ í•˜ëŠ” ê³¼ì •ì—ì„œ ê·¸ ë³€ìˆ˜ì˜ íƒ€ì…ì„ ì•Œì•„ì•¼ í•˜ëŠ” ê²½ìš°)ê°€ ë°œìƒí•˜ë©´ ì¶”ë¡ ì´ ì‹¤íŒ¨í•œë‹¤.

-   **[code] ì˜¬ë°”ë¥¸ ì •ì  í•„ë“œ íƒ€ì… ì¶”ë¡  ì˜ˆì‹œ ì½”ë“œ ì‘ì„±**
    
    Student í´ë˜ìŠ¤ì˜ ì •ì  í•„ë“œ nameì€ ì´ˆê¸° ê°’ â€˜ê¹€í•™ìƒâ€™ìœ¼ë¡œë¶€í„° String íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ ëœë‹¤.
    
    ```dart
    class Student {
      // ì´ˆê¸° ê°’ì„ ê°€ì§„ í•„ë“œì˜ íƒ€ì… ì¶”ë¡ 
      static var name = 'ê¹€í•™ìƒ'; // String íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ 
    }
    
    void main() {
      print(Student.name);
    }
    
    ```
    
    ```dart
    // ì¶œë ¥ ê²°ê³¼
    
    ê¹€í•™ìƒ
    
    ```
    
-   **[code] ìˆœí™˜ì°¸ì¡°ë¡œ ì¸í•œ íƒ€ì… ì¶”ë¡  ì‹¤íŒ¨ ì˜ˆì‹œ ì½”ë“œ ì‘ì„±**
    
    ----------
    
    **ìˆœí™˜ì°¸ì¡°ë€?**
    
    ë‘ ê°œ ì´ìƒì˜ ê°ì²´ ë˜ëŠ” ë³€ìˆ˜ê°€ ì„œë¡œë¥¼ ì°¸ì¡°í•˜ëŠ” ìƒí™©ì„ ë§í•œë‹¤.
    
    aì™€ bëŠ” ì„œë¡œì˜ ê°’ì„ ì°¸ì¡°í•˜ì—¬ ì´ˆê¸°í™”ë˜ê¸° ë•Œë¬¸ì—, íƒ€ì…ì„ ì¶”ë¡ í•  ìˆ˜ ì—†ë‹¤. ì´ë¡œ ì¸í•´ ì»´íŒŒì¼ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.
    
    ```dart
    class Example {
      // ì˜ëª»ëœ ì˜ˆì‹œ: ìˆœí™˜ ì°¸ì¡°ë¡œ ì¸í•´ íƒ€ì… ì¶”ë¡ ì´ ì‹¤íŒ¨
      static var a = b + 1; // ì»´íŒŒì¼ ì˜¤ë¥˜
      static var b = a + 1; // ì»´íŒŒì¼ ì˜¤ë¥˜
    }
    
    void main() {
      // ì´ ì½”ë“œëŠ” ì»´íŒŒì¼ë˜ì§€ ì•ŠëŠ”ë‹¤.
    }
    
    ```
    
    **ìˆœí™˜ ì°¸ì¡°ì˜ ë¬¸ì œì **
    
    -   **íƒ€ì… ì¶”ë¡  ì‹¤íŒ¨**
        
        ì»´íŒŒì¼ëŸ¬ê°€ ë³€ìˆ˜ì˜ íƒ€ì…ì„ ì¶”ë¡ í•˜ì§€ ëª»í•´ ì»´íŒŒì¼ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.
        
    -   **ë¬´í•œ ë£¨í”„**
        
        ìˆœí™˜ ì°¸ì¡°ë¡œ ì¸í•´ ë¬´í•œ ë£¨í”„ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.
        
    -   **ë©”ëª¨ë¦¬ ëˆ„ìˆ˜**
        
        ì„œë¡œ ì°¸ì¡°í•˜ëŠ” ê°ì²´ê°€ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ì— ì˜í•´ ìˆ˜ê±°ë˜ì§€ ì•Šì•„ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.
        
    
    **í•´ê²° ë°©ë²•**
    
    ìˆœí™˜ ì°¸ì¡°ë¥¼ í”¼í•˜ë ¤ë©´, ë³€ìˆ˜ë‚˜ ê°ì²´ê°€ ì„œë¡œë¥¼ ì§ì ‘ ì°¸ì¡°í•˜ì§€ ì•Šë„ë¡ ì„¤ê³„ë¥¼ ë³€ê²½í•´ì•¼ í•œë‹¤. ë˜ëŠ” ì´ˆê¸°í™” ìˆœì„œë¥¼ ëª…í™•íˆ í•˜ê±°ë‚˜, ì•½í•œ ì°¸ì¡°(weak reference)ë¥¼ ì‚¬ìš©í•˜ì—¬ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ë°©ì§€í•  ìˆ˜ ìˆë‹¤.
    
   
    

### **Local variable inference[#](https://dart.dev/language/type-system#local-variable-inference) ë¡œì»¬ ë³€ìˆ˜ ì¶”ë¡ **

**Local variable types are inferred from their initializer, if any. Subsequent assignments are not taken into account. This may mean that too precise a type may be inferred. If so, you can add a type annotation.**

ë¡œì»¬ ë³€ìˆ˜ì˜ íƒ€ì…ì€ ì´ˆê¸° ê°’ìœ¼ë¡œë¶€í„° ì¶”ë¡ í•œë‹¤(ìˆì„ ê²½ìš°). ì´í›„ì˜ í• ë‹¹ì€ ê³ ë ¤ë˜ì§€ ì•ŠëŠ”ë‹¤. ì´ëŠ” ë„ˆë¬´ êµ¬ì²´ì ì¸ íƒ€ì…ì´ ì¶”ë¡ ë  ìˆ˜ ìˆìŒì„ ì˜ë¯¸í•œë‹¤. ì´ëŸ° ê²½ìš°, íƒ€ì… ì–´ë…¸í…Œì´ì…˜ì„ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.

```dart
// âœ— static analysis: failure

var x = 3; // x is inferred as an int.
x = 4.0;

```

```dart
// âœ” static analysis: success

num y = 3; // A num can be double or int.
y = 4.0;

```

### **Type argument inference[#](https://dart.dev/language/type-system#type-argument-inference) íƒ€ì… ì¸ìˆ˜ ì¶”ë¡ **

**Type arguments to constructor calls and [generic method](https://dart.dev/language/generics#using-generic-methods) invocations are inferred based on a combination of downward information from the context of occurrence, and upward information from the arguments to the constructor or generic method. If inference is not doing what you want or expect, you can always explicitly specify the type arguments.**

ìƒì„±ì í˜¸ì¶œ ë° ì œë„¤ë¦­ ë©”ì„œë“œ í˜¸ì¶œì—ì„œì˜ íƒ€ì… ì¸ìˆ˜ëŠ” ë°œìƒí•œ ë¬¸ë§¥ìœ¼ë¡œë¶€í„°ì˜ í•˜í–¥ì‹ ì •ë³´ì™€, ìƒì„±ì ë˜ëŠ” ì œë„¤ë¦­ ë©”ì„œë“œì˜ ì¸ìˆ˜ë¡œë¶€í„°ì˜ ìƒí–¥ì‹ ì •ë³´ë¥¼ ì¡°í•©í•˜ì—¬ ì¶”ë¡ ëœë‹¤. ì¶”ë¡ ì´ ì›í•˜ëŠ” ëŒ€ë¡œ ì‘ë™í•˜ì§€ ì•Šê±°ë‚˜ ê¸°ëŒ€ì™€ ë‹¤ë¥¸ ê²½ìš°, í•­ìƒ íƒ€ì… ì¸ìˆ˜ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì§€ì •í•  ìˆ˜ ìˆë‹¤.

```dart
// Inferred as if you wrote <int>[].
List<int> listOfInt = [];

// Inferred as if you wrote <double>[3.0].
var listOfDouble = [3.0];

// Inferred as Iterable<int>.
var ints = listOfDouble.map((x) => x.toInt());

```

-   **[Q] í•˜í–¥ì‹ ì •ë³´ì™€ ìƒí–¥ì‹ ì •ë³´ë€?**
    
    ----------
    
    Dartì—ì„œëŠ” íƒ€ì…ì„ ì¶”ë¡  í•  ë•Œ, í•˜í–¥ì‹ ì •ë³´ì™€ ìƒí–¥ì‹ ì •ë³´ì˜ ì¡°í•©ì„ ì‚¬ìš©í•˜ì—¬ íƒ€ì…ì„ ê²°ì •í•œë‹¤.
    
    **í•˜í–¥ì‹ ì •ë³´ (Downward Information)**
    
    -   ë¬¸ë§¥ì—ì„œ ë‚´ë ¤ì˜¤ëŠ” ì •ë³´. ì¦‰, ë³€ìˆ˜ë‚˜ í‘œí˜„ì‹ì´ ì‚¬ìš©ë˜ëŠ” ìœ„ì¹˜ì—ì„œ íƒ€ì… ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ê²ƒ.
    -   ë³€ìˆ˜ê°€ í• ë‹¹ë  ë•Œ, ë³€ìˆ˜ì˜ ì„ ì–¸ íƒ€ì…ì´ í•˜í–¥ì‹ ì •ë³´ë¥¼ ì œê³µí•œë‹¤.
    
    List<int>ë¼ëŠ” íƒ€ì… ì •ë³´ê°€ ë³€ìˆ˜ numbersì— ëŒ€í•œ í•˜í–¥ì‹ ì •ë³´ì´ë‹¤. ë¦¬ìŠ¤íŠ¸ ë¦¬í„°ëŸ´ [1, 2, 3]ì˜ íƒ€ì…ì´ List<int>ë¡œ ì¶”ë¡ ëœë‹¤.
    
    ```dart
    void main() {
      List<int> numbers = [1, 2, 3]; // í•˜í–¥ì‹ ì •ë³´: List<int>
    }
    
    ```
    
    **ìƒí–¥ì‹ ì •ë³´ (Upward Information)**
    
    -   í•¨ìˆ˜ í˜¸ì¶œì´ë‚˜ í‘œí˜„ì‹ ìì²´ì˜ ì¸ìˆ˜ë‚˜ ë¦¬í„´ íƒ€ì…ì—ì„œ ì˜¬ë¼ì˜¤ëŠ” ì •ë³´. ì¦‰, í•¨ìˆ˜ë‚˜ ìƒì„±ìê°€ í˜¸ì¶œë  ë•Œ, ì „ë‹¬ëœ ì¸ìˆ˜ì˜ íƒ€ì…ì´ ìƒí–¥ì‹ ì •ë³´ë¥¼ ì œê³µí•˜ëŠ” ê²ƒ.
    -   í•¨ìˆ˜ì— ì „ë‹¬ëœ ì¸ìˆ˜ì˜ íƒ€ì…ì´ í•¨ìˆ˜ì˜ ë°˜í™˜ íƒ€ì…ì„ ê²°ì •í•˜ëŠ” ë° ì‚¬ìš©ëœë‹¤.
    
    getFirstElement í•¨ìˆ˜ëŠ” ì œë„¤ë¦­ íƒ€ì… Të¥¼ ì‚¬ìš©í•œë‹¤. í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œ, ì „ë‹¬ëœ ì¸ìˆ˜ stringsì˜ íƒ€ì…ì´ List<String>ì´ë¯€ë¡œ, TëŠ” Stringìœ¼ë¡œ ì¶”ë¡ ëœë‹¤.
    
    ```dart
    T getFirstElement<T>(List<T> list) {
      return list[0];
    }
    
    void main() {
      var strings = ['hello', 'world'];
      var first = getFirstElement(strings); // ìƒí–¥ì‹ ì •ë³´: List<String>
      print(first); // ì¶œë ¥: hello
    }
    
    ```
    
    ----------
    

**In the last example, `x` is inferred as `double` using downward information. The return type of the closure is inferred as `int` using upward information. Dart uses this return type as upward information when inferring the `map()` method's type argument: `<int>`.**

ë§ˆì§€ë§‰ ì˜ˆì œì—ì„œ xëŠ” í•˜í–¥ì‹ ì •ë³´ë¥¼ ì‚¬ìš©í•˜ì—¬ doubleë¡œ ì¶”ë¡ ëœë‹¤. í´ë¡œì €ì˜ ë°˜í™˜ íƒ€ì…ì€ ìƒí–¥ì‹ ì •ë³´ë¥¼ ì‚¬ìš©í•˜ì—¬ intë¡œ ì¶”ë¡ ëœë‹¤. DartëŠ” map() ë©”ì„œë“œì˜ íƒ€ì… ì¸ìˆ˜ <int>ë¥¼ ì¶”ë¡ í•  ë•Œ ì´ ë°˜í™˜ íƒ€ì…ì„ ìƒí–¥ì‹ ì •ë³´ë¡œ ì‚¬ìš©í•œë‹¤.

-   **[Q] í´ë¡œì €(closure)ë€?**
    
    ----------
    
    í•¨ìˆ˜ì™€ í•¨ìˆ˜ê°€ ì •ì˜ëœ í™˜ê²½(ë ‰ì‹œì»¬ ìŠ¤ì½”í”„)ì„ í•¨ê»˜ ì €ì¥í•˜ëŠ” êµ¬ì¡°ë¥¼ ë§í•œë‹¤. í´ë¡œì €ëŠ” í•¨ìˆ˜ê°€ ì„ ì–¸ëœ ìœ„ì¹˜ì˜ ë³€ìˆ˜ë¥¼ ì°¸ì¡°í•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŸ¬í•œ ë³€ìˆ˜ë¥¼ í•¨ìˆ˜ì˜ ì™¸ë¶€ì—ì„œë„ ê³„ì†í•´ì„œ ì ‘ê·¼í•˜ê³  ë³€ê²½í•  ìˆ˜ ìˆë‹¤.
    
    **íŠ¹ì§•**
    
    -   **í™˜ê²½ì„ ê¸°ì–µ**
        
        í´ë¡œì €ëŠ” í•¨ìˆ˜ê°€ ì •ì˜ë  ë•Œì˜ í™˜ê²½(ë³€ìˆ˜ë“¤)ì„ ê¸°ì–µí•œë‹¤.
        
    -   **ìƒíƒœ ìœ ì§€**
        
        í´ë¡œì €ëŠ” í•¨ìˆ˜ê°€ ì¢…ë£Œëœ í›„ì—ë„ ìƒíƒœë¥¼ ìœ ì§€í•  ìˆ˜ ìˆë‹¤.
        
    -   **ë³€ìˆ˜ ì ‘ê·¼**
        
        í´ë¡œì €ëŠ” ìì‹ ì´ ì •ì˜ëœ ìŠ¤ì½”í”„ì— ìˆëŠ” ë³€ìˆ˜ë“¤ì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.
        
    
    **í´ë¡œì €ë¥¼ ì‚¬ìš©í•œ ì¹´ìš´í„° ì˜ˆì œ**
    
    makeCounter í•¨ìˆ˜ëŠ” í´ë¡œì €ë¥¼ ë°˜í™˜í•œë‹¤. ë°˜í™˜ëœ í´ë¡œì €ëŠ” count ë³€ìˆ˜ë¥¼ ê¸°ì–µí•˜ê³ , í˜¸ì¶œë  ë•Œë§ˆë‹¤ countë¥¼ ì¦ê°€ì‹œì¼œ ë°˜í™˜í•œë‹¤. ì´ë¥¼ í†µí•´ í´ë¡œì €ê°€ ìƒíƒœë¥¼ ìœ ì§€í•˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
    
    ```dart
    Function makeCounter() {
      int count = 0;
    
      return () {
        count++;
        return count;
      };
    }
    
    void main() {
      Function counter = makeCounter();
    
      print(counter());
      print(counter());
      print(counter());
    }
    
    ```
    
    ```dart
    // ì¶œë ¥ ê²°ê³¼
    
    1
    2
    3
    
    ```
    
## **Substituting types[#](https://dart.dev/language/type-system#substituting-types) íƒ€ì… ëŒ€ì²´**

**When you override a method, you are replacing something of one type (in the old method) with something that might have a new type (in the new method). Similarly, when you pass an argument to a function, you are replacing something that has one type (a parameter with a declared type) with something that has another type (the actual argument). When can you replace something that has one type with something that has a subtype or a supertype?**

ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œ, ê¸°ì¡´ ë©”ì„œë“œì—ì„œì˜ í•œ íƒ€ì…ì„ ìƒˆë¡œìš´ ë©”ì„œë“œì—ì„œ ë‹¤ë¥¸ íƒ€ì…ìœ¼ë¡œ ëŒ€ì²´í•˜ëŠ” ê²ƒì´ë‹¤. ë§ˆì°¬ê°€ì§€ë¡œ, í•¨ìˆ˜ì— ì¸ìˆ˜ë¥¼ ì „ë‹¬í•  ë•Œ, ì„ ì–¸ëœ íƒ€ì…ì„ ê°€ì§„ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‹¤ì œ ì¸ìˆ˜ê°€ ê°€ì§„ ë‹¤ë¥¸ íƒ€ì…ìœ¼ë¡œ ëŒ€ì²´í•˜ëŠ” ê²ƒì´ë‹¤. ì–¸ì œ í•œ íƒ€ì…ì„ ì„œë¸Œíƒ€ì…ì´ë‚˜ ìŠˆí¼íƒ€ì…ìœ¼ë¡œ ëŒ€ì²´í•  ìˆ˜ ìˆì„ê¹Œ?

**When substituting types, it helps to think in terms of _consumers_ and _producers_. A consumer absorbs a type and a producer generates a type.**

íƒ€ì…ì„ ëŒ€ì²´í•  ë•ŒëŠ” ì†Œë¹„ìì™€ ìƒì‚°ìì˜ ê´€ì ì—ì„œ ìƒê°í•˜ëŠ” ê²ƒì´ ë„ì›€ì´ ëœë‹¤. ì†Œë¹„ìëŠ” íƒ€ì…ì„ í¡ìˆ˜í•˜ê³ , ìƒì‚°ìëŠ” íƒ€ì…ì„ ìƒì„±í•œë‹¤.

**You can replace a consumer's type with a supertype and a producer's type with a subtype.**

ì†Œë¹„ìì˜ íƒ€ì…ì€ ìŠˆí¼íƒ€ì…ìœ¼ë¡œ ëŒ€ì²´í•  ìˆ˜ ìˆê³ , ìƒì‚°ìì˜ íƒ€ì…ì€ ì„œë¸Œíƒ€ì…ìœ¼ë¡œ ëŒ€ì²´í•  ìˆ˜ ìˆë‹¤.

**Let's look at examples of simple type assignment and assignment with generic types.**

ë‹¨ìˆœí•œ íƒ€ì… í• ë‹¹ê³¼ ì œë„¤ë¦­ íƒ€ì…ì„ ì‚¬ìš©í•œ í• ë‹¹ì˜ ì˜ˆì œë¥¼ ì‚´í´ë³´ì.

### **Simple type assignment[#](https://dart.dev/language/type-system#simple-type-assignment) ë‹¨ìˆœ íƒ€ì… í• ë‹¹**

**When assigning objects to objects, when can you replace a type with a different type? The answer depends on whether the object is a consumer or a producer.**

ê°ì²´ë¥¼ ë‹¤ë¥¸ ê°ì²´ì— í• ë‹¹í•  ë•Œ, ì–¸ì œ íƒ€ì…ì„ ë‹¤ë¥¸ íƒ€ì…ìœ¼ë¡œ ëŒ€ì²´í•  ìˆ˜ ìˆì„ê¹Œ? ì´ëŠ” ê°ì²´ê°€ ì†Œë¹„ìì¸ì§€ ìƒì‚°ìì¸ì§€ì— ë”°ë¼ ë‹¬ë¼ì§„ë‹¤.

**Consider the following type hierarchy:**

ë‹¤ìŒ íƒ€ì… ê³„ì¸µì„ ê³ ë ¤í•´ë³´ì:

![[dart.dev ê³µì‹ë¬¸ì„œ ì´ë¯¸ì§€]](https://prod-files-secure.s3.us-west-2.amazonaws.com/9db5672d-4cb3-4971-8e51-08c5e31b5395/3a2c100e-7681-4ed4-aa4e-9be0d33148d1/Untitled.png)

[dart.dev ê³µì‹ë¬¸ì„œ ì´ë¯¸ì§€]

**Consider the following simple assignment where `Cat c` is a _consumer_ and `Cat()` is a _producer_:**

ë‹¤ìŒì€ Cat cê°€ ì†Œë¹„ìì´ê³  Cat()ì´ ìƒì‚°ìì¸ ê°„ë‹¨í•œ í• ë‹¹ ì˜ˆì œì´ë‹¤:

```dart
Cat c = Cat();

```

**In a consuming position, it's safe to replace something that consumes a specific type (`Cat`) with something that consumes anything (`Animal`), so replacing `Cat c` with `Animal c` is allowed, because `Animal` is a supertype of `Cat`.**

ì†Œë¹„ì ìœ„ì¹˜ì—ì„œëŠ” íŠ¹ì • íƒ€ì…(Cat)ì„ ì†Œë¹„í•˜ëŠ” ê²ƒì„ ëª¨ë“  ê²ƒì„ ì†Œë¹„í•˜ëŠ” íƒ€ì…(Animal)ìœ¼ë¡œ ëŒ€ì²´í•˜ëŠ” ê²ƒì´ ì•ˆì „í•˜ë‹¤. ë”°ë¼ì„œ Cat cë¥¼ Animal cë¡œ ëŒ€ì²´í•˜ëŠ” ê²ƒì€ í—ˆìš©ë©ë‹ˆë‹¤. ì´ëŠ” Animalì´ Catì˜ ìŠˆí¼íƒ€ì…ì´ê¸° ë•Œë¬¸ì´ë‹¤.

```dart
// âœ” static analysis: success

Animal c = Cat();

```

**But replacing `Cat c` with `MaineCoon c` breaks type safety, because the superclass may provide a type of Cat with different behaviors, such as `Lion`:**

ê·¸ëŸ¬ë‚˜ Cat cë¥¼ MaineCoon cë¡œ ëŒ€ì²´í•˜ë©´ íƒ€ì… ì•ˆì „ì„±ì´ ê¹¨ì§„ë‹¤. ìŠˆí¼í´ë˜ìŠ¤ëŠ” Lionê³¼ ê°™ì´ ë‹¤ë¥¸ ë™ì‘ì„ ê°€ì§„ Cat íƒ€ì…ì„ ì œê³µí•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.

```dart
// âœ— static analysis: failure

MaineCoon c = Cat();

```

**In a producing position, it's safe to replace something that produces a type (`Cat`) with a more specific type (`MaineCoon`). So, the following is allowed:**

ìƒì‚°ì ìœ„ì¹˜ì—ì„œëŠ” íŠ¹ì • íƒ€ì…(Cat)ì„ ìƒì‚°í•˜ëŠ” ê²ƒì„ ë” êµ¬ì²´ì ì¸ íƒ€ì…(MaineCoon)ìœ¼ë¡œ ëŒ€ì²´í•˜ëŠ” ê²ƒì´ ì•ˆì „í•˜ë‹¤. ë”°ë¼ì„œ ë‹¤ìŒê³¼ ê°™ì€ ì½”ë“œê°€ í—ˆìš©ëœë‹¤:

```dart
// âœ” static analysis: success

Cat c = MaineCoon();

```

### **Generic type assignment**[#](https://dart.dev/language/type-system#generic-type-assignment) **ì œë„¤ë¦­ íƒ€ì… í• ë‹¹**

**Are the rules the same for generic types? Yes. Consider the hierarchy of lists of animalsâ€”a `List` of `Cat` is a subtype of a `List` of `Animal`, and a supertype of a `List` of `MaineCoon`:**

ì œë„¤ë¦­ íƒ€ì…ì—ë„ ë™ì¼í•œ ê·œì¹™ì´ ì ìš©ë ê¹Œ? ê·¸ë ‡ë‹¤. ë™ë¬¼ ë¦¬ìŠ¤íŠ¸ì˜ ê³„ì¸µ êµ¬ì¡°ë¥¼ ê³ ë ¤í•´ë³´ìâ€”List<Cat>ì€ List<Animal>ì˜ ì„œë¸Œíƒ€ì…ì´ë©°, List<MaineCoon>ì˜ ìŠˆí¼íƒ€ì…ì´ë‹¤:

![[dart.dev ê³µì‹ë¬¸ì„œ ì´ë¯¸ì§€]](https://prod-files-secure.s3.us-west-2.amazonaws.com/9db5672d-4cb3-4971-8e51-08c5e31b5395/ccaf57ba-8fcd-4beb-9065-217a8b333332/Untitled.png)

[dart.dev ê³µì‹ë¬¸ì„œ ì´ë¯¸ì§€]

**In the following example, you can assign a `MaineCoon` list to `myCats` because `List<MaineCoon>` is a subtype of `List<Cat>`:**

ë‹¤ìŒ ì˜ˆì œì—ì„œ, List<MaineCoon>ì€ List<Cat>ì˜ ì„œë¸Œíƒ€ì…ì´ë¯€ë¡œ MaineCoon ë¦¬ìŠ¤íŠ¸ë¥¼ myCatsì— í• ë‹¹í•  ìˆ˜ ìˆë‹¤:

```dart
// âœ” static analysis: success

List<MaineCoon> myMaineCoons = ...
List<Cat> myCats = myMaineCoons;

```

**What about going in the other direction? Can you assign an `Animal` list to a `List<Cat>`?**

ê·¸ ë°˜ëŒ€ ë°©í–¥ì€ ì–´ë–¨ê¹Œ? List<Animal>ì„ List<Cat>ì— í• ë‹¹í•  ìˆ˜ ìˆì„ê¹Œ?

```dart
// âœ— static analysis: failure

List<Animal> myAnimals = ...
List<Cat> myCats = myAnimals;

```

**This assignment doesn't pass static analysis because it creates an implicit downcast, which is disallowed from non-`dynamic` types such as `Animal`.**

ì´ í• ë‹¹ì€ ì•”ì‹œì  ë‹¤ìš´ìºìŠ¤íŠ¸ë¥¼ ìƒì„±í•˜ë¯€ë¡œ ì •ì  ë¶„ì„ì„ í†µê³¼í•˜ì§€ ëª»í•œë‹¤. ì•”ì‹œì  ë‹¤ìš´ìºìŠ¤íŠ¸ëŠ” Animalê³¼ ê°™ì€ ë¹„ë™ì  íƒ€ì…ì—ì„œëŠ” í—ˆìš©ë˜ì§€ ì•ŠëŠ”ë‹¤.

**To make this type of code pass static analysis, you can use an explicit cast.**

ì´ëŸ° ìœ í˜•ì˜ ì½”ë“œê°€ ì •ì  ë¶„ì„ì„ í†µê³¼í•˜ë„ë¡ í•˜ë ¤ë©´ ëª…ì‹œì  ìºìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```dart
List<Animal> myAnimals = ...
List<Cat> myCats = myAnimals as List<Cat>;

```

**An explicit cast might still fail at runtime, though, depending on the actual type of the list being cast (`myAnimals`).**

ê·¸ëŸ¬ë‚˜ ëª…ì‹œì  ìºìŠ¤íŠ¸ëŠ” ë¦¬ìŠ¤íŠ¸ì˜ ì‹¤ì œ íƒ€ì…(myAnimals)ì— ë”°ë¼ ëŸ°íƒ€ì„ì— ì‹¤íŒ¨í•  ìˆ˜ ìˆë‹¤.

### **Methods[#](https://dart.dev/language/type-system#methods) ë©”ì„œë“œ**

**When overriding a method, the producer and consumer rules still apply. For example:**

ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œë„ ìƒì‚°ìì™€ ì†Œë¹„ì ê·œì¹™ì´ ì—¬ì „íˆ ì ìš©ë©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´:

![[dart.dev ê³µì‹ë¬¸ì„œ ì´ë¯¸ì§€]](https://prod-files-secure.s3.us-west-2.amazonaws.com/9db5672d-4cb3-4971-8e51-08c5e31b5395/30644a15-1503-49ea-a6f5-4bea9baceb31/Untitled.png)

[dart.dev ê³µì‹ë¬¸ì„œ ì´ë¯¸ì§€]

**For a consumer (such as the `chase(Animal)` method), you can replace the parameter type with a supertype. For a producer (such as the `parent` getter method), you can replace the return type with a subtype.**

ì†Œë¹„ì(ì˜ˆ: chase(Animal) ë©”ì„œë“œ)ì—ì„œëŠ” ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì„ ìŠˆí¼íƒ€ì…ìœ¼ë¡œ ëŒ€ì²´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìƒì‚°ì(ì˜ˆ: parent getter ë©”ì„œë“œ)ì—ì„œëŠ” ë°˜í™˜ íƒ€ì…ì„ ì„œë¸Œíƒ€ì…ìœ¼ë¡œ ëŒ€ì²´í•  ìˆ˜ ìˆë‹¤.

**For more information, see [Use sound return types when overriding methods](https://dart.dev/language/type-system#use-proper-return-types) and [Use sound parameter types when overriding methods](https://dart.dev/language/type-system#use-proper-param-types).**

ìì„¸í•œ ë‚´ìš©ì€ ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œ ì¼ê´€ëœ ë°˜í™˜ íƒ€ì…ì„ ì‚¬ìš©í•˜ê¸°ì™€ ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œ ì¼ê´€ëœ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì„ ì‚¬ìš©í•˜ê¸°ë¥¼ ì°¸ì¡°í•˜ì.

----------

## **Other resources[#](https://dart.dev/language/type-system#other-resources) ê¸°íƒ€ ìë£Œ**

**The following resources have further information on sound Dart:**

ë‹¤ìŒ ìë£Œë“¤ì€ sound Dartì— ëŒ€í•œ ì¶”ê°€ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤:

-   [**Fixing common type problems](https://dart.dev/guides/language/sound-problems) - Errors you may encounter when writing sound Dart code, and how to fix them.**
    
    ì¼ë°˜ì ì¸ íƒ€ì… ë¬¸ì œ í•´ê²° - sound Dart ì½”ë“œë¥¼ ì‘ì„±í•  ë•Œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì˜¤ë¥˜ì™€ ì´ë¥¼ í•´ê²°í•˜ëŠ” ë°©ë²•.
    
-   [**Fixing type promotion failures](https://dart.dev/tools/non-promotion-reasons) - Understand and learn how to fix type promotion errors.**
    
    íƒ€ì… í”„ë¡œëª¨ì…˜ ì‹¤íŒ¨ í•´ê²° - íƒ€ì… í”„ë¡œëª¨ì…˜ ì˜¤ë¥˜ë¥¼ ì´í•´í•˜ê³  í•´ê²°í•˜ëŠ” ë°©ë²•ì„ ë°°ì›ë‹ˆë‹¤.
    
-   [**Sound null safety](https://dart.dev/null-safety) - Learn about writing code with sound null safety.**
    
    Sound null safety - sound null safetyë¥¼ ì‚¬ìš©í•˜ì—¬ ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ” ë°©ë²•ì„ ë°°ì›ë‹ˆë‹¤.
    
-   [**Customizing static analysis](https://dart.dev/tools/analysis) - How to set up and customize the analyzer and linter using an analysis options file.**
    
    ì •ì  ë¶„ì„ ì‚¬ìš©ì ì§€ì • - ë¶„ì„ ì˜µì…˜ íŒŒì¼ì„ ì‚¬ìš©í•˜ì—¬ ë¶„ì„ê¸°ì™€ ë¦°í„°ë¥¼ ì„¤ì •í•˜ê³  ì‚¬ìš©ì ì§€ì •í•˜ëŠ” ë°©ë²•.

---

ğŸ”— [í˜ì´ì§€ ë§í¬]

# Patterns íŒ¨í„´

<aside> â„¹ï¸ **Version note**

Patterns require a [language version](https://dart.dev/guides/language/evolution#language-versioning) of at least 3.0. íŒ¨í„´ì€ ìµœì†Œ 3.0 ì´ìƒì˜ ì–¸ì–´ ë²„ì „ì´ í•„ìš”í•©ë‹ˆë‹¤.

</aside>

**Patterns are a syntactic category in the Dart language, like statements and expressions. A pattern represents the shape of a set of values that it may match against actual values.**

íŒ¨í„´ì€ ë¬¸ì¥(statements)ê³¼ í‘œí˜„ì‹(expressions)ì²˜ëŸ¼ Dart ì–¸ì–´ì˜ ë¬¸ë²•ì  ë²”ì£¼ì´ë‹¤. íŒ¨í„´ì€ ì‹¤ì œ ê°’ê³¼ ë§¤ì¹˜ë  ìˆ˜ ìˆëŠ” ê°’ë“¤ì˜ ëª¨ì–‘ì„ ë‚˜íƒ€ë‚¸ë‹¤.

**This page describes:**

ì´ í˜ì´ì§€ì—ì„œëŠ” ë‹¤ìŒ ë‚´ìš©ì„ ì„¤ëª…í•œë‹¤:

-   **What patterns do.**
    
    íŒ¨í„´ì˜ ê¸°ëŠ¥
    
-   **Where patterns are allowed in Dart code.**
    
    Dart ì½”ë“œì—ì„œ íŒ¨í„´ì´ í—ˆìš©ë˜ëŠ” ìœ„ì¹˜
    
-   **What the common use cases for patterns are.**
    
    íŒ¨í„´ì˜ ì¼ë°˜ì ì¸ ì‚¬ìš© ì‚¬ë¡€
    

**To learn about the different kinds of patterns, visit the [pattern types](https://dart.dev/language/pattern-types) page.**

ë‹¤ì–‘í•œ ì¢…ë¥˜ì˜ íŒ¨í„´ì— ëŒ€í•´ ë°°ìš°ë ¤ë©´, íŒ¨í„´ ìœ í˜• í˜ì´ì§€ë¥¼ ë°©ë¬¸í•˜ì.



## **What patterns do[#](https://dart.dev/language/patterns#what-patterns-do) íŒ¨í„´ì˜ ê¸°ëŠ¥**

**In general, a pattern may match a value, destructure a value, or both, depending on the context and shape of the pattern.**

ì¼ë°˜ì ìœ¼ë¡œ íŒ¨í„´ì€ ë¬¸ë§¥ê³¼ íŒ¨í„´ì˜ í˜•íƒœì— ë”°ë¼ ê°’ê³¼ ë§¤ì¹˜ë˜ê±°ë‚˜ ê°’ì„ ë¶„í•´í•˜ê±°ë‚˜, ë‘˜ ë‹¤ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**First, _pattern matching_ allows you to check whether a given value:**

ë¨¼ì €, íŒ¨í„´ ë§¤ì¹­ì„ í†µí•´ ì£¼ì–´ì§„ ê°’ì´ ë‹¤ìŒ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆë‹¤:

-   **Has a certain shape.**
    
    íŠ¹ì • ëª¨ì–‘ì„ ê°€ì§€ê³  ìˆëŠ”ì§€.
    
-   **Is a certain constant.**
    
    íŠ¹ì • ìƒìˆ˜ì¸ì§€.
    
-   **Is equal to something else.**
    
    ë‹¤ë¥¸ ê²ƒê³¼ ê°™ì€ì§€.
    
-   **Has a certain type.**
    
    íŠ¹ì • íƒ€ì…ì¸ì§€.
    

**Then, _pattern destructuring_ provides you with a convenient declarative syntax to break that value into its constituent parts. The same pattern can also let you bind variables to some or all of those parts in the process.**

ê·¸ ë‹¤ìŒ, íŒ¨í„´ ë¶„í•´ë¥¼ í†µí•´ í•´ë‹¹ ê°’ì„ êµ¬ì„± ìš”ì†Œë¡œ ë‚˜ëˆ„ëŠ” í¸ë¦¬í•œ ì„ ì–¸ì  ë¬¸ë²•ì„ ì œê³µí•œë‹¤. ê°™ì€ íŒ¨í„´ì„ ì‚¬ìš©í•˜ì—¬ ê·¸ ê³¼ì •ì—ì„œ ì¼ë¶€ ë˜ëŠ” ëª¨ë“  êµ¬ì„± ìš”ì†Œì— ë³€ìˆ˜ë¥¼ ë°”ì¸ë”©í•  ìˆ˜ë„ ìˆë‹¤.

-   **[Q] ë³€ìˆ˜ë¥¼ ë°”ì¸ë”©í•œë‹¤?**
    
    ----------
    
    ë³€ìˆ˜ë¥¼ ë°”ì¸ë”©í•œë‹¤ëŠ” ê²ƒì€ íŠ¹ì • ê°’ì„ ë³€ìˆ˜ì— í• ë‹¹í•˜ì—¬ **ê·¸ ë³€ìˆ˜ê°€ í•´ë‹¹ ê°’ì„ ì°¸ì¡°í•˜ë„ë¡ í•˜ëŠ” ê²ƒ**ì„ ì˜ë¯¸í•œë‹¤. ë°”ì¸ë”©ì€ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ê³  ì´ˆê¸°í™”í•  ë•Œ ë°œìƒí•œë‹¤.
    
    **ì¼ë°˜ì  ë³€ìˆ˜ ë°”ì¸ë”©**
    
    ì—¬ê¸°ì„œ nameì´ë¼ëŠ” ë³€ìˆ˜ëŠ” ë¬¸ìì—´ 'ê¹€í•™ìƒâ€™ì„ ì°¸ì¡°í•˜ë©°, ageë¼ëŠ” ë³€ìˆ˜ëŠ” ì •ìˆ˜ 15ë¥¼ ì°¸ì¡°í•œë‹¤
    
    ```dart
    String name = 'ê¹€í•™ìƒ'; // ë³€ìˆ˜ nameì„ ë¬¸ìì—´ 'ê¹€í•™ìƒ'ì— ë°”ì¸ë”©
    int age = 15; // ë³€ìˆ˜ ageì„ ì •ìˆ˜ 15ì— ë°”ì¸ë”©
    
    ```
    
    ----------
    

### **Matching[#](https://dart.dev/language/patterns#matching) ë§¤ì¹­**

**A pattern always tests against a value to determine if the value has the form you expect. In other words, you are checking if the value _matches_ the pattern.**

íŒ¨í„´ì€ í•­ìƒ ê°’ì„ í…ŒìŠ¤íŠ¸í•˜ì—¬ ê·¸ ê°’ì´ ê¸°ëŒ€í•˜ëŠ” í˜•íƒœë¥¼ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸í•œë‹¤. ì¦‰, ê°’ì„ íŒ¨í„´ê³¼ ë§¤ì¹­í•˜ëŠ”ì§€ í™•ì¸í•˜ëŠ” ê²ƒì´ë‹¤.

**What constitutes a match depends on [what kind of pattern](https://dart.dev/language/pattern-types) you are using. For example, a constant pattern matches if the value is equal to the pattern's constant:**

ë¬´ì—‡ì´ ë§¤ì¹­ì„ êµ¬ì„±í•˜ëŠ”ì§€ëŠ” ì‚¬ìš© ì¤‘ì¸ íŒ¨í„´ì˜ ì¢…ë¥˜ì— ë”°ë¼ ë‹¤ë¥´ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ìƒìˆ˜ íŒ¨í„´ì€ ê°’ì´ íŒ¨í„´ì˜ ìƒìˆ˜ì™€ ë™ì¼í•œ ê²½ìš°ì— ë§¤ì¹­ëœë‹¤:

```dart
switch (number) {
  // Constant pattern matches if 1 == number.
  case 1:
    print('one');
}

```

**Many patterns make use of subpatterns, sometimes called _outer_ and _inner_ patterns, respectively. Patterns match recursively on their subpatterns. For example, the individual fields of any [collection-type](https://dart.dev/language/collections) pattern could be [variable patterns](https://dart.dev/language/pattern-types#variable) or [constant patterns](https://dart.dev/language/pattern-types#constant):**

ë§ì€ íŒ¨í„´ì€ ê°ê° ì™¸ë¶€ íŒ¨í„´ê³¼ ë‚´ë¶€ íŒ¨í„´ì´ë¼ê³  ë¶ˆë¦¬ëŠ” ì„œë¸ŒíŒ¨í„´ì„ ì‚¬ìš©í•œë‹¤. íŒ¨í„´ì€ ì„œë¸ŒíŒ¨í„´ì— ëŒ€í•´ ì¬ê·€ì ìœ¼ë¡œ ë§¤ì¹­ëœë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì»¬ë ‰ì…˜ íƒ€ì… íŒ¨í„´ì˜ ê°œë³„ í•„ë“œëŠ” ë³€ìˆ˜ íŒ¨í„´ì´ë‚˜ ìƒìˆ˜ íŒ¨í„´ì´ ë  ìˆ˜ ìˆë‹¤.

```dart
const a = 'a';
const b = 'b';
switch (obj) {
  // List pattern [a, b] matches obj first if obj is a list with two fields,
  // then if its fields match the constant subpatterns 'a' and 'b'.
  case [a, b]:
    print('$a, $b');
}

```

-   **[note] ì½”ë“œ ì£¼ì„ ì‘ì„±**
    
    ```dart
    // ìƒìˆ˜ ì„ ì–¸
    // aì™€ bë¥¼ ê°ê° ë¬¸ìì—´ 'a'ì™€ 'b'ë¡œ ì´ˆê¸°í™”, ì´ ê°’ë“¤ì€ ë³€ê²½ë˜ì§€ ì•ŠëŠ” ìƒìˆ˜ì´ë‹¤.
    const a = 'a';
    const b = 'b';
    
    // switchë¬¸
    // ê°ì²´ objì˜ ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ì—¬ëŸ¬ caseì™€ ë§¤ì¹­í•œë‹¤.
    switch (obj) {
    // ë¦¬ìŠ¤íŠ¸ íŒ¨í„´ ë§¤ì¹­
    // ì´ caseëŠ” ë¦¬ìŠ¤íŠ¸ íŒ¨í„´ [a, b]ë¥¼ ì‚¬ìš©í•˜ì—¬ objì™€ ë§¤ì¹­.
    // ì´ íŒ¨í„´ì€ objê°€ ë‘ ê°œì˜ í•„ë“œë¥¼ ê°€ì§„ ë¦¬ìŠ¤íŠ¸ì¼ ë•Œ, ê·¸ë¦¬ê³  ê·¸ í•„ë“œë“¤ì´ ê°ê° ìƒìˆ˜ aì™€ bì™€ ì¼ì¹˜í•  ë•Œ ë§¤ì¹­ëœë‹¤.
    	// ë¨¼ì €, objê°€ ë‘ ê°œì˜ ìš”ì†Œë¥¼ ê°€ì§„ ë¦¬ìŠ¤íŠ¸ì¸ì§€ í™•ì¸
    	// ê·¸ ë‹¤ìŒ, ë¦¬ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ ìš”ì†Œê°€ ìƒìˆ˜ a (ì¦‰, 'a')ì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
    	// ë¦¬ìŠ¤íŠ¸ì˜ ë‘ ë²ˆì§¸ ìš”ì†Œê°€ ìƒìˆ˜ b (ì¦‰, 'b')ì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
    	// ë§Œì•½ objê°€ [a, b] íŒ¨í„´ê³¼ ì¼ì¹˜í•˜ë©´, print('$a, $b'); êµ¬ë¬¸ì´ ì‹¤í–‰
    	case [a, b]:
    	  print('$a, $b');
    }
    
    ```
    

**To ignore parts of a matched value, you can use a [wildcard pattern](https://dart.dev/language/pattern-types#wildcard) as a placeholder. In the case of list patterns, you can use a [rest element](https://dart.dev/language/pattern-types#rest-element).**

ë§¤ì¹­ëœ ê°’ì˜ ì¼ë¶€ë¥¼ ë¬´ì‹œí•˜ë ¤ë©´ ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ì„ í”Œë ˆì´ìŠ¤í™€ë”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ë¦¬ìŠ¤íŠ¸ íŒ¨í„´ì˜ ê²½ìš°, ë‚˜ë¨¸ì§€ ìš”ì†Œë¥¼ ë‚˜íƒ€ë‚´ëŠ” rest elementë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

-   **[Q] ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ì„ í”Œë ˆì´ìŠ¤í™€ë”ë¡œ ì‚¬ìš©?**
    
    **í”Œë ˆì´ìŠ¤í™€ë”**
    
    ì—¬ê¸°ì—ì„œ í”Œë ˆì´ìŠ¤í™€ë”ë€, íŒ¨í„´ ë§¤ì¹­ì—ì„œ íŠ¹ì • ê°’ì„ ë¬´ì‹œí•˜ê±°ë‚˜ ê´€ì‹¬ì´ ì—†ëŠ” ê°’ì„ ëŒ€ì²´í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë˜ëŠ” ê¸°í˜¸ë‚˜ ë³€ìˆ˜ë¥¼ ì˜ë¯¸í•œë‹¤. í”Œë ˆì´ìŠ¤í™€ë”ëŠ” ì‹¤ì œë¡œ ê°’ì„ ì €ì¥í•˜ê±°ë‚˜ ì‚¬ìš©í•˜ì§€ ì•Šì§€ë§Œ, íŒ¨í„´ì˜ í˜•íƒœë¥¼ ìœ ì§€í•˜ëŠ” ë° ì‚¬ìš©ëœë‹¤.
    
    **ì™€ì¼ë“œ ì¹´ë“œ íŒ¨í„´**
    
    ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ì€ íŠ¹ì • ìœ„ì¹˜ì˜ ê°’ì„ ë¬´ì‹œí•˜ê±°ë‚˜ ëŒ€ì²´í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë˜ëŠ” íŒ¨í„´ìœ¼ë¡œ, íŒ¨í„´ ë§¤ì¹­ ì‹œ ì¼ë¶€ ìš”ì†Œë¥¼ ì‹ ê²½ ì“°ì§€ ì•Šê³  ë„˜ì–´ê°ˆ ìˆ˜ ìˆë‹¤. Dartì—ì„œëŠ” ë°‘ì¤„ (underscore, _)ì„ ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ìœ¼ë¡œ ì‚¬ìš©í•œë‹¤.
    

### **Destructuring**[#](https://dart.dev/language/patterns#destructuring) **êµ¬ì¡° ë¶„í•´**

**When an object and pattern match, the pattern can then access the object's data and extract it in parts. In other words, the pattern _destructures_ the object:**

ê°ì²´ì™€ íŒ¨í„´ì´ ë§¤ì¹­ë˜ë©´, íŒ¨í„´ì€ ê°ì²´ì˜ ë°ì´í„°ë¥¼ ì ‘ê·¼í•˜ì—¬ ë¶€ë¶„ì ìœ¼ë¡œ ì¶”ì¶œí•  ìˆ˜ ìˆë‹¤. ì¦‰, íŒ¨í„´ì´ ê°ì²´ë¥¼ êµ¬ì¡° ë¶„í•´í•œë‹¤ëŠ” ê²ƒì´ë‹¤:

```dart
var numList = [1, 2, 3];
// List pattern [a, b, c] destructures the three elements from numList...
var [a, b, c] = numList;
// ...and assigns them to new variables.
print(a + b + c);

```

**You can nest [any kind of pattern](https://dart.dev/language/pattern-types) inside a destructuring pattern. For example, this case pattern matches and destructures a two-element list whose first element is `'a'` or `'b'`:**

êµ¬ì¡° ë¶„í•´ íŒ¨í„´ ì•ˆì— ì–´ë–¤ ì¢…ë¥˜ì˜ íŒ¨í„´ë„ ì¤‘ì²©í•  ìˆ˜ ìˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì´ ê²½ìš° íŒ¨í„´ì€ ì²« ë²ˆì§¸ ìš”ì†Œê°€ â€˜aâ€™ ë˜ëŠ” â€˜bâ€™ì¸ ë‘ ìš”ì†Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ë§¤ì¹­í•˜ê³  ë¶„í•´í•œë‹¤:

```dart
switch (list) {
  case ['a' || 'b', var c]:
    print(c);
}

```

-   **[note] ì¶”ê°€ ì½”ë“œ ì˜ˆì‹œ**
    
    Dartì—ì„œëŠ” í˜„ì¬ ê°ì²´ ë¶„í•´(destructuring)ë¥¼ ì§ì ‘ì ìœ¼ë¡œ ì§€ì›í•˜ì§€ ì•Šì§€ë§Œ, ê°ì²´ì˜ ì†ì„±ì„ ê°œë³„ ë³€ìˆ˜ì— í• ë‹¹í•˜ì—¬ ìœ ì‚¬í•œ ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤. ì•„ë˜ ì½”ë“œëŠ” ê°ì²´ì˜ ë°ì´í„°ë¥¼ ì¶”ì¶œí•˜ê³  ë³€ìˆ˜ë¥¼ í• ë‹¹í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤€ë‹¤.
    
    ```dart
    class Person {
      final String name;
      final int age;
    
      Person(this.name, this.age);
    }
    
    void main() {
      // Person ê°ì²´ ìƒì„±
      var person = Person('Alice', 30);
    
      // ê°ì²´ì—ì„œ ë°ì´í„° ì¶”ì¶œ
      var name = person.name;
      var age = person.age;
    
      // ì¶”ì¶œëœ ë°ì´í„° ì¶œë ¥
      print('Name: $name'); // ì¶œë ¥: Name: Alice
      print('Age: $age');   // ì¶œë ¥: Age: 30
    }
    
    ```
    


## **Places patterns can appear[#](https://dart.dev/language/patterns#places-patterns-can-appear) íŒ¨í„´ì´ ì‚¬ìš©ë  ìˆ˜ ìˆëŠ” ìœ„ì¹˜**

**You can use patterns in several places in the Dart language:**

Dart ì–¸ì–´ì—ì„œëŠ” ì—¬ëŸ¬ ê³³ì—ì„œ íŒ¨í„´ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤:

-   **Local variable [declarations](https://dart.dev/language/patterns#variable-declaration) and [assignments](https://dart.dev/language/patterns#variable-assignment)**
    
    ë¡œì»¬ ë³€ìˆ˜ ì„ ì–¸ ë° í• ë‹¹
    
-   [**for and for-in loops**](https://dart.dev/language/loops#for-loops)
    
    for ë° for-in ë£¨í”„
    
-   [**if-case](https://dart.dev/language/branches#if-case) and [switch-case](https://dart.dev/language/branches#switch-statements)**
    
    if-case ë° switch-case
    
-   **Control flow in [collection literals](https://dart.dev/language/collections#control-flow-operators)**
    
    ì»¬ë ‰ì…˜ ë¦¬í„°ëŸ´ì—ì„œì˜ ì œì–´ íë¦„
    

**This section describes common use cases for matching and destructuring with patterns.**

ì´ ì„¹ì…˜ì—ì„œëŠ” íŒ¨í„´ì„ ì‚¬ìš©í•œ ë§¤ì¹­ ë° êµ¬ì¡° ë¶„í•´ì˜ ì¼ë°˜ì ì¸ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ì„¤ëª…í•œë‹¤.

### **Variable declaration[#](https://dart.dev/language/patterns#variable-declaration) ë³€ìˆ˜ ì„ ì–¸**

**You can use a _pattern variable declaration_ anywhere Dart allows local variable declaration. The pattern matches against the value on the right of the declaration. Once matched, it destructures the value and binds it to new local variables:**

Dartì—ì„œ ë¡œì»¬ ë³€ìˆ˜ ì„ ì–¸ì´ í—ˆìš©ë˜ëŠ” ê³³ ì–´ë””ì—ì„œë“  íŒ¨í„´ ë³€ìˆ˜ ì„ ì–¸ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. íŒ¨í„´ì€ ì„ ì–¸ì˜ ì˜¤ë¥¸ìª½ ê°’ê³¼ ë§¤ì¹­ëœë‹¤. ë§¤ì¹­ì´ ì™„ë£Œë˜ë©´ ê°’ì„ êµ¬ì¡° ë¶„í•´í•˜ê³  ì´ë¥¼ ìƒˆë¡œìš´ ë¡œì»¬ ë³€ìˆ˜ì— ë°”ì¸ë”©í•œë‹¤:

```dart
// ìƒˆë¡œìš´ ë³€ìˆ˜ a, b, cë¥¼ ì„ ì–¸í•©ë‹ˆë‹¤.
var (a, [b, c]) = ('str', [1, 2]);

```

**A pattern variable declaration must start with either `var` or `final`, followed by a pattern.**

íŒ¨í„´ ë³€ìˆ˜ ì„ ì–¸ì€ ë°˜ë“œì‹œ var ë˜ëŠ” finalë¡œ ì‹œì‘í•˜ê³ , ê·¸ ë’¤ì— íŒ¨í„´ì´ ì™€ì•¼ í•œë‹¤.

-   **[Q] ì™œ ë°˜ë“œì‹œ `var` or `final` ë¡œ ì‹œì‘í•´ì•¼ í• ê¹Œ?**
    
    ----------
    
    íŒ¨í„´ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•  ë•Œ varë‚˜ finalë¡œ ì‹œì‘í•˜ëŠ” ì´ìœ ëŠ” ë³€ìˆ˜ ì„ ì–¸ì˜ ëª…í™•ì„±ê³¼ ì•ˆì •ì„±ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ì„œì´ë‹¤. Dart ì–¸ì–´ëŠ” ë³€ìˆ˜ì˜ ë²”ìœ„ì™€ ìƒëª…ì£¼ê¸°ë¥¼ ëª…í™•íˆ í•˜ê¸° ìœ„í•´ ì´ì™€ ê°™ì€ ê·œì¹™ì„ ì‚¬ìš©í•œë‹¤.
    
    **ì´ìœ  ì„¤ëª…**
    
    -   **ëª…í™•í•œ ë³€ìˆ˜ ì„ ì–¸**:
        -   varë‚˜ final í‚¤ì›Œë“œë¡œ ì‹œì‘í•¨ìœ¼ë¡œì¨ ìƒˆë¡œìš´ ë³€ìˆ˜ê°€ ì„ ì–¸ëœë‹¤ëŠ” ê²ƒì„ ëª…í™•íˆ ì•Œ ìˆ˜ ìˆë‹¤.
        -   ì´ë¥¼ í†µí•´ ì½”ë“œ ê°€ë…ì„±ì„ ë†’ì´ê³ , ë³€ìˆ˜ì˜ ë²”ìœ„ì™€ ì‚¬ìš© ìœ„ì¹˜ë¥¼ ì‰½ê²Œ ì•Œ ìˆ˜ ìˆë‹¤.
    -   **íƒ€ì… ì•ˆì •ì„±**:
        -   `var` í‚¤ì›Œë“œëŠ” ë³€ìˆ˜ì˜ íƒ€ì…ì„ ì»´íŒŒì¼ íƒ€ì„ì— ì¶”ë¡ í•œë‹¤. ì´ëŠ” íƒ€ì… ì•ˆì „ì„±ì„ ìœ ì§€í•˜ê³  ì½”ë“œì˜ ìœ ì—°ì„±ì„ ì œê³µí•œë‹¤.
        -   `final` í‚¤ì›Œë“œëŠ” ë³€ìˆ˜ì˜ ê°’ì„ í•œ ë²ˆë§Œ í• ë‹¹í•  ìˆ˜ ìˆê²Œ í•˜ì—¬, ë¶ˆë³€ì„±ì„ ë³´ì¥í•œë‹¤. ì´ëŠ” ì½”ë“œì˜ ì˜ˆì¸¡ ê°€ëŠ¥ì„±ì„ ë†’ì´ê³ , ì˜ë„ì¹˜ ì•Šì€ ë³€ê²½ì„ ë°©ì§€í•œë‹¤.
    -   **ë³€ìˆ˜ì˜ ìƒëª…ì£¼ê¸° ê´€ë¦¬**:
        -   ë³€ìˆ˜ ì„ ì–¸ í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•¨ìœ¼ë¡œì¨ ë³€ìˆ˜ì˜ ìƒëª…ì£¼ê¸°ë¥¼ ëª…í™•íˆ ê´€ë¦¬í•  ìˆ˜ ìˆë‹¤. ì´ëŠ” ë©”ëª¨ë¦¬ ê´€ë¦¬ë¥¼ í¬í•¨í•œ ë‹¤ì–‘í•œ ìµœì í™”ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•œë‹¤.
    
    ----------
    

### **Variable assignment[#](https://dart.dev/language/patterns#variable-assignment) ë³€ìˆ˜ í• ë‹¹**

**A _variable assignment pattern_ falls on the left side of an assignment. First, it destructures the matched object. Then it assigns the values to _existing_ variables, instead of binding new ones.**

ë³€ìˆ˜ í• ë‹¹ íŒ¨í„´ì€ í• ë‹¹ë¬¸ì˜ ì™¼ìª½ì— ìœ„ì¹˜í•œë‹¤. ë¨¼ì € ë§¤ì¹­ëœ ê°ì²´ë¥¼ êµ¬ì¡° ë¶„í•´í•œ ë‹¤ìŒ, ìƒˆë¡œìš´ ë³€ìˆ˜ë¥¼ ë°”ì¸ë”©í•˜ëŠ” ëŒ€ì‹  ê¸°ì¡´ ë³€ìˆ˜ì— ê°’ì„ í• ë‹¹í•œë‹¤.

**Use a variable assignment pattern to swap the values of two variables without declaring a third temporary one:**

ë³€ìˆ˜ í• ë‹¹ íŒ¨í„´ì„ ì‚¬ìš©í•˜ì—¬ ì„¸ ë²ˆì§¸ ì„ì‹œ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ì§€ ì•Šê³  ë‘ ë³€ìˆ˜ì˜ ê°’ì„ êµí™˜í•  ìˆ˜ ìˆë‹¤:

```dart
var (a, b) = ('left', 'right');
(b, a) = (a, b); // Swap.
print('$a $b'); // Prints "right left".

```

-   **[note] ìŠ¤ì™‘(Swap)ì´ë€? (ì½”ë“œ ì£¼ì„ ì¶”ê°€)**
    
    ìœ„ì— ë¬¸ì„œì— ë‚˜ì˜¤ëŠ” ì½”ë“œëŠ” íŠœí”Œì„ ì‚¬ìš©í•˜ì—¬ ë³€ìˆ˜ì˜ ê°’ì„ ë°”ê¾¸ëŠ”(ìŠ¤ì™‘í•˜ëŠ”) ì˜ˆì œì´ë‹¤.
    
    ```dart
    void main() {
      // íŠœí”Œ ë¶„í•´ë¥¼ ì‚¬ìš©í•˜ì—¬ ë³€ìˆ˜ ì„ ì–¸ ë° ì´ˆê¸°í™”
      // íŠœí”Œ ('left', 'right')ë¥¼ ë¶„í•´í•˜ì—¬ aì™€ b ë³€ìˆ˜ì— ê°ê° 'left'ì™€ 'right'ë¥¼ í• ë‹¹
      var (a, b) = ('left', 'right');
    
      // íŠœí”Œ ë¶„í•´ë¥¼ ì‚¬ìš©í•˜ì—¬ ë³€ìˆ˜ ê°’ ìŠ¤ì™‘
      // bëŠ” aì˜ ê°’ 'left'ë¥¼ ë°›ê³ , aëŠ” bì˜ ê°’ 'right'ë¥¼ ë°›ìŒ
      // ë”°ë¼ì„œ aì˜ ê°’ì€ 'right'ê°€ ë˜ê³ , bì˜ ê°’ì€ 'left'ê°€ ë˜ëŠ” ê²ƒ
      (b, a) = (a, b);
    
      // ê²°ê³¼ ì¶œë ¥
      print('$a $b'); // ì¶œë ¥: right left
    }
    
    ```
    
-   **[note] íŠœí”Œ(Tuple)? â†’ Dartì˜ ë ˆì½”ë“œ(Record)**
    
    ----------
    
    íŠœí”Œì€ ì—¬ëŸ¬ ê°œì˜ ê°’ì„ í•˜ë‚˜ì˜ ë³µí•© ë°ì´í„° êµ¬ì¡°ë¡œ ë¬¶ëŠ” ë°©ì‹ì´ë‹¤. íŠœí”Œì˜ ê° ìš”ì†ŒëŠ” ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ì„ ê°€ì§ˆ ìˆ˜ ìˆìœ¼ë©°, ê³ ì •ëœ í¬ê¸°ë¥¼ ê°€ì§€ëŠ” ê²ƒì´ íŠ¹ì§•ì´ë‹¤. íŠœí”Œì€ ì£¼ë¡œ í•¨ìˆ˜ì—ì„œ ì—¬ëŸ¬ ê°’ì„ ë°˜í™˜í•˜ê±°ë‚˜, ê´€ë ¨ëœ ì—¬ëŸ¬ ê°’ì„ í•œêº¼ë²ˆì— ë‹¤ë£¨ê¸° ìœ„í•´ ì‚¬ìš©ëœë‹¤.
    
    <aside> â„¹ï¸ **Version note**
    
    Dart 3.0ë¶€í„° ë„ì…ëœ ë ˆì½”ë“œ íƒ€ì…ì´ íŠœí”Œê³¼ ë§¤ìš° ìœ ì‚¬í•œ ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤. ì‚¬ì‹¤ìƒ ë ˆì½”ë“œëŠ” Dartì—ì„œ íŠœí”Œì˜ ì—­í• ì„ ìˆ˜í–‰í•œë‹¤ê³  ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    
    </aside>
    
    **íŠ¹ì§•**
    
    -   **ê³ ì •ëœ í¬ê¸°**: íŠœí”Œì€ ìƒì„±ë  ë•Œ ì •í•´ì§„ ìˆ˜ì˜ ìš”ì†Œë¥¼ ê°€ì§€ë©°, ê·¸ í¬ê¸°ëŠ” ë³€ê²½ë˜ì§€ ì•ŠëŠ”ë‹¤.
    -   **ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…**: íŠœí”Œì˜ ê° ìš”ì†ŒëŠ” ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ì¼ ìˆ˜ ìˆë‹¤.
    -   **ìˆœì„œê°€ ìˆìŒ**: íŠœí”Œì˜ ìš”ì†Œë“¤ì€ ì •ì˜ëœ ìˆœì„œëŒ€ë¡œ ì €ì¥ë˜ê³ , ì¸ë±ìŠ¤ë¥¼ í†µí•´ ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.
    
    **ì°¨ì´ì **
    
    -   **ì •ì˜ì™€ ìš©ë„**:
        -   **ë ˆì½”ë“œ(Record)**: í•„ë“œì˜ ì´ë¦„ì„ ëª…í™•íˆ ì§€ì •í•˜ì—¬ ì‚¬ìš©í•˜ê±°ë‚˜ ìœ„ì¹˜ ê¸°ë°˜ìœ¼ë¡œ ì‚¬ìš©ëœë‹¤. í•„ë“œ ì´ë¦„ì„ í†µí•´ ë” ëª…í™•í•˜ê³  ì˜ë¯¸ ìˆëŠ” ë°ì´í„° êµ¬ì¡°ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.
        -   **íŠœí”Œ(Tuple)**: ì£¼ë¡œ ìœ„ì¹˜ ê¸°ë°˜ìœ¼ë¡œ ì‚¬ìš©ë˜ë©°, í•„ë“œ ì´ë¦„ì„ ê°€ì§€ì§€ ì•ŠëŠ”ë‹¤. ë‹¨ìˆœíˆ ì—¬ëŸ¬ ê°’ì„ ë¬¶ëŠ” ìš©ë„ë¡œ ì‚¬ìš©ëœë‹¤.
    -   **ëª…ëª…ëœ í•„ë“œ**:
        -   **ë ˆì½”ë“œ**: í•„ë“œì— ì´ë¦„ì„ ë¶€ì—¬í•  ìˆ˜ ìˆì–´ ì½”ë“œì˜ ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì´ ë†’ì•„ì§„ë‹¤.
        -   **íŠœí”Œ**: í•„ë“œ ì´ë¦„ì´ ì—†ìœ¼ë©°, ìœ„ì¹˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•„ë“œì— ì ‘ê·¼í•œë‹¤.
    -   **ì–¸ì–´ ì§€ì›**:
        -   **ë ˆì½”ë“œ**: Dart 3.0ë¶€í„° ë„ì…ëœ ìƒˆë¡œìš´ ë°ì´í„° íƒ€ì…ì´ë‹¤.
        -   **íŠœí”Œ**: Dartì—ì„œëŠ” ì§ì ‘ì ì¸ íŠœí”Œ íƒ€ì…ì„ ì œê³µí•˜ì§€ ì•Šì§€ë§Œ, Dartì˜ ë ˆì½”ë“œëŠ” íŠœí”Œê³¼ ìœ ì‚¬í•œ ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.
    
    ----------
    
-   **[note] ë ˆì½”ë“œ(Record)ë€?**
    
    ë ˆì½”ë“œëŠ” ì—¬ëŸ¬ ê°œì˜ ê°’ì„ í•˜ë‚˜ì˜ ë‹¨ìœ„ë¡œ ë¬¶ì–´ì£¼ëŠ” ë°ì´í„° êµ¬ì¡°ì´ë‹¤. ë ˆì½”ë“œëŠ” Dart 3.0ë¶€í„° ë„ì…ëœ ìƒˆë¡œìš´ ë°ì´í„° íƒ€ì…ìœ¼ë¡œ, ì—¬ëŸ¬ ê°’ì„ í•˜ë‚˜ì˜ ë³€ìˆ˜ë¡œ ë‹¤ë£° ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤.
    
    **ìƒì„± ë° ì‚¬ìš© ë°©ë²•**
    
    ```dart
    void main() {
      // ë ˆì½”ë“œ ìƒì„±
      var person = ('Alice', 30);
    
      // ë ˆì½”ë“œì˜ ê° í•„ë“œì— ì ‘ê·¼
      var (name, age) = person;
    
      // í•„ë“œ ê°’ ì¶œë ¥
      print('Name: $name'); // ì¶œë ¥: Name: Alice
      print('Age: $age');   // ì¶œë ¥: Age: 30
    }
    
    ```
    
    **í•¨ìˆ˜ì—ì„œ ë ˆì½”ë“œ ë°˜í™˜**
    
    ë ˆì½”ë“œëŠ” ì—¬ëŸ¬ ê°’ì„ ë¬¶ì–´ì„œ ë°˜í™˜í•˜ê±°ë‚˜ ì „ë‹¬í•  ë•Œ ìœ ìš©í•˜ë‹¤. ë ˆì½”ë“œëŠ” ì—¬ëŸ¬ ê°œì˜ í•„ë“œë¥¼ ê°€ì§€ë©°, ê° í•„ë“œëŠ” ìœ„ì¹˜ì— ë”°ë¼ ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì²« ë²ˆì§¸ í•„ë“œëŠ” ì²« ë²ˆì§¸ ìœ„ì¹˜, ë‘ ë²ˆì§¸ í•„ë“œëŠ” ë‘ ë²ˆì§¸ ìœ„ì¹˜ì— ìˆë‹¤.
    
    ```dart
    // ì´ë¦„ê³¼ ë‚˜ì´ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
    (String, int) getPerson() {
      return ('Bob', 25);
    }
    
    void main() {
      // í•¨ìˆ˜ í˜¸ì¶œí•˜ì—¬ ë ˆì½”ë“œ ë°˜í™˜ë°›ê¸°
      var person = getPerson();
    
      // ë ˆì½”ë“œ ë¶„í•´
      var (name, age) = person;
    
      // í•„ë“œ ê°’ ì¶œë ¥
      print('Name: $name'); // ì¶œë ¥: Name: Bob
      print('Age: $age');   // ì¶œë ¥: Age: 25
    }
    
    ```
    
    **ë‹¤ì–‘í•œ ë ˆì½”ë“œ ì„ ì–¸ ë°©ì‹**
    
    -   **var í‚¤ì›Œë“œ**
        
        ë³€ìˆ˜ì˜ íƒ€ì…ì„ ì¶”ë¡ í•œë‹¤. ë ˆì½”ë“œì˜ ìš”ì†Œ íƒ€ì…ì„ ëª…ì‹œí•˜ì§€ ì•Šê³  ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
        
        ```dart
        void main() {
          // var í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë ˆì½”ë“œ ì„ ì–¸
          var point = (10, 20);
        
          // ë ˆì½”ë“œ ë¶„í•´
          var (x, y) = point;
        
          print('x: $x'); // ì¶œë ¥: x: 10
          print('y: $y'); // ì¶œë ¥: y: 20
        }
        
        ```
        
    -   **final í‚¤ì›Œë“œ**
        
        ë¶ˆë³€ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ë©°, í•œ ë²ˆ í• ë‹¹ëœ ê°’ì€ ë³€ê²½í•  ìˆ˜ ì—†ë‹¤.
        
        ```dart
        void main() {
          // final í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë¶ˆë³€ ë ˆì½”ë“œ ì„ ì–¸
          final person = (name: 'Alice', age: 30);
        
          // ë ˆì½”ë“œ ë¶„í•´
          final (name: n, age: a) = person;
        
          print('Name: $n, Age: $a'); // ì¶œë ¥: Name: Alice, Age: 30
        }
        
        ```
        
    -   **ëª…ì‹œì ì¸ íƒ€ì… ì„ ì–¸**
        
        ë ˆì½”ë“œì˜ ê° ìš”ì†Œ íƒ€ì…ì„ ëª…ì‹œì ìœ¼ë¡œ ì„ ì–¸í•  ìˆ˜ ìˆìœ¼ë©°, ì´ë¥¼ í†µí•´ ì½”ë“œì˜ íƒ€ì… ì•ˆì •ì„±ì„ ë†’ì¼ ìˆ˜ ìˆë‹¤.
        
        ```dart
        void main() {
          // ëª…ì‹œì ì¸ íƒ€ì… ì„ ì–¸ì„ ì‚¬ìš©í•˜ì—¬ ë ˆì½”ë“œ ì„ ì–¸
          (String, int, bool) person = ('Bob', 25, true);
        
          // ë ˆì½”ë“œ ë¶„í•´
          var (name, age, isActive) = person;
        
          print('Name: $name, Age: $age, Active: $isActive');
          // ì¶œë ¥: Name: Bob, Age: 25, Active: true
        }
        
        ```
        

### **Switch statements and expressions[#](https://dart.dev/language/patterns#switch-statements-and-expressions) Switch ë¬¸ê³¼ í‘œí˜„ì‹**

**Every case clause contains a pattern. This applies to [switch statements](https://dart.dev/language/branches#switch-statements) and [expressions](https://dart.dev/language/branches#switch-expressions), as well as [if-case statements](https://dart.dev/language/branches#if-case). You can use [any kind of pattern](https://dart.dev/language/pattern-types) in a case.**

ê° case ì ˆì€ íŒ¨í„´ì„ í¬í•¨í•œë‹¤. ì´ëŠ” switch ë¬¸ê³¼ í‘œí˜„ì‹, if-case ë¬¸ì—ë„ ì ìš©ëœë‹¤. caseì—ì„œëŠ” ì–´ë–¤ ì¢…ë¥˜ì˜ íŒ¨í„´ë„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

**_Case patterns_ are [refutable](https://dart.dev/resources/glossary#refutable-pattern). They allow control flow to either:**

case íŒ¨í„´ì€ ê±°ë¶€ ê°€ëŠ¥í•˜ë‹¤. ì´ëŠ” ì œì–´ íë¦„ì„ ë‹¤ìŒ ë‘ ê°€ì§€ ì¤‘ í•˜ë‚˜ë¡œ í—ˆìš©í•œë‹¤:

-   **Match and destructure the object being switched on.**
    
    ë§¤ì¹­í•˜ì—¬ ìŠ¤ìœ„ì¹˜ëœ ê°ì²´ë¥¼ êµ¬ì¡° ë¶„í•´í•œë‹¤.
    
-   **Continue execution if the object doesn't match.**
    
    ê°ì²´ê°€ ë§¤ì¹­ë˜ì§€ ì•Šìœ¼ë©´ ì‹¤í–‰ì„ ê³„ì†í•œë‹¤.
    

**The values that a pattern destructures in a case become local variables. Their scope is only within the body of that case.**

caseì—ì„œ íŒ¨í„´ì´ êµ¬ì¡° ë¶„í•´í•˜ëŠ” ê°’ì€ ë¡œì»¬ ë³€ìˆ˜ê°€ ëœë‹¤. ì´ ë³€ìˆ˜ë“¤ì˜ ìœ íš¨ ë²”ìœ„ëŠ” í•´ë‹¹ case ë³¸ë¬¸ ë‚´ì—ì„œë§Œ ìœ íš¨í•˜ë‹¤.

```dart
switch (obj) {
  // Matches if 1 == obj.
  case 1:
    print('one');

  // Matches if the value of obj is between the
  // constant values of 'first' and 'last'.
  // objì˜ ê°’ì´ 'first'ì™€ 'last'ì˜ ìƒìˆ˜ ê°’ ì‚¬ì´ì— ìˆì„ ë•Œ ë§¤ì¹­ëœë‹¤.
  case >= first && <= last:
    print('in range');

  // Matches if obj is a record with two fields,
  // then assigns the fields to 'a' and 'b'.
  // objê°€ ë‘ ê°œì˜ í•„ë“œë¥¼ ê°€ì§„ ë ˆì½”ë“œì¼ ë•Œ ë§¤ì¹­ë˜ë©°,
  // í•„ë“œë¥¼ 'a'ì™€ 'b'ì— í• ë‹¹í•œë‹¤.
  case (var a, var b):
    print('a = $a, b = $b');

  default:
}

```

[**Logical-or patterns](https://dart.dev/language/pattern-types#logical-or) are useful for having multiple cases share a body in switch expressions or statements:**

ë…¼ë¦¬ì  OR(||) íŒ¨í„´ì€ ì—¬ëŸ¬ ê²½ìš°ê°€ switch í‘œí˜„ì‹ì´ë‚˜ ë¬¸ì¥ì—ì„œ ë™ì¼í•œ ë³¸ë¬¸ì„ ê³µìœ í•˜ë„ë¡ í•˜ëŠ” ë° ìœ ìš©í•˜ë‹¤:

```dart
var isPrimary = switch (color) {
  Color.red || Color.yellow || Color.blue => true,
  _ => false
};

```

**Switch statements can have multiple cases share a body [without using logical-or patterns](https://dart.dev/language/branches#switch-share), but they are still uniquely useful for allowing multiple cases to share a [guard](https://dart.dev/language/branches#guard-clause):**

Switch ë¬¸ì€ ë…¼ë¦¬ì  OR íŒ¨í„´ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³ ë„ ì—¬ëŸ¬ ê²½ìš°ê°€ ë³¸ë¬¸ì„ ê³µìœ í•  ìˆ˜ ìˆì§€ë§Œ, ì—¬ëŸ¬ ê²½ìš°ê°€ ê²½ê³„ ì¡°ê±´(guard)ì„ ê³µìœ í•˜ë„ë¡ í•˜ëŠ” ë° ì—¬ì „íˆ(íŠ¹íˆ) ìœ ìš©í•˜ë‹¤:

```dart
switch (shape) {
  case Square(size: var s) || Circle(size: var s) when s > 0:
    print('Non-empty symmetric shape');
}

```

[**Guard clauses](https://dart.dev/language/branches#guard-clause) evaluate an arbitrary conditon as part of a case, without exiting the switch if the condition is false (like using an `if` statement in the case body would cause).**

ê²½ê³„ ì¡°ê±´ì€ íŠ¹ì • ì¡°ê±´ì´ ê±°ì§“ì¼ ê²½ìš° switch ë¬¸ì„ ì¢…ë£Œí•˜ì§€ ì•Šê³ , caseì˜ ì¼ë¶€ë¡œ ì„ì˜ì˜ ì¡°ê±´ì„ í‰ê°€í•œë‹¤ (case ë³¸ë¬¸ì—ì„œ if ë¬¸ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ì²˜ëŸ¼).

```dart
switch (pair) {
  case (int a, int b):
    if (a > b) print('First element greater');
  // If false, prints nothing and exits the switch.
  case (int a, int b) when a > b:
    // If false, prints nothing but proceeds to next case.
    print('First element greater');
  case (int a, int b):
    print('First element not greater');
}

```

-   **[Q] ê²½ê³„ ì¡°ê±´(Guard clauses)ì´ë€?**
    
    ê²½ê³„ ì¡°ê±´(guard clause)ì€ íŠ¹ì • ì¡°ê±´ì´ ì°¸ì¸ì§€ ì—¬ë¶€ë¥¼ ê²€ì‚¬í•˜ì—¬, **ì¡°ê±´ì´ ì°¸ì¼ ë•Œë§Œ ì½”ë“œ ë¸”ë¡ì„ ì‹¤í–‰í•˜ë„ë¡ í•˜ëŠ” ì½”ë“œ íŒ¨í„´**ì´ë‹¤. Dartì—ì„œ if-case ë˜ëŠ” switch ë¬¸ ë‚´ì—ì„œ ê²½ê³„ ì¡°ê±´ì„ ì‚¬ìš©í•˜ì—¬ ì¡°ê±´ì„ ë” ì •ë°€í•˜ê²Œ ê²€ì‚¬í•  ìˆ˜ ìˆë‹¤.
    

### **For and for-in loops[#](https://dart.dev/language/patterns#for-and-for-in-loops) for ë° for-in ë£¨í”„**

**You can use patterns in [for and for-in loops](https://dart.dev/language/loops#for-loops) to iterate-over and destructure values in a collection.**

for ë° for-in ë£¨í”„ì—ì„œ íŒ¨í„´ì„ ì‚¬ìš©í•˜ì—¬ ì»¬ë ‰ì…˜ì˜ ê°’ì„ ë°˜ë³µí•˜ê³  êµ¬ì¡° ë¶„í•´í•  ìˆ˜ ìˆë‹¤.

**This example uses [object destructuring](https://dart.dev/language/pattern-types#object) in a for-in loop to destructure the [`MapEntry`](https://api.dart.dev/stable/dart-core/MapEntry-class.html) objects that a `<Map>.entries` call returns:**

ì´ ì˜ˆì œì—ì„œëŠ” for-in ë£¨í”„ì—ì„œ ê°ì²´ êµ¬ì¡° ë¶„í•´ë¥¼ ì‚¬ìš©í•˜ì—¬ <Map>.entries í˜¸ì¶œì´ ë°˜í™˜í•˜ëŠ” MapEntry ê°ì²´ë¥¼ êµ¬ì¡° ë¶„í•´í•œë‹¤:

```dart
Map<String, int> hist = {
  'a': 23,
  'b': 100,
};

for (var MapEntry(key: key, value: count) in hist.entries) {
  print('$key occurred $count times');
}

```

**The object pattern checks that `hist.entries` has the named type `MapEntry`, and then recurses into the named field subpatterns `key` and `value`. It calls the `key` getter and `value` getter on the `MapEntry` in each iteration, and binds the results to local variables `key` and `count`, respectively.**

ê°ì²´ íŒ¨í„´ì€ hist.entriesê°€ MapEntryë¼ëŠ” ì´ë¦„ì˜ íƒ€ì…ì„ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸í•œ ë‹¤ìŒ, keyì™€ valueë¼ëŠ” ì´ë¦„ì˜ í•„ë“œ ì„œë¸ŒíŒ¨í„´ìœ¼ë¡œ ì¬ê·€ì ìœ¼ë¡œ ë“¤ì–´ê°‘ë‹ˆë‹¤. ê° ë°˜ë³µì—ì„œ MapEntryì˜ key ê²Œí„°ì™€ value ê²Œí„°ë¥¼ í˜¸ì¶œí•˜ì—¬ ê²°ê³¼ë¥¼ ê°ê° ë¡œì»¬ ë³€ìˆ˜ keyì™€ countì— ë°”ì¸ë”©í•©ë‹ˆë‹¤.

**Binding the result of a getter call to a variable of the same name is a common use case, so object patterns can also infer the getter name from the [variable subpattern](https://dart.dev/language/pattern-types#variable). This allows you to simplify the variable pattern from something redundant like `key: key` to just `:key`:**

ê²Œí„° í˜¸ì¶œì˜ ê²°ê³¼ë¥¼ ë™ì¼í•œ ì´ë¦„ì˜ ë³€ìˆ˜ì— ë°”ì¸ë”©í•˜ëŠ” ê²ƒì€ ì¼ë°˜ì ì¸ ì‚¬ìš© ì‚¬ë¡€ì´ê¸° ë•Œë¬¸ì—, ê°ì²´ íŒ¨í„´ì€ ë³€ìˆ˜ í•˜ìœ„ íŒ¨í„´ì—ì„œ ê²Œí„° ì´ë¦„ì„ ì¶”ë¡ í•  ìˆ˜ë„ ìˆë‹¤. ì´ëŠ” ì¤‘ë³µë˜ëŠ” key: keyì™€ ê°™ì€ ë³€ìˆ˜ íŒ¨í„´ì„ :keyì²˜ëŸ¼ ê°„ë‹¨í•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆê²Œ í•œë‹¤.

```dart
for (var MapEntry(:key, value: count) in hist.entries) {
  print('$key occurred $count times');
}

```

-   **[code] ì˜ˆì œ ì½”ë“œ ì¶”ê°€**
    
    ```dart
    void main() {
      // ì˜ˆì œ ë§µ ë°ì´í„°
      var hist = {'a': 3, 'b': 5, 'c': 2};
    
      // for-in ë£¨í”„ë¥¼ ì‚¬ìš©í•˜ì—¬ ë§µì˜ ì—”íŠ¸ë¦¬ë“¤ì„ ìˆœíšŒ
      // íŒ¨í„´ ë§¤ì¹­ì„ í†µí•œ ë³€ìˆ˜ ì¶”ì¶œí•˜ì—¬ ê°ê° keyì™€ count ë³€ìˆ˜ì— í• ë‹¹
      for (var MapEntry(:key, value: count) in hist.entries) {
        print('$key occurred $count times');
      }
    }
    
    ```
    
    ```dart
    // ì¶œë ¥ ê²°ê³¼
    
    a occurred 3 times
    b occurred 5 times
    c occurred 2 times
    
    ```
    

----------

## **Use cases for patterns[#](https://dart.dev/language/patterns#use-cases-for-patterns) íŒ¨í„´ì˜ ì‚¬ìš© ì‚¬ë¡€**

**The [previous section](https://dart.dev/language/patterns#places-patterns-can-appear) describes _how_ patterns fit into other Dart code constructs. You saw some interesting use cases as examples, like [swapping](https://dart.dev/language/patterns#variable-assignment) the values of two variables, or [destructuring key-value pairs](https://dart.dev/language/patterns#for-and-for-in-loops) in a map. This section describes even more use cases, answering:**

ì´ì „ ì„¹ì…˜ì—ì„œëŠ” íŒ¨í„´ì´ ë‹¤ë¥¸ Dart ì½”ë“œ êµ¬ì„± ìš”ì†Œì— ì–´ë–»ê²Œ ë§ì•„ë–¨ì–´ì§€ëŠ”ì§€ ì„¤ëª…í–ˆë‹¤. ë‘ ë³€ìˆ˜ì˜ ê°’ì„ êµí™˜í•˜ê±°ë‚˜ ë§µì—ì„œ í‚¤-ê°’ ìŒì„ êµ¬ì¡° ë¶„í•´í•˜ëŠ” ê²ƒê³¼ ê°™ì€ í¥ë¯¸ë¡œìš´ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ì˜ˆì œë¡œ ë³´ì•˜ë‹¤. ì´ ì„¹ì…˜ì—ì„œëŠ” ë” ë§ì€ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ì„¤ëª…í•˜ë©° ë‹¤ìŒ ì§ˆë¬¸ì— ë‹µí•œë‹¤:

-   **_When and why_ you might want to use patterns.**
    
    ì–¸ì œ ê·¸ë¦¬ê³  ì™œ íŒ¨í„´ì„ ì‚¬ìš©í•˜ê³  ì‹¶ì€ê°€?
    
-   **What kinds of problems they solve.**
    
    ì–´ë–¤ ì¢…ë¥˜ì˜ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ”ê°€?
    
-   **Which idioms they best suit.**
    
    ì–´ë–¤ ê´€ìš©êµ¬ì— ê°€ì¥ ì í•©í•œê°€?
    

### **Destructuring multiple returns[#](https://dart.dev/language/patterns#destructuring-multiple-returns) ì—¬ëŸ¬ ë°˜í™˜ê°’ì˜ êµ¬ì¡° ë¶„í•´**

**Records allow aggregating and [returning multiple values](https://dart.dev/language/records#multiple-returns) from a single function call. Patterns add the ability to destructure a record's fields directly into local variables, inline with the function call.**

ë ˆì½”ë“œë¥¼ ì‚¬ìš©í•˜ë©´ ë‹¨ì¼ í•¨ìˆ˜ í˜¸ì¶œì—ì„œ ì—¬ëŸ¬ ê°’ì„ ì§‘ê³„í•˜ê³  ë°˜í™˜í•  ìˆ˜ ìˆë‹¤. íŒ¨í„´ì„ ì‚¬ìš©í•˜ë©´ í•¨ìˆ˜ í˜¸ì¶œê³¼ í•¨ê»˜ ë ˆì½”ë“œì˜ í•„ë“œë¥¼ ë¡œì»¬ ë³€ìˆ˜ë¡œ ì§ì ‘ êµ¬ì¡° ë¶„í•´í•  ìˆ˜ ìˆë‹¤.

**Instead of individually declaring new local variables for each record field, like this:**

ê° ë ˆì½”ë“œ í•„ë“œì— ëŒ€í•´ ê°œë³„ì ìœ¼ë¡œ ìƒˆë¡œìš´ ë¡œì»¬ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ëŠ” ëŒ€ì‹ , ë‹¤ìŒê³¼ ê°™ì´ í•  ìˆ˜ ìˆë‹¤:

```dart
var info = userInfo(json);
var name = info.$1;
var age = info.$2;

```

**You can destructure the fields of a record that a function returns into local variables using a [variable declaration](https://dart.dev/language/patterns#variable-declaration) or [assigment pattern](https://dart.dev/language/patterns#variable-assignment), and a [record pattern](https://dart.dev/language/pattern-types#record) as its subpattern:**

ë³€ìˆ˜ ì„ ì–¸ ë˜ëŠ” í• ë‹¹ íŒ¨í„´ì„ ì‚¬ìš©í•˜ê³ , ë ˆì½”ë“œ íŒ¨í„´ì„ ì„œë¸ŒíŒ¨í„´ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ í•¨ìˆ˜ê°€ ë°˜í™˜í•˜ëŠ” ë ˆì½”ë“œì˜ í•„ë“œë¥¼ ë¡œì»¬ ë³€ìˆ˜ë¡œ êµ¬ì¡° ë¶„í•´í•  ìˆ˜ ìˆë‹¤:

```dart
var (name, age) = userInfo(json);

```

**To destructure a record with named fields using a pattern:**

ì´ë¦„ì´ ìˆëŠ” í•„ë“œë¥¼ ê°€ì§„ ë ˆì½”ë“œë¥¼ íŒ¨í„´ìœ¼ë¡œ êµ¬ì¡° ë¶„í•´í•˜ë ¤ë©´ ë‹¤ìŒê³¼ ê°™ì´ í•œë‹¤:

```dart
final (:name, :age) = getData(); // ì˜ˆ: return (name: 'doug', age: 25);

```

### **Destructuring class instances[#](https://dart.dev/language/patterns#destructuring-class-instances) í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ì˜ êµ¬ì¡° ë¶„í•´**

[**Object patterns](https://dart.dev/language/pattern-types#object) match against named object types, allowing you to destructure their data using the getters the object's class already exposes.**

ê°ì²´ íŒ¨í„´ì€ ì´ë¦„ì´ ì§€ì •ëœ ê°ì²´ íƒ€ì…ê³¼ ë§¤ì¹­ë˜ë©°, ê°ì²´ì˜ í´ë˜ìŠ¤ê°€ ì´ë¯¸ ë…¸ì¶œí•œ ê²Œí„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„°ë¥¼ êµ¬ì¡° ë¶„í•´í•  ìˆ˜ ìˆë‹¤.

**To destructure an instance of a class, use the named type, followed by the properties to destructure enclosed in parentheses:**

í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ êµ¬ì¡° ë¶„í•´í•˜ë ¤ë©´ ì´ë¦„ì´ ì§€ì •ëœ íƒ€ì…ì„ ì‚¬ìš©í•˜ê³ , êµ¬ì¡° ë¶„í•´í•  ì†ì„±ì„ ê´„í˜¸ ì•ˆì— ë„£ëŠ”ë‹¤:

```dart
final Foo myFoo = Foo(one: 'one', two: 2);
var Foo(:one, :two) = myFoo;
print('one $one, two $two');

```

-   **[code] ì˜ˆì œ ì½”ë“œ ì£¼ì„ ì¶”ê°€**
    
    ```dart
    void main() {
      // Foo ê°ì²´ ìƒì„±
      final Foo myFoo = Foo(one: 'one', two: 2);
    
      // ê°ì²´ ë¶„í•´ë¥¼ ì‚¬ìš©í•˜ì—¬ í•„ë“œ ê°’ì„ ë³€ìˆ˜ë¡œ ì¶”ì¶œ
      // one ë³€ìˆ˜ëŠ” 'one' ê°’ì„, two ë³€ìˆ˜ëŠ” 2 ê°’ì„ í• ë‹¹
      var Foo(:one, :two) = myFoo;
    
      // ê²°ê³¼ ì¶œë ¥
      print('one $one, two $two'); // ì¶œë ¥: one one, two 2
    }
    
    ```
    

### **Algebraic data types[#](https://dart.dev/language/patterns#algebraic-data-types) ëŒ€ìˆ˜ì  ë°ì´í„° íƒ€ì…**

**Object destructuring and switch cases are conducive to writing code in an [algebraic data type](https://en.wikipedia.org/wiki/Algebraic_data_type) style. Use this method when:**

ê°ì²´ êµ¬ì¡° ë¶„í•´ì™€ switch caseëŠ” ëŒ€ìˆ˜ì  ë°ì´í„° íƒ€ì… ìŠ¤íƒ€ì¼ë¡œ ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ” ë° ìœ ë¦¬í•˜ë‹¤. ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš°ì— ì´ ë°©ë²•ì„ ì‚¬ìš©í•´ë³´ì:

-   **You have a family of related types.**
    
    ê´€ë ¨ëœ íƒ€ì…ë“¤ì´ ìˆë‹¤.
    
-   **You have an operation that needs specific behavior for each type.**
    
    ê° íƒ€ì…ì— ëŒ€í•´ íŠ¹ì • ë™ì‘ì´ í•„ìš”í•œ ì‘ì—…ì´ ìˆë‹¤.
    
-   **You want to group that behavior in one place instead of spreading it across all the different type definitions.**
    
    ê·¸ ë™ì‘ì„ ì—¬ëŸ¬ íƒ€ì… ì •ì˜ì— ë¶„ì‚°ì‹œí‚¤ì§€ ì•Šê³  í•œ ê³³ì— ëª¨ìœ¼ê³  ì‹¶ë‹¤.
    
-   **[Q] ëŒ€ìˆ˜ì (Algebraic) ì´ë¼ëŠ”ê²Œ?**
    
    ----------
    
    â€œëŒ€ìˆ˜ì  ë°ì´í„° íƒ€ì…(Algebraic Data Type, ADT)â€œì€ í”„ë¡œê·¸ë˜ë°ì—ì„œ ë°ì´í„° íƒ€ì…ì„ ì •ì˜í•˜ëŠ” ë° ì‚¬ìš©í•˜ëŠ” ê°œë…ì´ë‹¤. ì´ëŠ” ë³´í†µ ë‘ ê°€ì§€ ì£¼ìš” ìœ í˜•ìœ¼ë¡œ êµ¬ì„±ëœë‹¤: **í•© íƒ€ì…(sum type)**ê³¼ **ê³± íƒ€ì…(product type)**.
    
    **í•© íƒ€ì… (Sum Type)**
    
    í•© íƒ€ì…ì€ ì—¬ëŸ¬ ë‹¤ë¥¸ íƒ€ì… ì¤‘ í•˜ë‚˜ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆëŠ” ë°ì´í„° íƒ€ì…ì„ ì •ì˜í•œë‹¤. Dartì—ì„œëŠ” `enum`ì´ ì´ì— í•´ë‹¹í•œë‹¤. ë‹¤ë¥¸ ì–¸ì–´ì—ì„œëŠ” Union íƒ€ì…ìœ¼ë¡œë„ ë¶ˆë¦¬ë©°, ì´ëŠ” ì—¬ëŸ¬ íƒ€ì… ì¤‘ í•˜ë‚˜ë¡œë§Œ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.
    
    ```dart
    enum Result {
      success,
      failure
    }
    
    ```
    
    **ê³± íƒ€ì… (Product Type)**
    
    ê³± íƒ€ì…ì€ ì—¬ëŸ¬ íƒ€ì…ì„ ì¡°í•©í•˜ì—¬ í•˜ë‚˜ì˜ ë³µí•© íƒ€ì…ì„ ë§Œë“œëŠ” ê²ƒì´ë‹¤. Dartì—ì„œëŠ” í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë¥¼ ì •ì˜í•  ìˆ˜ ìˆë‹¤. ì´ëŠ” ì—¬ëŸ¬ í•„ë“œë¥¼ ê°€ì§€ëŠ” ê°ì²´ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.
    
    ```dart
    class Point {
      final int x;
      final int y;
    
      Point(this.x, this.y);
    }
    
    ```
    
    **ëŒ€ìˆ˜ì  ë°ì´í„° íƒ€ì… ì‚¬ìš© ì˜ˆì‹œ**
    
    ëŒ€ìˆ˜ì  ë°ì´í„° íƒ€ì…ì„ ì‚¬ìš©í•˜ë©´ ê´€ë ¨ëœ íƒ€ì…ë“¤ì„ ë¬¶ì–´ ë” ëª…í™•í•˜ê³  ìœ ì§€ë³´ìˆ˜í•˜ê¸° ì‰¬ìš´ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ê²°ê³¼ë¥¼ ë‚˜íƒ€ë‚´ëŠ” íƒ€ì…ì„ ì •ì˜í•˜ê³  ì´ë¥¼ ì‚¬ìš©í•˜ëŠ” í•¨ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤:
    
    ```dart
    abstract class Result {}
    
    class Success extends Result {
      final String data;
      Success(this.data);
    }
    
    class Failure extends Result {
      final String error;
      Failure(this.error);
    }
    
    String handleResult(Result result) {
      switch (result.runtimeType) {
        case Success:
          return 'Success: ${(result as Success).data}';
        case Failure:
          return 'Error: ${(result as Failure).error}';
        default:
          return 'Unknown result';
      }
    }
    
    void main() {
      Result result1 = Success('Data loaded');
      Result result2 = Failure('Failed to load data');
    
      print(handleResult(result1)); // Output: Success: Data loaded
      print(handleResult(result2)); // Output: Error: Failed to load data
    }
    
    ```
    
    **ìš”ì•½**
    
    -   **ëŒ€ìˆ˜ì  ë°ì´í„° íƒ€ì…**ì€ í•© íƒ€ì…ê³¼ ê³± íƒ€ì…ì„ ì‚¬ìš©í•˜ì—¬ ë³µì¡í•œ ë°ì´í„° êµ¬ì¡°ë¥¼ ì •ì˜í•˜ëŠ” ë°©ë²•ì´ë‹¤.
    -   **í•© íƒ€ì…**ì€ ì—¬ëŸ¬ íƒ€ì… ì¤‘ í•˜ë‚˜ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆëŠ” ë°ì´í„° íƒ€ì…ì´ê³ , **ê³± íƒ€ì…**ì€ ì—¬ëŸ¬ íƒ€ì…ì„ ì¡°í•©í•˜ì—¬ í•˜ë‚˜ì˜ ë³µí•© íƒ€ì…ì„ ë§Œë“œëŠ” ê²ƒì´ë‹¤.
    -   Dartì—ì„œëŠ” enumê³¼ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ëŒ€ìˆ˜ì  ë°ì´í„° íƒ€ì…ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.
    -   ì´ë¥¼ í†µí•´ ê´€ë ¨ëœ íƒ€ì…ë“¤ì„ ë¬¶ì–´ ë” êµ¬ì¡°ì ì´ê³  ìœ ì§€ë³´ìˆ˜í•˜ê¸° ì‰¬ìš´ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.
    
    ----------
    

**Instead of implementing the operation as an instance method for every type, keep the operation's variations in a single function that switches over the subtypes:**

ê° íƒ€ì…ì— ëŒ€í•´ ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œë¡œ êµ¬í˜„í•˜ëŠ” ëŒ€ì‹ , ì„œë¸Œíƒ€ì…ì„ ì „í™˜í•˜ëŠ” ë‹¨ì¼ í•¨ìˆ˜ì— ê·¸ ë™ì‘ì˜ ë³€í˜•ì„ ìœ ì§€í•˜ì.

```dart
sealed class Shape {}

class Square implements Shape {
  final double length;
  Square(this.length);
}

class Circle implements Shape {
  final double radius;
  Circle(this.radius);
}

double calculateArea(Shape shape) => switch (shape) {
      Square(length: var l) => l * l,
      Circle(radius: var r) => math.pi * r * r
    };

```

### **Validating incoming JSON[#](https://dart.dev/language/patterns#validating-incoming-json)

ë“¤ì–´ì˜¤ëŠ” JSON ë°ì´í„° ê²€ì¦**

[**Map](https://dart.dev/language/pattern-types#map) and [list](https://dart.dev/language/pattern-types#list) patterns work well for destructuring key-value pairs in JSON data:**

ë§µê³¼ ë¦¬ìŠ¤íŠ¸ íŒ¨í„´ì€ JSON ë°ì´í„°ì—ì„œ í‚¤-ê°’ ìŒì„ êµ¬ì¡° ë¶„í•´í•˜ëŠ” ë° ì˜ ì‘ë™í•œë‹¤:

```dart
var json = {
  'user': ['Lily', 13]
};
var {'user': [name, age]} = json;

```

**If you know that the JSON data has the structure you expect, the previous example is realistic. But data typically comes from an external source, like over the network. You need to validate it first to confirm its structure.**

JSON ë°ì´í„°ê°€ ì˜ˆìƒí•œ êµ¬ì¡°ë¥¼ ê°€ì§€ê³  ìˆë‹¤ëŠ” ê²ƒì„ ì•Œê³  ìˆë‹¤ë©´, ì´ì „ ì˜ˆì œëŠ” í˜„ì‹¤ì ì´ë‹¤. ê·¸ëŸ¬ë‚˜ ë°ì´í„°ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ë„¤íŠ¸ì›Œí¬ë¥¼ í†µí•´ ì™¸ë¶€ ì†ŒìŠ¤ì—ì„œ ì˜¤ê¸° ë•Œë¬¸ì— ë¨¼ì € ê·¸ êµ¬ì¡°ë¥¼ í™•ì¸í•˜ê¸° ìœ„í•´ ê²€ì¦í•´ì•¼ í•œë‹¤.

**Without patterns, validation is verbose:**

íŒ¨í„´ ì—†ì´ ê²€ì¦í•˜ë©´ ì½”ë“œê°€ ì¥í™©í•´ì§„ë‹¤:

```dart
if (json is Map<String, Object?> &&
    json.length == 1 &&
    json.containsKey('user')) {
  var user = json['user'];
  if (user is List<Object> &&
      user.length == 2 &&
      user[0] is String &&
      user[1] is int) {
    var name = user[0] as String;
    var age = user[1] as int;
    print('User $name is $age years old.');
  }
}

```

**A single [case pattern](https://dart.dev/language/patterns#switch-statements-and-expressions) can achieve the same validation. Single cases work best as [if-case](https://dart.dev/language/branches#if-case) statements. Patterns provide a more declarative, and much less verbose method of validating JSON:**

ë‹¨ì¼ case íŒ¨í„´ìœ¼ë¡œ ë™ì¼í•œ ê²€ì¦ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤. ë‹¨ì¼ caseëŠ” if-case ë¬¸ìœ¼ë¡œ ê°€ì¥ ì˜ ì‘ë™í•œë‹¤. íŒ¨í„´ì€ JSONì„ ê²€ì¦í•˜ëŠ” ë° ìˆì–´ ë” ì„ ì–¸ì ì´ê³  í›¨ì”¬ ê°„ê²°í•œ ë°©ë²•ì„ ì œê³µí•œë‹¤:

```dart
if (json case {'user': [String name, int age]}) {
  print('User $name is $age years old.');
}

```

**This case pattern simultaneously validates that:**

ì´ case íŒ¨í„´ì€ ë™ì‹œì— ë‹¤ìŒì„ ê²€ì¦í•œë‹¤:

-   **`json` is a map, because it must first match the outer [map pattern](https://dart.dev/language/pattern-types#map) to proceed.**
    
    jsonì´ ë§µì¸ì§€ í™•ì¸í•œë‹¤. ì™œëƒí•˜ë©´ ì™¸ë¶€ ë§µ íŒ¨í„´ê³¼ ë¨¼ì € ë§¤ì¹­ë˜ì–´ì•¼ í•˜ê¸° ë•Œë¬¸ì´ë‹¤.
    
    -   **And, since it's a map, it also confirms `json` is not null.**
        
        jsonì´ ë§µì´ë¯€ë¡œ, jsonì´ nullì´ ì•„ë‹˜ì„ í™•ì¸í•œë‹¤.
        
-   **`json` contains a key `user`.**
    
    jsonì— user í‚¤ê°€ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•œë‹¤.
    
-   **The key `user` pairs with a list of two values.**
    
    user í‚¤ê°€ ë‘ ê°œì˜ ê°’ì„ ê°€ì§„ ë¦¬ìŠ¤íŠ¸ì™€ ì—°ê²°ë˜ëŠ”ì§€ í™•ì¸í•œë‹¤.
    
-   **The types of the list values are `String` and `int`.**
    
    ë¦¬ìŠ¤íŠ¸ ê°’ì˜ íƒ€ì…ì´ Stringê³¼ intì¸ì§€ í™•ì¸í•œë‹¤.
    
-   **The new local variables to hold the values are `name` and `age`.**
    
    ê°’ì„ ì €ì¥í•  ìƒˆë¡œìš´ ë¡œì»¬ ë³€ìˆ˜ëŠ” nameê³¼ ageì´ë‹¤.
