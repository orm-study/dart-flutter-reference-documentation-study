ğŸ”— [[í˜ì´ì§€ ë§í¬]](https://dart.dev/language/class-modifiers)

# **Class modifiers í´ë˜ìŠ¤ ìˆ˜ì •ì**

<aside> â„¹ï¸ **Version note**

**Class modifiers, besides `abstract`, require a [language version](https://dart.dev/guides/language/evolution#language-versioning) of at least 3.0.**

ì¶”ìƒì ì¸ ê²ƒ ì™¸ì—ë„ í´ë˜ìŠ¤ ìˆ˜ì •ìëŠ” ìµœì†Œ 3.0 ë²„ì „ì˜ ì–¸ì–´ê°€ í•„ìš”í•˜ë‹¤.

</aside>

**Class modifiers control how a class or mixin can be used, both [from within its own library](https://dart.dev/language/class-modifiers#abstract), and from outside the library where it's defined.**

í´ë˜ìŠ¤ ìˆ˜ì •ìëŠ” í´ë˜ìŠ¤ë‚˜ ë¯¹ìŠ¤ë¥¼ ì‚¬ìš© ë°©ë²•ì„ ì œì–´í•œë‹¤. ì´ëŠ” í•´ë‹¹ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë‚´ì—ì„œì™€ ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ëª¨ë‘ ì ìš©ëœë‹¤.

**Modifier keywords come before a class or mixin declaration. For example, writing `abstract class` defines an abstract class. The full set of modifiers that can appear before a class declaration include:**

ìˆ˜ì •ì í‚¤ì›Œë“œëŠ” í´ë˜ìŠ¤ë‚˜ ë¯¹ìŠ¤ ì„ ì–¸ ì „ì— ì˜¨ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, abstract classëŠ” ì¶”ìƒ í´ë˜ìŠ¤ë¥¼ ì •ì˜í•œë‹¤. í´ë˜ìŠ¤ ì„ ì–¸ ì „ì— ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ìˆ˜ì •ìì˜ ì „ì²´ ëª©ë¡ì€ ë‹¤ìŒê³¼ ê°™ë‹¤:

-   **`abstract`**
-   **`base`**
-   **`final`**
-   **`interface`**
-   **`sealed`**
-   [**`mixin`**](https://dart.dev/language/mixins#class-mixin-or-mixin-class)

**Only the `base` modifier can appear before a mixin declaration. The modifiers do not apply to other declarations like `enum`, `typedef`, `extension`, or `extension type`.**

ë¯¹ìŠ¤ ì„ ì–¸ ì „ì— ì˜¬ ìˆ˜ ìˆëŠ” ìˆ˜ì •ìëŠ” baseë§Œ ê°€ëŠ¥í•˜ë‹¤. ìˆ˜ì •ìëŠ” enum, typedef, extension ë˜ëŠ” extension typeê³¼ ê°™ì€ ë‹¤ë¥¸ ì„ ì–¸ì—ëŠ” ì ìš©ë˜ì§€ ì•ŠëŠ”ë‹¤.

**When deciding whether to use class modifiers, consider the intended uses of the class, and what behaviors the class needs to be able to rely on.**

í´ë˜ìŠ¤ ìˆ˜ì •ìë¥¼ ì‚¬ìš©í• ì§€ ê²°ì •í•  ë•Œ, í´ë˜ìŠ¤ì˜ ì˜ë„ëœ ì‚¬ìš© ë°©ë²•ê³¼ í´ë˜ìŠ¤ê°€ ì˜ì¡´í•´ì•¼ í•˜ëŠ” ë™ì‘ì„ ê³ ë ¤í•´ì•¼ í•œë‹¤.

<aside> â„¹ï¸ **Note**

**If you maintain a library, read the [Class modifiers for API maintainers](https://dart.dev/language/class-modifiers-for-apis) page for guidance on how to navigate these changes for your libraries.**

ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ìœ ì§€í•˜ëŠ” ê²½ìš°, ë¼ì´ë¸ŒëŸ¬ë¦¬ ë³€ê²½ ì‚¬í•­ì— ëŒ€í•œ ì§€ì¹¨ì„ ì–»ìœ¼ë ¤ë©´ API ìœ ì§€ ë³´ìˆ˜ìë¥¼ ìœ„í•œ í´ë˜ìŠ¤ ìˆ˜ì •ì í˜ì´ì§€ë¥¼ ì°¸ì¡°í•˜ë¼.

</aside>


## **No modifier[#](https://dart.dev/language/class-modifiers#no-modifier)** ìˆ˜ì •ì ì—†ìŒ

**To allow unrestricted permission to construct or subtype from any library, use a `class` or `mixin` declaration without a modifier. By default, you can:**

ì œí•œ ì—†ì´ ëª¨ë“  ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ìƒì„± ë˜ëŠ” ì„œë¸Œíƒ€ì…í™”í•  ìˆ˜ ìˆë„ë¡ í•˜ë ¤ë©´ ìˆ˜ì •ìê°€ ì—†ëŠ” í´ë˜ìŠ¤ ë˜ëŠ” ë¯¹ìŠ¤ ì„ ì–¸ì„ ì‚¬ìš©í•˜ë¼. ê¸°ë³¸ì ìœ¼ë¡œ ë‹¤ìŒì„ í•  ìˆ˜ ìˆë‹¤:

-   [**Construct](https://dart.dev/language/constructors) new instances of a class.**
    
    í´ë˜ìŠ¤ì˜ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•œë‹¤.
    
-   [**Extend](https://dart.dev/language/extend) a class to create a new subtype.**
    
    í´ë˜ìŠ¤ë¥¼ í™•ì¥í•˜ì—¬ ìƒˆ ì„œë¸Œíƒ€ì…ì„ ìƒì„±í•œë‹¤.
    
-   [**Implement](https://dart.dev/language/classes#implicit-interfaces) a class or mixin's interface.**
    
    í´ë˜ìŠ¤ ë˜ëŠ” ë¯¹ìŠ¤ì˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œë‹¤.
    
-   [**Mix in](https://dart.dev/language/mixins) a mixin or mixin class.**
    
    ë¯¹ìŠ¤ ë˜ëŠ” ë¯¹ìŠ¤ í´ë˜ìŠ¤ë¥¼ ë¯¹ìŠ¤í•œë‹¤.
    


## **abstract[#](https://dart.dev/language/class-modifiers#abstract)**

**To define a class that doesn't require a full, concrete implementation of its entire interface, use the `abstract` modifier.**

í´ë˜ìŠ¤ê°€ ì „ì²´ ì¸í„°í˜ì´ìŠ¤ì˜ êµ¬ì²´ì ì¸ êµ¬í˜„ì„ ìš”êµ¬í•˜ì§€ ì•Šë„ë¡ í•˜ë ¤ë©´ abstract ìˆ˜ì •ìë¥¼ ì‚¬ìš©í•˜ë¼.

**Abstract classes cannot be constructed from any library, whether its own or an outside library. Abstract classes often have [abstract methods](https://dart.dev/language/methods#abstract-methods).**

ì¶”ìƒ í´ë˜ìŠ¤ëŠ” í•´ë‹¹ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë‚´ë¶€ë“  ì™¸ë¶€ë“  ìƒì„±í•  ìˆ˜ ì—†ë‹¤. ì¶”ìƒ í´ë˜ìŠ¤ëŠ” ì¢…ì¢… ì¶”ìƒ ë©”ì„œë“œë¥¼ í¬í•¨í•œë‹¤.

**a.dart**

```dart
abstract class Vehicle {
  void moveForward(int meters);
}

```

**b.dart**

```dart
// b.dart
import 'a.dart';

// ì˜¤ë¥˜: ìƒì„±í•  ìˆ˜ ì—†ë‹¤.
Vehicle myVehicle = Vehicle();

// í™•ì¥í•  ìˆ˜ ìˆë‹¤.
class Car extends Vehicle {
  int passengers = 4;

  @override
  void moveForward(int meters) {
    // ...
  }
}

// êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.
class MockVehicle implements Vehicle {
  @override
  void moveForward(int meters) {
    // ...
  }
}

```

**If you want your abstract class to appear to be instantiable, define a [factory constructor](https://dart.dev/language/constructors#factory-constructors).**

ì¶”ìƒ í´ë˜ìŠ¤ë¥¼ ì¸ìŠ¤í„´ìŠ¤í™”í•  ìˆ˜ ìˆë„ë¡ ë³´ì´ê²Œ í•˜ë ¤ë©´ íŒ©í† ë¦¬ ìƒì„±ìë¥¼ ì •ì˜í•˜ë¼.


## **base[#](https://dart.dev/language/class-modifiers#base)**

**To enforce inheritance of a class or mixin's implementation, use the `base` modifier. A base class disallows implementation outside of its own library. This guarantees:**

í´ë˜ìŠ¤ë‚˜ ë¯¹ìŠ¤ì˜ êµ¬í˜„ ìƒì†ì„ ê°•ì œí•˜ë ¤ë©´ base ìˆ˜ì •ìë¥¼ ì‚¬ìš©í•˜ë¼. base í´ë˜ìŠ¤ëŠ” ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ êµ¬í˜„ì„ í—ˆìš©í•˜ì§€ ì•ŠëŠ”ë‹¤. ì´ëŠ” ë‹¤ìŒì„ ë³´ì¥í•œë‹¤:

-   **The base class constructor is called whenever an instance of a subtype of the class is created.**
    
    base í´ë˜ìŠ¤ ìƒì„±ìê°€ í•´ë‹¹ í´ë˜ìŠ¤ì˜ ì„œë¸Œíƒ€ì… ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë  ë•Œë§ˆë‹¤ í˜¸ì¶œëœë‹¤.
    
-   **All implemented private members exist in subtypes.**
    
    ëª¨ë“  êµ¬í˜„ëœ ë¹„ê³µê°œ ë©¤ë²„ê°€ ì„œë¸Œíƒ€ì…ì— ì¡´ì¬í•œë‹¤.
    
-   **A new implemented member in a `base` class does not break subtypes, since all subtypes inherit the new member.**
    
    base í´ë˜ìŠ¤ì—ì„œ ìƒˆë¡œ êµ¬í˜„ëœ ë©¤ë²„ëŠ” ì„œë¸Œíƒ€ì…ì„ ê¹¨ëœ¨ë¦¬ì§€ ì•ŠëŠ”ë‹¤. ì´ëŠ” ëª¨ë“  ì„œë¸Œíƒ€ì…ì´ ìƒˆ ë©¤ë²„ë¥¼ ìƒì†ë°›ê¸° ë•Œë¬¸ì´ë‹¤.
    
    -   This is true unless the subtype already declares a member with the same name and an incompatible signature.
        
        ì´ëŠ” ì„œë¸Œíƒ€ì…ì´ ë™ì¼í•œ ì´ë¦„ê³¼ í˜¸í™˜ë˜ì§€ ì•ŠëŠ” ì„œëª…ì„ ê°€ì§„ ë©¤ë²„ë¥¼ ì´ë¯¸ ì„ ì–¸í•˜ì§€ ì•ŠëŠ” í•œ ìœ íš¨í•˜ë‹¤.
        

**You must mark any class which implements or extends a base class as `base`, `final`, or `sealed`. This prevents outside libraries from breaking the base class guarantees.**

base í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•˜ê±°ë‚˜ í™•ì¥í•˜ëŠ” ëª¨ë“  í´ë˜ìŠ¤ëŠ” base, final, ë˜ëŠ” sealedë¡œ í‘œì‹œí•´ì•¼ í•œë‹¤. ì´ëŠ” ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ base í´ë˜ìŠ¤ì˜ ë³´ì¥ì„ ê¹¨ëœ¨ë¦¬ëŠ” ê²ƒì„ ë°©ì§€í•œë‹¤.

**a.dart**

```dart
base class Vehicle {
  void moveForward(int meters) {
    // ...
  }
}

```

**b.dart**

```dart
// b.dart
import 'a.dart';

// ìƒì„±í•  ìˆ˜ ìˆë‹¤.
Vehicle myVehicle = Vehicle();

// í™•ì¥í•  ìˆ˜ ìˆë‹¤.
base class Car extends Vehicle {
  int passengers = 4;
  // ...
}

// ì˜¤ë¥˜: êµ¬í˜„í•  ìˆ˜ ì—†ë‹¤.
base class MockVehicle implements Vehicle {
  @override
  void moveForward() {
    // ...
  }
}

```


## **interface[#](https://dart.dev/language/class-modifiers#interface)**

**To define an interface, use the `interface` modifier. Libraries outside of the interface's own defining library can implement the interface, but not extend it. This guarantees:**

ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•˜ë ¤ë©´ interface ìˆ˜ì •ìë¥¼ ì‚¬ìš©í•˜ë¼. ì¸í„°í˜ì´ìŠ¤ê°€ ì •ì˜ëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì™¸ë¶€ì˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆì§€ë§Œ, í™•ì¥í•  ìˆ˜ëŠ” ì—†ë‹¤. ì´ëŠ” ë‹¤ìŒì„ ë³´ì¥í•œë‹¤:

-   **When one of the class's instance methods calls another instance method on `this`, it will always invoke a known implementation of the method from the same library.**
    
    í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œ ì¤‘ í•˜ë‚˜ê°€ thisì—ì„œ ë‹¤ë¥¸ ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ë•Œ, í•­ìƒ ë™ì¼í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ë©”ì„œë“œì˜ ì•Œë ¤ì§„ êµ¬í˜„ì„ í˜¸ì¶œí•œë‹¤.
    
-   **Other libraries can't override methods that the interface class's own methods might later call in unexpected ways. This reduces the [fragile base class problem](https://en.wikipedia.org/wiki/Fragile_base_class).**
    
    ë‹¤ë¥¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œëŠ” ì¸í„°í˜ì´ìŠ¤ í´ë˜ìŠ¤ì˜ ìì²´ ë©”ì„œë“œê°€ ë‚˜ì¤‘ì— ì˜ˆìƒì¹˜ ëª»í•œ ë°©ì‹ìœ¼ë¡œ í˜¸ì¶œí•  ìˆ˜ ìˆëŠ” ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ìˆ˜ ì—†ë‹¤. ì´ëŠ” ì·¨ì•½í•œ ê¸°ë³¸ í´ë˜ìŠ¤ ë¬¸ì œë¥¼ ì¤„ì¸ë‹¤.
    

**a.dart**

```dart
// a.dart
interface class Vehicle {
  void moveForward(int meters) {
    // ...
  }
}

```

**b.dart**

```dart
// b.dart
import 'a.dart';

// ìƒì„±í•  ìˆ˜ ìˆë‹¤.
Vehicle myVehicle = Vehicle();

// ì˜¤ë¥˜: ìƒì†í•  ìˆ˜ ì—†ë‹¤.
class Car extends Vehicle {
  int passengers = 4;
  // ...
}

// êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.
class MockVehicle implements Vehicle {
  @override
  void moveForward(int meters) {
    // ...
  }
}

```


## **`abstract interface`[#](https://dart.dev/language/class-modifiers#abstract-interface)**

**The most common use for the `interface` modifier is to define a pure interface. [Combine](https://dart.dev/language/class-modifiers#combining-modifiers) the `interface` and [`abstract`](https://dart.dev/language/class-modifiers#abstract) modifiers for an `abstract interface class`.**

ì¸í„°í˜ì´ìŠ¤ ìˆ˜ì •ìì˜ ê°€ì¥ ì¼ë°˜ì ì¸ ì‚¬ìš©ë²•ì€ ìˆœìˆ˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•˜ëŠ” ê²ƒì´ë‹¤. interfaceì™€ abstract ìˆ˜ì •ìë¥¼ ê²°í•©í•˜ì—¬ ì¶”ìƒ ì¸í„°í˜ì´ìŠ¤ í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.

**Like an `interface` class, other libraries can implement, but can't inherit, a pure interface. Like an `abstract` class, a pure interface can have abstract members.**

ì¸í„°í˜ì´ìŠ¤ í´ë˜ìŠ¤ì²˜ëŸ¼ ë‹¤ë¥¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” êµ¬í˜„í•  ìˆ˜ ìˆì§€ë§Œ ìƒì†í•  ìˆ˜ëŠ” ì—†ë‹¤. ì¶”ìƒ í´ë˜ìŠ¤ì²˜ëŸ¼ ì¶”ìƒ ì¸í„°í˜ì´ìŠ¤ëŠ” ì¶”ìƒ ë©¤ë²„ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆë‹¤.



## **final[#](https://dart.dev/language/class-modifiers#final)**

**To close the type hierarchy, use the `final` modifier. This prevents subtyping from a class outside of the current library. Disallowing both inheritance and implementation prevents subtyping entirely. This guarantees:**

íƒ€ì… ê³„ì¸µ êµ¬ì¡°ë¥¼ ë‹«ìœ¼ë ¤ë©´ final ìˆ˜ì •ìë¥¼ ì‚¬ìš©í•˜ë¼. ì´ëŠ” í˜„ì¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì™¸ë¶€ì—ì„œì˜ ì„œë¸Œíƒ€ì…í™”ë¥¼ ë°©ì§€í•œë‹¤. ìƒì† ë° êµ¬í˜„ì„ ëª¨ë‘ í—ˆìš©í•˜ì§€ ì•Šìœ¼ë©´ ì„œë¸Œíƒ€ì…í™”ë¥¼ ì™„ì „íˆ ë°©ì§€í•œë‹¤. ì´ëŠ” ë‹¤ìŒì„ ë³´ì¥í•œë‹¤:

-   **You can safely add incremental changes to the API.**
    
    APIì— ì ì§„ì ì¸ ë³€ê²½ ì‚¬í•­ì„ ì•ˆì „í•˜ê²Œ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.
    
-   **You can call instance methods knowing that they haven't been overwritten in a third-party subclass.**
    
    ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ë•Œ ì œ3ì ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ ì¬ì •ì˜ë˜ì§€ ì•Šì•˜ìŒì„ ì•Œ ìˆ˜ ìˆë‹¤.
    

**Final classes can be extended or implemented within the same library. The `final` modifier encompasses the effects of `base`, and therefore any subclasses must also be marked `base`, `final`, or `sealed`.**

final í´ë˜ìŠ¤ëŠ” ë™ì¼í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë‚´ì—ì„œ í™•ì¥ë˜ê±°ë‚˜ êµ¬í˜„ë  ìˆ˜ ìˆë‹¤. final ìˆ˜ì •ìëŠ” baseì˜ íš¨ê³¼ë¥¼ í¬í•¨í•˜ë¯€ë¡œ ëª¨ë“  ì„œë¸Œí´ë˜ìŠ¤ëŠ” base, final ë˜ëŠ” sealedë¡œ í‘œì‹œí•´ì•¼ í•œë‹¤.

**a.dart**

```dart
// a.dart
final class Vehicle {
  void moveForward(int meters) {
    // ...
  }
}

```

**b.dart**

```dart
// b.dart
import 'a.dart';

// ìƒì„±í•  ìˆ˜ ìˆë‹¤.
Vehicle myVehicle = Vehicle();

// ì˜¤ë¥˜: ìƒì†í•  ìˆ˜ ì—†ë‹¤.
class Car extends Vehicle {
  int passengers = 4;
  // ...
}

// ì˜¤ë¥˜: êµ¬í˜„í•  ìˆ˜ ì—†ë‹¤.
class MockVehicle implements Vehicle {
  @override
  void moveForward(int meters) {
    // ...
  }
}

```


## **sealed[#](https://dart.dev/language/class-modifiers#sealed)**

**To create a known, enumerable set of subtypes, use the `sealed` modifier. This allows you to create a switch over those subtypes that is statically ensured to be [_exhaustive_](https://dart.dev/language/branches#exhaustiveness-checking).\**

ì•Œë ¤ì§„, ì—´ê±° ê°€ëŠ¥í•œ ì„œë¸Œíƒ€ì… ì§‘í•©ì„ ë§Œë“¤ë ¤ë©´ sealed ìˆ˜ì •ìë¥¼ ì‚¬ìš©í•˜ë¼. ì´ëŠ” ì •ì ìœ¼ë¡œ ëª¨ë“  ì„œë¸Œíƒ€ì…ì„ ì²˜ë¦¬í•˜ë„ë¡ ë³´ì¥ëœ ìŠ¤ìœ„ì¹˜ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.

**The `sealed` modifier prevents a class from being extended or implemented outside its own library. Sealed classes are implicitly [abstract](https://dart.dev/language/class-modifiers#abstract).]**

sealed ìˆ˜ì •ìëŠ” í´ë˜ìŠ¤ê°€ ìì²´ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì™¸ë¶€ì—ì„œ í™•ì¥ë˜ê±°ë‚˜ êµ¬í˜„ë˜ì§€ ì•Šë„ë¡ í•œë‹¤. sealed í´ë˜ìŠ¤ëŠ” ì•”ì‹œì ìœ¼ë¡œ ì¶”ìƒì ì´ë‹¤.

-   **They cannot be constructed themselves.**
    
    ìì²´ì ìœ¼ë¡œ ìƒì„±í•  ìˆ˜ ì—†ë‹¤.
    
-   **They can have [factory constructors](https://dart.dev/language/constructors#factory-constructors).**
    
    íŒ©í† ë¦¬ ìƒì„±ìë¥¼ ê°€ì§ˆ ìˆ˜ ìˆë‹¤.
    
-   **They can define constructors for their subclasses to use.**
    
    ì„œë¸Œí´ë˜ìŠ¤ê°€ ì‚¬ìš©í•  ìƒì„±ìë¥¼ ì •ì˜í•  ìˆ˜ ìˆë‹¤.
    

**Subclasses of sealed classes are, however, not implicitly abstract.**

sealed í´ë˜ìŠ¤ì˜ ì„œë¸Œí´ë˜ìŠ¤ëŠ” ì•”ì‹œì ìœ¼ë¡œ ì¶”ìƒì ì´ì§€ ì•Šë‹¤.

**The compiler is aware of any possible direct subtypes because they can only exist in the same library. This allows the compiler to alert you when a switch does not exhaustively handle all possible subtypes in its cases:**

ì»´íŒŒì¼ëŸ¬ëŠ” ê°€ëŠ¥í•œ ëª¨ë“  ì§ì ‘ ì„œë¸Œíƒ€ì…ì„ ì•Œê³  ìˆê¸° ë•Œë¬¸ì— ìŠ¤ìœ„ì¹˜ê°€ ëª¨ë“  ê°€ëŠ¥í•œ ì„œë¸Œíƒ€ì…ì„ ì‚¬ë¡€ë¡œ ì²˜ë¦¬í•˜ì§€ ì•Šì„ ë•Œ ê²½ê³ í•  ìˆ˜ ìˆë‹¤.

ì»´íŒŒì¼ëŸ¬ëŠ” ëª¨ë“  ê°€ëŠ¥í•œ ì§ì ‘ ì„œë¸Œíƒ€ì…ì„ ì¸ì‹í•˜ê³  ìˆë‹¤. ì™œëƒí•˜ë©´ ì´ ì„œë¸Œíƒ€ì…ë“¤ì€ ê°™ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë‚´ì—ë§Œ ì¡´ì¬í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤. ì´ëŠ” switch ë¬¸ì—ì„œ ëª¨ë“  ê°€ëŠ¥í•œ ì„œë¸Œíƒ€ì…ì„ í¬ê´„ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ì§€ ì•Šì•˜ì„ ë•Œ ì»´íŒŒì¼ëŸ¬ê°€ ê²½ê³ í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤.

```dart
sealed class Vehicle {}

class Car extends Vehicle {}

class Truck implements Vehicle {}

class Bicycle extends Vehicle {}

// ì˜¤ë¥˜: ì¸ìŠ¤í„´ìŠ¤í™”í•  ìˆ˜ ì—†ë‹¤.
Vehicle myVehicle = Vehicle();

// ì„œë¸Œí´ë˜ìŠ¤ëŠ” ì¸ìŠ¤í„´ìŠ¤í™”í•  ìˆ˜ ìˆë‹¤.
Vehicle myCar = Car();

String getVehicleSound(Vehicle vehicle) {
  // ì˜¤ë¥˜: ìŠ¤ìœ„ì¹˜ê°€ Bicycle ì„œë¸Œíƒ€ì… ë˜ëŠ” ê¸°ë³¸ ì‚¬ë¡€ë¥¼ ë†“ì¹˜ê³  ìˆë‹¤.
  return switch (vehicle) {
    Car() => 'vroom',
    Truck() => 'VROOOOMM',
  };
}

```

**If you don't want [exhaustive switching](https://dart.dev/language/branches#exhaustiveness-checking), or want to be able to add subtypes later without breaking the API, use the [`final`](https://dart.dev/language/class-modifiers#final) modifier. For a more in depth comparison, read [`sealed` versus `final`](https://dart.dev/language/class-modifiers-for-apis#sealed-versus-final).**

í¬ê´„ì ì¸ ìŠ¤ìœ„ì¹­ì„ ì›í•˜ì§€ ì•Šê±°ë‚˜ ë‚˜ì¤‘ì— ì„œë¸Œíƒ€ì…ì„ ì¶”ê°€í•´ë„ APIê°€ ê¹¨ì§€ì§€ ì•Šê¸°ë¥¼ ì›í•œë‹¤ë©´ final ìˆ˜ì •ìë¥¼ ì‚¬ìš©í•˜ë¼. ë” ì‹¬ì¸µì ì¸ ë¹„êµë¥¼ ìœ„í•´ sealedì™€ finalì„ ì½ì–´ë³´ë¼.


## **Combining modifiers[#](https://dart.dev/language/class-modifiers#combining-modifiers) ìˆ˜ì •ì ê²°í•©**

**You can combine some modifiers for layered restrictions. A class declaration can be, in order:**

ì¼ë¶€ ìˆ˜ì •ìë¥¼ ê²°í•©í•˜ì—¬ ê³„ì¸µì ì¸ ì œí•œì„ ì ìš©í•  ìˆ˜ ìˆë‹¤. í´ë˜ìŠ¤ ì„ ì–¸ì€ ìˆœì„œëŒ€ë¡œ ë‹¤ìŒê³¼ ê°™ì„ ìˆ˜ ìˆë‹¤:

1.  **(Optional) `abstract`, describing whether the class can contain abstract members and prevents instantiation.**
    
    (ì„ íƒ ì‚¬í•­) abstract, í´ë˜ìŠ¤ê°€ ì¶”ìƒ ë©¤ë²„ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆê³  ì¸ìŠ¤í„´ìŠ¤í™”í•  ìˆ˜ ì—†ëŠ”ì§€ ì„¤ëª…í•œë‹¤.
    
2.  **(Optional) One of `base`, `interface`, `final` or `sealed`, describing restrictions on other libraries subtyping the class.**
    
    (ì„ íƒ ì‚¬í•­) base, interface, final ë˜ëŠ” sealed ì¤‘ í•˜ë‚˜, ë‹¤ë¥¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ í´ë˜ìŠ¤ë¥¼ ì„œë¸Œíƒ€ì…í™”í•˜ëŠ” ê²ƒì„ ì œí•œí•œë‹¤.
    
3.  **(Optional) `mixin`, describing whether the declaration can be mixed in.**
    
    (ì„ íƒ ì‚¬í•­) mixin, ì„ ì–¸ì„ ë¯¹ìŠ¤í•  ìˆ˜ ìˆëŠ”ì§€ ì„¤ëª…í•œë‹¤.
    
4.  **The `class` keyword itself.**
    
    í´ë˜ìŠ¤ í‚¤ì›Œë“œ ìì²´.
    

**You can't combine some modifiers because they are contradictory, redundant, or otherwise mutually exclusive:**

ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš°ì—ëŠ” ìˆ˜ì •ìë¥¼ ê²°í•©í•  ìˆ˜ ì—†ë‹¤. ì´ëŠ” ëª¨ìˆœë˜ê±°ë‚˜ ì¤‘ë³µë˜ê±°ë‚˜ ìƒí˜¸ ë°°íƒ€ì ì´ê¸° ë•Œë¬¸ì´ë‹¤:

-   **`abstract` with `sealed`. A [sealed](https://dart.dev/language/class-modifiers#sealed) class is implicitly [abstract](https://dart.dev/language/class-modifiers#abstract).**
    
    abstractì™€ sealed. sealed í´ë˜ìŠ¤ëŠ” ì•”ì‹œì ìœ¼ë¡œ ì¶”ìƒì ì´ë‹¤.
    
-   **`interface`, `final` or `sealed` with `mixin`. These access modifiers prevent [mixing in](https://dart.dev/language/mixins).**
    
    interface, final, ë˜ëŠ” sealedì™€ mixin. ì´ëŸ¬í•œ ì ‘ê·¼ ìˆ˜ì •ìëŠ” ë¯¹ìŠ¤ë¥¼ ë°©ì§€í•œë‹¤.
    

**For further guidance on how class modifiers can be combined, check out the [Class modifiers reference](https://dart.dev/language/modifier-reference).**

í´ë˜ìŠ¤ ìˆ˜ì •ìë¥¼ ê²°í•©í•˜ëŠ” ë°©ë²•ì— ëŒ€í•œ ìì„¸í•œ ì§€ì¹¨ì€ í´ë˜ìŠ¤ ìˆ˜ì •ì ì°¸ì¡°ë¥¼ í™•ì¸í•˜ë¼.
