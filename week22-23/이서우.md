# 성능 모범 사례
https://docs.flutter.dev/perf/best-practices

https://docs.flutter.dev/perf/rendering-performance

## 비용이 많이 드는 작업 최소화

비용이 큰 작업은 더 많은 자원을 소비하므로 꼭 필요한 경우 수행하도록 한다. 앱 UI 디자인과 구현 방식에 따라 성능이 달라질 수 있다.

### build() 메서드 최적화하기

- 상위 위젯을 리빌드할 때 build()가 자주 호출될 수 있으므로 build()에서 비용이 큰 작업을 피한다.
- 큰 build() 메서드를 가진 단일 위젯은 여러 위젯으로 분리한다.
- setState() 호출 시 모든 하위 위젯이 다시 그려지므로, 필요한 부분에만 setState()를 호출하도록 한다.
- const 생성자를 사용하여 Flutter가 불필요한 리빌드를 방지하도록 한다. (flutter_lints 패키지 사용 시 const를 사용해야 하는 부분을 자동으로 알려줌)
- 재사용할 수 있는 UI를 만들 때 함수보다 StatelessWidget을 사용한다.

### saveLayer() 신중하게 사용하기

saveLayer()는 UI에 다양한 시각적 효과를 구현한다.

saveLayer()를 과도하게 호출하면 버벅거림이 발생할 수 있다. 명시적으로 호출하지 않더라도 다른 위젯이나 패키지에서 호출하고 있을 수 있다.

**[언제 saveLayer가 필요한가]**

예를 들어, 서버에서 동적으로 불러오는 여러 개의 도형을 화면에 표시할 때 각 도형이 투명도를 가지고 있으며, 서로 겹칠 수도 있는 상황이라면 saveLayer()를 사용할 수밖에 없다.

**[왜 saveLayer는 비용이 큰가]**

saveLayer()를 호출하면 **오프스크린 버퍼**가 할당된다. 컨텐츠를 오프스크린 버퍼에 그리면, **렌더 타깃 전환**이 발생할 수 있다. **GPU는 데이터를 연속적으로 처리하기를 원하는데, 렌더 타깃 전환은 GPU가 데이터 흐름을 일시적으로 다른 곳으로 돌렸다가 원래 흐름으로 다시 돌아오게 만들기 때문**에 이 과정이 GPU의 성능에 부담을 준다. 특히, 모바일 GPU에서 이러한 전환이 성능에 큰 영향을 미친다.

**[saveLayer 호출 디버깅 방법]**

saveLayer()가 얼마나 자주 호출되는지 확인하려면, DevTools 타임라인에서 이벤트를 체크하면 된다. DevTools의 **PerformanceOverlayLayer.checkerboardOffscreenLayers** 옵션을 켜서 어떤 장면에서 saveLayer가 호출되는지 확인할 수 있다.

**[saveLayer 호출 최소화하기]**

saveLayer 호출 최소화를 위해 시각 효과를 만드는 방법을 다시 생각해보는 것이 필요할 수 있다.

1. **코드에서 saveLayer 호출을 줄일 수 있는지 검토하기**
    - 예를 들어, UI에서 두 개의 도형이 **겹쳐져 있고**, 각 도형이 **투명도**를 가지고 있는 경우를 생각해 본다.
    - 이 도형들이 항상 **같은 위치**에서 **같은 방식으로 겹쳐지고 같은 투명도**를 가지고 있다면, 겹쳐진 모양을 **미리 계산**하고 **캐시에 저장**해두고 그 결과를 재사용할 수 있다. 이렇게 하면 saveLayer를 호출하지 않고도 같은 시각 효과를 낼 수 있다.
    - 미리 계산 가능한 **정적인 모양**에 사용할 수 있다.
2. **페인팅 로직을 리팩터링해 겹침을 없앨 수 있는지 확인하기**
    - 겹쳐지는 도형을 재구성하여 겹침을 줄이거나 없앨 수 있다면, saveLayer 호출을 피할 수 있다.
3. **내가 소유하지 않은 패키지에서 saveLayer가 호출되는 경우**
    - 패키지에서 saveLayer를 사용하고 있다면 패키지 제작자에게 **왜 saveLayer가 필요한지** 문의해 보는 것도 방법이다. 줄이거나 제거할 방법이 있는지 확인하고, 그렇지 않다면 **다른 패키지를 찾거나 직접 구현**해야 할 수도 있다.

**[saveLayer를 호출할 가능성이 있는 위젯들]**

- **ShaderMask**: 그래픽에 셰이더를 입히기 위해 사용
- **ColorFilter**: 색상 필터를 적용할 때 사용
- **Chip**: `disabledColorAlpha` 값이 `0xff`가 아닌 경우 saveLayer를 호출할 수 있음
- **Text**: `overflowShader`가 있는 경우 saveLayer를 호출할 수 있음

### Opacity와 Clipping 사용 최소화하기

**Opacity(불투명도)와 Clipping(잘라내기) 작업은 비용이 큰 작업**이기 때문에 필요할 때만 사용하는 것이 좋다.

- **이미지 자체에 투명도를 적용하는 방법**이 Opacity 위젯을 사용하는 것보다 더 빠르다. (예시는 Opacity API 페이지의 ‘Transparent image’ 섹션 참고)
- 간단한 도형이나 텍스트의 투명도를 설정할 때는 **Opacity 위젯을 감싸지 않고, 반투명 색상**으로 그리는 것이 보통 더 빠르다. 다만, 그리려는 모양이 다른 것과 겹쳐 있지 않을 때만 유효하다.
- 이미지를 서서히 표시할 때는 **FadeInImage** 위젯이 적합하다. 이 위젯은 GPU의 프래그먼트 셰이더를 사용해 점진적인 투명도를 적용하므로 성능이 더 좋다.
- Clipping은 **saveLayer()를 호출하지 않기 때문에 Opacity보다 비용이 적지만**, 여전히 성능에 부담이 될 수 있다. 기본적으로 Clipping은 비활성화되어 있다. **모서리가 둥근 사각형**을 만들 때는 Clipping 대신 **borderRadius 속성**을 사용한다. 많은 위젯에서 borderRadius 속성을 제공하므로, 성능을 더 효율적으로 유지할 수 있다.

### 그리드와 리스트를 효율적으로 구현하기

**[Lazy 로드하기]**

큰 그리드나 리스트를 만들 때는 **Lazy(지연) 빌더 방식**을 사용해 **화면에 보이는 부분만 먼저 생성**한다. **ListView.builder**나 **GridView.builder**를 사용하면, 화면에 보이는 항목만 로드되므로 초기 로딩 속도가 빨라지고 메모리 사용량도 줄어든다.

[**intrinsics 피하기**]

그리드나 리스트에서 **intrinsics**를 활용하면, 모든 요소의 크기를 계산해야 하므로 성능이 저하될 수 있다. 이와 관련된 성능 문제를 방지하려면, 다음 섹션에서 설명하는 **intrinsic passes**를 피하는 것이 좋다.

### Intrinsic 연산으로 인한 레이아웃 패스를 최소화하기

Flutter는 UI를 구성할 때 **레이아웃 규칙**에 따라, 기본적으로 위젯에 대해 **단 한 번의 레이아웃 패스**를 수행하도록 설계되었다. 하지만, 그리드와 리스트 같은 일부 위젯에서는 추가적인 레이아웃 패스(내재적 패스, intrinsic pass)가 발생할 수 있다.

**[Intrinsic Pass란?]**

Intrinsic Pass는 모든 셀의 크기를 **가장 큰 셀**이나 **가장 작은 셀의 크기**로 맞추고자 할 때 발생한다. 예를 들어, 큰 그리드에 카드들이 들어있는 경우, 그리드의 각 셀이 동일한 크기를 가져야 한다면 레이아웃 코드가 모든 카드의 선호 크기(내재적 크기)를 확인하는 과정을 거쳐야 한다. 즉, 화면에 보이지 않는 카드까지 포함하여 각 카드가 원하는 크기를 확인한 후, 최종적으로 모든 셀의 크기를 동일하게 맞춘다. 이는 두 번째 레이아웃 패스가 추가적으로 필요하게 만들며, 성능을 느리게 한다.

**[Intrinsic Pass 디버깅 방법]**

**DevTools**에서 **Track layouts** 옵션을 활성화하면 앱의 레이아웃 패스 횟수를 추적할 수 있다. 활성화 후에는 '$runtimeType intrinsics'로 표시된 이벤트를 통해 추가적인 intrinsic pass가 발생했는지 확인할 수 있다.

**[Intrinsic Pass를 피하는 방법]**

- **셀 크기를 고정된 크기로 설정**: 모든 셀의 크기를 처음부터 고정해 설정하면 intrinsic pass를 피할 수 있다.
- **기준 셀(anchor cell)을 설정**: 특정 셀을 기준으로 다른 셀 크기를 조정하는 방법도 있다. 이 경우, 맞춤형 RenderObject를 작성하여 기준 셀을 먼저 배치하고 나머지 셀을 기준 셀에 맞춰 배치한다.

### 16ms 내에 프레임을 빌드하고 표시하기

60Hz 디스플레이에서는 **프레임당 16ms 내에 화면을 그려야** 매끄럽게 보인다. Flutter는 **빌드 작업과 렌더링 작업을 별도의 스레드에서 처리**하므로, 각각 16ms가 주어진다. **최적 성능을 위해서는 빌드를 8ms 이하, 렌더링도 8ms 이하**로 처리해 전체 16ms 이하로 프레임을 완료하는 것이 좋다.

**[16ms 이하로 프레임 렌더링이 중요한 이유]**

- 프레임 렌더링을 16ms 이하로 줄이면 **시각적인 차이는 크지 않지만, 배터리 수명과 기기 발열을 줄이는 데** 도움이 된다.
- 고사양 기기에서는 성능이 잘 나오더라도, **성능이 낮은 기기**에서도 원활히 실행되도록 최적화하는 것이 좋다.
- 120fps를 지원하는 고주사율 기기에서는 **프레임당 8ms 이하**로 렌더링해야 최상의 경험을 제공할 수 있다.

## 성능 최적화를 위해 주의해야 할 사항

앱의 성능을 조정하거나 UI가 기대만큼 매끄럽지 않다면 **DevTools의 성능 뷰**를 활용해 문제를 파악할 수 있다. 또한, IDE의 Flutter 플러그인에서 **Show widget rebuild information** 옵션을 켜면 프레임이 16ms 이상 걸리는지 확인할 수 있으며, 필요한 경우 성능 최적화 팁도 제공한다.

### **Opacity 위젯 사용 피하기**

특히 **애니메이션**에서 Opacity 위젯을 사용하지 않는 것이 좋다. 대신 **AnimatedOpacity**나 **FadeInImage**를 사용하면 더 우수한 성능을 낼 수 있다.

### **AnimatedBuilder 사용 시 주의하기**

**애니메이션과 관련이 없는 위젯을 AnimatedBuilder의 builder 함수 안에 넣지 않도록 한다**. 이렇게 하면 애니메이션이 실행될 때마다 모든 위젯이 다시 빌드된다. 애니메이션에 영향을 받지 않는 위젯은 **한 번만 빌드하고** AnimatedBuilder의 **child로 전달**하여 재사용하는 것이 좋다.

### **애니메이션에서 Clipping 피하기**

가능하면 **애니메이션 전에 이미지를 미리 잘라놓는 방법**을 고려한다. 애니메이션 중에 클리핑을 하면 성능이 저하될 수 있다.

### **Column, ListView와 같은 자식 리스트 사용 시 주의하기**

자식 리스트가 모두 보이지 않는 경우에는 **고정된 자식 리스트(예: Column이나 ListView의 구체적인 자식 리스트)를 사용하지 않는다**. 보이지 않는 자식들까지 빌드하는 비용이 크기 때문이다.

### **Widget에서 == 연산자 오버라이딩 피하기**

== 연산자를 오버라이딩하면 불필요한 리빌드를 줄일 것 같지만, 실제로는 **성능에 악영향**을 미친다. 특히, N²(제곱) 성능 저하를 초래할 수 있다. 예외는 자식이 없는 **리프(leaf) 위젯**만 해당하며, 이 경우에도 캐싱을 사용하는 것이 더 바람직하다.
