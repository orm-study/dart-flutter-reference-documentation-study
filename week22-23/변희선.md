공식 문서 : https://docs.flutter.dev/perf/best-practices

## Flutter 앱 성능 최적화 모범 사례

Flutter 앱은 기본적으로 성능이 좋지만, 몇 가지 흔한 실수를 피하면 더 뛰어난 성능을 얻을 수 있습니다. 아래 모범 사례를 통해 최적의 성능을 구현할 수 있는 방법을 살펴보겠습니다.

### 1. 불필요한 작업을 피하기

### build() 메서드의 비용 관리

- **build() 메서드 내 반복적인 작업 최소화**: 이 메서드는 조상 위젯이 갱신될 때마다 호출되므로, 불필요한 계산이나 UI 변경 작업을 최대한 줄이는 것이 좋습니다.
- **큰 위젯을 나누기**: build() 메서드가 복잡한 경우, 변경이 잦은 부분과 그렇지 않은 부분을 나누어 각각 위젯으로 캡슐화하면 불필요한 리빌드를 피할 수 있습니다.
- **setState() 위치 조정**: 최상단에서 setState()를 호출하면 전체 트리의 하위 위젯이 모두 다시 그려지기 때문에, 변경이 필요한 부분에만 호출하여 불필요한 리빌드를 줄입니다.

### const 생성자 사용

- **const 생성자 활용**: 위젯을 생성할 때 `const` 생성자를 최대한 사용하면, Flutter가 리빌드 작업을 단축할 수 있어 성능에 유리합니다. 이를 쉽게 도와주는 `flutter_lints` 패키지를 통해 상수화 가능한 경우 자동으로 상기할 수 있습니다.

### 2. saveLayer() 사용 관리

- **비용**: `saveLayer()`는 오프스크린 버퍼를 할당하고, 렌더 타깃을 전환하기 때문에 지나치게 호출되면 성능에 부정적인 영향을 미칩니다.
- **대안**:
    - **캐싱 활용**: 투명도나 여러 객체가 겹쳐서 그려지는 부분을 미리 계산하여 캐싱해두면, `saveLayer()` 호출을 줄일 수 있습니다. 예를 들어, 항상 같은 형태로 겹치는 객체들이 있다면, 이 부분을 미리 계산해 두고 매번 `saveLayer()`를 호출하는 대신 그 값을 재사용할 수 있습니다.
    - **그리기 최적화**: 겹침을 최소화하는 방식으로 그리기 로직을 리팩토링하면 `saveLayer()` 호출을 줄일 수 있습니다.

### 외부 패키지 사용 시 주의

- 만약 외부 패키지에서 `saveLayer()`를 불필요하게 많이 호출하는 경우, 성능 저하가 발생할 수 있습니다.
    - **패키지 개발자와 소통**: 패키지에서 왜 `saveLayer()`를 사용하는지, 이를 줄일 수 있는 방법이 있는지 확인해봅니다.
    - **대체 패키지 찾기**: 성능에 영향을 줄 수 있다면, 다른 최적화된 패키지를 고려하거나 직접 커스터마이징할 수 있습니다.

### 3. Opacity와 Clip 사용 최적화

### Opacity 사용 주의사항

- **Opacity 위젯을 최소화**: 단순한 도형이나 텍스트의 투명도를 조절해야 한다면, 반투명 색상을 사용하는 것이 빠릅니다.
- **FadeInImage 사용**: 이미지 페이딩에 Opacity 대신 FadeInImage 위젯을 사용하는 것이 좋습니다. 이는 GPU의 쉐이더를 이용하여 성능을 개선합니다.

### Clip 사용 최적화

- **Clip.none을 기본으로 사용**: Flutter는 기본적으로 Clip.none으로 클리핑을 비활성화해 두었으며, 클리핑을 필요로 하는 경우에만 명시적으로 활성화하는 것이 좋습니다.
- **모서리 둥글기 구현**: 클리핑 대신 `borderRadius` 속성을 활용하면 불필요한 클리핑 비용을 줄일 수 있습니다.

### 4. 리스트와 그리드 구현 최적화

### 리스트와 그리드에서 지연 빌드 사용

- **Lazy 빌드 메서드 활용**: 긴 리스트나 그리드를 구성할 때 `ListView.builder`와 같은 지연 로딩 방식의 빌더 메서드를 사용하면 초기 로딩 시 화면에 표시되는 항목만 생성할 수 있어 성능에 유리합니다.

### 고정된 크기 사용

- **고정된 셀 크기 설정**: 모든 셀을 같은 크기로 설정할 수 있다면, 레이아웃 패스를 줄일 수 있습니다. `RenderObject`를 사용하여 특정 셀을 기준으로 삼고 주변 셀을 배치하는 방식도 고려해볼 수 있습니다.

### 5. 프레임을 16ms 내에 빌드 및 렌더링

- Flutter 앱은 60Hz 디스플레이에서 매끄러운 UI를 위해 16ms 이내에 빌드 및 렌더링이 되어야 합니다. 이 목표를 달성하면, 배터리 소모나 열 발산 문제도 완화됩니다.
- **120fps 지원 대비**: 120fps를 지원하는 기기에서는 8ms 이내에 프레임을 빌드하고 렌더링하는 것이 이상적입니다.

### 6. 기타 성능 저하 원인 피하기

- **AnimatedBuilder 최적화**: 애니메이션과 상관없는 서브트리 부분을 AnimatedBuilder 빌더 함수 밖에 분리하여 성능 저하를 피할 수 있습니다.
- **Opacity 위젯의 애니메이션 대신 AnimatedOpacity 사용**: Opacity를 애니메이션에 사용할 때는 AnimatedOpacity로 대체하여 애니메이션의 성능을 최적화할 수 있습니다.
- **구체적인 리스트 사용 피하기**: Column()이나 ListView()와 같이 화면에 보이지 않는 많은 자식 요소가 포함된 경우에는 리스트를 구체적으로 나열하지 않고 lazy 빌드 방식을 활용해야 합니다.

---

## 렌더링 성능 향상 방법

공식문서 : https://docs.flutter.dev/perf/rendering-performance

### 일반적인 팁

1. **앱의 프로파일 모드에서 성능 분석하기**
    
    애니메이션이 매끄럽지 않을 경우, 프로파일 모드에서 앱을 빌드하여 성능을 분석하세요. 디버그 모드에서의 성능은 실제 배포 성능과 다릅니다.
    
2. **자주 발생하는 문제**
    - 예상보다 많은 UI 부분이 매 프레임 재빌드되는 경우 성능 저하가 발생할 수 있습니다. 이를 추적하려면 DevTools에서 **성능 데이터 표시** 기능을 사용해 보세요.
    - 큰 리스트를 ListView 없이 자식 요소들을 직접 빌드하면 성능이 저하됩니다.

### 성능 최적화 문서 참고

Flutter 성능 분석과 관련된 상세 문서는 아래와 같습니다:

- [Performance Best Practices](https://www.notion.so/part-2-13e07565f81c8081850bc95f29a0c3e9?pvs=21)
- [Flutter Performance Profiling](https://www.notion.so/part-2-13e07565f81c8081850bc95f29a0c3e9?pvs=21)

### 모바일 전용 팁

모바일 앱에서 **첫 번째 애니메이션 실행 시에만 발생하는 끊김 현상**이 있다면, 모바일의 셰이더 컴파일로 인한 렌더링 지연을 줄이는 방법을 확인해 보세요. 자세한 정보는 "[Reduce shader animation jank on mobile](https://www.notion.so/part-2-13e07565f81c8081850bc95f29a0c3e9?pvs=21)" 문서에서 확인할 수 있습니다.

### 웹 전용 팁

Flutter 웹의 성능 최적화와 관련된 내용은 Flutter Gallery 앱 성능 개선 사례를 참고하세요:

- **트리 쉐이킹 및 지연 로딩**을 통한 성능 최적화
- 이미지 플레이스홀더 및 프리캐칭을 통한 사용자 경험 개선
- 웹에서 애니메이션 전환을 비활성화하여 성능 향상
