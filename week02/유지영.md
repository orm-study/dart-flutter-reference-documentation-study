# The Dart type system 타입 시스템

🔗 [페이지 링크]

**The Dart language is type safe: it uses a combination of static type checking and [runtime checks](https://dart.dev/language/type-system#runtime-checks) to ensure that a variable's value always matches the variable's static type, sometimes referred to as sound typing. Although _types_ are mandatory, type _annotations_ are optional because of [type inference](https://dart.dev/language/type-system#type-inference).**

Dart 언어는 타입 안전(type safe)한다. 이는 정적 타입(static type) 검사와 런타임(runtime) 검사를 조합하여 변수의 값이 항상 변수의 정적 타입과 일치하도록 보장한다는 것을 의미하며, 이는 종종 ’타입의 일관성(sound typing)’이라고도 말한다. 타입은 필수적이지만, 타입 추론(type inference) 덕분에 타입 어노테이션은 선택 사항이다.

-   **[Q] 타입의 일관성(sound typing) ?**
    
    ----------
    
    타입의 일관성(sound typing)은 프로그래밍 언어의 타입 시스템이 타입 오류를 방지하고 프로그램이 올바르게 실행되도록 보장하는 특성이다. 이는 타입 시스템이 정적 타입(컴파일 타임에 결정된 타입)과 런타임에 사용되는 실제 값의 타입이 항상 일치하도록 강제하는 것을 의미한다. 오류를 방지하고 코드의 가독성과 유지보수성을 향상시키는 데 중요한 역할을 한다.
    
    **주요 개념**
    
    -   **타입 안전성**
        
        타입 안전성은 타입 불일치로 인해 발생할 수 있는 오류를 방지한다. 타입 안전한 언어에서는 변수에 할당된 값의 타입이 변수의 선언된 타입과 일치해야 한다.
        
    -   **정적 타입 검사**
        
        컴파일 타임에 타입 오류를 발견한다. 예를 들어, 문자열을 정수 변수에 할당하려고 하면 컴파일 타임에 오류가 발생한다.
        
    -   **런타임 타입 검사**
        
        런타임에 타입이 올바르게 사용되는지 확인합니다. 예를 들어, 객체를 특정 타입으로 캐스팅할 때 실제로 해당 타입인지 확인한다.
        
    
    ```dart
    void main() {
      // 컴파일 타임에 오류를 발견
      int number = 42;
      // number = "hello"; // A value of type 'String' can't be assigned to a variable of type 'int'.
    
      // 런타임에 캐스팅 오류를 방지
      dynamic value = "hello";
      try {
        int number = value as int;
      } catch (e) {
        print('캐스팅 오류: $e');
      }
    }
    
    ```
    
    ```dart
    // 출력 결과
    캐스팅 오류: type 'String' is not a subtype of type 'int' in type cast
    
    ```
    
    
-   **[Q] 타입 어노테이션(type annotations) ?**
    

    
    타입 어노테이션(type annotations)은 **변수, 함수, 매개변수 등에 명시적으로 타입을 지정하는 것**을 의미한다. Dart에서는 타입 추론이 가능하기 때문에 타입 어노테이션은 선택 사항이지만, 명시적으로 타입을 지정하면 코드의 가독성과 안정성을 높일 수 있다.
    
    **장점**
    
    -   **가독성 향상**: 코드의 타입 정보를 명시적으로 나타내어, 코드 읽기가 더 쉽다.
    -   **타입 안전성**: 타입 어노테이션을 사용하면 타입 불일치 오류를 컴파일 타임에 발견할 수 있어, 런타임 오류를 줄일 수 있다.
    -   **코드 완성 지원**: IDE에서 타입 정보를 바탕으로 코드 완성을 제공하여, 더 빠르고 정확하게 코드를 작성할 수 있다.
    
    ----------
    

**One benefit of static type checking is the ability to find bugs at compile time using Dart's [static analyzer.](https://dart.dev/tools/analysis)**

정적 타입 검사의 한 가지 이점은 Dart의 정적 분석기를 사용하여 컴파일 시간에 버그를 찾을 수 있다는 점이다.

**You can fix most static analysis errors by adding type annotations to generic classes. The most common generic classes are the collection types `List<T>` and `Map<K,V>`.**

대부분의 정적 분석 오류는 제네릭 클래스에 타입 어노테이션을 추가하여 수정할 수 있다. 가장 일반적인 제네릭 클래스는 List<T>와 Map<K,V>와 같은 컬렉션 타입이다.

**For example, in the following code the `printInts()` function prints an integer list, and `main()` creates a list and passes it to `printInts()`.**

예를 들어, 다음 코드에서 printInts() 함수는 정수 리스트를 출력하며, main() 함수는 리스트를 생성하여 printInts() 함수에 전달한다.

```dart
//✗ static analysis: failure

void printInts(List<int> a) => print(a);

void main() {
  final list = [];
  list.add(1);
  list.add('2');
  printInts(list);
}

```

```dart
// 출력 결과
// List<dynamic> 타입을 List<int> 타입의 매개변수에 할당할 수 없음
Error: The argument type 'List<dynamic>' can't be assigned to the parameter type 'List<int>'.

```

**The preceding code results in a type error on `list` (highlighted above) at the call of `printInts(list)`:**

위의 코드는 printInts(list) 호출 시 list에서 타입 오류를 발생킨다.

**The error highlights an unsound implicit cast from `List<dynamic>` to `List<int>`. The `list` variable has static type `List<dynamic>`. This is because the initializing declaration `var list = []` doesn't provide the analyzer with enough information for it to infer a type argument more specific than `dynamic`. The `printInts()` function expects a parameter of type `List<int>`, causing a mismatch of types.**

오류는 List<dynamic>에서 List<int>로의 불안전한 암시적 캐스트를 강조한다. list 변수의 정적 타입은 List<dynamic>입니다. 이는 초기 선언 var list = []가 분석기에게 dynamic보다 구체적인 타입 인수를 추론할 수 있는 충분한 정보를 제공하지 않기 때문이다. printInts() 함수는 List<int> 타입의 매개변수를 기대하므로 타입 불일치가 발생한다.

**When adding a type annotation (`<int>`) on creation of the list (highlighted below) the analyzer complains that a string argument can't be assigned to an `int` parameter. Removing the quotes in `list.add('2')` results in code that passes static analysis and runs with no errors or warnings.**

리스트를 생성할 때 타입 어노테이션(<int>)을 추가하면, 분석기는 문자열 인수를 int 매개변수에 할당할 수 없다고 경고한다. list.add('2')의 따옴표를 제거하면, 정적 분석을 통과하고 오류나 경고 없이 실행되는 코드가 된다.

```dart
// ✔ static analysis: success

void printInts(List<int> a) => print(a);

void main() {
  final list = <int>[];
  list.add(1);
  list.add(2);
  printInts(list);
}

```

-   **[code] 수정한 코드 주석**
    
    ```dart
    void main() {
    	// final list = []; Type: List<dynamic>
    	// 타입 어노테이션을 사용하여 변수의 타입을 명시적으로 표현
      final list = <int>[];
      
      list.add(1);
      // list.add('2'); 컴파일 오류: String 타입을 int 타입의 매개변수에 할당할 수 없음
      list.add(2);
      
      printInts(list);
    }
    
    ```
    
    ```dart
    // 출력 결과
    [1, 2]
    
    ```
    

----------

## What is soundness?[#](https://dart.dev/language/type-system#what-is-soundness) **Soundness란 무엇인가?**

**_Soundness_ is about ensuring your program can't get into certain invalid states. A sound _type system_ means you can never get into a state where an expression evaluates to a value that doesn't match the expression's static type. For example, if an expression's static type is `String`, at runtime you are guaranteed to only get a string when you evaluate it.**

타입의 일관성(soundness)은 프로그램이 특정 잘못된 상태에 빠지지 않도록 보장하는 것이다. 타입 시스템의 일관성(sound typing)이란 표현식이 정적 타입과 일치하지 않는 값으로 평가되는 상태에 절대 도달할 수 없음을 의미한다. 예를 들어, 표현식의 정적 타입이 String인 경우, 런타임에 해당 표현식을 평가할 때 반드시 문자열을 얻을 수 있음을 보장한다.

**Dart's type system, like the type systems in Java and C#, is sound. It enforces that soundness using a combination of static checking (compile-time errors) and runtime checks. For example, assigning a `String` to `int` is a compile-time error. Casting an object to a `String` using `as String` fails with a runtime error if the object isn't a `String`.**

Dart의 타입 시스템은 Java와 C#의 타입 시스템처럼 일관성이 있다. 이는 정적 검사(컴파일 타임 오류)와 런타임 검사를 조합하여 일관성을 강제한다. 예를 들어, 문자열을 정수에 할당하려고 하면 컴파일 타임 오류가 발생한다. 객체를 as String을 사용하여 문자열로 캐스팅하려고 할 때 해당 객체가 문자열이 아니면 런타임 오류가 발생한다.

----------

## **The benefits of soundness[#](https://dart.dev/language/type-system#the-benefits-of-soundness) Soundness의 이점**

**A sound type system has several benefits:**

일관된 타입 시스템에는 여러 가지 이점이 있다:

1.  **Revealing type-related bugs at compile time.**
    
    컴파일 타임에 타입 관련 버그를 발견한다.
    
    -   **A sound type system forces code to be unambiguous about its types, so type-related bugs that might be tricky to find at runtime are revealed at compile time.**
        
        일관된 타입 시스템은 코드가 타입에 대해 명확하지 않으면 안되므로, 런타임에 찾기 어려운 타입 관련 버그를 컴파일 타임에 드러나게 한다.
        
2.  **More readable code.**
    
    보다 읽기 쉬운 코드.
    
    -   **Code is easier to read because you can rely on a value actually having the specified type. In sound Dart, types can't lie.**
        
        값이 실제로 지정된 타입을 가지고 있기 때문에 코드를 더 읽기 쉽게 할 수 있다. 일관된 Dart에서는 타입이 거짓말을 할 수 없다.
        
3.  **More maintainable code.**
    
    유지보수에 용이한 코드.
    
    -   **With a sound type system, when you change one piece of code, the type system can warn you about the other pieces of code that just broke.**
        
        일관된 타입 시스템을 사용하면, 코드의 일부분을 변경할 때 타입 시스템이 다른 깨진 코드 조각에 대해 경고할 수 있다.
        
4.  **Better ahead of time (AOT) compilation.**
    
    향상된 사전 컴파일(AOT) 성능.
    
    -   **While AOT compilation is possible without types, the generated code is much less efficient.**
        
        타입 없이도 AOT 컴파일이 가능하지만, 생성된 코드는 훨씬 비효율적이다.
        


## **Tips for passing static analysis**[#](https://dart.dev/language/type-system#tips-for-passing-static-analysis) **정적 분석을 통과하기 위한 팁**

**Most of the rules for static types are easy to understand. Here are some of the less obvious rules:**

대부분의 정적 타입 규칙은 이해하기 쉽다. 여기에 덜 명확한 몇 가지 규칙이 있다:

-   **Use sound return types when overriding methods.**
    
    메서드를 재정의할 때 일관된 반환 타입을 사용하라.
    
-   **Use sound parameter types when overriding methods.**
    
    메서드를 재정의할 때 일관된 매개변수 타입을 사용하라.
    
-   **Don't use a dynamic list as a typed list.**
    
    동적 리스트를 타입이 지정된 리스트로 사용하지 말아라.
    

**Let's see these rules in detail, with examples that use the following type hierarchy:**

다음 타입 계층 구조를 사용하는 예제와 함께 이러한 규칙을 자세히 살펴보자:

![[dart.dev 공식문서 이미지]](https://prod-files-secure.s3.us-west-2.amazonaws.com/9db5672d-4cb3-4971-8e51-08c5e31b5395/e177ffa6-d01e-4616-9d19-c02e0a6b2b07/Untitled.png)

[dart.dev 공식문서 이미지]

-   **[note] 기본 개념**
    
    
    **슈퍼클래스 (Superclass)**
    
    -   다른 클래스에 의해 상속되는 클래스. 기본 클래스 또는 부모 클래스라고도 한다.
    -   공통된 속성(필드)과 동작(메서드)을 정의하여 서브클래스가 이를 상속받아 사용할 수 있다.
    
    **서브클래스 (Subclass)**
    
    -   슈퍼클래스를 상속받는 클래스 파생 클래스 또는 자식 클래스라고도 한다.
    -   슈퍼클래스의 속성과 동작을 상속받아 사용할 수 있으며, 필요에 따라 추가적인 속성이나 동작을 정의하거나, 슈퍼클래스의 동작을 재정의(오버라이드)할 수 있다.
    
    **매개변수 타입**
    
    -   메서드의 인자로 사용되는 타입.
    
    ----------
    

### **Use sound return types when overriding methods**[#](https://dart.dev/language/type-system#use-sound-return-types-when-overriding-methods) **메서드를 재정의할 때 일관된 반환 타입을 사용하기**

**The return type of a method in a subclass must be the same type or a subtype of the return type of the method in the superclass. Consider the getter method in the `Animal` class:**

서브클래스의 메서드 반환 타입은 슈퍼클래스의 메서드 반환 타입과 같거나 그 서브타입이어야 한다. 다음은 Animal 클래스의 getter 메서드를 예로 들어 설명한다:

```dart
class Animal {
  void chase(Animal a) { ... }
  Animal get parent => ...
}

```

**The `parent` getter method returns an `Animal`. In the `HoneyBadger` subclass, you can replace the getter's return type with `HoneyBadger` (or any other subtype of `Animal`), but an unrelated type is not allowed.**

부모 getter 메서드는 Animal을 반환한다. HoneyBadger 서브클래스에서는 getter의 반환 타입을 HoneyBadger(또는 Animal의 다른 서브타입)로 대체할 수 있지만, 관련 없는 타입으로 대체하는 것은 허용되지 않는다.

```dart
// ✔ static analysis: success

class HoneyBadger extends Animal {
  @override
  void chase(Animal a) { ... }

  @override
  HoneyBadger get parent => ...
}

```

```dart
// ✗ static analysis: failure

class HoneyBadger extends Animal {
  @override
  void chase(Animal a) { ... }

  @override
  Root get parent => ...
}

```

### **Use sound parameter types when overriding methods[#](https://dart.dev/language/type-system#use-sound-parameter-types-when-overriding-methods) 메서드를 재정의할 때 일관된 매개변수 타입을 사용하기**

**The parameter of an overridden method must have either the same type or a supertype of the corresponding parameter in the superclass. Don't "tighten" the parameter type by replacing the type with a subtype of the original parameter.**

재정의된 메서드의 매개변수 타입은 슈퍼클래스의 해당 매개변수 타입과 같거나 그 슈퍼타입이어야 한다. 원래 매개변수의 타입을 서브타입으로 대체하여 매개변수 타입을 “좁히지” 말아라.

<aside> ℹ️ **Note 주의**

**If you have a valid reason to use a subtype, you can use the [`covariant` keyword](https://dart.dev/guides/language/sound-problems#the-covariant-keyword).**

만약 서브타입을 사용해야 하는 타당한 이유가 있다면, covariant 키워드를 사용할 수 있다.

</aside>

-   **[Q] covariant 키워드 ?**
    
    ----------
    
    메서드나 생성자의 매개변수 타입을 서브타입으로 제한하고 싶을 때 사용한다. 특히 상속 구조에서 메서드를 재정의할 때 유용하다. 일반적으로 매개변수 타입을 더 구체적인 타입으로 변경하는 것은 허용되지 않지만, covariant 키워드를 사용하면 이를 허용할 수 있다.
    
    covariant 키워드는 슈퍼클래스 메서드나 서브클래스 메서드 어느 곳에나 사용할 수 있다. 보통 슈퍼클래스 메서드에 사용하는 것이 가장 좋다. covariant 키워드는 단일 매개변수에 적용되며, setter와 필드에서도 지원된다.
    
    ```dart
    class Animal {
      void chase(covariant Animal a) {
        print('Chasing an animal');
      }
    }
    
    class Dog extends Animal {
      @override
      void chase(covariant Dog d) {
        print('Chasing a dog');
      }
    }
    
    void main() {
      Animal animal = Animal();
      Dog dog = Dog();
      
      animal.chase(animal);
      dog.chase(dog);
    }
    
    ```
    
    ```dart
    // 출력 결과
    Chasing an animal
    Chasing a dog
    
    ```
    
    ----------
    

**Consider the `chase(Animal)` method for the `Animal` class:**

다음은 Animal 클래스의 chase(Animal) 메서드를 예로 들어 설명한다:

```dart
class Animal {
  void chase(Animal a) { ... }
  Animal get parent => ...
}

```

**The `chase()` method takes an `Animal`. A `HoneyBadger` chases anything. It's OK to override the `chase()` method to take anything (`Object`).**

chase() 메서드는 Animal을 매개변수로 받는다. HoneyBadger는 모든 것을 쫓는다. chase() 메서드를 모든 것을 매개변수로 받도록(Object)로 재정의하는 것은 괜찮다.

```dart
// ✔ static analysis: success

class HoneyBadger extends Animal {
  @override
  void chase(Object a) { ... }

  @override
  Animal get parent => ...
}

```

**The following code tightens the parameter on the `chase()` method from `Animal` to `Mouse`, a subclass of `Animal`.**

다음 코드는 chase() 메서드의 매개변수 타입을 Animal에서 Mouse로 좁히고 있다. Mouse는 Animal의 서브클래스이다.

```dart
// ✗ static analysis: failure

class Mouse extends Animal { ... }

class Cat extends Animal {
  @override
  void chase(Mouse a) { ... }
}

```

**This code is not type safe because it would then be possible to define a cat and send it after an alligator:**

이 코드는 타입 안전하지 않는다. 왜냐하면 이를 통해 고양이를 정의하고 악어를 쫓도록 할 수 있기 때문이다:

```dart
Animal a = Cat();
a.chase(Alligator()); // Not type safe or feline safe.

```

-   **[Q] 매개변수 타입을 좁히는 것과 좁히면 안되는 이유에 대한 추가 내용**
    
    ----------
    
    여기서 Cat 클래스는 chase 메서드를 재정의하면서 매개변수 타입을 Mouse로 좁혔다. Mouse는 Animal의 서브클래스이다. 이렇게 매개변수 타입을 더 구체적인 서브타입으로 변경하는 것을 “타입을 좁히는 것(tighten the parameter type)“이라고 한다.
    
    그러나 이는 허용되지 않는다. 왜냐하면 슈퍼클래스의 매개변수 타입보다 더 구체적인 타입으로 재정의하면 타입 안전성을 보장할 수 없기 때문이다.
    
    ```dart
    Animal a = Cat();
    a.chase(Alligator()); // Not type safe or feline safe.
    
    ```
    
    위 코드에서 Animal 타입의 변수 a는 Cat 객체를 참조한다. 그런데 chase 메서드가 Animal을 매개변수로 받는 대신 Mouse를 매개변수로 받도록 재정의 되어있다. 이 경우, Alligator 객체를 chase 메서드의 인자로 넘기면 타입 불일치가 발생합니다. Alligator는 Mouse의 서브타입이 아니기 때문에, 이는 타입 안전하지 못한 것이다.
    
    **요약**
    
    -   **슈퍼클래스의 매개변수 타입**보다 **더 구체적인 서브타입**으로 메서드를 재정의하면 안된다.
    -   매개변수 타입은 슈퍼클래스의 타입과 같거나 더 상위 타입이어야 한다.
    -   이렇게 해야 타입 안전성을 보장할 수 있다.
    
    ----------
    

### **Don't use a dynamic list as a typed list[#](https://dart.dev/language/type-system#dont-use-a-dynamic-list-as-a-typed-list) 동적 리스트를 타입이 지정된 리스트로 사용하지 마세요**

**A `dynamic` list is good when you want to have a list with different kinds of things in it. However, you can't use a `dynamic` list as a typed list.**

동적 리스트는 다양한 종류의 요소를 포함하는 리스트를 만들고자 할 때 유용하다. 그러나 동적(dynamic) 리스트를 타입이 지정된 리스트로 사용할 수는 없다.

**This rule also applies to instances of generic types.**

이 규칙은 제네릭 타입의 인스턴스에도 적용된다.

**The following code creates a `dynamic` list of `Dog`, and assigns it to a list of type `Cat`, which generates an error during static analysis.**

다음 코드는 Dog 타입의 동적 리스트를 생성하고 이를 Cat 타입의 리스트에 할당하여 정적 분석 시 오류를 발생시킨다.

```dart
// ✗ static analysis: failure

void main() {
  List<Cat> foo = <dynamic>[Dog()]; // Error
  List<dynamic> bar = <dynamic>[Dog(), Cat()]; // OK
}

```

----------

## **Runtime checks[#](https://dart.dev/language/type-system#runtime-checks) 런타임 검사**

**Runtime checks deal with type safety issues that can't be detected at compile time.**

런타임 검사는 컴파일 타임에 감지할 수 없는 타입 안전성 문제를 처리한다.

**For example, the following code throws an exception at runtime because it's an error to cast a list of dogs to a list of cats:**

예를 들어, 다음 코드는 개의 리스트를 고양이의 리스트로 캐스팅하려고 할 때 런타임에 예외를 발생시킨다:

```dart
// ✗ runtime: failure

void main() {
  List<Animal> animals = <Dog>[Dog()];
  List<Cat> cats = animals as List<Cat>;
}

```

-   **[Q] 위 코드에서 타입캐스팅이 안되는 이유?**
    
    ----------
    
    -   Dart에서 제네릭 타입을 잘못된 타입으로 캐스팅하려고 하면 런타임 오류가 발생한다.
    -   이는 타입 안전성을 보장하기 위해 제네릭 타입 정보를 런타임에 유지하고, 잘못된 캐스팅을 감지하는 방식으로 동작한다.
    -   타입 캐스팅을 올바르게 사용하기 위해서는 상위 타입으로 업캐스팅하거나, 동일한 타입을 유지해야 한다.
    

## **Type inference[#](https://dart.dev/language/type-system#type-inference) 타입 추론**

**The analyzer can infer types for fields, methods, local variables, and most generic type arguments. When the analyzer doesn't have enough information to infer a specific type, it uses the `dynamic` type.**

분석기는 필드, 메서드, 로컬 변수, 대부분의 제네릭 타입 인수에 대한 타입을 추론할 수 있다. 분석기가 특정 타입을 추론하기에 충분한 정보가 없으면, dynamic 타입을 사용한다.

**Here's an example of how type inference works with generics. In this example, a variable named `arguments` holds a map that pairs string keys with values of various types.**

다음은 제네릭과 함께 타입 추론이 어떻게 작동하는지 보여주는 예제이다. 이 예제에서 arguments라는 변수는 문자열 키와 다양한 타입의 값들을 쌍으로 가지는 맵을 저장한다.

**If you explicitly type the variable, you might write this:**

변수의 타입을 명시적으로 지정하려면 다음과 같이 작성할 수 있다:

```dart
Map<String, dynamic> arguments = {'argA': 'hello', 'argB': 42};

```

**Alternatively, you can use `var` or `final` and let Dart infer the type:**

또는 var나 final을 사용하여 Dart가 타입을 추론하도록 할 수 있습니다:

```dart
var arguments = {'argA': 'hello', 'argB': 42}; // Map<String, Object>

```

**The map literal infers its type from its entries, and then the variable infers its type from the map literal's type. In this map, the keys are both strings, but the values have different types (`String` and `int`, which have the upper bound `Object`). So the map literal has the type `Map<String, Object>`, and so does the `arguments` variable.**

맵 리터럴은 항목들로부터 타입을 추론하고, 변수는 맵 리터럴의 타입으로부터 자신의 타입을 추론한다. 이 맵에서 키는 모두 문자열이지만, 값은 서로 다른 타입을 가진다(문자열과 정수는 상위 타입이 Object입니다). 따라서 맵 리터럴은 Map<String, Object> 타입을 가지며, arguments 변수도 동일한 타입을 갖게 된다.

### **Field and method inference[#](https://dart.dev/language/type-system#field-and-method-inference)

필드와 메서드 추론**

**A field or method that has no specified type and that overrides a field or method from the superclass, inherits the type of the superclass method or field.**

타입이 명시되지 않고 슈퍼클래스의 필드나 메서드를 재정의하는 필드나 메서드는 슈퍼클래스 메서드나 필드의 타입을 상속받는다.

-   **[code] 슈퍼클래스 메서드 재정의 예시 코드 작성**
    
    SpiderMan 클래스는 Hero 클래스의 attack 메서드를 재정의한다. attack 메서드의 타입을 명시적으로 지정하지 않았지만, Hero 클래스에서 상속된 void 타입을 유지한다.
    
    ```dart
    class Hero {
      void attack() {
        print('공격했다.');
      }
    }
    
    class SpiderMan extends Hero {
    	// 슈퍼클래스의 메서드를 재정의
    	// 타입을 명시하지 않아도 슈퍼클래스의 타입을 상속
      @override
      attack() {
        print('스파이더맨이 공격했다.');
      }
    }
    
    void main() {
      Hero spiderMan = SpiderMan();
      spiderMan.attack();
      print(spiderMan.attack.runtimeType);
    }
    
    ```
    
    ```dart
    // 출력 결과
    
    스파이더맨이 공격했다.
    () => void
    
    ```
    

**A field that does not have a declared or inherited type but that is declared with an initial value, gets an inferred type based on the initial value.**

선언된 타입이나 상속된 타입이 없지만 초기 값이 있는 필드는 초기 값을 기반으로 타입을 추론한다.

-   **[code] 초기 값 기반 타입 추론 예시 코드 작성**
    
    Student 클래스의 name과 age 필드는 초기 값에 기반하여 각각 String과 int 타입으로 추론됩니다. 메서드 startStudying은 dynamic을 반환하도록 명시되었지만, 실제로는 String 값을 반환합니다.
    
    ```dart
    class Student {
      // 초기 값을 가진 필드의 타입 추론
      var name = '김학생'; // String 타입으로 추론
      var age = 15; // int 타입으로 추론
    
      // 타입을 명시하지 않고 초기 값을 가진 메서드
      dynamic startStudying() {
        return '공부를 시작합니다.';
      }
    }
    
    void main() {
      var student = Student();
      print(student.name);
      print('student.name.runtimeType: ${student.name.runtimeType}');
      print(student.age);
      print('student.age.runtimeType: ${student.age.runtimeType}');
      print(student.startStudying());
      print('student.startStudying(student.name).runtimeType: ${student.startStudying().runtimeType}');
    }
    
    ```
    
    ```dart
    // 출력 결과
    
    김학생
    student.name.runtimeType: String
    15
    student.age.runtimeType: int
    공부를 시작합니다.
    student.startStudying(student.name).runtimeType: String
    
    ```
    

### **Static field inference[#](https://dart.dev/language/type-system#static-field-inference) 정적 필드 추론**

**Static fields and variables get their types inferred from their initializer. Note that inference fails if it encounters a cycle (that is, inferring a type for the variable depends on knowing the type of that variable).**

정적 필드와 변수는 초기 값으로부터 타입을 추론한다. 추론 중에 순환 참조(변수의 타입을 추론하는 과정에서 그 변수의 타입을 알아야 하는 경우)가 발생하면 추론이 실패한다.

-   **[code] 올바른 정적 필드 타입 추론 예시 코드 작성**
    
    Student 클래스의 정적 필드 name은 초기 값 ‘김학생’으로부터 String 타입으로 추론된다.
    
    ```dart
    class Student {
      // 초기 값을 가진 필드의 타입 추론
      static var name = '김학생'; // String 타입으로 추론
    }
    
    void main() {
      print(Student.name);
    }
    
    ```
    
    ```dart
    // 출력 결과
    
    김학생
    
    ```
    
-   **[code] 순환참조로 인한 타입 추론 실패 예시 코드 작성**
    
    ----------
    
    **순환참조란?**
    
    두 개 이상의 객체 또는 변수가 서로를 참조하는 상황을 말한다.
    
    a와 b는 서로의 값을 참조하여 초기화되기 때문에, 타입을 추론할 수 없다. 이로 인해 컴파일 오류가 발생한다.
    
    ```dart
    class Example {
      // 잘못된 예시: 순환 참조로 인해 타입 추론이 실패
      static var a = b + 1; // 컴파일 오류
      static var b = a + 1; // 컴파일 오류
    }
    
    void main() {
      // 이 코드는 컴파일되지 않는다.
    }
    
    ```
    
    **순환 참조의 문제점**
    
    -   **타입 추론 실패**
        
        컴파일러가 변수의 타입을 추론하지 못해 컴파일 오류가 발생한다.
        
    -   **무한 루프**
        
        순환 참조로 인해 무한 루프가 발생할 수 있다.
        
    -   **메모리 누수**
        
        서로 참조하는 객체가 가비지 컬렉션에 의해 수거되지 않아 메모리 누수가 발생할 수 있다.
        
    
    **해결 방법**
    
    순환 참조를 피하려면, 변수나 객체가 서로를 직접 참조하지 않도록 설계를 변경해야 한다. 또는 초기화 순서를 명확히 하거나, 약한 참조(weak reference)를 사용하여 메모리 누수를 방지할 수 있다.
    
   
    

### **Local variable inference[#](https://dart.dev/language/type-system#local-variable-inference) 로컬 변수 추론**

**Local variable types are inferred from their initializer, if any. Subsequent assignments are not taken into account. This may mean that too precise a type may be inferred. If so, you can add a type annotation.**

로컬 변수의 타입은 초기 값으로부터 추론한다(있을 경우). 이후의 할당은 고려되지 않는다. 이는 너무 구체적인 타입이 추론될 수 있음을 의미한다. 이런 경우, 타입 어노테이션을 추가할 수 있다.

```dart
// ✗ static analysis: failure

var x = 3; // x is inferred as an int.
x = 4.0;

```

```dart
// ✔ static analysis: success

num y = 3; // A num can be double or int.
y = 4.0;

```

### **Type argument inference[#](https://dart.dev/language/type-system#type-argument-inference) 타입 인수 추론**

**Type arguments to constructor calls and [generic method](https://dart.dev/language/generics#using-generic-methods) invocations are inferred based on a combination of downward information from the context of occurrence, and upward information from the arguments to the constructor or generic method. If inference is not doing what you want or expect, you can always explicitly specify the type arguments.**

생성자 호출 및 제네릭 메서드 호출에서의 타입 인수는 발생한 문맥으로부터의 하향식 정보와, 생성자 또는 제네릭 메서드의 인수로부터의 상향식 정보를 조합하여 추론된다. 추론이 원하는 대로 작동하지 않거나 기대와 다른 경우, 항상 타입 인수를 명시적으로 지정할 수 있다.

```dart
// Inferred as if you wrote <int>[].
List<int> listOfInt = [];

// Inferred as if you wrote <double>[3.0].
var listOfDouble = [3.0];

// Inferred as Iterable<int>.
var ints = listOfDouble.map((x) => x.toInt());

```

-   **[Q] 하향식 정보와 상향식 정보란?**
    
    ----------
    
    Dart에서는 타입을 추론 할 때, 하향식 정보와 상향식 정보의 조합을 사용하여 타입을 결정한다.
    
    **하향식 정보 (Downward Information)**
    
    -   문맥에서 내려오는 정보. 즉, 변수나 표현식이 사용되는 위치에서 타입 정보를 가져오는 것.
    -   변수가 할당될 때, 변수의 선언 타입이 하향식 정보를 제공한다.
    
    List<int>라는 타입 정보가 변수 numbers에 대한 하향식 정보이다. 리스트 리터럴 [1, 2, 3]의 타입이 List<int>로 추론된다.
    
    ```dart
    void main() {
      List<int> numbers = [1, 2, 3]; // 하향식 정보: List<int>
    }
    
    ```
    
    **상향식 정보 (Upward Information)**
    
    -   함수 호출이나 표현식 자체의 인수나 리턴 타입에서 올라오는 정보. 즉, 함수나 생성자가 호출될 때, 전달된 인수의 타입이 상향식 정보를 제공하는 것.
    -   함수에 전달된 인수의 타입이 함수의 반환 타입을 결정하는 데 사용된다.
    
    getFirstElement 함수는 제네릭 타입 T를 사용한다. 함수가 호출될 때, 전달된 인수 strings의 타입이 List<String>이므로, T는 String으로 추론된다.
    
    ```dart
    T getFirstElement<T>(List<T> list) {
      return list[0];
    }
    
    void main() {
      var strings = ['hello', 'world'];
      var first = getFirstElement(strings); // 상향식 정보: List<String>
      print(first); // 출력: hello
    }
    
    ```
    
    ----------
    

**In the last example, `x` is inferred as `double` using downward information. The return type of the closure is inferred as `int` using upward information. Dart uses this return type as upward information when inferring the `map()` method's type argument: `<int>`.**

마지막 예제에서 x는 하향식 정보를 사용하여 double로 추론된다. 클로저의 반환 타입은 상향식 정보를 사용하여 int로 추론된다. Dart는 map() 메서드의 타입 인수 <int>를 추론할 때 이 반환 타입을 상향식 정보로 사용한다.

-   **[Q] 클로저(closure)란?**
    
    ----------
    
    함수와 함수가 정의된 환경(렉시컬 스코프)을 함께 저장하는 구조를 말한다. 클로저는 함수가 선언된 위치의 변수를 참조할 수 있으며, 이러한 변수를 함수의 외부에서도 계속해서 접근하고 변경할 수 있다.
    
    **특징**
    
    -   **환경을 기억**
        
        클로저는 함수가 정의될 때의 환경(변수들)을 기억한다.
        
    -   **상태 유지**
        
        클로저는 함수가 종료된 후에도 상태를 유지할 수 있다.
        
    -   **변수 접근**
        
        클로저는 자신이 정의된 스코프에 있는 변수들에 접근할 수 있다.
        
    
    **클로저를 사용한 카운터 예제**
    
    makeCounter 함수는 클로저를 반환한다. 반환된 클로저는 count 변수를 기억하고, 호출될 때마다 count를 증가시켜 반환한다. 이를 통해 클로저가 상태를 유지하는 것을 확인할 수 있다.
    
    ```dart
    Function makeCounter() {
      int count = 0;
    
      return () {
        count++;
        return count;
      };
    }
    
    void main() {
      Function counter = makeCounter();
    
      print(counter());
      print(counter());
      print(counter());
    }
    
    ```
    
    ```dart
    // 출력 결과
    
    1
    2
    3
    
    ```
    
## **Substituting types[#](https://dart.dev/language/type-system#substituting-types) 타입 대체**

**When you override a method, you are replacing something of one type (in the old method) with something that might have a new type (in the new method). Similarly, when you pass an argument to a function, you are replacing something that has one type (a parameter with a declared type) with something that has another type (the actual argument). When can you replace something that has one type with something that has a subtype or a supertype?**

메서드를 재정의할 때, 기존 메서드에서의 한 타입을 새로운 메서드에서 다른 타입으로 대체하는 것이다. 마찬가지로, 함수에 인수를 전달할 때, 선언된 타입을 가진 매개변수를 실제 인수가 가진 다른 타입으로 대체하는 것이다. 언제 한 타입을 서브타입이나 슈퍼타입으로 대체할 수 있을까?

**When substituting types, it helps to think in terms of _consumers_ and _producers_. A consumer absorbs a type and a producer generates a type.**

타입을 대체할 때는 소비자와 생산자의 관점에서 생각하는 것이 도움이 된다. 소비자는 타입을 흡수하고, 생산자는 타입을 생성한다.

**You can replace a consumer's type with a supertype and a producer's type with a subtype.**

소비자의 타입은 슈퍼타입으로 대체할 수 있고, 생산자의 타입은 서브타입으로 대체할 수 있다.

**Let's look at examples of simple type assignment and assignment with generic types.**

단순한 타입 할당과 제네릭 타입을 사용한 할당의 예제를 살펴보자.

### **Simple type assignment[#](https://dart.dev/language/type-system#simple-type-assignment) 단순 타입 할당**

**When assigning objects to objects, when can you replace a type with a different type? The answer depends on whether the object is a consumer or a producer.**

객체를 다른 객체에 할당할 때, 언제 타입을 다른 타입으로 대체할 수 있을까? 이는 객체가 소비자인지 생산자인지에 따라 달라진다.

**Consider the following type hierarchy:**

다음 타입 계층을 고려해보자:

![[dart.dev 공식문서 이미지]](https://prod-files-secure.s3.us-west-2.amazonaws.com/9db5672d-4cb3-4971-8e51-08c5e31b5395/3a2c100e-7681-4ed4-aa4e-9be0d33148d1/Untitled.png)

[dart.dev 공식문서 이미지]

**Consider the following simple assignment where `Cat c` is a _consumer_ and `Cat()` is a _producer_:**

다음은 Cat c가 소비자이고 Cat()이 생산자인 간단한 할당 예제이다:

```dart
Cat c = Cat();

```

**In a consuming position, it's safe to replace something that consumes a specific type (`Cat`) with something that consumes anything (`Animal`), so replacing `Cat c` with `Animal c` is allowed, because `Animal` is a supertype of `Cat`.**

소비자 위치에서는 특정 타입(Cat)을 소비하는 것을 모든 것을 소비하는 타입(Animal)으로 대체하는 것이 안전하다. 따라서 Cat c를 Animal c로 대체하는 것은 허용됩니다. 이는 Animal이 Cat의 슈퍼타입이기 때문이다.

```dart
// ✔ static analysis: success

Animal c = Cat();

```

**But replacing `Cat c` with `MaineCoon c` breaks type safety, because the superclass may provide a type of Cat with different behaviors, such as `Lion`:**

그러나 Cat c를 MaineCoon c로 대체하면 타입 안전성이 깨진다. 슈퍼클래스는 Lion과 같이 다른 동작을 가진 Cat 타입을 제공할 수 있기 때문이다.

```dart
// ✗ static analysis: failure

MaineCoon c = Cat();

```

**In a producing position, it's safe to replace something that produces a type (`Cat`) with a more specific type (`MaineCoon`). So, the following is allowed:**

생산자 위치에서는 특정 타입(Cat)을 생산하는 것을 더 구체적인 타입(MaineCoon)으로 대체하는 것이 안전하다. 따라서 다음과 같은 코드가 허용된다:

```dart
// ✔ static analysis: success

Cat c = MaineCoon();

```

### **Generic type assignment**[#](https://dart.dev/language/type-system#generic-type-assignment) **제네릭 타입 할당**

**Are the rules the same for generic types? Yes. Consider the hierarchy of lists of animals—a `List` of `Cat` is a subtype of a `List` of `Animal`, and a supertype of a `List` of `MaineCoon`:**

제네릭 타입에도 동일한 규칙이 적용될까? 그렇다. 동물 리스트의 계층 구조를 고려해보자—List<Cat>은 List<Animal>의 서브타입이며, List<MaineCoon>의 슈퍼타입이다:

![[dart.dev 공식문서 이미지]](https://prod-files-secure.s3.us-west-2.amazonaws.com/9db5672d-4cb3-4971-8e51-08c5e31b5395/ccaf57ba-8fcd-4beb-9065-217a8b333332/Untitled.png)

[dart.dev 공식문서 이미지]

**In the following example, you can assign a `MaineCoon` list to `myCats` because `List<MaineCoon>` is a subtype of `List<Cat>`:**

다음 예제에서, List<MaineCoon>은 List<Cat>의 서브타입이므로 MaineCoon 리스트를 myCats에 할당할 수 있다:

```dart
// ✔ static analysis: success

List<MaineCoon> myMaineCoons = ...
List<Cat> myCats = myMaineCoons;

```

**What about going in the other direction? Can you assign an `Animal` list to a `List<Cat>`?**

그 반대 방향은 어떨까? List<Animal>을 List<Cat>에 할당할 수 있을까?

```dart
// ✗ static analysis: failure

List<Animal> myAnimals = ...
List<Cat> myCats = myAnimals;

```

**This assignment doesn't pass static analysis because it creates an implicit downcast, which is disallowed from non-`dynamic` types such as `Animal`.**

이 할당은 암시적 다운캐스트를 생성하므로 정적 분석을 통과하지 못한다. 암시적 다운캐스트는 Animal과 같은 비동적 타입에서는 허용되지 않는다.

**To make this type of code pass static analysis, you can use an explicit cast.**

이런 유형의 코드가 정적 분석을 통과하도록 하려면 명시적 캐스트를 사용할 수 있다.

```dart
List<Animal> myAnimals = ...
List<Cat> myCats = myAnimals as List<Cat>;

```

**An explicit cast might still fail at runtime, though, depending on the actual type of the list being cast (`myAnimals`).**

그러나 명시적 캐스트는 리스트의 실제 타입(myAnimals)에 따라 런타임에 실패할 수 있다.

### **Methods[#](https://dart.dev/language/type-system#methods) 메서드**

**When overriding a method, the producer and consumer rules still apply. For example:**

메서드를 재정의할 때도 생산자와 소비자 규칙이 여전히 적용됩니다. 예를 들어:

![[dart.dev 공식문서 이미지]](https://prod-files-secure.s3.us-west-2.amazonaws.com/9db5672d-4cb3-4971-8e51-08c5e31b5395/30644a15-1503-49ea-a6f5-4bea9baceb31/Untitled.png)

[dart.dev 공식문서 이미지]

**For a consumer (such as the `chase(Animal)` method), you can replace the parameter type with a supertype. For a producer (such as the `parent` getter method), you can replace the return type with a subtype.**

소비자(예: chase(Animal) 메서드)에서는 매개변수 타입을 슈퍼타입으로 대체할 수 있습니다. 생산자(예: parent getter 메서드)에서는 반환 타입을 서브타입으로 대체할 수 있다.

**For more information, see [Use sound return types when overriding methods](https://dart.dev/language/type-system#use-proper-return-types) and [Use sound parameter types when overriding methods](https://dart.dev/language/type-system#use-proper-param-types).**

자세한 내용은 메서드를 재정의할 때 일관된 반환 타입을 사용하기와 메서드를 재정의할 때 일관된 매개변수 타입을 사용하기를 참조하자.

----------

## **Other resources[#](https://dart.dev/language/type-system#other-resources) 기타 자료**

**The following resources have further information on sound Dart:**

다음 자료들은 sound Dart에 대한 추가 정보를 제공합니다:

-   [**Fixing common type problems](https://dart.dev/guides/language/sound-problems) - Errors you may encounter when writing sound Dart code, and how to fix them.**
    
    일반적인 타입 문제 해결 - sound Dart 코드를 작성할 때 발생할 수 있는 오류와 이를 해결하는 방법.
    
-   [**Fixing type promotion failures](https://dart.dev/tools/non-promotion-reasons) - Understand and learn how to fix type promotion errors.**
    
    타입 프로모션 실패 해결 - 타입 프로모션 오류를 이해하고 해결하는 방법을 배웁니다.
    
-   [**Sound null safety](https://dart.dev/null-safety) - Learn about writing code with sound null safety.**
    
    Sound null safety - sound null safety를 사용하여 코드를 작성하는 방법을 배웁니다.
    
-   [**Customizing static analysis](https://dart.dev/tools/analysis) - How to set up and customize the analyzer and linter using an analysis options file.**
    
    정적 분석 사용자 지정 - 분석 옵션 파일을 사용하여 분석기와 린터를 설정하고 사용자 지정하는 방법.

---

🔗 [페이지 링크]

# Patterns 패턴

<aside> ℹ️ **Version note**

Patterns require a [language version](https://dart.dev/guides/language/evolution#language-versioning) of at least 3.0. 패턴은 최소 3.0 이상의 언어 버전이 필요합니다.

</aside>

**Patterns are a syntactic category in the Dart language, like statements and expressions. A pattern represents the shape of a set of values that it may match against actual values.**

패턴은 문장(statements)과 표현식(expressions)처럼 Dart 언어의 문법적 범주이다. 패턴은 실제 값과 매치될 수 있는 값들의 모양을 나타낸다.

**This page describes:**

이 페이지에서는 다음 내용을 설명한다:

-   **What patterns do.**
    
    패턴의 기능
    
-   **Where patterns are allowed in Dart code.**
    
    Dart 코드에서 패턴이 허용되는 위치
    
-   **What the common use cases for patterns are.**
    
    패턴의 일반적인 사용 사례
    

**To learn about the different kinds of patterns, visit the [pattern types](https://dart.dev/language/pattern-types) page.**

다양한 종류의 패턴에 대해 배우려면, 패턴 유형 페이지를 방문하자.



## **What patterns do[#](https://dart.dev/language/patterns#what-patterns-do) 패턴의 기능**

**In general, a pattern may match a value, destructure a value, or both, depending on the context and shape of the pattern.**

일반적으로 패턴은 문맥과 패턴의 형태에 따라 값과 매치되거나 값을 분해하거나, 둘 다 할 수 있습니다.

**First, _pattern matching_ allows you to check whether a given value:**

먼저, 패턴 매칭을 통해 주어진 값이 다음 조건을 만족하는지 확인할 수 있다:

-   **Has a certain shape.**
    
    특정 모양을 가지고 있는지.
    
-   **Is a certain constant.**
    
    특정 상수인지.
    
-   **Is equal to something else.**
    
    다른 것과 같은지.
    
-   **Has a certain type.**
    
    특정 타입인지.
    

**Then, _pattern destructuring_ provides you with a convenient declarative syntax to break that value into its constituent parts. The same pattern can also let you bind variables to some or all of those parts in the process.**

그 다음, 패턴 분해를 통해 해당 값을 구성 요소로 나누는 편리한 선언적 문법을 제공한다. 같은 패턴을 사용하여 그 과정에서 일부 또는 모든 구성 요소에 변수를 바인딩할 수도 있다.

-   **[Q] 변수를 바인딩한다?**
    
    ----------
    
    변수를 바인딩한다는 것은 특정 값을 변수에 할당하여 **그 변수가 해당 값을 참조하도록 하는 것**을 의미한다. 바인딩은 변수를 선언하고 초기화할 때 발생한다.
    
    **일반적 변수 바인딩**
    
    여기서 name이라는 변수는 문자열 '김학생’을 참조하며, age라는 변수는 정수 15를 참조한다
    
    ```dart
    String name = '김학생'; // 변수 name을 문자열 '김학생'에 바인딩
    int age = 15; // 변수 age을 정수 15에 바인딩
    
    ```
    
    ----------
    

### **Matching[#](https://dart.dev/language/patterns#matching) 매칭**

**A pattern always tests against a value to determine if the value has the form you expect. In other words, you are checking if the value _matches_ the pattern.**

패턴은 항상 값을 테스트하여 그 값이 기대하는 형태를 가지고 있는지 확인한다. 즉, 값을 패턴과 매칭하는지 확인하는 것이다.

**What constitutes a match depends on [what kind of pattern](https://dart.dev/language/pattern-types) you are using. For example, a constant pattern matches if the value is equal to the pattern's constant:**

무엇이 매칭을 구성하는지는 사용 중인 패턴의 종류에 따라 다르다. 예를 들어, 상수 패턴은 값이 패턴의 상수와 동일한 경우에 매칭된다:

```dart
switch (number) {
  // Constant pattern matches if 1 == number.
  case 1:
    print('one');
}

```

**Many patterns make use of subpatterns, sometimes called _outer_ and _inner_ patterns, respectively. Patterns match recursively on their subpatterns. For example, the individual fields of any [collection-type](https://dart.dev/language/collections) pattern could be [variable patterns](https://dart.dev/language/pattern-types#variable) or [constant patterns](https://dart.dev/language/pattern-types#constant):**

많은 패턴은 각각 외부 패턴과 내부 패턴이라고 불리는 서브패턴을 사용한다. 패턴은 서브패턴에 대해 재귀적으로 매칭된다. 예를 들어, 컬렉션 타입 패턴의 개별 필드는 변수 패턴이나 상수 패턴이 될 수 있다.

```dart
const a = 'a';
const b = 'b';
switch (obj) {
  // List pattern [a, b] matches obj first if obj is a list with two fields,
  // then if its fields match the constant subpatterns 'a' and 'b'.
  case [a, b]:
    print('$a, $b');
}

```

-   **[note] 코드 주석 작성**
    
    ```dart
    // 상수 선언
    // a와 b를 각각 문자열 'a'와 'b'로 초기화, 이 값들은 변경되지 않는 상수이다.
    const a = 'a';
    const b = 'b';
    
    // switch문
    // 객체 obj의 값을 기준으로 여러 case와 매칭한다.
    switch (obj) {
    // 리스트 패턴 매칭
    // 이 case는 리스트 패턴 [a, b]를 사용하여 obj와 매칭.
    // 이 패턴은 obj가 두 개의 필드를 가진 리스트일 때, 그리고 그 필드들이 각각 상수 a와 b와 일치할 때 매칭된다.
    	// 먼저, obj가 두 개의 요소를 가진 리스트인지 확인
    	// 그 다음, 리스트의 첫 번째 요소가 상수 a (즉, 'a')와 일치하는지 확인
    	// 리스트의 두 번째 요소가 상수 b (즉, 'b')와 일치하는지 확인
    	// 만약 obj가 [a, b] 패턴과 일치하면, print('$a, $b'); 구문이 실행
    	case [a, b]:
    	  print('$a, $b');
    }
    
    ```
    

**To ignore parts of a matched value, you can use a [wildcard pattern](https://dart.dev/language/pattern-types#wildcard) as a placeholder. In the case of list patterns, you can use a [rest element](https://dart.dev/language/pattern-types#rest-element).**

매칭된 값의 일부를 무시하려면 와일드카드 패턴을 플레이스홀더로 사용할 수 있다. 리스트 패턴의 경우, 나머지 요소를 나타내는 rest element를 사용할 수 있다.

-   **[Q] 와일드카드 패턴을 플레이스홀더로 사용?**
    
    **플레이스홀더**
    
    여기에서 플레이스홀더란, 패턴 매칭에서 특정 값을 무시하거나 관심이 없는 값을 대체하기 위해 사용되는 기호나 변수를 의미한다. 플레이스홀더는 실제로 값을 저장하거나 사용하지 않지만, 패턴의 형태를 유지하는 데 사용된다.
    
    **와일드 카드 패턴**
    
    와일드카드 패턴은 특정 위치의 값을 무시하거나 대체하기 위해 사용되는 패턴으로, 패턴 매칭 시 일부 요소를 신경 쓰지 않고 넘어갈 수 있다. Dart에서는 밑줄 (underscore, _)을 와일드카드 패턴으로 사용한다.
    

### **Destructuring**[#](https://dart.dev/language/patterns#destructuring) **구조 분해**

**When an object and pattern match, the pattern can then access the object's data and extract it in parts. In other words, the pattern _destructures_ the object:**

객체와 패턴이 매칭되면, 패턴은 객체의 데이터를 접근하여 부분적으로 추출할 수 있다. 즉, 패턴이 객체를 구조 분해한다는 것이다:

```dart
var numList = [1, 2, 3];
// List pattern [a, b, c] destructures the three elements from numList...
var [a, b, c] = numList;
// ...and assigns them to new variables.
print(a + b + c);

```

**You can nest [any kind of pattern](https://dart.dev/language/pattern-types) inside a destructuring pattern. For example, this case pattern matches and destructures a two-element list whose first element is `'a'` or `'b'`:**

구조 분해 패턴 안에 어떤 종류의 패턴도 중첩할 수 있다. 예를 들어, 이 경우 패턴은 첫 번째 요소가 ‘a’ 또는 ‘b’인 두 요소 리스트를 매칭하고 분해한다:

```dart
switch (list) {
  case ['a' || 'b', var c]:
    print(c);
}

```

-   **[note] 추가 코드 예시**
    
    Dart에서는 현재 객체 분해(destructuring)를 직접적으로 지원하지 않지만, 객체의 속성을 개별 변수에 할당하여 유사한 결과를 얻을 수 있다. 아래 코드는 객체의 데이터를 추출하고 변수를 할당하는 방법을 보여준다.
    
    ```dart
    class Person {
      final String name;
      final int age;
    
      Person(this.name, this.age);
    }
    
    void main() {
      // Person 객체 생성
      var person = Person('Alice', 30);
    
      // 객체에서 데이터 추출
      var name = person.name;
      var age = person.age;
    
      // 추출된 데이터 출력
      print('Name: $name'); // 출력: Name: Alice
      print('Age: $age');   // 출력: Age: 30
    }
    
    ```
    


## **Places patterns can appear[#](https://dart.dev/language/patterns#places-patterns-can-appear) 패턴이 사용될 수 있는 위치**

**You can use patterns in several places in the Dart language:**

Dart 언어에서는 여러 곳에서 패턴을 사용할 수 있다:

-   **Local variable [declarations](https://dart.dev/language/patterns#variable-declaration) and [assignments](https://dart.dev/language/patterns#variable-assignment)**
    
    로컬 변수 선언 및 할당
    
-   [**for and for-in loops**](https://dart.dev/language/loops#for-loops)
    
    for 및 for-in 루프
    
-   [**if-case](https://dart.dev/language/branches#if-case) and [switch-case](https://dart.dev/language/branches#switch-statements)**
    
    if-case 및 switch-case
    
-   **Control flow in [collection literals](https://dart.dev/language/collections#control-flow-operators)**
    
    컬렉션 리터럴에서의 제어 흐름
    

**This section describes common use cases for matching and destructuring with patterns.**

이 섹션에서는 패턴을 사용한 매칭 및 구조 분해의 일반적인 사용 사례를 설명한다.

### **Variable declaration[#](https://dart.dev/language/patterns#variable-declaration) 변수 선언**

**You can use a _pattern variable declaration_ anywhere Dart allows local variable declaration. The pattern matches against the value on the right of the declaration. Once matched, it destructures the value and binds it to new local variables:**

Dart에서 로컬 변수 선언이 허용되는 곳 어디에서든 패턴 변수 선언을 사용할 수 있다. 패턴은 선언의 오른쪽 값과 매칭된다. 매칭이 완료되면 값을 구조 분해하고 이를 새로운 로컬 변수에 바인딩한다:

```dart
// 새로운 변수 a, b, c를 선언합니다.
var (a, [b, c]) = ('str', [1, 2]);

```

**A pattern variable declaration must start with either `var` or `final`, followed by a pattern.**

패턴 변수 선언은 반드시 var 또는 final로 시작하고, 그 뒤에 패턴이 와야 한다.

-   **[Q] 왜 반드시 `var` or `final` 로 시작해야 할까?**
    
    ----------
    
    패턴 변수를 선언할 때 var나 final로 시작하는 이유는 변수 선언의 명확성과 안정성을 보장하기 위해서이다. Dart 언어는 변수의 범위와 생명주기를 명확히 하기 위해 이와 같은 규칙을 사용한다.
    
    **이유 설명**
    
    -   **명확한 변수 선언**:
        -   var나 final 키워드로 시작함으로써 새로운 변수가 선언된다는 것을 명확히 알 수 있다.
        -   이를 통해 코드 가독성을 높이고, 변수의 범위와 사용 위치를 쉽게 알 수 있다.
    -   **타입 안정성**:
        -   `var` 키워드는 변수의 타입을 컴파일 타임에 추론한다. 이는 타입 안전성을 유지하고 코드의 유연성을 제공한다.
        -   `final` 키워드는 변수의 값을 한 번만 할당할 수 있게 하여, 불변성을 보장한다. 이는 코드의 예측 가능성을 높이고, 의도치 않은 변경을 방지한다.
    -   **변수의 생명주기 관리**:
        -   변수 선언 키워드를 사용함으로써 변수의 생명주기를 명확히 관리할 수 있다. 이는 메모리 관리를 포함한 다양한 최적화를 가능하게 한다.
    
    ----------
    

### **Variable assignment[#](https://dart.dev/language/patterns#variable-assignment) 변수 할당**

**A _variable assignment pattern_ falls on the left side of an assignment. First, it destructures the matched object. Then it assigns the values to _existing_ variables, instead of binding new ones.**

변수 할당 패턴은 할당문의 왼쪽에 위치한다. 먼저 매칭된 객체를 구조 분해한 다음, 새로운 변수를 바인딩하는 대신 기존 변수에 값을 할당한다.

**Use a variable assignment pattern to swap the values of two variables without declaring a third temporary one:**

변수 할당 패턴을 사용하여 세 번째 임시 변수를 선언하지 않고 두 변수의 값을 교환할 수 있다:

```dart
var (a, b) = ('left', 'right');
(b, a) = (a, b); // Swap.
print('$a $b'); // Prints "right left".

```

-   **[note] 스왑(Swap)이란? (코드 주석 추가)**
    
    위에 문서에 나오는 코드는 튜플을 사용하여 변수의 값을 바꾸는(스왑하는) 예제이다.
    
    ```dart
    void main() {
      // 튜플 분해를 사용하여 변수 선언 및 초기화
      // 튜플 ('left', 'right')를 분해하여 a와 b 변수에 각각 'left'와 'right'를 할당
      var (a, b) = ('left', 'right');
    
      // 튜플 분해를 사용하여 변수 값 스왑
      // b는 a의 값 'left'를 받고, a는 b의 값 'right'를 받음
      // 따라서 a의 값은 'right'가 되고, b의 값은 'left'가 되는 것
      (b, a) = (a, b);
    
      // 결과 출력
      print('$a $b'); // 출력: right left
    }
    
    ```
    
-   **[note] 튜플(Tuple)? → Dart의 레코드(Record)**
    
    ----------
    
    튜플은 여러 개의 값을 하나의 복합 데이터 구조로 묶는 방식이다. 튜플의 각 요소는 서로 다른 타입을 가질 수 있으며, 고정된 크기를 가지는 것이 특징이다. 튜플은 주로 함수에서 여러 값을 반환하거나, 관련된 여러 값을 한꺼번에 다루기 위해 사용된다.
    
    <aside> ℹ️ **Version note**
    
    Dart 3.0부터 도입된 레코드 타입이 튜플과 매우 유사한 기능을 제공한다. 사실상 레코드는 Dart에서 튜플의 역할을 수행한다고 볼 수 있습니다.
    
    </aside>
    
    **특징**
    
    -   **고정된 크기**: 튜플은 생성될 때 정해진 수의 요소를 가지며, 그 크기는 변경되지 않는다.
    -   **서로 다른 타입**: 튜플의 각 요소는 서로 다른 타입일 수 있다.
    -   **순서가 있음**: 튜플의 요소들은 정의된 순서대로 저장되고, 인덱스를 통해 접근할 수 있다.
    
    **차이점**
    
    -   **정의와 용도**:
        -   **레코드(Record)**: 필드의 이름을 명확히 지정하여 사용하거나 위치 기반으로 사용된다. 필드 이름을 통해 더 명확하고 의미 있는 데이터 구조를 만들 수 있다.
        -   **튜플(Tuple)**: 주로 위치 기반으로 사용되며, 필드 이름을 가지지 않는다. 단순히 여러 값을 묶는 용도로 사용된다.
    -   **명명된 필드**:
        -   **레코드**: 필드에 이름을 부여할 수 있어 코드의 가독성과 유지보수성이 높아진다.
        -   **튜플**: 필드 이름이 없으며, 위치를 기반으로 필드에 접근한다.
    -   **언어 지원**:
        -   **레코드**: Dart 3.0부터 도입된 새로운 데이터 타입이다.
        -   **튜플**: Dart에서는 직접적인 튜플 타입을 제공하지 않지만, Dart의 레코드는 튜플과 유사한 기능을 제공한다.
    
    ----------
    
-   **[note] 레코드(Record)란?**
    
    레코드는 여러 개의 값을 하나의 단위로 묶어주는 데이터 구조이다. 레코드는 Dart 3.0부터 도입된 새로운 데이터 타입으로, 여러 값을 하나의 변수로 다룰 수 있게 해준다.
    
    **생성 및 사용 방법**
    
    ```dart
    void main() {
      // 레코드 생성
      var person = ('Alice', 30);
    
      // 레코드의 각 필드에 접근
      var (name, age) = person;
    
      // 필드 값 출력
      print('Name: $name'); // 출력: Name: Alice
      print('Age: $age');   // 출력: Age: 30
    }
    
    ```
    
    **함수에서 레코드 반환**
    
    레코드는 여러 값을 묶어서 반환하거나 전달할 때 유용하다. 레코드는 여러 개의 필드를 가지며, 각 필드는 위치에 따라 접근할 수 있다. 예를 들어, 첫 번째 필드는 첫 번째 위치, 두 번째 필드는 두 번째 위치에 있다.
    
    ```dart
    // 이름과 나이를 반환하는 함수
    (String, int) getPerson() {
      return ('Bob', 25);
    }
    
    void main() {
      // 함수 호출하여 레코드 반환받기
      var person = getPerson();
    
      // 레코드 분해
      var (name, age) = person;
    
      // 필드 값 출력
      print('Name: $name'); // 출력: Name: Bob
      print('Age: $age');   // 출력: Age: 25
    }
    
    ```
    
    **다양한 레코드 선언 방식**
    
    -   **var 키워드**
        
        변수의 타입을 추론한다. 레코드의 요소 타입을 명시하지 않고 사용할 수 있다.
        
        ```dart
        void main() {
          // var 키워드를 사용하여 레코드 선언
          var point = (10, 20);
        
          // 레코드 분해
          var (x, y) = point;
        
          print('x: $x'); // 출력: x: 10
          print('y: $y'); // 출력: y: 20
        }
        
        ```
        
    -   **final 키워드**
        
        불변 변수를 선언하며, 한 번 할당된 값은 변경할 수 없다.
        
        ```dart
        void main() {
          // final 키워드를 사용하여 불변 레코드 선언
          final person = (name: 'Alice', age: 30);
        
          // 레코드 분해
          final (name: n, age: a) = person;
        
          print('Name: $n, Age: $a'); // 출력: Name: Alice, Age: 30
        }
        
        ```
        
    -   **명시적인 타입 선언**
        
        레코드의 각 요소 타입을 명시적으로 선언할 수 있으며, 이를 통해 코드의 타입 안정성을 높일 수 있다.
        
        ```dart
        void main() {
          // 명시적인 타입 선언을 사용하여 레코드 선언
          (String, int, bool) person = ('Bob', 25, true);
        
          // 레코드 분해
          var (name, age, isActive) = person;
        
          print('Name: $name, Age: $age, Active: $isActive');
          // 출력: Name: Bob, Age: 25, Active: true
        }
        
        ```
        

### **Switch statements and expressions[#](https://dart.dev/language/patterns#switch-statements-and-expressions) Switch 문과 표현식**

**Every case clause contains a pattern. This applies to [switch statements](https://dart.dev/language/branches#switch-statements) and [expressions](https://dart.dev/language/branches#switch-expressions), as well as [if-case statements](https://dart.dev/language/branches#if-case). You can use [any kind of pattern](https://dart.dev/language/pattern-types) in a case.**

각 case 절은 패턴을 포함한다. 이는 switch 문과 표현식, if-case 문에도 적용된다. case에서는 어떤 종류의 패턴도 사용할 수 있다.

**_Case patterns_ are [refutable](https://dart.dev/resources/glossary#refutable-pattern). They allow control flow to either:**

case 패턴은 거부 가능하다. 이는 제어 흐름을 다음 두 가지 중 하나로 허용한다:

-   **Match and destructure the object being switched on.**
    
    매칭하여 스위치된 객체를 구조 분해한다.
    
-   **Continue execution if the object doesn't match.**
    
    객체가 매칭되지 않으면 실행을 계속한다.
    

**The values that a pattern destructures in a case become local variables. Their scope is only within the body of that case.**

case에서 패턴이 구조 분해하는 값은 로컬 변수가 된다. 이 변수들의 유효 범위는 해당 case 본문 내에서만 유효하다.

```dart
switch (obj) {
  // Matches if 1 == obj.
  case 1:
    print('one');

  // Matches if the value of obj is between the
  // constant values of 'first' and 'last'.
  // obj의 값이 'first'와 'last'의 상수 값 사이에 있을 때 매칭된다.
  case >= first && <= last:
    print('in range');

  // Matches if obj is a record with two fields,
  // then assigns the fields to 'a' and 'b'.
  // obj가 두 개의 필드를 가진 레코드일 때 매칭되며,
  // 필드를 'a'와 'b'에 할당한다.
  case (var a, var b):
    print('a = $a, b = $b');

  default:
}

```

[**Logical-or patterns](https://dart.dev/language/pattern-types#logical-or) are useful for having multiple cases share a body in switch expressions or statements:**

논리적 OR(||) 패턴은 여러 경우가 switch 표현식이나 문장에서 동일한 본문을 공유하도록 하는 데 유용하다:

```dart
var isPrimary = switch (color) {
  Color.red || Color.yellow || Color.blue => true,
  _ => false
};

```

**Switch statements can have multiple cases share a body [without using logical-or patterns](https://dart.dev/language/branches#switch-share), but they are still uniquely useful for allowing multiple cases to share a [guard](https://dart.dev/language/branches#guard-clause):**

Switch 문은 논리적 OR 패턴을 사용하지 않고도 여러 경우가 본문을 공유할 수 있지만, 여러 경우가 경계 조건(guard)을 공유하도록 하는 데 여전히(특히) 유용하다:

```dart
switch (shape) {
  case Square(size: var s) || Circle(size: var s) when s > 0:
    print('Non-empty symmetric shape');
}

```

[**Guard clauses](https://dart.dev/language/branches#guard-clause) evaluate an arbitrary conditon as part of a case, without exiting the switch if the condition is false (like using an `if` statement in the case body would cause).**

경계 조건은 특정 조건이 거짓일 경우 switch 문을 종료하지 않고, case의 일부로 임의의 조건을 평가한다 (case 본문에서 if 문을 사용하는 경우처럼).

```dart
switch (pair) {
  case (int a, int b):
    if (a > b) print('First element greater');
  // If false, prints nothing and exits the switch.
  case (int a, int b) when a > b:
    // If false, prints nothing but proceeds to next case.
    print('First element greater');
  case (int a, int b):
    print('First element not greater');
}

```

-   **[Q] 경계 조건(Guard clauses)이란?**
    
    경계 조건(guard clause)은 특정 조건이 참인지 여부를 검사하여, **조건이 참일 때만 코드 블록을 실행하도록 하는 코드 패턴**이다. Dart에서 if-case 또는 switch 문 내에서 경계 조건을 사용하여 조건을 더 정밀하게 검사할 수 있다.
    

### **For and for-in loops[#](https://dart.dev/language/patterns#for-and-for-in-loops) for 및 for-in 루프**

**You can use patterns in [for and for-in loops](https://dart.dev/language/loops#for-loops) to iterate-over and destructure values in a collection.**

for 및 for-in 루프에서 패턴을 사용하여 컬렉션의 값을 반복하고 구조 분해할 수 있다.

**This example uses [object destructuring](https://dart.dev/language/pattern-types#object) in a for-in loop to destructure the [`MapEntry`](https://api.dart.dev/stable/dart-core/MapEntry-class.html) objects that a `<Map>.entries` call returns:**

이 예제에서는 for-in 루프에서 객체 구조 분해를 사용하여 <Map>.entries 호출이 반환하는 MapEntry 객체를 구조 분해한다:

```dart
Map<String, int> hist = {
  'a': 23,
  'b': 100,
};

for (var MapEntry(key: key, value: count) in hist.entries) {
  print('$key occurred $count times');
}

```

**The object pattern checks that `hist.entries` has the named type `MapEntry`, and then recurses into the named field subpatterns `key` and `value`. It calls the `key` getter and `value` getter on the `MapEntry` in each iteration, and binds the results to local variables `key` and `count`, respectively.**

객체 패턴은 hist.entries가 MapEntry라는 이름의 타입을 가지고 있는지 확인한 다음, key와 value라는 이름의 필드 서브패턴으로 재귀적으로 들어갑니다. 각 반복에서 MapEntry의 key 게터와 value 게터를 호출하여 결과를 각각 로컬 변수 key와 count에 바인딩합니다.

**Binding the result of a getter call to a variable of the same name is a common use case, so object patterns can also infer the getter name from the [variable subpattern](https://dart.dev/language/pattern-types#variable). This allows you to simplify the variable pattern from something redundant like `key: key` to just `:key`:**

게터 호출의 결과를 동일한 이름의 변수에 바인딩하는 것은 일반적인 사용 사례이기 때문에, 객체 패턴은 변수 하위 패턴에서 게터 이름을 추론할 수도 있다. 이는 중복되는 key: key와 같은 변수 패턴을 :key처럼 간단하게 만들 수 있게 한다.

```dart
for (var MapEntry(:key, value: count) in hist.entries) {
  print('$key occurred $count times');
}

```

-   **[code] 예제 코드 추가**
    
    ```dart
    void main() {
      // 예제 맵 데이터
      var hist = {'a': 3, 'b': 5, 'c': 2};
    
      // for-in 루프를 사용하여 맵의 엔트리들을 순회
      // 패턴 매칭을 통한 변수 추출하여 각각 key와 count 변수에 할당
      for (var MapEntry(:key, value: count) in hist.entries) {
        print('$key occurred $count times');
      }
    }
    
    ```
    
    ```dart
    // 출력 결과
    
    a occurred 3 times
    b occurred 5 times
    c occurred 2 times
    
    ```
    

----------

## **Use cases for patterns[#](https://dart.dev/language/patterns#use-cases-for-patterns) 패턴의 사용 사례**

**The [previous section](https://dart.dev/language/patterns#places-patterns-can-appear) describes _how_ patterns fit into other Dart code constructs. You saw some interesting use cases as examples, like [swapping](https://dart.dev/language/patterns#variable-assignment) the values of two variables, or [destructuring key-value pairs](https://dart.dev/language/patterns#for-and-for-in-loops) in a map. This section describes even more use cases, answering:**

이전 섹션에서는 패턴이 다른 Dart 코드 구성 요소에 어떻게 맞아떨어지는지 설명했다. 두 변수의 값을 교환하거나 맵에서 키-값 쌍을 구조 분해하는 것과 같은 흥미로운 사용 사례를 예제로 보았다. 이 섹션에서는 더 많은 사용 사례를 설명하며 다음 질문에 답한다:

-   **_When and why_ you might want to use patterns.**
    
    언제 그리고 왜 패턴을 사용하고 싶은가?
    
-   **What kinds of problems they solve.**
    
    어떤 종류의 문제를 해결하는가?
    
-   **Which idioms they best suit.**
    
    어떤 관용구에 가장 적합한가?
    

### **Destructuring multiple returns[#](https://dart.dev/language/patterns#destructuring-multiple-returns) 여러 반환값의 구조 분해**

**Records allow aggregating and [returning multiple values](https://dart.dev/language/records#multiple-returns) from a single function call. Patterns add the ability to destructure a record's fields directly into local variables, inline with the function call.**

레코드를 사용하면 단일 함수 호출에서 여러 값을 집계하고 반환할 수 있다. 패턴을 사용하면 함수 호출과 함께 레코드의 필드를 로컬 변수로 직접 구조 분해할 수 있다.

**Instead of individually declaring new local variables for each record field, like this:**

각 레코드 필드에 대해 개별적으로 새로운 로컬 변수를 선언하는 대신, 다음과 같이 할 수 있다:

```dart
var info = userInfo(json);
var name = info.$1;
var age = info.$2;

```

**You can destructure the fields of a record that a function returns into local variables using a [variable declaration](https://dart.dev/language/patterns#variable-declaration) or [assigment pattern](https://dart.dev/language/patterns#variable-assignment), and a [record pattern](https://dart.dev/language/pattern-types#record) as its subpattern:**

변수 선언 또는 할당 패턴을 사용하고, 레코드 패턴을 서브패턴으로 사용하여 함수가 반환하는 레코드의 필드를 로컬 변수로 구조 분해할 수 있다:

```dart
var (name, age) = userInfo(json);

```

**To destructure a record with named fields using a pattern:**

이름이 있는 필드를 가진 레코드를 패턴으로 구조 분해하려면 다음과 같이 한다:

```dart
final (:name, :age) = getData(); // 예: return (name: 'doug', age: 25);

```

### **Destructuring class instances[#](https://dart.dev/language/patterns#destructuring-class-instances) 클래스 인스턴스의 구조 분해**

[**Object patterns](https://dart.dev/language/pattern-types#object) match against named object types, allowing you to destructure their data using the getters the object's class already exposes.**

객체 패턴은 이름이 지정된 객체 타입과 매칭되며, 객체의 클래스가 이미 노출한 게터를 사용하여 데이터를 구조 분해할 수 있다.

**To destructure an instance of a class, use the named type, followed by the properties to destructure enclosed in parentheses:**

클래스 인스턴스를 구조 분해하려면 이름이 지정된 타입을 사용하고, 구조 분해할 속성을 괄호 안에 넣는다:

```dart
final Foo myFoo = Foo(one: 'one', two: 2);
var Foo(:one, :two) = myFoo;
print('one $one, two $two');

```

-   **[code] 예제 코드 주석 추가**
    
    ```dart
    void main() {
      // Foo 객체 생성
      final Foo myFoo = Foo(one: 'one', two: 2);
    
      // 객체 분해를 사용하여 필드 값을 변수로 추출
      // one 변수는 'one' 값을, two 변수는 2 값을 할당
      var Foo(:one, :two) = myFoo;
    
      // 결과 출력
      print('one $one, two $two'); // 출력: one one, two 2
    }
    
    ```
    

### **Algebraic data types[#](https://dart.dev/language/patterns#algebraic-data-types) 대수적 데이터 타입**

**Object destructuring and switch cases are conducive to writing code in an [algebraic data type](https://en.wikipedia.org/wiki/Algebraic_data_type) style. Use this method when:**

객체 구조 분해와 switch case는 대수적 데이터 타입 스타일로 코드를 작성하는 데 유리하다. 다음과 같은 경우에 이 방법을 사용해보자:

-   **You have a family of related types.**
    
    관련된 타입들이 있다.
    
-   **You have an operation that needs specific behavior for each type.**
    
    각 타입에 대해 특정 동작이 필요한 작업이 있다.
    
-   **You want to group that behavior in one place instead of spreading it across all the different type definitions.**
    
    그 동작을 여러 타입 정의에 분산시키지 않고 한 곳에 모으고 싶다.
    
-   **[Q] 대수적(Algebraic) 이라는게?**
    
    ----------
    
    “대수적 데이터 타입(Algebraic Data Type, ADT)“은 프로그래밍에서 데이터 타입을 정의하는 데 사용하는 개념이다. 이는 보통 두 가지 주요 유형으로 구성된다: **합 타입(sum type)**과 **곱 타입(product type)**.
    
    **합 타입 (Sum Type)**
    
    합 타입은 여러 다른 타입 중 하나를 가질 수 있는 데이터 타입을 정의한다. Dart에서는 `enum`이 이에 해당한다. 다른 언어에서는 Union 타입으로도 불리며, 이는 여러 타입 중 하나로만 존재할 수 있다.
    
    ```dart
    enum Result {
      success,
      failure
    }
    
    ```
    
    **곱 타입 (Product Type)**
    
    곱 타입은 여러 타입을 조합하여 하나의 복합 타입을 만드는 것이다. Dart에서는 클래스를 사용하여 이를 정의할 수 있다. 이는 여러 필드를 가지는 객체를 나타낸다.
    
    ```dart
    class Point {
      final int x;
      final int y;
    
      Point(this.x, this.y);
    }
    
    ```
    
    **대수적 데이터 타입 사용 예시**
    
    대수적 데이터 타입을 사용하면 관련된 타입들을 묶어 더 명확하고 유지보수하기 쉬운 코드를 작성할 수 있다. 예를 들어, 결과를 나타내는 타입을 정의하고 이를 사용하는 함수는 다음과 같다:
    
    ```dart
    abstract class Result {}
    
    class Success extends Result {
      final String data;
      Success(this.data);
    }
    
    class Failure extends Result {
      final String error;
      Failure(this.error);
    }
    
    String handleResult(Result result) {
      switch (result.runtimeType) {
        case Success:
          return 'Success: ${(result as Success).data}';
        case Failure:
          return 'Error: ${(result as Failure).error}';
        default:
          return 'Unknown result';
      }
    }
    
    void main() {
      Result result1 = Success('Data loaded');
      Result result2 = Failure('Failed to load data');
    
      print(handleResult(result1)); // Output: Success: Data loaded
      print(handleResult(result2)); // Output: Error: Failed to load data
    }
    
    ```
    
    **요약**
    
    -   **대수적 데이터 타입**은 합 타입과 곱 타입을 사용하여 복잡한 데이터 구조를 정의하는 방법이다.
    -   **합 타입**은 여러 타입 중 하나를 가질 수 있는 데이터 타입이고, **곱 타입**은 여러 타입을 조합하여 하나의 복합 타입을 만드는 것이다.
    -   Dart에서는 enum과 클래스를 사용하여 대수적 데이터 타입을 구현할 수 있다.
    -   이를 통해 관련된 타입들을 묶어 더 구조적이고 유지보수하기 쉬운 코드를 작성할 수 있다.
    
    ----------
    

**Instead of implementing the operation as an instance method for every type, keep the operation's variations in a single function that switches over the subtypes:**

각 타입에 대해 인스턴스 메서드로 구현하는 대신, 서브타입을 전환하는 단일 함수에 그 동작의 변형을 유지하자.

```dart
sealed class Shape {}

class Square implements Shape {
  final double length;
  Square(this.length);
}

class Circle implements Shape {
  final double radius;
  Circle(this.radius);
}

double calculateArea(Shape shape) => switch (shape) {
      Square(length: var l) => l * l,
      Circle(radius: var r) => math.pi * r * r
    };

```

### **Validating incoming JSON[#](https://dart.dev/language/patterns#validating-incoming-json)

들어오는 JSON 데이터 검증**

[**Map](https://dart.dev/language/pattern-types#map) and [list](https://dart.dev/language/pattern-types#list) patterns work well for destructuring key-value pairs in JSON data:**

맵과 리스트 패턴은 JSON 데이터에서 키-값 쌍을 구조 분해하는 데 잘 작동한다:

```dart
var json = {
  'user': ['Lily', 13]
};
var {'user': [name, age]} = json;

```

**If you know that the JSON data has the structure you expect, the previous example is realistic. But data typically comes from an external source, like over the network. You need to validate it first to confirm its structure.**

JSON 데이터가 예상한 구조를 가지고 있다는 것을 알고 있다면, 이전 예제는 현실적이다. 그러나 데이터는 일반적으로 네트워크를 통해 외부 소스에서 오기 때문에 먼저 그 구조를 확인하기 위해 검증해야 한다.

**Without patterns, validation is verbose:**

패턴 없이 검증하면 코드가 장황해진다:

```dart
if (json is Map<String, Object?> &&
    json.length == 1 &&
    json.containsKey('user')) {
  var user = json['user'];
  if (user is List<Object> &&
      user.length == 2 &&
      user[0] is String &&
      user[1] is int) {
    var name = user[0] as String;
    var age = user[1] as int;
    print('User $name is $age years old.');
  }
}

```

**A single [case pattern](https://dart.dev/language/patterns#switch-statements-and-expressions) can achieve the same validation. Single cases work best as [if-case](https://dart.dev/language/branches#if-case) statements. Patterns provide a more declarative, and much less verbose method of validating JSON:**

단일 case 패턴으로 동일한 검증을 수행할 수 있다. 단일 case는 if-case 문으로 가장 잘 작동한다. 패턴은 JSON을 검증하는 데 있어 더 선언적이고 훨씬 간결한 방법을 제공한다:

```dart
if (json case {'user': [String name, int age]}) {
  print('User $name is $age years old.');
}

```

**This case pattern simultaneously validates that:**

이 case 패턴은 동시에 다음을 검증한다:

-   **`json` is a map, because it must first match the outer [map pattern](https://dart.dev/language/pattern-types#map) to proceed.**
    
    json이 맵인지 확인한다. 왜냐하면 외부 맵 패턴과 먼저 매칭되어야 하기 때문이다.
    
    -   **And, since it's a map, it also confirms `json` is not null.**
        
        json이 맵이므로, json이 null이 아님을 확인한다.
        
-   **`json` contains a key `user`.**
    
    json에 user 키가 포함되어 있는지 확인한다.
    
-   **The key `user` pairs with a list of two values.**
    
    user 키가 두 개의 값을 가진 리스트와 연결되는지 확인한다.
    
-   **The types of the list values are `String` and `int`.**
    
    리스트 값의 타입이 String과 int인지 확인한다.
    
-   **The new local variables to hold the values are `name` and `age`.**
    
    값을 저장할 새로운 로컬 변수는 name과 age이다.
