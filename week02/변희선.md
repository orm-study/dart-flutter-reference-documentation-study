Dart(Type system)
ê³µì‹ë¬¸ì„œ : https://dart.dev/language/type-system

The Dart language is type safe: it uses a combination of static type checking andÂ [runtime checks](https://dart.dev/language/type-system#runtime-checks)Â to ensure that a variable's value always matches the variable's static type, sometimes referred to as sound typing. AlthoughÂ *types*Â are mandatory, typeÂ *annotations*Â are optional because ofÂ [type inference](https://dart.dev/language/type-system#type-inference).

> Dart ì–¸ì–´ëŠ” ì •ì  ìœ í˜• ê²€ì‚¬ì™€ ëŸ°íƒ€ì„ ê²€ì‚¬ë¥¼ ì¡°í•©í•˜ì—¬ ë³€ìˆ˜ ê°’ì´ í•­ìƒ ë³€ìˆ˜ì˜ ì •ì  ìœ í˜•ê³¼ ì¼ì¹˜í•˜ë„ë¡ ë³´ì¥í•˜ëŠ” ìœ í˜• ì•ˆì „ì„±ì„ ì œê³µí•©ë‹ˆë‹¤(ì‚¬ìš´ë“œ íƒ€ì´í•‘ì´ë¼ê³ ë„ í•¨). ìœ í˜•ì€ í•„ìˆ˜ì´ì§€ë§Œ ìœ í˜• ì¶”ë¡  ë•Œë¬¸ì— ìœ í˜• ì£¼ì„ì€ ì„ íƒ ì‚¬í•­ì…ë‹ˆë‹¤.
> 

One benefit of static type checking is the ability to find bugs at compile time using Dart'sÂ [static analyzer.](https://dart.dev/tools/analysis)

You can fix most static analysis errors by adding type annotations to generic classes. The most common generic classes are the collection typesÂ `List<T>`Â andÂ `Map<K,V>`.

For example, in the following code theÂ `printInts()`Â function prints an integer list, andÂ `main()`Â creates a list and passes it toÂ `printInts()`.

> ì •ì  ìœ í˜• ê²€ì‚¬ì˜ í•œ ê°€ì§€ ì´ì ì€ Dartì˜ ì •ì  ë¶„ì„ê¸°ë¥¼ ì‚¬ìš©í•˜ì—¬ ì»´íŒŒì¼ ì‹œ ë²„ê·¸ë¥¼ ì°¾ì„ ìˆ˜ ìˆë‹¤ëŠ” ì ì…ë‹ˆë‹¤.
> 
> 
> ì œë„¤ë¦­ í´ë˜ìŠ¤ì— íƒ€ì… ì£¼ì„ì„ ì¶”ê°€í•˜ë©´ ëŒ€ë¶€ë¶„ì˜ ì •ì  ë¶„ì„ ì˜¤ë¥˜ë¥¼ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê°€ì¥ ì¼ë°˜ì ì¸ ì œë„¤ë¦­ í´ë˜ìŠ¤ëŠ” ì»¬ë ‰ì…˜ ìœ í˜•ì¸ List<T>ì™€ Map<K,V>ì…ë‹ˆë‹¤.
> 
> ì˜ˆë¥¼ ë“¤ì–´, ë‹¤ìŒ ì½”ë“œì—ì„œ printInts() í•¨ìˆ˜ëŠ” ì •ìˆ˜ ëª©ë¡ì„ ì¸ì‡„í•˜ê³ , main()ì€ ëª©ë¡ì„ ìƒì„±í•˜ì—¬ printInts()ì— ì „ë‹¬í•©ë‹ˆë‹¤.
> 

```dart
void printInts(List<int> a) => print(a);

void main() {
  final list = [];
  list.add(1);
  // íƒ€ì…ì´ String íƒ€ì… ë¶ˆì¼ì¹˜   '''list.add(2);''' ë¡œ ë³€ê²½í•´ì•¼ ì˜¬ë°”ë¥¸ íƒ€ì… ë§¤ì¹­ë¨
  list.add('2');
  printInts(list);
}
```

- ì˜¤ë¥˜ ë©”ì„¸ì§€
    - error - The argument type 'List<dynamic>' can't be assigned to the parameter type 'List<int>'. - argument_type_not_assignable
    
    The error highlights an unsound implicit cast fromÂ `List<dynamic>`Â toÂ `List<int>`. TheÂ `list`Â variable has static typeÂ `List<dynamic>`. This is because the initializing declarationÂ `var list = []`Â doesn't provide the analyzer with enough information for it to infer a type argument more specific thanÂ `dynamic`. TheÂ `printInts()`Â function expects a parameter of typeÂ `List<int>`, causing a mismatch of types.
    
    When adding a type annotation (`<int>`) on creation of the list (highlighted below) the analyzer complains that a string argument can't be assigned to anÂ `int`Â parameter. Removing the quotes inÂ `list.add('2')`Â results in code that passes static analysis and runs with no errors or warnings.
    
    > 
    > 
    > 
    > ì´ ì˜¤ë¥˜ëŠ” List<dynamic>ì—ì„œ List<int>ë¡œì˜ ë¶ˆê±´ì „í•œ ì•”ì‹œì  í˜•ë³€í™˜ì„ ê°•ì¡°í•©ë‹ˆë‹¤. ëª©ë¡ ë³€ìˆ˜ì˜ ì •ì  ìœ í˜•ì´ List<ë™ì >ì…ë‹ˆë‹¤. ì´ëŠ” ì´ˆê¸°í™” ì„ ì–¸ var list = []ê°€ ë¶„ì„ê¸°ì— ë™ì ë³´ë‹¤ ë” êµ¬ì²´ì ì¸ ìœ í˜• ì¸ìˆ˜ë¥¼ ì¶”ë¡ í•  ìˆ˜ ìˆëŠ” ì¶©ë¶„í•œ ì •ë³´ë¥¼ ì œê³µí•˜ì§€ ì•Šê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. printInts() í•¨ìˆ˜ëŠ” List<int> ìœ í˜•ì˜ ë§¤ê°œ ë³€ìˆ˜ë¥¼ ê¸°ëŒ€í•˜ë¯€ë¡œ ìœ í˜•ì´ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
    > 
    > ëª©ë¡ ìƒì„± ì‹œ ìœ í˜• ì£¼ì„(<int>)ì„ ì¶”ê°€í•  ë•Œ(ì•„ë˜ ê°•ì¡° í‘œì‹œ) ë¶„ì„ê¸°ëŠ” ë¬¸ìì—´ ì¸ìˆ˜ë¥¼ int ë§¤ê°œ ë³€ìˆ˜ì— í• ë‹¹í•  ìˆ˜ ì—†ë‹¤ê³  ë¶ˆí‰í•©ë‹ˆë‹¤. list.add('2')ì—ì„œ ë”°ì˜´í‘œë¥¼ ì œê±°í•˜ë©´ ì •ì  ë¶„ì„ì„ í†µê³¼í•˜ê³  ì˜¤ë¥˜ë‚˜ ê²½ê³  ì—†ì´ ì‹¤í–‰ë˜ëŠ” ì½”ë“œê°€ ìƒì„±ë©ë‹ˆë‹¤.
    > 

**What is soundness?**

*Soundness*Â is about ensuring your program can't get into certain invalid states. A soundÂ *type system*Â means you can never get into a state where an expression evaluates to a value that doesn't match the expression's static type. For example, if an expression's static type isÂ `String`, at runtime you are guaranteed to only get a string when you evaluate it.

Dart's type system, like the type systems in Java and C#, is sound. It enforces that soundness using a combination of static checking (compile-time errors) and runtime checks. For example, assigning aÂ `String`Â toÂ `int`Â is a compile-time error. Casting an object to aÂ `String`Â usingÂ `as String`Â fails with a runtime error if the object isn't aÂ `String`.

> **íƒ€ë‹¹ì„±(Soundness)ì´ë€?**

 í”„ë¡œê·¸ë¨ì´ íŠ¹ì •í•œ ì˜ëª»ëœ ìƒíƒœì— ë¹ ì§€ì§€ ì•Šë„ë¡ ë³´ì¥í•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. íƒ€ë‹¹í•œ íƒ€ì… ì‹œìŠ¤í…œì€ í‘œí˜„ì‹ì˜ ì •ì  íƒ€ì…ê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠëŠ” ê°’ìœ¼ë¡œ í‰ê°€ë˜ëŠ” ìƒí™©ì´ ë°œìƒí•˜ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í‘œí˜„ì‹ì˜ ì •ì  íƒ€ì…ì´ `String`ì´ë¼ë©´, ëŸ°íƒ€ì„ì—ì„œë„ í•´ë‹¹ í‘œí˜„ì‹ì´ ë°˜ë“œì‹œ ë¬¸ìì—´ ê°’ì„ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.

Dartì˜ íƒ€ì… ì‹œìŠ¤í…œì€ Javaì™€ C#ì˜ íƒ€ì… ì‹œìŠ¤í…œì²˜ëŸ¼ íƒ€ë‹¹ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤. ì´ëŠ” ì •ì  ê²€ì‚¬(ì»´íŒŒì¼ íƒ€ì„ ì—ëŸ¬)ì™€ ëŸ°íƒ€ì„ ì²´í¬ë¥¼ ê²°í•©í•˜ì—¬ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, `String` íƒ€ì…ì„ `int`ì— í• ë‹¹í•˜ë ¤ê³  í•˜ë©´ ì»´íŒŒì¼ íƒ€ì„ ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤. ë˜í•œ, ê°ì²´ë¥¼ `as String`ì„ ì‚¬ìš©í•˜ì—¬ ë¬¸ìì—´ë¡œ ìºìŠ¤íŒ…í•˜ë ¤ê³  í•  ë•Œ, í•´ë‹¹ ê°ì²´ê°€ ë¬¸ìì—´ì´ ì•„ë‹ˆë©´ ëŸ°íƒ€ì„ ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤.
ì´ì™€ ê°™ì´, Dartì˜ íƒ€ì… ì‹œìŠ¤í…œì€ í”„ë¡œê·¸ë¨ì´ ì˜ˆìƒì¹˜ ëª»í•œ íƒ€ì… ë¶ˆì¼ì¹˜ë¡œ ì¸í•´ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ê³ , ì•ˆì •ì ì¸ ì½”ë“œ ì‹¤í–‰ì„ ë³´ì¥í•©ë‹ˆë‹¤.
> 

**The benefits of soundness**

A sound type system has several benefits:

- Revealing type-related bugs at compile time.
    
    A sound type system forces code to be unambiguous about its types, so type-related bugs that might be tricky to find at runtime are revealed at compile time.
    
- More readable code.
    
    Code is easier to read because you can rely on a value actually having the specified type. In sound Dart, types can't lie.
    
- More maintainable code.
    
    With a sound type system, when you change one piece of code, the type system can warn you about the other pieces of code that just broke.
    
- Better ahead of time (AOT) compilation.
    
    While AOT compilation is possible without types, the generated code is much less efficient.
    

> **íƒ€ë‹¹ì„±ì˜ ì´ì **
> 
> 
> 
> ì‚¬ìš´ë“œ íƒ€ì… ì‹œìŠ¤í…œì—ëŠ” ì—¬ëŸ¬ ê°€ì§€ ì´ì ì´ ìˆìŠµë‹ˆë‹¤:
> 
> - ì»´íŒŒì¼ ì‹œ íƒ€ì… ê´€ë ¨ ë²„ê·¸ ë°œê²¬.
> ì‚¬ìš´ë“œ íƒ€ì… ì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ë©´ ì½”ë“œì˜ íƒ€ì…ì´ ëª¨í˜¸í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ëŸ°íƒ€ì„ì— ì°¾ê¸° ì–´ë ¤ìš¸ ìˆ˜ ìˆëŠ” íƒ€ì… ê´€ë ¨ ë²„ê·¸ê°€ ì»´íŒŒì¼ ì‹œì ì— ë“œëŸ¬ë‚©ë‹ˆë‹¤.
> - ë” ì½ê¸° ì‰¬ìš´ ì½”ë“œ.
> ì‹¤ì œë¡œ ì§€ì •ëœ ìœ í˜•ì„ ê°€ì§„ ê°’ì— ì˜ì¡´í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ì½”ë“œë¥¼ ë” ì‰½ê²Œ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì‚¬ìš´ë“œ ë‹¤íŠ¸ì—ì„œ íƒ€ì…ì€ ê±°ì§“ë§ì„ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
> - ìœ ì§€ ê´€ë¦¬ê°€ ë” ì‰¬ìš´ ì½”ë“œ.
> ì‚¬ìš´ë“œ íƒ€ì… ì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ë©´ ì½”ë“œ í•œ ë¶€ë¶„ì„ ë³€ê²½í•  ë•Œ íƒ€ì… ì‹œìŠ¤í…œì´ ë°©ê¸ˆ ê¹¨ì§„ ë‹¤ë¥¸ ì½”ë“œì— ëŒ€í•´ ê²½ê³ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> - ë” ë‚˜ì€ ë¯¸ë¦¬ ì»´íŒŒì¼(AOT).
> AOT ì»´íŒŒì¼ì€ ìœ í˜• ì—†ì´ë„ ê°€ëŠ¥í•˜ì§€ë§Œ ìƒì„±ëœ ì½”ë“œì˜ íš¨ìœ¨ì„±ì€ í›¨ì”¬ ë–¨ì–´ì§‘ë‹ˆë‹¤.

**Tips for passing static analysis**

Most of the rules for static types are easy to understand. Here are some of the less obvious rules:

- Use sound return types when overriding methods.
- Use sound parameter types when overriding methods.
- Don't use a dynamic list as a typed list.

Let's see these rules in detail, with examples that use the following type hierarchy:

> **ì •ì  ë¶„ì„ í†µê³¼ë¥¼ ìœ„í•œ íŒ**
> 
> 
> ì •ì  ìœ í˜•ì— ëŒ€í•œ ëŒ€ë¶€ë¶„ì˜ ê·œì¹™ì€ ì´í•´í•˜ê¸° ì‰½ìŠµë‹ˆë‹¤. ë‹¤ìŒì€ ëª…í™•í•˜ì§€ ì•Šì€ ëª‡ ê°€ì§€ ê·œì¹™ì…ë‹ˆë‹¤:
> 
> ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œ ì‚¬ìš´ë“œ ë°˜í™˜ ìœ í˜•ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
> ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•ŒëŠ” ì‚¬ìš´ë“œ ë§¤ê°œë³€ìˆ˜ ìœ í˜•ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
> ë™ì  ëª©ë¡ì„ ìœ í˜•í™”ëœ ëª©ë¡ìœ¼ë¡œ ì‚¬ìš©í•˜ì§€ ë§ˆì„¸ìš”.
> ë‹¤ìŒ ìœ í˜• ê³„ì¸µ êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ëŠ” ì˜ˆì œë¥¼ í†µí•´ ì´ëŸ¬í•œ ê·œì¹™ì„ ìì„¸íˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:
> 
- ì˜ˆì‹œ)
    
    ![á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2024-06-14 á„‹á…©á„Œá…¥á†« 11.22.14.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/638f156c-ab35-4f7a-9b1f-c5ded03b6195/95fac957-0935-474a-aa75-5cba83e4f47b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-06-14_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.22.14.png)
    

**Use sound return types when overriding methods**

The return type of a method in a subclass must be the same type or a subtype of the return type of the method in the superclass. Consider the getter method in theÂ `Animal`Â class:

> **ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œ ì‚¬ìš´ë“œ ë°˜í™˜ ìœ í˜• ì‚¬ìš©**
> 
> 
> 
> ì„œë¸Œí´ë˜ìŠ¤ì— ìˆëŠ” ë©”ì„œë“œì˜ ë°˜í™˜ ìœ í˜•ì€ ìŠˆí¼í´ë˜ìŠ¤ì— ìˆëŠ” ë©”ì„œë“œì˜ ë°˜í™˜ ìœ í˜•ê³¼ ë™ì¼í•œ ìœ í˜•ì´ê±°ë‚˜ í•˜ìœ„ ìœ í˜•ì´ì–´ì•¼ í•©ë‹ˆë‹¤. Animal í´ë˜ìŠ¤ì˜ getter ë©”ì„œë“œë¥¼ ì˜ˆë¡œ ë“¤ì–´ë³´ê² ìŠµë‹ˆë‹¤:
> 

```dart
class Animal {
  void chase(Animal a) { ... }
  Animal get parent => ...
}

// ì˜¬ë°”ë¥¸ ì˜¤ë²„ë¼ì´ë“œ: ìƒìœ„ í´ë˜ìŠ¤ì˜ íƒ€ì…ê³¼ ë™ì¼í•˜ê±°ë‚˜ ë” ë„“ì€ íƒ€ì… ì‚¬ìš©
class HoneyBadger extends Animal {
  @override
  Animal get parent => ... // Animal íƒ€ì… ë˜ëŠ” ìƒìœ„ íƒ€ì…ì´ì–´ì•¼ í•©ë‹ˆë‹¤
}

// ì˜ëª»ëœ ì˜¤ë²„ë¼ì´ë“œ: ìƒìœ„ í´ë˜ìŠ¤ì˜ íƒ€ì…ê³¼ ìƒê´€ì—†ìŒ
class Root extends Animal {
  @override
  Root get parent => ... //
}

```

TheÂ `parent`Â getter method returns anÂ `Animal`. In theÂ `HoneyBadger`Â subclass, you can replace the getter's return type withÂ `HoneyBadger`Â (or any other subtype ofÂ `Animal`), but an unrelated type is not allowed.

> ë¶€ëª¨ getter ë©”ì„œë“œëŠ” Animalì„ ë°˜í™˜í•©ë‹ˆë‹¤. HoneyBadger í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ getterì˜ ë°˜í™˜ ìœ í˜•ì„ HoneyBadger(ë˜ëŠ” Animalì˜ ë‹¤ë¥¸ í•˜ìœ„ ìœ í˜•)ë¡œ ë°”ê¿€ ìˆ˜ ìˆì§€ë§Œ ê´€ë ¨ ì—†ëŠ” ìœ í˜•ì€ í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
> 

**Use sound parameter types when overriding methods**

The parameter of an overridden method must have either the same type or a supertype of the corresponding parameter in the superclass. Don't "tighten" the parameter type by replacing the type with a subtype of the original parameter.

> **ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œ ì‚¬ìš´ë“œ ë§¤ê°œë³€ìˆ˜ ìœ í˜• ì‚¬ìš©**
> 
> 
> 
> ì¬ì •ì˜ëœ ë©”ì„œë“œì˜ ë§¤ê°œë³€ìˆ˜ëŠ” ìŠˆí¼í´ë˜ìŠ¤ì— ìˆëŠ” í•´ë‹¹ ë§¤ê°œë³€ìˆ˜ì™€ ë™ì¼í•œ ìœ í˜•ì´ê±°ë‚˜ ìƒìœ„ ìœ í˜•ì´ì–´ì•¼ í•©ë‹ˆë‹¤. ë§¤ê°œë³€ìˆ˜ ìœ í˜•ì„ ì›ë˜ ë§¤ê°œë³€ìˆ˜ì˜ í•˜ìœ„ ìœ í˜•ìœ¼ë¡œ ëŒ€ì²´í•˜ì—¬ ë§¤ê°œë³€ìˆ˜ ìœ í˜•ì„ "ì œí•œ"í•˜ì§€ ë§ˆì„¸ìš”.
> 

```dart
class Animal {
  void chase(Animal a) { ... }
}

class HoneyBadger extends Animal {
  @override
  void chase(Object a) { ... }

  @override
  Animal get parent => ...
}

class Mouse extends Animal { ... }

class Cat extends Animal {
// ì˜ëª»ëœ ì˜¤ë²„ë¼ì´ë“œ: Animal íƒ€ì…ì´ ì•„ë‹Œ Mouse íƒ€ì…ìœ¼ë¡œ ì œí•œ
  @override
  void chase(Mouse a) { ... } 
}
// Not type safe or feline safe: Animal íƒ€ì…ì˜ ëª¨ë“  ê°ì²´ë¥¼ ë°›ì„ ìˆ˜ ìˆì–´ì•¼ í•¨
Animal a = Cat();
a.chase(Alligator()); 
```

**Don't use a dynamic list as a typed list**

AÂ `dynamic`Â list is good when you want to have a list with different kinds of things in it. However, you can't use aÂ `dynamic`Â list as a typed list.

This rule also applies to instances of generic types.

The following code creates aÂ `dynamic`Â list ofÂ `Dog`, and assigns it to a list of typeÂ `Cat`, which generates an error during static analysis.

> **ë™ì  ëª©ë¡ì„ ì…ë ¥ëœ ëª©ë¡ìœ¼ë¡œ ì‚¬ìš©í•˜ì§€ ë§ˆì„¸ìš”.**
> 
> 
> 
> ë™ì  ëª©ë¡ì€ ë‹¤ì–‘í•œ ì¢…ë¥˜ì˜ í•­ëª©ì´ í¬í•¨ëœ ëª©ë¡ì„ ë§Œë“¤ê³ ì í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ë™ì  ëª©ë¡ì„ ì…ë ¥í˜• ëª©ë¡ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤.
> 
> ì´ ê·œì¹™ì€ ì¼ë°˜ ìœ í˜•ì˜ ì¸ìŠ¤í„´ìŠ¤ì—ë„ ì ìš©ë©ë‹ˆë‹¤.
> 
> ë‹¤ìŒ ì½”ë“œëŠ” ë™ì  ëª©ë¡ì¸ Dogë¥¼ ìƒì„±í•˜ê³  ì´ë¥¼ ìœ í˜• Catì˜ ëª©ë¡ì— í• ë‹¹í•˜ì—¬ ì •ì  ë¶„ì„ ì¤‘ì— ì˜¤ë¥˜ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
> 

```dart
void main() {
  List<Cat> foo = <dynamic>[Dog()]; // Error
  List<dynamic> bar = <dynamic>[Dog(), Cat()]; // OK
}
```

**Runtime checks**

Runtime checks deal with type safety issues that can't be detected at compile time.

For example, the following code throws an exception at runtime because it's an error to cast a list of dogs to a list of cats:

> **ëŸ°íƒ€ì„ ê²€ì‚¬**
> 
> 
> 
> ëŸ°íƒ€ì„ ê²€ì‚¬ëŠ” ì»´íŒŒì¼ ì‹œì ì— ê°ì§€í•  ìˆ˜ ì—†ëŠ” ìœ í˜• ì•ˆì „ ë¬¸ì œë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.
> 
> ì˜ˆë¥¼ ë“¤ì–´ ë‹¤ìŒ ì½”ë“œëŠ” ê°œ ëª©ë¡ì„ ê³ ì–‘ì´ ëª©ë¡ìœ¼ë¡œ ìºìŠ¤íŒ…í•˜ëŠ” ê²ƒì´ ì˜¤ë¥˜ì´ë¯€ë¡œ ëŸ°íƒ€ì„ì— ì˜ˆì™¸ë¥¼ ë˜ì§‘ë‹ˆë‹¤:
> 

```dart
void main() {
  List<Animal> animals = <Dog>[Dog()];
  List<Cat> cats = animals as List<Cat>;
}
```

**Type inference**

The analyzer can infer types for fields, methods, local variables, and most generic type arguments. When the analyzer doesn't have enough information to infer a specific type, it uses theÂ `dynamic`Â type.

Here's an example of how type inference works with generics. In this example, a variable namedÂ `arguments`Â holds a map that pairs string keys with values of various types.

If you explicitly type the variable, you might write this:

> **ìœ í˜• ì¶”ë¡ **
> 
> 
> 
> ë¶„ì„ê¸°ëŠ” í•„ë“œ, ë©”ì„œë“œ, ì§€ì—­ ë³€ìˆ˜ ë° ëŒ€ë¶€ë¶„ì˜ ì¼ë°˜ ìœ í˜• ì¸ìˆ˜ì˜ ìœ í˜•ì„ ì¶”ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¶„ì„ê¸°ì— íŠ¹ì • ìœ í˜•ì„ ì¶”ë¡ í•  ìˆ˜ ìˆëŠ” ì •ë³´ê°€ ì¶©ë¶„í•˜ì§€ ì•Šì€ ê²½ìš° ë™ì  ìœ í˜•ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
> 
> ë‹¤ìŒì€ ì œë„¤ë¦­ì—ì„œ ìœ í˜• ì¶”ë¡ ì´ ì–´ë–»ê²Œ ì‘ë™í•˜ëŠ”ì§€ì— ëŒ€í•œ ì˜ˆì…ë‹ˆë‹¤. ì´ ì˜ˆì œì—ì„œ argumentsë¼ëŠ” ì´ë¦„ì˜ ë³€ìˆ˜ëŠ” ë¬¸ìì—´ í‚¤ì™€ ë‹¤ì–‘í•œ ìœ í˜•ì˜ ê°’ì„ ìŒìœ¼ë¡œ ë¬¶ëŠ” ë§µì„ ë³´ìœ í•©ë‹ˆë‹¤.
> 
> ë³€ìˆ˜ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì…ë ¥í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:
> 

```dart
Map<String, dynamic> arguments = {'argA': 'hello', 'argB': 42};
// ë˜ëŠ” var ë˜ëŠ” finalì„ ì‚¬ìš©í•˜ì—¬ Dartê°€ ìœ í˜•ì„ ìœ ì¶”í•˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
var arguments = {'argA': 'hello', 'argB': 42}; // Map<String, Object>
```

**Field and method inference**

A field or method that has no specified type and that overrides a field or method from the superclass, inherits the type of the superclass method or field.

A field that does not have a declared or inherited type but that is declared with an initial value, gets an inferred type based on the initial value.

> **í•„ë“œ ë° ë©”ì„œë“œ ì¶”ë¡ **
> 
> 
> 
> ì§€ì •ëœ ìœ í˜•ì´ ì—†ê³  ìˆ˜í¼í´ë˜ìŠ¤ì˜ í•„ë“œ ë˜ëŠ” ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•˜ëŠ” í•„ë“œ ë˜ëŠ” ë©”ì„œë“œëŠ” ìˆ˜í¼í´ë˜ìŠ¤ ë©”ì„œë“œ ë˜ëŠ” í•„ë“œì˜ ìœ í˜•ì„ ìƒì†í•©ë‹ˆë‹¤.
> 
> ì„ ì–¸ë˜ê±°ë‚˜ ìƒì†ëœ ìœ í˜•ì´ ì—†ì§€ë§Œ ì´ˆê¸° ê°’ìœ¼ë¡œ ì„ ì–¸ëœ í•„ë“œëŠ” ì´ˆê¸° ê°’ì„ ê¸°ë°˜ìœ¼ë¡œ ì¶”ë¡ ëœ ìœ í˜•ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
> 

**Static field inference**[#](https://dart.dev/language/type-system#static-field-inference)

Static fields and variables get their types inferred from their initializer. Note that inference fails if it encounters a cycle (that is, inferring a type for the variable depends on knowing the type of that variable).

> **ì •ì  í•„ë“œ ì¶”ë¡ **
> 
> 
> 
> ì •ì  í•„ë“œì™€ ë³€ìˆ˜ëŠ” ì´ë‹ˆì…œë¼ì´ì €ì—ì„œ ìœ í˜•ì„ ìœ ì¶”í•©ë‹ˆë‹¤. ì£¼ê¸°ê°€ ë°œìƒí•˜ë©´ ì¶”ë¡ ì´ ì‹¤íŒ¨í•©ë‹ˆë‹¤(ì¦‰, ë³€ìˆ˜ì˜ ìœ í˜•ì„ ì¶”ë¡ í•˜ë ¤ë©´ í•´ë‹¹ ë³€ìˆ˜ì˜ ìœ í˜•ì„ ì•Œì•„ì•¼ í•©ë‹ˆë‹¤).
> 

**Local variable inference**[#](https://dart.dev/language/type-system#local-variable-inference)

Local variable types are inferred from their initializer, if any. Subsequent assignments are not taken into account. This may mean that too precise a type may be inferred. If so, you can add a type annotation.

> **ë¡œì»¬ ë³€ìˆ˜ ì¶”ë¡ **
> 
> 
> 
> ë¡œì»¬ ë³€ìˆ˜ ìœ í˜•ì€ ì´ë‹ˆì…œë¼ì´ì €ê°€ ìˆëŠ” ê²½ìš° ì´ë‹ˆì…œë¼ì´ì €(ì´ˆê¸°í™”)ì—ì„œ ì¶”ë¡ ë©ë‹ˆë‹¤. í›„ì† í• ë‹¹ì€ ê³ ë ¤ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ëŠ” ë„ˆë¬´ ì •í™•í•œ ìœ í˜•ì´ ì¶”ë¡ ë  ìˆ˜ ìˆìŒì„ ì˜ë¯¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë ‡ë‹¤ë©´ ìœ í˜• ì–´ë…¸í…Œì´ì…˜ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> 

**Type argument inference**[#](https://dart.dev/language/type-system#type-argument-inference)

Type arguments to constructor calls andÂ [generic method](https://dart.dev/language/generics#using-generic-methods)Â invocations are inferred based on a combination of downward information from the context of occurrence, and upward information from the arguments to the constructor or generic method. If inference is not doing what you want or expect, you can always explicitly specify the type arguments.

> ìœ í˜• ì¸ìˆ˜ ì¶”ë¡ 
> 
> 
> 
> ìƒì„±ì í˜¸ì¶œ ë° ì œë„¤ë¦­ ë©”ì„œë“œ í˜¸ì¶œì— ëŒ€í•œ íƒ€ì… ì¸ìˆ˜ëŠ” ë°œìƒ ì»¨í…ìŠ¤íŠ¸ì˜ í•˜í–¥ ì •ë³´ì™€ ìƒì„±ì ë˜ëŠ” ì œë„¤ë¦­ ë©”ì„œë“œì— ëŒ€í•œ ì¸ìˆ˜ì˜ ìƒí–¥ ì •ë³´ì˜ ì¡°í•©ì„ ê¸°ë°˜ìœ¼ë¡œ ì¶”ë¡ ë©ë‹ˆë‹¤. ì¶”ë¡ ì´ ì›í•˜ëŠ” ëŒ€ë¡œ ì‘ë™í•˜ì§€ ì•Šê±°ë‚˜ ì˜ˆìƒí•œ ëŒ€ë¡œ ì‘ë™í•˜ì§€ ì•ŠëŠ” ê²½ìš° ì–¸ì œë“ ì§€ ìœ í˜• ì¸ìˆ˜ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> 

```dart
// Inferred as if you wrote <int>[].
List<int> listOfInt = [];

// Inferred as if you wrote <double>[3.0].
var listOfDouble = [3.0];

// Inferred as Iterable<int>.
// map() ë©”ì„œë“œì— ì „ë‹¬ëœ í´ë¡œì € (ìµëª… í•¨ìˆ˜)
var ints = listOfDouble.map((x) => x.toInt());
```

In the last example,Â `x`Â is inferred asÂ `double`Â using downward information. The return type of the closure is inferred asÂ `int`Â using upward information. Dart uses this return type as upward information when inferring theÂ `map()`Â method's type argument:Â `<int>`.

> ë§ˆì§€ë§‰ ì˜ˆì œì—ì„œ xëŠ” í•˜í–¥ ì •ë³´ë¥¼ ì‚¬ìš©í•˜ì—¬ doubleë¡œ ì¶”ë¡ ë©ë‹ˆë‹¤. í´ë¡œì €ì˜ ë°˜í™˜ ìœ í˜•ì€ ìƒí–¥ ì •ë³´ë¥¼ ì‚¬ìš©í•˜ì—¬ intë¡œ ì¶”ë¡ ë©ë‹ˆë‹¤. DartëŠ” map() ë©”ì„œë“œì˜ íƒ€ì… ì¸ìˆ˜ë¥¼ ìœ ì¶”í•  ë•Œ ì´ ë°˜í™˜ ìœ í˜•ì„ ìƒí–¥ ì •ë³´ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.
> 

**Substituting types**

When you override a method, you are replacing something of one type (in the old method) with something that might have a new type (in the new method). Similarly, when you pass an argument to a function, you are replacing something that has one type (a parameter with a declared type) with something that has another type (the actual argument). When can you replace something that has one type with something that has a subtype or a supertype?

When substituting types, it helps to think in terms ofÂ *consumers*Â andÂ *producers*. A consumer absorbs a type and a producer generates a type.

**You can replace a consumer's type with a supertype and a producer's type with a subtype.**

Let's look at examples of simple type assignment and assignment with generic types

> **ëŒ€ì²´ ìœ í˜•**
> 
> 
> 
> ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•˜ë©´ í•œ ê°€ì§€ ìœ í˜•(ì´ì „ ë©”ì„œë“œì—ì„œ)ì„ ìƒˆë¡œìš´ ìœ í˜•(ìƒˆ ë©”ì„œë“œì—ì„œ)ì„ ê°€ì§ˆ ìˆ˜ ìˆëŠ” ê²ƒìœ¼ë¡œ ëŒ€ì²´í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ë§ˆì°¬ê°€ì§€ë¡œ í•¨ìˆ˜ì— ì¸ìˆ˜ë¥¼ ì „ë‹¬í•  ë•Œ í•œ ê°€ì§€ ìœ í˜•(ì„ ì–¸ëœ ìœ í˜•ì„ ê°€ì§„ ë§¤ê°œë³€ìˆ˜)ì„ ë‹¤ë¥¸ ìœ í˜•(ì‹¤ì œ ì¸ìˆ˜)ìœ¼ë¡œ ëŒ€ì²´í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. í•˜ë‚˜ì˜ ìœ í˜•ì„ ê°€ì§„ ê²ƒì„ í•˜ìœ„ ìœ í˜•ì´ë‚˜ ìƒìœ„ ìœ í˜•ì„ ê°€ì§„ ê²ƒìœ¼ë¡œ ëŒ€ì²´í•  ìˆ˜ ìˆëŠ” ê²½ìš°ëŠ” ì–¸ì œì¸ê°€ìš”?
> 
> ìœ í˜•ì„ ëŒ€ì²´í•  ë•ŒëŠ” ì†Œë¹„ìì™€ ìƒì‚°ìì˜ ê´€ì ì—ì„œ ìƒê°í•˜ë©´ ë„ì›€ì´ ë©ë‹ˆë‹¤. ì†Œë¹„ìëŠ” ìœ í˜•ì„ í¡ìˆ˜í•˜ê³  ìƒì‚°ìëŠ” ìœ í˜•ì„ ìƒì„±í•©ë‹ˆë‹¤.
> 
> **ì†Œë¹„ìì˜ ìœ í˜•ì€ ìŠˆí¼ ìœ í˜•ìœ¼ë¡œ, ìƒì‚°ìì˜ ìœ í˜•ì€ í•˜ìœ„ ìœ í˜•ìœ¼ë¡œ ëŒ€ì²´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.**
> 
> ê°„ë‹¨í•œ ìœ í˜• í• ë‹¹ê³¼ ì¼ë°˜ ìœ í˜•ì„ ì‚¬ìš©í•œ í• ë‹¹ì˜ ì˜ˆë¥¼ ì‚´í´ ë³´ê² ìŠµë‹ˆë‹¤.
> 

<aside>
ğŸ’¡ **ì†Œë¹„ì(Consumer)ì™€ ìƒì‚°ì(Producer)ì˜ ê°œë…**

**ì†Œë¹„ì(Consumer): íŠ¹ì • íƒ€ì…ì˜ ê°’ì„ ì‚¬ìš©í•˜ëŠ” í•¨ìˆ˜ë‚˜ ë©”ì„œë“œ, í´ë˜ìŠ¤ ë“±ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í•¨ìˆ˜ ë§¤ê°œë³€ìˆ˜ëŠ” ì†Œë¹„ìì…ë‹ˆë‹¤. ì†Œë¹„ìëŠ” ì „ë‹¬ëœ ê°’ì„ ì†Œë¹„(ì‚¬ìš©)í•©ë‹ˆë‹¤.
ìƒì‚°ì(Producer): íŠ¹ì • íƒ€ì…ì˜ ê°’ì„ ìƒì„±í•˜ê±°ë‚˜ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ë‚˜ ë©”ì„œë“œ, í´ë˜ìŠ¤ ë“±ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í•¨ìˆ˜ì˜ ë°˜í™˜ ê°’ì€ ìƒì‚°ìì…ë‹ˆë‹¤. ìƒì‚°ìëŠ” ê°’ì„ ìƒì„±í•˜ê±°ë‚˜ ë°˜í™˜í•©ë‹ˆë‹¤.**

</aside>

**Simple type assignment**

When assigning objects to objects, when can you replace a type with a different type? The answer depends on whether the object is a consumer or a producer.

Consider the following type hierarchy:

> **ê°„ë‹¨í•œ ìœ í˜• í• ë‹¹**
> 
> 
> 
> ê°ì²´ì— ê°ì²´ë¥¼ í• ë‹¹í•  ë•Œ ì–¸ì œ ìœ í˜•ì„ ë‹¤ë¥¸ ìœ í˜•ìœ¼ë¡œ ë°”ê¿€ ìˆ˜ ìˆë‚˜ìš”? ëŒ€ë‹µì€ ê°ì²´ê°€ ì†Œë¹„ìì¸ì§€ ìƒì‚°ìì¸ì§€ì— ë”°ë¼ ë‹¤ë¦…ë‹ˆë‹¤.
> 
> ë‹¤ìŒ ìœ í˜• ê³„ì¸µ êµ¬ì¡°ë¥¼ ê³ ë ¤í•´ ë³´ì„¸ìš”:
> 
- ì˜ˆì‹œ)
    
    ![á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2024-06-14 á„‹á…©á„’á…® 12.20.12.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/638f156c-ab35-4f7a-9b1f-c5ded03b6195/bb5888ea-e273-4920-aceb-0b3073538ba4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-06-14_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_12.20.12.png)
    
    Cat cê°€ ì†Œë¹„ìì´ê³  Cat()ì´ ìƒì‚°ìì¸ ë‹¤ìŒì˜ ê°„ë‹¨í•œ í• ë‹¹ì„ ìƒê°í•´ ë³´ì„¸ìš”
    
    ```dart
    // 'Animal' íƒ€ì…ì˜ ë³€ìˆ˜ cì— 'Cat' ê°ì²´ë¥¼ í• ë‹¹ (ì—…ìºìŠ¤íŒ…)
    Animal c = Cat(); 
    
    // 'MaineCoon' íƒ€ì…ì˜ ë³€ìˆ˜ cì— 'Cat' ê°ì²´ë¥¼ í• ë‹¹ (íƒ€ì… ë¶ˆì¼ì¹˜ë¡œ ì»´íŒŒì¼ ì˜¤ë¥˜ ë°œìƒ)
    MaineCoon c = Cat(); 
    
    // 'Cat' íƒ€ì…ì˜ ë³€ìˆ˜ cì— 'MaineCoon' ê°ì²´ë¥¼ í• ë‹¹ (ë‹¤ìš´ìºìŠ¤íŒ…, Catì´ MaineCoonì˜ ìŠˆí¼í´ë˜ìŠ¤ë¼ ê°€ëŠ¥)
    Cat c = MaineCoon();  
    ```
    

**Generic type assignment**

Are the rules the same for generic types? Yes. Consider the hierarchy of lists of animalsâ€”aÂ `List`Â ofÂ `Cat`Â is a subtype of aÂ `List`Â ofÂ `Animal`, and a supertype of aÂ `List`Â ofÂ `MaineCoon`:

- ì˜ˆì‹œ)
    
    ![á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2024-06-14 á„‹á…©á„’á…® 5.13.35.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/638f156c-ab35-4f7a-9b1f-c5ded03b6195/fa8fbe98-801a-4eb7-a445-5b491cf4b731/d31423eb-196c-49c3-8ad4-a97d08a4800a.png)
    
    ë‹¤ìŒ ì˜ˆì œì—ì„œëŠ” List<MaineCoon>ì´ List<Cat>ì˜ í•˜ìœ„ ìœ í˜•ì´ë¯€ë¡œ myCatsì— MaineCoon ëª©ë¡ì„ í• ë‹¹í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    
    ```dart
    // 'MaineCoon' íƒ€ì…ì˜ ê°ì²´ ëª©ë¡ì„ ìƒì„±
    List<MaineCoon> myMaineCoons = ...; 
    // ì»´íŒŒì¼ ì˜¤ë¥˜: 'List<MaineCoon>'ì„ 'List<Cat>'ì— í• ë‹¹í•  ìˆ˜ ì—†ìŒ
    List<Cat> myCats = myMaineCoons;
    
    // 'Animal' íƒ€ì…ì˜ ê°ì²´ ëª©ë¡ì„ ìƒì„±
    List<Animal> myAnimals = ...; 
    // ì»´íŒŒì¼ ì˜¤ë¥˜: 'List<Animal>'ì„ 'List<Cat>'ì— í• ë‹¹í•  ìˆ˜ ì—†ìŒ
    List<Cat> myCats = myAnimals; 
    
    // 'Animal' íƒ€ì…ì˜ ê°ì²´ ëª©ë¡ì„ ìƒì„±
    List<Animal> myAnimals = ...;
    // ëŸ°íƒ€ì„ ì˜¤ë¥˜ ê°€ëŠ¥: 'List<Animal>'ì„ 'List<Cat>'ë¡œ ê°•ì œ ìºìŠ¤íŒ… (ì•ˆì „í•˜ì§€ ì•ŠìŒ)
    List<Cat> myCats = myAnimals as List<Cat>; 
    ```
    

**Methods**

When overriding a method, the producer and consumer rules still apply. For example:

- ì˜ˆì œ)
    
    ![á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2024-06-14 á„‹á…©á„’á…® 5.21.26.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/638f156c-ab35-4f7a-9b1f-c5ded03b6195/f0bcad78-f781-470d-b92a-610b2884fdcc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-06-14_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.21.26.png)
    
    For a consumer (such as theÂ `chase(Animal)`Â method), you can replace the parameter type with a supertype. For a producer (such as theÂ `parent`Â getter method), you can replace the return type with a subtype.
    
    For more information, seeÂ [Use sound return types when overriding methods](https://dart.dev/language/type-system#use-proper-return-types)Â andÂ [Use sound parameter types when overriding methods](https://dart.dev/language/type-system#use-proper-param-types).
    
    > ì†Œë¹„ì(ì˜ˆ: ì²´ì´ìŠ¤(ë™ë¬¼) ë©”ì„œë“œ)ì˜ ê²½ìš° ë§¤ê°œë³€ìˆ˜ ìœ í˜•ì„ ìƒìœ„ ìœ í˜•ìœ¼ë¡œ ëŒ€ì²´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìƒì‚°ì(ì˜ˆ: ë¶€ëª¨ ê²Œí„° ë©”ì„œë“œ)ì˜ ê²½ìš° ë°˜í™˜ ìœ í˜•ì„ í•˜ìœ„ ìœ í˜•ìœ¼ë¡œ ë°”ê¿€ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    > 
    > 
    > ìì„¸í•œ ë‚´ìš©ì€ ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œ ì‚¬ìš´ë“œ ë°˜í™˜ ìœ í˜• ì‚¬ìš© ë° ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œ ì‚¬ìš´ë“œ ë§¤ê°œë³€ìˆ˜ ìœ í˜• ì‚¬ìš©ì„ ì°¸ì¡°í•˜ì„¸ìš”.
    

    Dart(Patterns)
  ê³µì‹ë¬¸ì„œ :https://dart.dev/language/patterns

This page describes:

- What patterns do.
- Where patterns are allowed in Dart code.
- What the common use cases for patterns are.

To learn about the different kinds of patterns, visit theÂ [pattern types](https://dart.dev/language/pattern-types)Â page.

> ì´ í˜ì´ì§€ì—ì„œ ì„¤ëª…í•©ë‹ˆë‹¤:
> 
> - íŒ¨í„´ì˜ ê¸°ëŠ¥.
> - Dart ì½”ë“œì—ì„œ íŒ¨í„´ì´ í—ˆìš©ë˜ëŠ” ìœ„ì¹˜.
> - íŒ¨í„´ì˜ ì¼ë°˜ì ì¸ ì‚¬ìš© ì‚¬ë¡€.
> 
> ë‹¤ì–‘í•œ ì¢…ë¥˜ì˜ íŒ¨í„´ì— ëŒ€í•´ ì•Œì•„ë³´ë ¤ë©´ íŒ¨í„´ ìœ í˜• í˜ì´ì§€ë¥¼ ë°©ë¬¸í•˜ì„¸ìš”.
> 

**What patterns do**

In general, a pattern mayÂ **match**Â a value,Â **destructure**Â a value, or both, depending on the context and shape of the pattern.

First,Â *pattern matching*Â allows you to check whether a given value:

- Has a certain shape.
- Is a certain constant.
- Is equal to something else.
- Has a certain type.

Then,Â *pattern destructuring*Â provides you with a convenient declarative syntax to break that value into its constituent parts. The same pattern can also let you bind variables to some or all of those parts in the process.

> **íŒ¨í„´ì„ ì–´ë–»ê²Œ ì“¸ê¹Œ**
> 
> 
> 
> ì¼ë°˜ì ìœ¼ë¡œ íŒ¨í„´ì€ íŒ¨í„´ì˜ ë¬¸ë§¥ê³¼ í˜•íƒœì— ë”°ë¼ ê°’ê³¼ ì¼ì¹˜í•˜ê±°ë‚˜, ê°’ì„ íŒŒê´´í•˜ê±°ë‚˜, ë‘˜ ë‹¤ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> 
> ë¨¼ì €, íŒ¨í„´ ì¼ì¹˜ë¥¼ ì‚¬ìš©í•˜ë©´ ì£¼ì–´ì§„ ê°’ì´ ì¼ì¹˜í•˜ëŠ”ì§€ ì—¬ë¶€ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:
> 
> - íŠ¹ì • ëª¨ì–‘ì„ ê°€ì¡ŒëŠ”ì§€.
> - íŠ¹ì • ìƒìˆ˜ì…ë‹ˆë‹¤.
> - ë‹¤ë¥¸ ê°’ê³¼ ë™ì¼í•˜ë‹¤.
> - íŠ¹ì • ìœ í˜•ì´ ìˆìŠµë‹ˆë‹¤.
> 
> ê·¸ëŸ° ë‹¤ìŒ íŒ¨í„´ ë¶„í•´ëŠ” í¸ë¦¬í•œ ì„ ì–¸ì  êµ¬ë¬¸ì„ ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ ê°’ì„ êµ¬ì„± ë¶€ë¶„ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆìŠµë‹ˆë‹¤. 
> ë˜í•œ ë™ì¼í•œ íŒ¨í„´ì„ ì‚¬ìš©í•˜ì—¬ ì´ëŸ¬í•œ ë¶€ë¶„ì˜ ì¼ë¶€ ë˜ëŠ” ì „ì²´ì— ë³€ìˆ˜ë¥¼ ë°”ì¸ë”©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> 

**Matching**

A pattern always tests against a value to determine if the value has the form you expect. In other words, you are checking if the valueÂ *matches*Â the pattern.

What constitutes a match depends onÂ [what kind of pattern](https://dart.dev/language/pattern-types)Â you are using. For example, a constant pattern matches if the value is equal to the pattern's constant:

> **ë§¤ì¹­**
> 
> 
> 
> íŒ¨í„´ì€ í•­ìƒ ê°’ì— ëŒ€í•´ í…ŒìŠ¤íŠ¸í•˜ì—¬ ê°’ì´ ì˜ˆìƒí•œ í˜•ì‹ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤. 
> ì¦‰, ê°’ì´ íŒ¨í„´ê³¼ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.
> 
> ì¼ì¹˜ë¥¼ êµ¬ì„±í•˜ëŠ” ê²ƒì€ ì‚¬ìš© ì¤‘ì¸ íŒ¨í„´ì˜ ì¢…ë¥˜ì— ë”°ë¼ ë‹¤ë¦…ë‹ˆë‹¤. 
> ì˜ˆë¥¼ ë“¤ì–´ ìƒìˆ˜ íŒ¨í„´ì€ ê°’ì´ íŒ¨í„´ì˜ ìƒìˆ˜ì™€ ê°™ìœ¼ë©´ ì¼ì¹˜í•©ë‹ˆë‹¤:
> 

```dart
switch (number) {
  // Constant pattern matches if 1 == number.
  case 1:
    print('one');
}
```

Many patterns make use of subpatterns, sometimes calledÂ *outer*Â andÂ *inner*Â patterns, respectively. Patterns match recursively on their subpatterns. For example, the individual fields of anyÂ [collection-type](https://dart.dev/language/collections)Â pattern could beÂ [variable patterns](https://dart.dev/language/pattern-types#variable)Â orÂ [constant patterns](https://dart.dev/language/pattern-types#constant):

> ë§ì€ íŒ¨í„´ì€ ê°ê° ì™¸ë¶€ íŒ¨í„´ê³¼ ë‚´ë¶€ íŒ¨í„´ì´ë¼ê³ ë„ í•˜ëŠ” í•˜ìœ„ íŒ¨í„´ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. íŒ¨í„´ì€ í•˜ìœ„ íŒ¨í„´ì—ì„œ ì¬ê·€ì ìœ¼ë¡œ ì¼ì¹˜í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì»¬ë ‰ì…˜ ìœ í˜• íŒ¨í„´ì˜ ê°œë³„ í•„ë“œëŠ” ê°€ë³€ íŒ¨í„´ ë˜ëŠ” ìƒìˆ˜ íŒ¨í„´ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> 

```dart
const a = 'a'; 
const b = 'b'; 

switch (obj) {
  // ë¦¬ìŠ¤íŠ¸ íŒ¨í„´ [a, b]ê°€ objì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
  // objê°€ ë‘ ê°œì˜ í•„ë“œë¥¼ ê°€ì§„ ë¦¬ìŠ¤íŠ¸ì´ê³ , í•´ë‹¹ í•„ë“œê°€ ìƒìˆ˜ 'a'ì™€ 'b'ì™€ ì¼ì¹˜í•˜ëŠ” ê²½ìš°ì—ë§Œ ë§¤ì¹­ëœë‹¤.
  case [a, b]:
    print('$a, $b'); 
}
```

To ignore parts of a matched value, you can use aÂ [wildcard pattern](https://dart.dev/language/pattern-types#wildcard)Â as a placeholder. In the case of list patterns, you can use aÂ [rest element](https://dart.dev/language/pattern-types#rest-element).

> ì¼ì¹˜í•˜ëŠ” ê°’ì˜ ì¼ë¶€ë¥¼ ë¬´ì‹œí•˜ë ¤ë©´ ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ì„ ìë¦¬ í‘œì‹œìë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ëª©ë¡ íŒ¨í„´ì˜ ê²½ìš° ë‚˜ë¨¸ì§€ ìš”ì†Œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> 

**Destructuring**

When an object and pattern match, the pattern can then access the object's data and extract it in parts. In other words, the patternÂ *destructures*Â the object:

> ë¶„í•´
> 
> 
> ê°ì²´ì™€ íŒ¨í„´ì´ ì¼ì¹˜í•˜ë©´ íŒ¨í„´ì€ ê°ì²´ì˜ ë°ì´í„°ì— ì•¡ì„¸ìŠ¤í•˜ì—¬ ë¶€ë¶„ì ìœ¼ë¡œ ì¶”ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¦‰, íŒ¨í„´ì´ ê°ì²´ë¥¼ íŒŒê´´í•©ë‹ˆë‹¤
> 

**Places patterns can appear**

You can use patterns in several places in the Dart language:

- Local variableÂ [declarations](https://dart.dev/language/patterns#variable-declaration)Â andÂ [assignments](https://dart.dev/language/patterns#variable-assignment)
- [for and for-in loops](https://dart.dev/language/loops#for-loops)
- [if-case](https://dart.dev/language/branches#if-case)Â andÂ [switch-case](https://dart.dev/language/branches#switch-statements)
- Control flow inÂ [collection literals](https://dart.dev/language/collections#control-flow-operators)

This section describes common use cases for matching and destructuring with patterns.

> **ì¥ì†Œ íŒ¨í„´ì´ ë‚˜íƒ€ë‚  ìˆ˜ ìˆìŠµë‹ˆë‹¤.**
> 
> 
> Dart ì–¸ì–´ì˜ ì—¬ëŸ¬ ìœ„ì¹˜ì—ì„œ íŒ¨í„´ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:
> 
> ì§€ì—­ ë³€ìˆ˜ ì„ ì–¸ ë° í• ë‹¹
> for ë° for-in ë£¨í”„
> if-case ë° switch-case
> ì»¬ë ‰ì…˜ ë¦¬í„°ëŸ´ì˜ ì œì–´ íë¦„
> ì´ ì„¹ì…˜ì—ì„œëŠ” íŒ¨í„´ì„ ì‚¬ìš©í•œ ì¼ì¹˜ ë° í•´ì²´ì˜ ì¼ë°˜ì ì¸ ì‚¬ìš© ì‚¬ë¡€ì— ëŒ€í•´ ì„¤ëª…í•©ë‹ˆë‹¤.
> 

**Variable declaration**

You can use aÂ *pattern variable declaration*Â anywhere Dart allows local variable declaration. The pattern matches against the value on the right of the declaration. Once matched, it destructures the value and binds it to new local variables:

```dart
//  ì„ ì–¸            
var (a, [b, c]) = 
//   í• ë‹¹
('str', [1, 2]);
```

**Variable assignment**

AÂ *variable assignment pattern*Â falls on the left side of an assignment. First, it destructures the matched object. Then it assigns the values toÂ *existing*Â variables, instead of binding new ones.

Use a variable assignment pattern to swap the values of two variables without declaring a third temporary one:

> **ë³€ìˆ˜ í• ë‹¹**
> 
> 
> 
> ë³€ìˆ˜ í• ë‹¹ íŒ¨í„´ì€ í• ë‹¹ì˜ ì™¼ìª½ì— í•´ë‹¹í•©ë‹ˆë‹¤. ë¨¼ì € ì¼ì¹˜í•˜ëŠ” ê°ì²´ë¥¼ íŒŒê´´í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ ìƒˆ ë³€ìˆ˜ë¥¼ ë°”ì¸ë”©í•˜ëŠ” ëŒ€ì‹  ê¸°ì¡´ ë³€ìˆ˜ì— ê°’ì„ í• ë‹¹í•©ë‹ˆë‹¤.
> 
> ë³€ìˆ˜ í• ë‹¹ íŒ¨í„´ì„ ì‚¬ìš©í•˜ë©´ ì„¸ ë²ˆì§¸ ì„ì‹œ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ì§€ ì•Šê³  ë‘ ë³€ìˆ˜ì˜ ê°’ì„ ë°”ê¿€ ìˆ˜ ìˆìŠµë‹ˆë‹¤:
> 

```dart
// ('left', 'right') íŠœí”Œì„ (a, b) ë³€ìˆ˜ì— í• ë‹¹í•©ë‹ˆë‹¤.
var (a, b) = ('left', 'right');

// aì™€ bì˜ ê°’ì„ ì„œë¡œ êµí™˜í•©ë‹ˆë‹¤.
(b, a) = (a, b); // Swap.

print('$a $b'); // Prints "right left".
```

**Switch statements and expressions**

Every case clause contains a pattern. This applies toÂ [switch statements](https://dart.dev/language/branches#switch-statements)Â andÂ [expressions](https://dart.dev/language/branches#switch-expressions), as well asÂ [if-case statements](https://dart.dev/language/branches#if-case). You can useÂ [any kind of pattern](https://dart.dev/language/pattern-types)Â in a case.

*Case patterns*Â areÂ [refutable](https://dart.dev/resources/glossary#refutable-pattern). They allow control flow to either:

- Match and destructure the object being switched on.
- Continue execution if the object doesn't match.

The values that a pattern destructures in a case become local variables. Their scope is only within the body of that case.

> **ì „í™˜ ë¬¸ ë° í‘œí˜„ì‹**
> 
> 
> 
> ëª¨ë“  ëŒ€/ì†Œë¬¸ì ì ˆì—ëŠ” íŒ¨í„´ì´ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” switch ë¬¸ê³¼ í‘œí˜„ì‹ì€ ë¬¼ë¡  if-ëŒ€/ì†Œë¬¸ì ë¬¸ì—ë„ ì ìš©ë©ë‹ˆë‹¤. ëª¨ë“  ì¢…ë¥˜ì˜ íŒ¨í„´ì„ ì¼€ì´ìŠ¤ì— ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> 
> ì¼€ì´ìŠ¤ íŒ¨í„´ì€ ë°˜ë°•ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. ì–´ëŠ ìª½ìœ¼ë¡œë„ ì œì–´ íë¦„ì„ í—ˆìš©í•©ë‹ˆë‹¤:
> 
> ìŠ¤ìœ„ì¹˜ê°€ ì¼œì§€ëŠ” ê°ì²´ë¥¼ ì¼ì¹˜ì‹œí‚¤ê³  íŒŒê´´í•©ë‹ˆë‹¤.
> ê°ì²´ê°€ ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ì‹¤í–‰ì„ ê³„ì†í•©ë‹ˆë‹¤.
> íŒ¨í„´ì´ ì¼€ì´ìŠ¤ì—ì„œ íŒŒê´´í•˜ëŠ” ê°’ì€ ë¡œì»¬ ë³€ìˆ˜ê°€ ë©ë‹ˆë‹¤. ê·¸ ë²”ìœ„ëŠ” í•´ë‹¹ ì¼€ì´ìŠ¤ì˜ ë³¸ë¬¸ ë‚´ì—ë§Œ ìˆìŠµë‹ˆë‹¤.
> 

```dart
switch (obj) {
  // objê°€ 1ê³¼ ì¼ì¹˜í•˜ëŠ” ê²½ìš°.
  case 1:
    print('one');

  // objì˜ ê°’ì´ 'first'ì™€ 'last'ì˜ ìƒìˆ˜ ê°’ ì‚¬ì´ì— ìˆëŠ” ê²½ìš°.
  case >= first && <= last:
    print('in range');

  // objê°€ ë‘ ê°œì˜ í•„ë“œë¥¼ ê°€ì§„ ë ˆì½”ë“œì¸ ê²½ìš°,
  // í•„ë“œë¥¼ 'a'ì™€ 'b'ì— í• ë‹¹í•©ë‹ˆë‹¤.
  case (var a, var b):
    print('a = $a, b = $b');

  default:
}
```

- ì¶”ê°€íŒ¨í„´
    
    [ë…¼ë¦¬í•© íŒ¨í„´ì€](https://dart.dev/language/pattern-types#logical-or)Â ì—¬ëŸ¬ ì‚¬ë¡€ê°€ ìŠ¤ìœ„ì¹˜ ì‹ì´ë‚˜ ë¬¸ì˜ ë³¸ë¬¸ì„ ê³µìœ í•˜ë„ë¡ í•˜ëŠ” ë° ìœ ìš©í•©ë‹ˆë‹¤.
    
    ```dart
    // colorê°€ ê¸°ë³¸ ìƒ‰ìƒì¸ì§€ í™•ì¸í•˜ëŠ” ë³€ìˆ˜ isPrimaryë¥¼ ì„ ì–¸í•©ë‹ˆë‹¤.
    var isPrimary = switch (color) {
      // colorê°€ Color.red, Color.yellow, Color.blue ì¤‘ í•˜ë‚˜ì¼ ë•Œ trueë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
      Color.red || Color.yellow || Color.blue => true,
      // ê·¸ ì™¸ì˜ ê²½ìš°ì—ëŠ” falseë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
      _ => false
    };
    ```
    
    [Switch ë¬¸ì€ ë…¼ë¦¬ ë˜ëŠ” íŒ¨í„´ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³ ](https://dart.dev/language/branches#switch-share)Â ì—¬ëŸ¬ ì¼€ì´ìŠ¤ê°€ ë³¸ë¬¸ì„ ê³µìœ í•˜ë„ë¡ í•  ìˆ˜ ìˆì§€ë§Œ ì—¬ëŸ¬ ì¼€ì´ìŠ¤ê°€Â [ê°€ë“œë¥¼](https://dart.dev/language/branches#guard-clause)Â ê³µìœ í•˜ë„ë¡ í—ˆìš©í•˜ëŠ” ë° ì—¬ì „íˆ ìœ ìš©í•©ë‹ˆë‹¤Â .
    
    ```dart
    // shapeê°€ ìœ íš¨í•œ ëŒ€ì¹­ ë„í˜•ì¸ì§€ í™•ì¸í•˜ëŠ” switch ë¬¸ì…ë‹ˆë‹¤.
    switch (shape) {
      // shapeê°€ Square ë˜ëŠ” Circleì´ê³ , í¬ê¸° sê°€ 0ë³´ë‹¤ í´ ë•Œ ì‹¤í–‰í•©ë‹ˆë‹¤.
      case Square(size: var s) || Circle(size: var s) when s > 0:
        // ìœ íš¨í•œ ëŒ€ì¹­ ë„í˜•ì´ë¯€ë¡œ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.
        print('Non-empty symmetric shape');
    }
    ```
    
    [Guard ì ˆì€](https://dart.dev/language/branches#guard-clause)Â ì¡°ê±´ì´ ê±°ì§“ì¸ ê²½ìš° ìŠ¤ìœ„ì¹˜ë¥¼ ì¢…ë£Œí•˜ì§€ ì•Šê³  ì„ì˜ì˜ ì¡°ê±´ì„ ì‚¬ë¡€ì˜ ì¼ë¶€ë¡œ í‰ê°€í•©ë‹ˆë‹¤(ì˜ˆ:Â `if`ì‚¬ë¡€ ë³¸ë¬¸ì—ì„œ ë¬¸ì„ ì‚¬ìš©í•˜ë©´ ë°œìƒí•¨).
    
    ```dart
    // pairê°€ ë‘ ê°œì˜ ì •ìˆ˜ë¥¼ í¬í•¨í•˜ëŠ” íŠœí”Œì¸ì§€ í™•ì¸í•˜ëŠ” switch ë¬¸ì…ë‹ˆë‹¤.
    switch (pair) {
      // pairê°€ ë‘ ê°œì˜ ì •ìˆ˜ë¡œ ì´ë£¨ì–´ì§„ íŠœí”Œì¼ ë•Œ,
      case (int a, int b):
        // ì²« ë²ˆì§¸ ìš”ì†Œ aê°€ ë‘ ë²ˆì§¸ ìš”ì†Œ bë³´ë‹¤ í´ ê²½ìš° ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.
        if (a > b) print('First element greater');
      // aê°€ bë³´ë‹¤ í´ ë•Œë§Œ ì‹¤í–‰ë©ë‹ˆë‹¤.
      // ë§Œì•½ ì¡°ê±´ì´ ê±°ì§“ì´ë©´ ì•„ë¬´ê²ƒë„ ì¶œë ¥í•˜ì§€ ì•Šê³  ë‹¤ìŒ ì¼€ì´ìŠ¤ë¡œ ì§„í–‰í•©ë‹ˆë‹¤.
      case (int a, int b) when a > b:
        // ì²« ë²ˆì§¸ ìš”ì†Œê°€ ë‘ ë²ˆì§¸ ìš”ì†Œë³´ë‹¤ í° ê²½ìš° ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.
        print('First element greater');
      // pairê°€ ë‘ ê°œì˜ ì •ìˆ˜ë¡œ ì´ë£¨ì–´ì§„ íŠœí”Œì¼ ë•Œ,
      case (int a, int b):
        // ì²« ë²ˆì§¸ ìš”ì†Œê°€ ë‘ ë²ˆì§¸ ìš”ì†Œë³´ë‹¤ í¬ì§€ ì•Šì€ ê²½ìš° ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.
        print('First element not greater');
    }
    ```
    

**For and for-in loops**[#](https://dart.dev/language/patterns#for-and-for-in-loops)

You can use patterns inÂ [for and for-in loops](https://dart.dev/language/loops#for-loops)Â to iterate-over and destructure values in a collection.

This example usesÂ [object destructuring](https://dart.dev/language/pattern-types#object)Â in a for-in loop to destructure theÂ [`MapEntry`](https://api.dart.dev/stable/dart-core/MapEntry-class.html)Â objects that aÂ `<Map>.entries`Â call returns:

> **For ë° For-in ë£¨í”„**
> 
> 
> for ë° for-in ë£¨í”„ì—ì„œ íŒ¨í„´ì„ ì‚¬ìš©í•˜ì—¬ ì»¬ë ‰ì…˜ì˜ ê°’ì„ ë°˜ë³µí•˜ê³  íŒŒê´´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> 
> ì´ ì˜ˆì œì—ì„œëŠ” for-in ë£¨í”„ì—ì„œ ê°ì²´ êµ¬ì¡°ì¡°ì •ì„ ì‚¬ìš©í•˜ì—¬ <Map>.entries í˜¸ì¶œì´ ë°˜í™˜í•˜ëŠ” MapEntry ê°ì²´ë¥¼ êµ¬ì¡°ì¡°ì •í•©ë‹ˆë‹¤:
> 

```dart
// ë¬¸ìì—´ í‚¤ì™€ ì •ìˆ˜ ê°’ì„ ê°€ì§€ëŠ” ë§µ histë¥¼ ì„ ì–¸í•˜ê³  ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
Map<String, int> hist = {
  'a': 23,   
  'b': 100, 
};

// hist ë§µì˜ ê° ì—”íŠ¸ë¦¬ì— ëŒ€í•´ ë°˜ë³µë¬¸ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
for (var MapEntry(key: key, value: count) in hist.entries) {
  // ê° ì—”íŠ¸ë¦¬ì˜ í‚¤ì™€ ê°’ì„ ì¶œë ¥í•©ë‹ˆë‹¤.
  print('$key occurred $count times');
  // ì˜ˆë¥¼ ë“¤ì–´, 'a' í‚¤ëŠ” 23ë²ˆ ë°œìƒí–ˆìŒì„ ì¶œë ¥í•©ë‹ˆë‹¤.
}
//ë™ì¼í•œ ì´ë¦„ì˜ ë³€ìˆ˜ì— getter í˜¸ì¶œ ê²°ê³¼ë¥¼ ë°”ì¸ë”©í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì¸ ì‚¬ìš© ì‚¬ë¡€ì´ë¯€ë¡œ 
//ê°ì²´ íŒ¨í„´ì€ ë³€ìˆ˜ subpattern ì—ì„œ getter ì´ë¦„ì„ ì¶”ë¡ í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤ . 
//ì´ë¥¼ í†µí•´ key: keyë‹¤ìŒê³¼ ê°™ì€ ì¤‘ë³µëœ ë³€ìˆ˜ íŒ¨í„´ì„ ë‹¨ìˆœí™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ :key.
for (var MapEntry(:key, value: count) in hist.entries) {
  print('$key occurred $count times');
}
```

**Use cases for patterns**

TheÂ [previous section](https://dart.dev/language/patterns#places-patterns-can-appear)Â describesÂ *how*Â patterns fit into other Dart code constructs. You saw some interesting use cases as examples, likeÂ [swapping](https://dart.dev/language/patterns#variable-assignment)Â the values of two variables, orÂ [destructuring key-value pairs](https://dart.dev/language/patterns#for-and-for-in-loops)Â in a map. This section describes even more use cases, answering:

- *When and why*Â you might want to use patterns.
- What kinds of problems they solve.
- Which idioms they best suit.

> **íŒ¨í„´ ì‚¬ìš© ì‚¬ë¡€**
> 
> 
> ì´ì „ ì„¹ì…˜ì—ì„œëŠ” íŒ¨í„´ì´ ë‹¤ë¥¸ Dart ì½”ë“œ êµ¬ì„±ì— ì–´ë–»ê²Œ ì ìš©ë˜ëŠ”ì§€ ì„¤ëª…í–ˆìŠµë‹ˆë‹¤. ë‘ ë³€ìˆ˜ì˜ ê°’ì„ ë°”ê¾¸ê±°ë‚˜ ë§µì—ì„œ í‚¤-ê°’ ìŒì„ íŒŒê´´í•˜ëŠ” ê²ƒê³¼ ê°™ì€ í¥ë¯¸ë¡œìš´ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ì˜ˆë¡œ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤. ì´ ì„¹ì…˜ì—ì„œëŠ” ë” ë§ì€ ì‚¬ìš© ì‚¬ë¡€ì— ëŒ€í•´ ì„¤ëª…í•©ë‹ˆë‹¤:
> 
> ì–¸ì œ, ì™œ íŒ¨í„´ì„ ì‚¬ìš©í•´ì•¼ í•˜ëŠ”ì§€.
> ì–´ë–¤ ì¢…ë¥˜ì˜ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆëŠ”ì§€.
> ì–´ë–¤ ê´€ìš©êµ¬ì— ê°€ì¥ ì í•©í•œì§€.
> 

**Destructuring multiple returns**[#](https://dart.dev/language/patterns#destructuring-multiple-returns)

Records allow aggregating andÂ [returning multiple values](https://dart.dev/language/records#multiple-returns)Â from a single function call. Patterns add the ability to destructure a record's fields directly into local variables, inline with the function call.

Instead of individually declaring new local variables for each record field, like this:

> **ë‹¤ì¤‘ ë°˜í™˜ êµ¬ì¡°í™”í•˜ê¸°**
ë ˆì½”ë“œë¥¼ ì‚¬ìš©í•˜ë©´ ë‹¨ì¼ í•¨ìˆ˜ í˜¸ì¶œì—ì„œ ì—¬ëŸ¬ ê°’ì„ ì§‘ê³„í•˜ê³  ë°˜í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 
íŒ¨í„´ì€ í•¨ìˆ˜ í˜¸ì¶œê³¼ ì¸ë¼ì¸ìœ¼ë¡œ ë ˆì½”ë“œì˜ í•„ë“œë¥¼ ë¡œì»¬ ë³€ìˆ˜ë¡œ ì§ì ‘ êµ¬ì¡° ë¶„í•´í•˜ëŠ” ê¸°ëŠ¥ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
ë‹¤ìŒê³¼ ê°™ì´ ê° ë ˆì½”ë“œ í•„ë“œì— ëŒ€í•´ ìƒˆë¡œìš´ ë¡œì»¬ ë³€ìˆ˜ë¥¼ ê°œë³„ì ìœ¼ë¡œ ì„ ì–¸í•˜ëŠ” ëŒ€ì‹ ì—
> 

You can destructure the fields of a record that a function returns into local variables using aÂ [variable declaration](https://dart.dev/language/patterns#variable-declaration)Â orÂ [assigment pattern](https://dart.dev/language/patterns#variable-assignment), and aÂ [record pattern](https://dart.dev/language/pattern-types#record)Â as its subpattern:

> ë³€ìˆ˜ ì„ ì–¸ ë˜ëŠ” í• ë‹¹ íŒ¨í„´ê³¼ ê·¸ í•˜ìœ„ íŒ¨í„´ìœ¼ë¡œ ë ˆì½”ë“œ íŒ¨í„´ì„ ì‚¬ìš©í•˜ì—¬ í•¨ìˆ˜ê°€ ë°˜í™˜í•˜ëŠ” ë ˆì½”ë“œì˜ í•„ë“œë¥¼ ë¡œì»¬ ë³€ìˆ˜ë¡œ ë¶„í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:
> 

```dart
// ê°œë³„ì  ì„ ì–¸
var info = userInfo(json);
var name = info.$1;
var age = info.$2;
// êµ¬ì¡° í•´ì œ ì„ ì–¸
var (name, age) = userInfo(json);
// êµ¬ì¡° í•´ì œ ì„ ì–¸ (ëª…ëª…ëœ ìš”ì†Œ ì‚¬ìš©)
final (:name, :age) =
    getData(); // ì˜ˆì‹œ: getData í•¨ìˆ˜ê°€ (name: 'doug', age: 25)ì™€ ê°™ì€ í˜•íƒœë¡œ ë°˜í™˜
```

**Destructuring class instances**

[Object patterns](https://dart.dev/language/pattern-types#object)Â match against named object types, allowing you to destructure their data using the getters the object's class already exposes.

To destructure an instance of a class, use the named type, followed by the properties to destructure enclosed in parentheses:

> **í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ íŒŒê´´í•˜ê¸°**
> 
> 
> ê°ì²´ íŒ¨í„´ì€ ëª…ëª…ëœ ê°ì²´ ìœ í˜•ê³¼ ì¼ì¹˜í•˜ë¯€ë¡œ ê°ì²´ì˜ í´ë˜ìŠ¤ê°€ ì´ë¯¸ ë…¸ì¶œí•œ ê²Œí„°ë¥¼ ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ ë°ì´í„°ë¥¼ íŒŒê´´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> 
> í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ íŒŒê´´í•˜ë ¤ë©´ ëª…ëª…ëœ ìœ í˜•ê³¼ ê´„í˜¸ ì•ˆì— ê´„í˜¸ë¡œ ë¬¶ì¸ íŒŒê´´í•  í”„ë¡œí¼í‹°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤:
> 

```dart
final Foo myFoo = Foo(one: 'one', two: 2);
var Foo(:one, :two) = myFoo;
print('one $one, two $two');
```

**Algebraic data types**

Object destructuring and switch cases are conducive to writing code in anÂ [algebraic data type](https://en.wikipedia.org/wiki/Algebraic_data_type)Â style. Use this method when:

- You have a family of related types.
- You have an operation that needs specific behavior for each type.
- You want to group that behavior in one place instead of spreading it across all the different type definitions.

Instead of implementing the operation as an instance method for every type, keep the operation's variations in a single function that switches over the subtypes:

> **ëŒ€ìˆ˜ ë°ì´í„° ìœ í˜•**
> 
> 
> ê°ì²´ êµ¬ì¡° ë¶„í•´ ë° ìŠ¤ìœ„ì¹˜ ì¼€ì´ìŠ¤ëŠ” ëŒ€ìˆ˜ ë°ì´í„° ìœ í˜• ìŠ¤íƒ€ì¼ë¡œ ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤. ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš°ì— ì´ ë°©ë²•ì„ ì‚¬ìš©í•˜ì„¸ìš”:
> 
> ê´€ë ¨ ìœ í˜• ê³„ì—´ì´ ìˆëŠ” ê²½ìš°.
> ê° ìœ í˜•ì— ëŒ€í•´ íŠ¹ì • ë™ì‘ì´ í•„ìš”í•œ ì‘ì—…ì´ ìˆìŠµë‹ˆë‹¤.
> í•´ë‹¹ ë™ì‘ì„ ëª¨ë“  ë‹¤ë¥¸ ìœ í˜• ì •ì˜ì— ë¶„ì‚°í•˜ì§€ ì•Šê³  í•œ ê³³ì— ê·¸ë£¹í™”í•˜ë ¤ëŠ” ê²½ìš°.
> ëª¨ë“  ìœ í˜•ì— ëŒ€í•´ ì—°ì‚°ì„ ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œë¡œ êµ¬í˜„í•˜ëŠ” ëŒ€ì‹  í•˜ìœ„ ìœ í˜•ì„ ì „í™˜í•˜ëŠ” ë‹¨ì¼ í•¨ìˆ˜ì— ì—°ì‚°ì˜ ë³€í˜•ì„ ìœ ì§€í•©ë‹ˆë‹¤:
> 

```dart

sealed class Shape {}

// Shape ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ëŠ” Square í´ë˜ìŠ¤
class Square implements Shape {
// ì •ì‚¬ê°í˜•ì˜ í•œ ë³€ì˜ ê¸¸ì´
  final double length; 
// ìƒì„±ìë¥¼ í†µí•´ ê¸¸ì´ë¥¼ ì´ˆê¸°í™”
  Square(this.length); 
}

// Shape ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ëŠ” Circle í´ë˜ìŠ¤
class Circle implements Shape {
// ì›ì˜ ë°˜ì§€ë¦„
  final double radius; 
// ìƒì„±ìë¥¼ í†µí•´ ë°˜ì§€ë¦„ì„ ì´ˆê¸°í™”
  Circle(this.radius); 
}

// ì£¼ì–´ì§„ Shape ê°ì²´ì˜ ë©´ì ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
double calculateArea(Shape shape) => switch (shape) {
      // shapeê°€ Squareì¼ ê²½ìš°, ì •ì‚¬ê°í˜•ì˜ ë©´ì ì„ ê³„ì‚°
      Square(length: var l) => l * l,
      // shapeê°€ Circleì¼ ê²½ìš°, ì›ì˜ ë©´ì ì„ ê³„ì‚°
      Circle(radius: var r) => math.pi * r * r
    };

```

**Validating incoming JSON**[#](https://dart.dev/language/patterns#validating-incoming-json)

[Map](https://dart.dev/language/pattern-types#map)Â andÂ [list](https://dart.dev/language/pattern-types#list)Â patterns work well for destructuring key-value pairs in JSON data

> **ë“¤ì–´ì˜¤ëŠ” JSON ìœ íš¨ì„± ê²€ì‚¬**
> 
> 
> ë§µ ë° ëª©ë¡ íŒ¨í„´ì€ JSON ë°ì´í„°ì˜ í‚¤-ê°’ ìŒì„ êµ¬ì¡°í™”í•˜ëŠ” ë° íš¨ê³¼ì ì…ë‹ˆë‹¤.
> 

```dart
var json = {
  'user': ['Lily', 13]
};
var {'user': [name, age]} = json;
```

If you know that the JSON data has the structure you expect, the previous example is realistic. But data typically comes from an external source, like over the network. You need to validate it first to confirm its structure.

Without patterns, validation is verbose:

> JSON ë°ì´í„°ê°€ ì˜ˆìƒí•˜ëŠ” êµ¬ì¡°ë¥¼ ê°€ì§€ê³  ìˆë‹¤ëŠ” ê²ƒì„ ì•Œê³  ìˆë‹¤ë©´ ì•ì˜ ì˜ˆê°€ í˜„ì‹¤ì ì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ë°ì´í„°ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ë„¤íŠ¸ì›Œí¬ì™€ ê°™ì€ ì™¸ë¶€ ì†ŒìŠ¤ì—ì„œ ê°€ì ¸ì˜µë‹ˆë‹¤. ë”°ë¼ì„œ ë¨¼ì € ë°ì´í„°ì˜ ìœ íš¨ì„±ì„ ê²€ì‚¬í•˜ì—¬ êµ¬ì¡°ë¥¼ í™•ì¸í•´ì•¼ í•©ë‹ˆë‹¤.
> 
> 
> íŒ¨í„´ì´ ì—†ìœ¼ë©´ ìœ íš¨ì„± ê²€ì‚¬ëŠ” ì¥í™©í•©ë‹ˆë‹¤
> 

A singleÂ [case pattern](https://dart.dev/language/patterns#switch-statements-and-expressions)Â can achieve the same validation. Single cases work best asÂ [if-case](https://dart.dev/language/branches#if-case)Â statements. Patterns provide a more declarative, and much less verbose method of validating JSON:

> ë‹¨ì¼ ëŒ€/ì†Œë¬¸ì íŒ¨í„´ìœ¼ë¡œ ë™ì¼í•œ ìœ íš¨ì„± ê²€ì‚¬ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¨ì¼ ëŒ€ì†Œë¬¸ìëŠ” if-ëŒ€ì†Œë¬¸ì ë¬¸ìœ¼ë¡œ ê°€ì¥ ì˜ ì‘ë™í•©ë‹ˆë‹¤. íŒ¨í„´ì€ ë³´ë‹¤ ì„ ì–¸ì ì´ê³  í›¨ì”¬ ëœ ì¥í™©í•œ JSON ìœ íš¨ì„± ê²€ì‚¬ ë°©ë²•ì„ ì œê³µí•©ë‹ˆë‹¤:
> 

```dart
// jsonì´ Map<String, Object?> íƒ€ì…ì¸ì§€ í™•ì¸í•˜ê³ , 
// ê¸¸ì´ê°€ 1ì´ë©° 'user' í‚¤ë¥¼ í¬í•¨í•˜ê³  ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
if (json is Map<String, Object?> &&
    json.length == 1 &&
    json.containsKey('user')) {
  // 'user' í‚¤ì— í•´ë‹¹í•˜ëŠ” ê°’ì„ user ë³€ìˆ˜ì— ì €ì¥
  var user = json['user'];
  
  // userê°€ List<Object> íƒ€ì…ì¸ì§€ í™•ì¸í•˜ê³ , 
  // ê¸¸ì´ê°€ 2ì´ë©° ì²« ë²ˆì§¸ ìš”ì†Œê°€ String, ë‘ ë²ˆì§¸ ìš”ì†Œê°€ int íƒ€ì…ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
  if (user is List<Object> &&
      user.length == 2 &&
      user[0] is String &&
      user[1] is int) {
    // ì²« ë²ˆì§¸ ìš”ì†Œë¥¼ String íƒ€ì…ìœ¼ë¡œ ìºìŠ¤íŒ…
    var name = user[0] as String;
    // ë‘ ë²ˆì§¸ ìš”ì†Œë¥¼ int íƒ€ì…ìœ¼ë¡œ ìºìŠ¤íŒ…
    var age = user[1] as int;
    print('User $name is $age years old.');
  }
}
// íŒ¨í„´ì„ ì‚¬ìš©í•œ JSON ìœ íš¨ì„±ê²€ì‚¬
if (json case {'user': [String name, int age]}) {
  print('User $name is $age years old.');
}

```
