# The Dart type system

The Dart language is type safe: it uses a combination of static type checking and [runtime checks](https://dart.dev/language/type-system#runtime-checks) to ensure that a variable's value always matches the variable's static type, sometimes referred to as sound typing. Although _types_ are mandatory, type _annotations_ are optional because of [type inference](https://dart.dev/language/type-system#type-inference).

One benefit of static type checking is the ability to find bugs at compile time using Dart's [static analyzer.](https://dart.dev/tools/analysis)

You can fix most static analysis errors by adding type annotations to generic classes. The most common generic classes are the collection types `List<T>` and `Map<K,V>`.

For example, in the following code the `printInts()` function prints an integer list, and `main()` creates a list and passes it to `printInts()`.

다트(Dart) 언어는 타입 안전성을 갖추고 있습니다. 이는 정적 타입 검사와 런타임 검사의 조합을 사용하여 변수의 값이 항상 변수의 정적 타입과 일치하도록 보장하는 것을 의미하며, 이를 흔히 안전한 타이핑(Sound Typing)이라고 합니다. 타입은 필수적이지만, 타입 추론 덕분에 타입 주석(Type Annotations)은 선택 사항입니다.

정적 타입 검사의 한 가지 이점은 다트의 정적 분석기를 사용하여 컴파일 시점에 버그를 찾을 수 있다는 것입니다.

대부분의 정적 분석 오류는 제네릭 클래스에 타입 주석을 추가하여 해결할 수 있습니다. 가장 흔한 제네릭 클래스는 컬렉션 타입인 List\<T>와 Map\<K, V>입니다.

예를 들어, 다음 코드에서 printInts() 함수는 정수 리스트를 출력하고, main() 함수는 리스트를 생성하여 printInts() 함수에 전달합니다.

```dart
//✗ static analysis: failuredart
void printInts(List<int> a) => print(a);

void main() {
  final list = [];
  list.add(1);
  list.add('2');
  printInts(list); // list 오류
}
```
The preceding code results in a type error on `list` (highlighted above) at the call of `printInts(list)`:

앞선 코드는 printInts(list) 호출 시 list에서 타입 오류를 발생시킵니다(위에 강조 표시된 부분).

```
error - The argument type 'List<dynamic>' can't be assigned to the parameter type 'List<int>'. - argument_type_not_assignable
오류 - 전달인자 타입 'List<dynamic>'은(는) 매개변수 타입 'List<int>'에 할당할 수 없습니다. - argument_type_not_assignable
```

The error highlights an unsound implicit cast from `List<dynamic>` to `List<int>`. The `list` variable has static type `List<dynamic>`. This is because the initializing declaration `var list = []` doesn't provide the analyzer with enough information for it to infer a type argument more specific than `dynamic`. The `printInts()` function expects a parameter of type `List<int>`, causing a mismatch of types.

When adding a type annotation (`<int>`) on creation of the list (highlighted below) the analyzer complains that a string argument can't be assigned to an `int` parameter. Removing the quotes in `list.add('2')` results in code that passes static analysis and runs with no errors or warnings.

이 오류는 List\<dynamic>에서 List\<int>로의 안전하지 않은 암시적 캐스트를 강조합니다. list 변수는 정적 타입 List\<dynamic>을 가지고 있습니다. 이는 var list = []로 초기화 선언할 때 분석기에 dynamic보다 더 구체적인 타입 인수를 추론할 수 있는 충분한 정보를 제공하지 않기 때문입니다. printInts() 함수는 List\<int> 타입의 매개변수를 기대하기 때문에 타입 불일치가 발생합니다.

리스트 생성 시 타입 주석(\<int>)을 추가하면(아래에 강조 표시된 부분) 분석기는 문자열 인수를 int 매개변수에 할당할 수 없다고 경고합니다. list.add('2')에서 따옴표를 제거하면 정적 분석을 통과하고 오류나 경고 없이 실행되는 코드를 얻을 수 있습니다.


```dart
// ✔ static analysis: successdart
void printInts(List<int> a) => print(a);

void main() {
  final list = <int>[]; // <int> 강조
  list.add(1);
  list.add(2); // 2 강조
  printInts(list);
}
```


## What is soundness?

## Soundness란 무엇인가요?

_Soundness_ is about ensuring your program can't get into certain invalid states. A sound _type system_ means you can never get into a state where an expression evaluates to a value that doesn't match the expression's static type. For example, if an expression's static type is `String`, at runtime you are guaranteed to only get a string when you evaluate it.

Dart's type system, like the type systems in Java and C#, is sound. It enforces that soundness using a combination of static checking (compile-time errors) and runtime checks. For example, assigning a `String` to `int` is a compile-time error. Casting an object to a `String` using `as String` fails with a runtime error if the object isn't a `String`.

**Soundness**는 프로그램이 특정한 잘못된 상태에 빠지지 않도록 보장하는 것을 의미합니다. 안전한 타입 시스템이란 표현식이 평가될 때 그 표현식의 정적 타입과 일치하지 않는 값으로 평가되지 않는 상태에 절대 도달하지 않음을 의미합니다. 예를 들어, 표현식의 정적 타입이 String인 경우, 런타임 시 평가하면 반드시 문자열을 얻을 수 있음을 보장합니다.

다트(Dart)의 타입 시스템은 자바(Java)와 C#의 타입 시스템처럼 안전합니다. 이는 정적 검사(컴파일 시 오류)와 런타임 검사의 조합을 통해 안전성을 보장합니다. 예를 들어, 문자열을 정수에 할당하려고 하면 컴파일 타임 오류가 발생합니다. 객체를 as String을 사용하여 문자열로 캐스팅할 때 객체가 문자열이 아니면 런타임 오류가 발생합니다.

## The benefits of soundness

## Soundness의 장점

A sound type system has several benefits:

- Revealing type-related bugs at compile time.  
	A sound type system forces code to be unambiguous about its types, so type-related bugs that might be tricky to find at runtime are revealed at compile time.

- More readable code.  
	Code is easier to read because you can rely on a value actually having the specified type. In sound Dart, types can't lie.

- More maintainable code.  
	With a sound type system, when you change one piece of code, the type system can warn you about the other pieces of code that just broke.

- Better ahead of time (AOT) compilation.  
	While AOT compilation is possible without types, the generated code is much less efficient.

- **타입 관련 버그를 컴파일 시점에 발견**:
	Sound한 타입 시스템은 코드의 타입을 명확히 할 것을 강제하므로, 런타임에 찾기 어려운 타입 관련 버그를 컴파일 시점에 드러냅니다.

- **더 읽기 쉬운 코드**:
	코드를 읽을 때 지정된 타입이 실제로 해당 값을 가진다는 것을 신뢰할 수 있기 때문에 코드가 더 읽기 쉬워집니다. Sound한 다트에서는 타입이 거짓말을 할 수 없습니다.

- **더 유지보수하기 쉬운 코드**:
	 Sound한 타입 시스템 덕분에 코드의 한 부분을 변경하면, 타입 시스템이 깨진 다른 코드 부분에 대해 경고를 제공할 수 있습니다.

- **더 나은 사전 컴파일 (AOT) 성능**:
	타입이 없어도 AOT 컴파일은 가능하지만, 생성된 코드의 효율성은 크게 떨어집니다.
## Tips for passing static analysis

Most of the rules for static types are easy to understand. Here are some of the less obvious rules:

- Use sound return types when overriding methods.
- Use sound parameter types when overriding methods.
- Don't use a dynamic list as a typed list.

Let's see these rules in detail, with examples that use the following type hierarchy:


## 정적 분석을 통과하기 위한 팁

대부분의 정적 타입 규칙은 이해하기 쉽습니다. 다음은 덜 명확한 규칙들입니다:

- 메서드를 재정의할 때는 유효한 반환 타입을 사용하세요.
- 메서드를 재정의할 때는 유효한 매개변수 타입을 사용하세요.
- 동적 리스트를 타입 지정된 리스트로 사용하지 마세요.

다음은 이러한 규칙을 설명하기 위한 타입 계층을 사용하는 예제들입니다:

![a hierarchy of animals where the supertype is Animal and the subtypes are Alligator, Cat, and HoneyBadger. Cat has the subtypes of Lion and MaineCoon](https://dart.dev/assets/img/AQ-sq8I8Lm-490.png)

### Use sound return types when overriding methods

The return type of a method in a subclass must be the same type or a subtype of the return type of the method in the superclass. Consider the getter method in the `Animal` class:

### 메서드를 오버라이딩할 때 안전한 반환 타입을 사용하세요.

메서드를 재정의할 때는 반환 타입이 부모 클래스의 메서드에서 사용하는 반환 타입과 같거나 그 하위 타입이어야 합니다. 다음은 Animal 클래스의 getter 메서드를 고려한 예입니다:

```dart 
class Animal {
  void chase(Animal a) { ... }
  Animal get parent => ...
}
```

The `parent` getter method returns an `Animal`. In the `HoneyBadger` subclass, you can replace the getter's return type with `HoneyBadger` (or any other subtype of `Animal`), but an unrelated type is not allowed.

`부모 클래스`의 getter 메서드는 `Animal`을 반환합니다. `HoneyBadger` 서브클래스에서는 getter의 반환 타입을 HoneyBadger로 바꿀 수 있습니다. 그러나 관련 없는 다른 타입으로 반환 타입을 변경하는 것은 허용되지 않습니다.

```dart 
// ✔ static analysis: successdart
class HoneyBadger extends Animal {
  @override
  void chase(Animal a) { ... }

  @override
  HoneyBadger get parent => ...
}
```


```dart
// ✗ static analysis: failuredart
class HoneyBadger extends Animal {
  @override
  void chase(Animal a) { ... }

  @override
  Root get parent => ...
}
```
### Use sound parameter types when overriding methods

[#](https://dart.dev/language/type-system#use-sound-parameter-types-when-overriding-methods)

The parameter of an overridden method must have either the same type or a supertype of the corresponding parameter in the superclass. Don't "tighten" the parameter type by replacing the type with a subtype of the original parameter.

### 메서드를 재정의할 때는 매개변수 타입을 정확히 사용하세요.

부모 클래스에서 매개변수로 사용된 매개변수와 동일한 타입 또는 그 상위 타입이어야 하는 것은 메서드를 재정의할 때 적용되는 원칙입니다. 매개변수의 타입을 원래 매개변수의 하위 타입으로 "타입을 좁히는" 것은 허용되지 않습니다.

_Note_

If you have a valid reason to use a subtype, you can use the [`covariant` keyword](https://dart.dev/guides/language/sound-problems#the-covariant-keyword).

_정보_

만약 하위 타입을 사용하는 합당한 이유가 있다면, `covariant` 키워드를 사용할 수 있습니다.

Consider the `chase(Animal)` method for the `Animal` class:

`Animal` 클래스의 `chase(Animal)` 메서드를 고려해 보세요:

```dart 
class Animal {
  void chase(Animal a) { ... }
  Animal get parent => ...
}
```

The `chase()` method takes an `Animal`. A `HoneyBadger` chases anything. It's OK to override the `chase()` method to take anything (`Object`).

`chase()` 메서드는 Animal을 매개변수로 받습니다. HoneyBadger는 무엇이든 쫓습니다. `chase()` 메서드를 재정의하여 모든 것을 (Object) 매개변수로 받도록 하는 것은 괜찮습니다.


```dart
// ✔ static analysis: successdart
class HoneyBadger extends Animal {
  @override
  void chase(Object a) { ... }

  @override
  Animal get parent => ...
}
```

The following code tightens the parameter on the `chase()` method from `Animal` to `Mouse`, a subclass of `Animal`.

다음 코드는 `chase()` 메서드의 매개변수를 `Animal`에서 `Animal`의 하위 클래스인 `Mouse`로 좁힙니다.

```dart
// ✗ static analysis: failuredart
class Mouse extends Animal { ... }

class Cat extends Animal {
  @override
  void chase(Mouse a) { ... }
}
```

This code is not type safe because it would then be possible to define a cat and send it after an alligator:

이 코드는 타입 안전하지 않습니다. 왜냐하면 고양이를 정의하고 그것을 악어에게 보내는 것이 가능해지기 때문입니다:

```dart
Animal a = Cat();
a.chase(Alligator()); // Not type safe or feline safe.
```
### Don't use a dynamic list as a typed list

A `dynamic` list is good when you want to have a list with different kinds of things in it. However, you can't use a `dynamic` list as a typed list.

This rule also applies to instances of generic types.

The following code creates a `dynamic` list of `Dog`, and assigns it to a list of type `Cat`, which generates an error during static analysis.

### 동적 리스트를 타입이 지정된 리스트로 사용하지 마세요

동적 리스트는 여러 종류의 항목을 포함하는 리스트를 만들 때 유용합니다. 그러나 동적 리스트를 타입이 지정된 리스트로 사용할 수는 없습니다.

이 규칙은 제네릭 타입의 인스턴스에도 적용됩니다.

다음 코드는 Dog의 동적 리스트를 생성하여 Cat 타입의 리스트에 할당하며, 이는 정적 분석 중에 오류를 발생시킵니다.

```dart
// ✗ static analysis: failuredart
void main() {
  List<Cat> foo = <dynamic>[Dog()]; // Error
  List<dynamic> bar = <dynamic>[Dog(), Cat()]; // OK
}
```
## Runtime checks

Runtime checks deal with type safety issues that can't be detected at compile time.

For example, the following code throws an exception at runtime because it's an error to cast a list of dogs to a list of cats:
### 런타임 검사

런타임 검사는 컴파일 시에 감지할 수 없는 타입 안전성 문제를 다룹니다.

예를 들어, 다음 코드는 런타임에 예외를 발생시킵니다. 왜냐하면 Dog 리스트를 Cat 리스트로 캐스팅하는 것은 오류이기 때문입니다:

```dart
// ✗ runtime: failuredart
void main() {
  List<Animal> animals = <Dog>[Dog()];
  List<Cat> cats = animals as List<Cat>;
}
```
## Type inference

The analyzer can infer types for fields, methods, local variables, and most generic type arguments. When the analyzer doesn't have enough information to infer a specific type, it uses the `dynamic` type.

Here's an example of how type inference works with generics. In this example, a variable named `arguments` holds a map that pairs string keys with values of various types.

If you explicitly type the variable, you might write this:

### 타입 추론

분석기는 필드, 메서드, 로컬 변수, 그리고 대부분의 제네릭 타입 인수에 대해 타입을 추론할 수 있습니다. 분석기가 특정 타입을 추론하기에 충분한 정보가 없을 때는 동적 타입을 사용합니다.

다음은 제네릭과 함께 타입 추론이 어떻게 작동하는지 보여주는 예입니다. 이 예제에서 `arguments`라는 변수는 문자열 키를 다양한 타입의 값과 쌍으로 이루어진 맵을 가집니다.

변수의 타입을 명시적으로 지정하면 다음과 같이 작성할 수 있습니다:

```dart
Map<String, dynamic> arguments = {'argA': 'hello', 'argB': 42};
```

Alternatively, you can use `var` or `final` and let Dart infer the type:

대안으로, `var` 또는 `final`을 사용하여 Dart가 타입을 추론하게 할 수 있습니다:

```dart
var arguments = {'argA': 'hello', 'argB': 42}; // Map<String, Object>
```

The map literal infers its type from its entries, and then the variable infers its type from the map literal's type. In this map, the keys are both strings, but the values have different types (`String` and `int`, which have the upper bound `Object`). So the map literal has the type `Map<String, Object>`, and so does the `arguments` variable.

맵 리터럴은 자신의 항목들로부터 타입을 추론하고, 그 후 변수는 맵 리터럴의 타입으로부터 자신의 타입을 추론합니다. 이 맵에서 키는 모두 문자열이지만 값들은 다른 타입을 가지고 있습니다 (String과 int는 상위 타입으로 Object를 가집니다). 따라서 맵 리터럴은 타입 Map<String, Object>를 가지며, 변수 arguments도 마찬가지입니다.

### Field and method inference

A field or method that has no specified type and that overrides a field or method from the superclass, inherits the type of the superclass method or field.

A field that does not have a declared or inherited type but that is declared with an initial value, gets an inferred type based on the initial value.
### 필드와 메서드 추론

만약 명시적으로 타입이 지정되지 않은 필드나 메서드가 슈퍼클래스의 필드나 메서드를 재정의하는 경우, 그것은 슈퍼클래스의 메서드나 필드의 타입을 상속받습니다.

만약 선언된 초기값이 있는데 선언된 혹은 상속된 타입이 없는 필드는, 초기값을 기반으로 추론된 타입을 가집니다.
### Static field inference

Static fields and variables get their types inferred from their initializer. Note that inference fails if it encounters a cycle (that is, inferring a type for the variable depends on knowing the type of that variable).

### 정적 필드 추론

정적 필드와 변수는 초기화자에서 타입을 추론합니다. 다만, 초기화 과정에서 순환 의존성이 발생할 경우 추론이 실패할 수 있습니다 (즉, 변수의 타입을 추론하는 것이 해당 변수의 타입을 알아야 하는 상황에서 실패할 수 있음).
### Local variable inference

Local variable types are inferred from their initializer, if any. Subsequent assignments are not taken into account. This may mean that too precise a type may be inferred. If so, you can add a type annotation.
### 지역 변수 추론

지역 변수의 타입은 초기화 값에서 추론됩니다. 이후의 할당은 고려되지 않습니다. 때때로 너무 정확한 타입이 추론될 수 있습니다. 이 경우 타입 주석을 추가할 수 있습니다.

```dart 
// ✗ static analysis: failuredart
var x = 3; // x is inferred as an int.
x = 4.0;
```

```dart
// ✔ static analysis: successdart
num y = 3; // A num can be double or int.
y = 4.0;
```


### Type argument inference

Type arguments to constructor calls and [generic method](https://dart.dev/language/generics#using-generic-methods) invocations are inferred based on a combination of downward information from the context of occurrence, and upward information from the arguments to the constructor or generic method. If inference is not doing what you want or expect, you can always explicitly specify the type arguments.
### 타입 인자 추론

생성자 호출과 제네릭 메서드 호출에서의 타입 인자는 발생 문맥의 하향 정보와 생성자 또는 제네릭 메서드의 인자에서의 상향 정보를 기반으로 추론됩니다. 추론이 원하는 대로 작동하지 않는 경우 명시적으로 타입 인자를 지정할 수 있습니다.

```dart
// ✔ static analysis: successdart
// Inferred as if you wrote <int>[].
List<int> listOfInt = [];

// Inferred as if you wrote <double>[3.0].
var listOfDouble = [3.0];

// Inferred as Iterable<int>.
var ints = listOfDouble.map((x) => x.toInt());
```

In the last example, `x` is inferred as `double` using downward information. The return type of the closure is inferred as `int` using upward information. Dart uses this return type as upward information when inferring the `map()` method's type argument: `<int>`.

마지막 예에서 `x`는 하향 정보를 사용하여 double로 추론됩니다. 클로저의 반환 타입은 상향 정보를 사용하여 int로 추론됩니다. Dart는 이 반환 타입을 상향 정보로 사용하여 `map()` 메서드의 타입 인자를 추론합니다: `<int>`.

## Substituting types

When you override a method, you are replacing something of one type (in the old method) with something that might have a new type (in the new method). Similarly, when you pass an argument to a function, you are replacing something that has one type (a parameter with a declared type) with something that has another type (the actual argument). When can you replace something that has one type with something that has a subtype or a supertype?

When substituting types, it helps to think in terms of _consumers_ and _producers_. A consumer absorbs a type and a producer generates a type.

**You can replace a consumer's type with a supertype and a producer's type with a subtype.**

Let's look at examples of simple type assignment and assignment with generic types.

### 타입 치환

메서드를 재정의할 때는 이전 메서드의 타입(기존 메서드)을 새로운 타입으로 대체합니다(새 메서드). 마찬가지로, 함수에 인자를 전달할 때는 선언된 타입을 가진 매개변수를 실제 인자로 대체합니다. 언제 하나의 타입을 다른 타입(하위 타입 또는 상위 타입)으로 대체할 수 있을까요?

타입을 치환할 때 소비자(consumer)와 생산자(producer)의 관점에서 생각하는 것이 도움이 됩니다. 소비자는 타입을 소비하고, 생산자는 타입을 생성합니다.

**소비자의 타입은 상위 타입으로, 생산자의 타입은 하위 타입으로 대체할 수 있습니다.**

간단한 타입 할당과 제네릭 타입을 사용한 할당 예제를 살펴보겠습니다.

### Simple type assignment

When assigning objects to objects, when can you replace a type with a different type? The answer depends on whether the object is a consumer or a producer.

Consider the following type hierarchy:

### 단순 타입 할당

객체를 객체에 할당할 때, 언제 타입을 다른 타입으로 대체할 수 있을까요? 이에 대한 답은 객체가 소비자인지 생산자인지에 따라 달라집니다.

다음과 같은 타입 계층을 고려해 보겠습니다:

![a hierarchy of animals where the supertype is Animal and the subtypes are Alligator, Cat, and HoneyBadger. Cat has the subtypes of Lion and MaineCoon](https://dart.dev/assets/img/AQ-sq8I8Lm-490.png)

Consider the following simple assignment where `Cat c` is a _consumer_ and `Cat()` is a _producer_:

고려해야 할 다음 간단한 할당에서 Cat c는 소비자이고, Cat()는 생산자입니다:

```dart
Cat c = Cat();
```

In a consuming position, it's safe to replace something that consumes a specific type (`Cat`) with something that consumes anything (`Animal`), so replacing `Cat c` with `Animal c` is allowed, because `Animal` is a supertype of `Cat`.

소비자 위치에서는 특정 타입(`Cat`)을 소비하는 것을 아무 타입(`Animal`)을 소비하는 것으로 대체하는 것이 안전합니다. 따라서 `Cat c`를 `Animal c`로 대체하는 것이 허용됩니다. 왜냐하면 `Animal`이 `Cat`의 상위 타입이기 때문입니다.

```dart
// ✔ static analysis: successdart
Animal c = Cat();
```

But replacing `Cat c` with `MaineCoon c` breaks type safety, because the superclass may provide a type of Cat with different behaviors, such as `Lion`:

`Cat c`를 `MaineCoon c`로 대체하는 것은 타입 안정성을 깨뜨립니다. 왜냐하면 슈퍼클래스인 `Cat`은 `Lion`과 같은 다른 행동을 가진 서브타입을 제공할 수 있기 때문입니다:

```dart
// ✗ static analysis: failuredart
MaineCoon c = Cat();
```

In a producing position, it's safe to replace something that produces a type (`Cat`) with a more specific type (`MaineCoon`). So, the following is allowed:

생산 위치에서는 특정 타입(`Cat`)을 생성하는 것을 더 구체적인 타입(`MaineCoon`)으로 대체하는 것이 안전합니다. 따라서 다음과 같은 것이 허용됩니다:

```dart
// ✔ static analysis: successdart
Cat c = MaineCoon();
```
### Generic type assignmen

Are the rules the same for generic types? Yes. Consider the hierarchy of lists of animals—a `List` of `Cat` is a subtype of a `List` of `Animal`, and a supertype of a `List` of `MaineCoon`:

### 일반적으로 사용되는 제네릭 타입 할당 규칙

제네릭 타입 할당 규칙은 일반적인 타입 할당 규칙과 동일한가요? 네, 같습니다. 동물 목록의 계층 구조를 고려해 봅시다 - Cat의 목록은 Animal의 목록의 하위 타입이며, MaineCoon의 목록의 상위 타입입니다:

![List\<Animal> -> List\<Cat> -> List\<MaineCoon>](https://dart.dev/assets/img/FGoXqlcRFj-148.png)


In the following example, you can assign a `MaineCoon` list to `myCats` because `List<MaineCoon>` is a subtype of `List<Cat>`:

다음 예시에서는 List\<MaineCoon>이 List\<Cat>의 하위 타입이기 때문에 myCats에 MaineCoon 목록을 할당할 수 있습니다:

```dart
// ✔ static analysis: successdart
List<MaineCoon> myMaineCoons = ...
List<Cat> myCats = myMaineCoons;
```

What about going in the other direction? Can you assign an `Animal` list to a `List<Cat>`?

반대 방향으로는 어떨까요? Animal 목록을 List\<Cat>에 할당할 수 있나요?

```dart
// ✗ static analysis: failuredart
List<Animal> myAnimals = ...
List<Cat> myCats = myAnimals;
```

This assignment doesn't pass static analysis because it creates an implicit downcast, which is disallowed from non-`dynamic` types such as `Animal`.

To make this type of code pass static analysis, you can use an explicit cast.

이 할당은 정적 분석을 통과하지 못합니다. 이는 Animal과 같은 non-dynamic 타입에서 암시적으로 다운캐스트를 생성하기 때문입니다.

이러한 유형의 코드가 정적 분석을 통과하도록 하려면 명시적 캐스트를 사용할 수 있습니다.

```dart
List<Animal> myAnimals = ...
List<Cat> myCats = myAnimals as List<Cat>;
```

An explicit cast might still fail at runtime, though, depending on the actual type of the list being cast (`myAnimals`).

명시적 캐스트는 실제로 캐스트되는 목록(myAnimals)의 실제 타입에 따라 런타임에서 실패할 수 있습니다.
### Methods

When overriding a method, the producer and consumer rules still apply. For example:

### 메서드

메서드를 재정의할 때에도 생산자와 소비자 규칙이 적용됩니다. 예를 들어:
![Animal class showing the chase method as the consumer and the parent getter as the producer](https://dart.dev/assets/img/dkM9WrIUOv-310.png)

For a consumer (such as the `chase(Animal)` method), you can replace the parameter type with a supertype. For a producer (such as the `parent` getter method), you can replace the return type with a subtype.

For more information, see [Use sound return types when overriding methods](https://dart.dev/language/type-system#use-proper-return-types) and [Use sound parameter types when overriding methods](https://dart.dev/language/type-system#use-proper-param-types).

소비자(예: chase(Animal) 메서드)의 경우, 매개변수 타입을 상위 타입으로 대체할 수 있습니다. 생산자(예: 부모 getter 메서드)의 경우, 반환 타입을 하위 타입으로 대체할 수 있습니다.

더 자세한 정보는 "메서드 재정의 시 안전한 반환 타입 사용"과 "메서드 재정의 시 안전한 매개변수 타입 사용"을 참조하세요.

## Other resources

The following resources have further information on sound Dart:

- [Fixing common type problems](https://dart.dev/guides/language/sound-problems) - Errors you may encounter when writing sound Dart code, and how to fix them.
- [Fixing type promotion failures](https://dart.dev/tools/non-promotion-reasons) - Understand and learn how to fix type promotion errors.
- [Sound null safety](https://dart.dev/null-safety) - Learn about writing code with sound null safety.
- [Customizing static analysis](https://dart.dev/tools/analysis) - How to set up and customize the analyzer and linter using an analysis options file.
- 
## 다음은 sound Dart에 대한 추가 자료입니다:

- **일반적인 타입 문제 해결**: 이 자료는 sound Dart 코드를 작성할 때 발생할 수 있는 일반적인 타입 관련 문제와 그 해결 방법에 대해 다룹니다.
- **타입 프로모션 실패 해결**: 타입 프로모션 관련 오류를 이해하고 해결하는 방법에 대해 설명합니다. 이를 통해 Dart 코드가 타입 안전성을 유지할 수 있습니다.
- **Sound null safety**: sound null safety를 적용하여 안전하고 견고한 Dart 코드를 작성하는 방법에 대해 학습할 수 있습니다.
- **정적 분석 사용자 정의**: 분석 옵션 파일을 사용하여 Dart 분석기와 린터를 설정하고 사용자 정의하는 방법에 대해 배웁니다.

# Patterns


Patterns are a syntactic category in the Dart language, like statements and expressions. A pattern represents the shape of a set of values that it may match against actual values.

This page describes:

- What patterns do.
- Where patterns are allowed in Dart code.
- What the common use cases for patterns are.

To learn about the different kinds of patterns, visit the [pattern types](https://dart.dev/language/pattern-types) page.

패턴은 다트 언어에서 문장 및 표현식과 같은 구문 범주입니다. 패턴은 실제 값에 대해 일치시킬 수 있는 값 집합의 형태를 나타냅니다.

이 페이지에서는 다음을 설명합니다:

- 패턴이 무엇을 하는지.
- 다트 코드에서 패턴이 허용되는 위치.
- 패턴의 일반적인 사용 사례.
- 다양한 종류의 패턴에 대해 배우려면, 패턴 종류 페이지를 방문하세요.

## What patterns do

In general, a pattern may **match** a value, **destructure** a value, or both, depending on the context and shape of the pattern.

First, _pattern matching_ allows you to check whether a given value:

- Has a certain shape.
- Is a certain constant.
- Is equal to something else.
- Has a certain type.

Then, _pattern destructuring_ provides you with a convenient declarative syntax to break that value into its constituent parts. The same pattern can also let you bind variables to 
some or all of those parts in the process.

### 패턴이 하는 일

일반적으로, 패턴은 값과 일치하거나, 값을 구조 분해하거나, 또는 둘 다 할 수 있으며, 이는 패턴의 형태와 문맥에 따라 다릅니다.

먼저, 패턴 매칭은 주어진 값이 다음을 만족하는지 확인할 수 있게 합니다:

- 특정 형태를 가짐.
- 특정 상수임.
- 다른 것과 같음.
- 특정 타입을 가짐.

그 다음, 패턴 구조 분해는 그 값을 구성 요소로 분해할 수 있는 편리한 선언적 구문을 제공합니다. 동일한 패턴은 또한 그 과정에서 일부 또는 모든 구성 요소에 변수들을 바인딩할 수 있게 합니다.
### Matching

A pattern always tests against a value to determine if the value has the form you expect. In other words, you are checking if the value _matches_ the pattern.

What constitutes a match depends on [what kind of pattern](https://dart.dev/language/pattern-types) you are using. For example, a constant pattern matches if the value is equal to the pattern's constant:

### 매칭

패턴은 항상 값에 대해 테스트하여 그 값이 기대하는 형태를 가지고 있는지 결정합니다. 즉, 값을 패턴과 일치시키는지 확인하는 것입니다.

무엇이 일치하는지 여부는 사용하는 패턴의 종류에 따라 다릅니다. 예를 들어, 상수 패턴은 값이 패턴의 상수와 동일할 때 일치합니다:

```dart
switch (number) {
  // Constant pattern matches if 1 == number.
  case 1:
    print('one');
}
```

Many patterns make use of subpatterns, sometimes called _outer_ and _inner_ patterns, respectively. Patterns match recursively on their subpatterns. For example, the individual fields of any [collection-type](https://dart.dev/language/collections) pattern could be [variable patterns](https://dart.dev/language/pattern-types#variable) or [constant patterns](https://dart.dev/language/pattern-types#constant):

많은 패턴은 각각 외부 패턴과 내부 패턴이라고 불리는 하위 패턴을 사용합니다. 패턴은 하위 패턴에 대해 재귀적으로 일치합니다. 예를 들어, 어떤 컬렉션 타입 패턴의 개별 필드는 변수 패턴 또는 상수 패턴일 수 있습니다:

```dart
const a = 'a';
const b = 'b';
switch (obj) {
  // List pattern [a, b] matches obj first if obj is a list with two fields,
  // then if its fields match the constant subpatterns 'a' and 'b'.
  case [a, b]:
    print('$a, $b');
}
```

To ignore parts of a matched value, you can use a [wildcard pattern](https://dart.dev/language/pattern-types#wildcard) as a placeholder. In the case of list patterns, you can use a [rest element](https://dart.dev/language/pattern-types#rest-element).

일치하는 값의 일부를 무시하려면, 와일드카드 패턴을 자리 표시자로 사용할 수 있습니다. 리스트 패턴의 경우, 나머지 요소(rest element)를 사용할 수 있습니다.
### Destructuring

When an object and pattern match, the pattern can then access the object's data and extract it in parts. In other words, the pattern _destructures_ the object:
### 구조 분해

객체와 패턴이 일치하면, 패턴은 객체의 데이터를 접근하여 부분적으로 추출할 수 있습니다. 다시 말해, 패턴이 객체를 구조 분해하는 것입니다.

```dart
var numList = [1, 2, 3];
// List pattern [a, b, c] destructures the three elements from numList...
var [a, b, c] = numList;
// ...and assigns them to new variables.
print(a + b + c);
```

You can nest [any kind of pattern](https://dart.dev/language/pattern-types) inside a destructuring pattern. For example, this case pattern matches and destructures a two-element list whose first element is `'a'` or `'b'`:

구조 분해 패턴 안에 어떤 종류의 패턴이든 중첩할 수 있습니다. 예를 들어, 다음의 경우 패턴은 첫 번째 요소가 'a' 또는 'b'인 두 요소 리스트와 일치하고 이를 구조 분해합니다:

```dart
switch (list) {
  case ['a' || 'b', var c]:
    print(c);
}
```
## Places patterns can appear

You can use patterns in several places in the Dart language:

- Local variable [declarations](https://dart.dev/language/patterns#variable-declaration) and [assignments](https://dart.dev/language/patterns#variable-assignment)
- [for and for-in loops](https://dart.dev/language/loops#for-loops)
- [if-case](https://dart.dev/language/branches#if-case) and [switch-case](https://dart.dev/language/branches#switch-statements)
- Control flow in [collection literals](https://dart.dev/language/collections#control-flow-operators)

This section describes common use cases for matching and destructuring with patterns.

## 패턴이 나타날 수 있는 위치

다트 언어에서는 여러 곳에서 패턴을 사용할 수 있습니다:

- 로컬 변수 선언 및 할당
- for 및 for-in 루프
- if-case 및 switch-case
- 컬렉션 리터럴의 제어 흐름

이 섹션에서는 패턴을 사용한 매칭 및 구조 분해의 일반적인 사용 사례를 설명합니다.

### Variable declaration

You can use a _pattern variable declaration_ anywhere Dart allows local variable declaration. The pattern matches against the value on the right of the declaration. Once matched, it destructures the value and binds it to new local variables:
## 변수 선언

패턴 변수 선언은 다트가 로컬 변수 선언을 허용하는 곳 어디에서든 사용할 수 있습니다. 패턴은 선언의 오른쪽에 있는 값과 매칭됩니다. 매칭이 이루어지면, 그 값을 구조 분해하고 새로운 로컬 변수에 바인딩합니다:

```dart
// Declares new variables a, b, and c.
var (a, [b, c]) = ('str', [1, 2]);
```

A pattern variable declaration must start with either `var` or `final`, followed by a pattern.

패턴 변수 선언은 `var` 또는 `final` 키워드로 시작해야 하며, 그 뒤에 패턴이 옵니다.
### Variable assignment

A _variable assignment pattern_ falls on the left side of an assignment. First, it destructures the matched object. Then it assigns the values to _existing_ variables, instead of binding new ones.

Use a variable assignment pattern to swap the values of two variables without declaring a third temporary one:

### 변수 할당

변수 할당 패턴은 할당 구문의 왼쪽에 위치합니다. 먼저 매칭된 객체를 구조 분해한 후, 새로운 변수를 바인딩하는 대신 기존 변수에 값을 할당합니다.

세 번째 임시 변수를 선언하지 않고 두 변수의 값을 교환하는 예시에서 변수 할당 패턴을 사용할 수 있습니다:

```dart
var (a, b) = ('left', 'right');
(b, a) = (a, b); // Swap.
print('$a $b'); // Prints "right left".
```
### Switch statements and expressions

Every case clause contains a pattern. This applies to [switch statements](https://dart.dev/language/branches#switch-statements) and [expressions](https://dart.dev/language/branches#switch-expressions), as well as [if-case statements](https://dart.dev/language/branches#if-case). You can use [any kind of pattern](https://dart.dev/language/pattern-types) in a case.

_Case patterns_ are [refutable](https://dart.dev/resources/glossary#refutable-pattern). They allow control flow to either:

- Match and destructure the object being switched on.
- Continue execution if the object doesn't match.

The values that a pattern destructures in a case become local variables. Their scope is only within the body of that case.

### switch 문과 표현식

switch 문과 표현식은 각 case 절이 패턴을 포함합니다. 이는 if-case 문에서도 적용됩니다. case 절에서는 어떤 종류의 패턴이든 사용할 수 있습니다.

case 패턴은 반박 가능합니다(refutable). 이는 제어 흐름을 다음과 같이 나눌 수 있습니다:

- 스위치 대상 객체를 일치시키고 구조 분해합니다.
- 객체가 일치하지 않는 경우 실행을 계속합니다.

case에서 패턴으로 구조 분해된 값들은 로컬 변수가 됩니다. 이들의 범위는 해당 case의 본문 내에서만 유효합니다.

```dart
switch (obj) {
  // Matches if 1 == obj.
  case 1:
    print('one');

  // Matches if the value of obj is between the
  // constant values of 'first' and 'last'.
  case >= first && <= last:
    print('in range');

  // Matches if obj is a record with two fields,
  // then assigns the fields to 'a' and 'b'.
  case (var a, var b):
    print('a = $a, b = $b');

  default:
}
```

[Logical-or patterns](https://dart.dev/language/pattern-types#logical-or) are useful for having multiple cases share a body in switch expressions or statements:

논리 OR 패턴은 switch 표현식 또는 문에서 여러 경우가 동일한 본문을 공유할 수 있도록 유용합니다.

```dart
var isPrimary = switch (color) {
  Color.red || Color.yellow || Color.blue => true,
  _ => false
};
```

Switch statements can have multiple cases share a body [without using logical-or patterns](https://dart.dev/language/branches#switch-share), but they are still uniquely useful for allowing multiple cases to share a [guard](https://dart.dev/language/branches#guard-clause):

switch 문은 논리 OR 패턴을 사용하지 않고도 여러 경우가 동일한 본문을 공유할 수 있지만, 논리 OR 패턴은 여러 경우가 동일한 가드(guard)를 공유할 수 있도록 독특하게 유용합니다.

```dart
switch (shape) {
  case Square(size: var s) || Circle(size: var s) when s > 0:
    print('Non-empty symmetric shape');
}
```

[Guard clauses](https://dart.dev/language/branches#guard-clause) evaluate an arbitrary conditon as part of a case, without exiting the switch if the condition is false (like using an `if` statement in the case body would cause).

가드 절은 case의 일부로서 임의의 조건을 평가합니다. 이 조건이 false일 경우 switch를 종료하지 않고 계속 진행합니다 (일반적으로 case 본문에서 if 문을 사용할 때와 달리).

```dart
switch (pair) {
  case (int a, int b):
    if (a > b) print('First element greater');
  // If false, prints nothing and exits the switch.
  case (int a, int b) when a > b:
    // If false, prints nothing but proceeds to next case.
    print('First element greater');
  case (int a, int b):
    print('First element not greater');
}
```
### For and for-in loops

[#](https://dart.dev/language/patterns#for-and-for-in-loops)

You can use patterns in [for and for-in loops](https://dart.dev/language/loops#for-loops) to iterate-over and destructure values in a collection.

This example uses [object destructuring](https://dart.dev/language/pattern-types#object) in a for-in loop to destructure the [`MapEntry`](https://api.dart.dev/stable/dart-core/MapEntry-class.html) objects that a `<Map>.entries` call returns:

### for 및 for-in 루프

for와 for-in 루프에서는 패턴을 사용하여 컬렉션 내의 값을 반복하고 구조 분해할 수 있습니다.

다음 예시는 for-in 루프에서 객체 구조 분해를 사용하여 `<Map>.entries` 호출로 반환된 MapEntry 객체를 구조 분해하는 방법을 보여줍니다:

```dart
Map<String, int> hist = {
  'a': 23,
  'b': 100,
};

for (var MapEntry(key: key, value: count) in hist.entries) {
  print('$key occurred $count times');
}
```

The object pattern checks that `hist.entries` has the named type `MapEntry`, and then recurses into the named field subpatterns `key` and `value`. It calls the `key` getter and `value` getter on the `MapEntry` in each iteration, and binds the results to local variables `key` and `count`, respectively.

Binding the result of a getter call to a variable of the same name is a common use case, so object patterns can also infer the getter name from the [variable subpattern](https://dart.dev/language/pattern-types#variable). This allows you to simplify the variable pattern from something redundant like `key: key` to just `:key`:

객체 패턴은 `hist.entries`가 `MapEntry`라는 이름이 붙은 타입인지 확인한 후, `key`와 `value`라는 이름의 필드 하위 패턴으로 재귀적으로 진행합니다. 각 반복에서는 `MapEntry`의 `key` getter와 `value` getter를 호출하여 결과를 각각 `key`와 `count`라는 지역 변수에 바인딩합니다.

같은 이름의 getter 호출 결과를 해당 이름의 변수에 바인딩하는 것은 흔한 사용 사례입니다. 따라서 객체 패턴에서는 변수 하위 패턴에서 getter 이름을 자동으로 추론할 수 있습니다. 이로써 `key: key`와 같이 중복된 표현을 단순히 `:key`로 줄일 수 있습니다:

```dart
for (var MapEntry(:key, value: count) in hist.entries) {
  print('$key occurred $count times');
}
```
## Use cases for patterns

[#](https://dart.dev/language/patterns#use-cases-for-patterns)

The [previous section](https://dart.dev/language/patterns#places-patterns-can-appear) describes _how_ patterns fit into other Dart code constructs. You saw some interesting use cases as examples, like [swapping](https://dart.dev/language/patterns#variable-assignment) the values of two variables, or [destructuring key-value pairs](https://dart.dev/language/patterns#for-and-for-in-loops) in a map. This section describes even more use cases, answering:

- _When and why_ you might want to use patterns.
- What kinds of problems they solve.
- Which idioms they best suit.

## 패턴의 사용 사례

이전 섹션에서는 패턴이 다른 Dart 코드 구조에 어떻게 적합한지를 설명했습니다. 변수 두 개의 값을 교환하는 것이나 맵의 키-값 쌍을 구조 분해하는 것과 같은 흥미로운 예제를 보았습니다. 이 섹션에서는 패턴의 더 많은 사용 사례를 설명하며 다음 질문에 답합니다:

- 패턴을 사용할 때와 그 이유
- 패턴이 해결하는 문제 유형
- 어떤 관용구에 가장 잘 맞는지
### Destructuring multiple returns

Records allow aggregating and [returning multiple values](https://dart.dev/language/records#multiple-returns) from a single function call. Patterns add the ability to destructure a record's fields directly into local variables, inline with the function call.

Instead of individually declaring new local variables for each record field, like this:

### 다중 반환의 구조 분해

레코드는 단일 함수 호출로 여러 값을 모아서 반환할 수 있습니다. 패턴은 이 레코드의 필드를 직접 로컬 변수에 구조 분해하는 기능을 추가합니다.

다음과 같이 각 레코드 필드에 대해 개별적으로 새로운 로컬 변수를 선언하는 대신에:

```dart
var info = userInfo(json);
var name = info.$1;
var age = info.$2;
```

You can destructure the fields of a record that a function returns into local variables using a [variable declaration](https://dart.dev/language/patterns#variable-declaration) or [assigment pattern](https://dart.dev/language/patterns#variable-assignment), and a [record pattern](https://dart.dev/language/pattern-types#record) as its subpattern:

함수가 반환하는 레코드의 필드를 변수 선언 또는 할당 패턴을 사용하여 로컬 변수로 구조 분해할 수 있습니다. 이 때, 하위 패턴으로 레코드 패턴을 사용합니다.

```dart
var (name, age) = userInfo(json);
```

To destructure a record with named fields using a pattern:

다트에서 패턴을 사용하여 이름이 있는 필드를 가진 레코드를 구조 분해하는 방법은 다음과 같습니다:

```dart
final (:name, :age) =
    getData(); // For example, return (name: 'doug', age: 25);
```
### Destructuring class instances

[Object patterns](https://dart.dev/language/pattern-types#object) match against named object types, allowing you to destructure their data using the getters the object's class already exposes.

To destructure an instance of a class, use the named type, followed by the properties to destructure enclosed in parentheses:

### 클래스 인스턴스를 구조 분해하는 것

객체 패턴은 명명된 객체 유형에 일치하여 해당 객체의 클래스가 이미 노출하는 getter를 사용하여 데이터를 구조 분해할 수 있도록 합니다.

클래스 인스턴스를 구조 분해하려면, 속성을 괄호로 묶어야 하는 명명된 유형을 사용하세요

```dart
final Foo myFoo = Foo(one: 'one', two: 2);
var Foo(:one, :two) = myFoo;
print('one $one, two $two');
```
### Algebraic data types

Object destructuring and switch cases are conducive to writing code in an [algebraic data type](https://en.wikipedia.org/wiki/Algebraic_data_type) style. Use this method when:

- You have a family of related types.
- You have an operation that needs specific behavior for each type.
- You want to group that behavior in one place instead of spreading it across all the different type definitions.

Instead of implementing the operation as an instance method for every type, keep the operation's variations in a single function that switches over the subtypes:

### 대수적 데이터 타입

객체 구조 분해와 switch case는 대수적 데이터 타입 스타일로 코드를 작성하는 데 유리합니다. 이 방법을 사용하는 경우:

- 관련된 여러 타입을 가지고 있을 때
- 각 타입마다 특정 동작이 필요할 때
- 이러한 동작을 모든 다른 타입 정의에 흩어지지 않고 하나의 장소에 그룹화하고 싶을 때

각 타입의 인스턴스 메서드로 동작을 구현하는 대신, 서브타입을 switch하여 다양한 동작을 단일 함수에 유지하는 것이 좋습니다.

```dart 
sealed class Shape {}

class Square implements Shape {
  final double length;
  Square(this.length);
}

class Circle implements Shape {
  final double radius;
  Circle(this.radius);
}

double calculateArea(Shape shape) => switch (shape) {
      Square(length: var l) => l * l,
      Circle(radius: var r) => math.pi * r * r
    };
```
### Validating incoming JSON

[Map](https://dart.dev/language/pattern-types#map) and [list](https://dart.dev/language/pattern-types#list) patterns work well for destructuring key-value pairs in JSON data:

### 수신된 JSON 검증

맵과 리스트 패턴은 JSON 데이터의 키-값 쌍을 구조 분해하는 데 매우 유용합니다:

```dart
var json = {
  'user': ['Lily', 13]
};
var {'user': [name, age]} = json;
```

If you know that the JSON data has the structure you expect, the previous example is realistic. But data typically comes from an external source, like over the network. You need to validate it first to confirm its structure.

Without patterns, validation is verbose:

예상한 구조를 가진 JSON 데이터를 알고 있다면, 이전 예제는 현실적입니다. 하지만 데이터는 일반적으로 네트워크를 통해 외부 소스에서 가져오게 됩니다. 구조를 확인하기 위해 먼저 검증해야 합니다.

패턴을 사용하지 않으면 검증 과정이 장황해집니다:

```dart
if (json is Map<String, Object?> &&
    json.length == 1 &&
    json.containsKey('user')) {
  var user = json['user'];
  if (user is List<Object> &&
      user.length == 2 &&
      user[0] is String &&
      user[1] is int) {
    var name = user[0] as String;
    var age = user[1] as int;
    print('User $name is $age years old.');
  }
}
```

A single [case pattern](https://dart.dev/language/patterns#switch-statements-and-expressions) can achieve the same validation. Single cases work best as [if-case](https://dart.dev/language/branches#if-case) statements. Patterns provide a more declarative, and much less verbose method of validating JSON:

단일 case 패턴을 사용하면 동일한 검증을 수행할 수 있습니다. 단일 case는 if-case 문에서 가장 잘 작동합니다. 패턴을 사용하면 JSON을 검증하는 더 선언적이고 훨씬 덜 장황한 방법을 제공합니다.

```dart
if (json case {'user': [String name, int age]}) {
  print('User $name is $age years old.');
}
```

This case pattern simultaneously validates that:

- `json` is a map, because it must first match the outer [map pattern](https://dart.dev/language/pattern-types#map) to proceed.
    - And, since it's a map, it also confirms `json` is not null.
- `json` contains a key `user`.
- The key `user` pairs with a list of two values.
- The types of the list values are `String` and `int`.
- The new local variables to hold the values are `name` and `age`.

다음 case 패턴은 동시에 다음을 검증합니다:

- `json`이 맵이어야 하므로 먼저 외부 맵 패턴과 일치해야 합니다.
- 맵이므로 `json`이 null이 아님을 확인합니다.
- `json`에는 `user`라는 키가 있어야 합니다.
- `user` 키는 두 개의 값으로 구성된 리스트와 쌍을 이루어야 합니다.
- 리스트 값의 타입은 각각 String과 int여야 합니다.
- 이 값을 저장할 새로운 로컬 변수는 name과 age입니다.

# Pattern types

This page is a reference for the different kinds of patterns. For an overview of how patterns work, where you can use them in Dart, and common use cases, visit the main [Patterns](https://dart.dev/language/patterns) page.

이 페이지는 다양한 패턴 종류에 대한 참고 자료입니다. 패턴이 어떻게 작동하는지, Dart에서 어디에 사용할 수 있는지, 일반적인 사용 사례를 알아보려면 메인 패턴 페이지를 방문하세요.

#### Pattern precedence

Similar to [operator precedence](https://dart.dev/language/operators#operator-precedence-example), pattern evaluation adheres to precedence rules. You can use [parenthesized patterns](https://dart.dev/language/pattern-types#parenthesized) to evaluate lower-precedence patterns first.

This document lists the pattern types in ascending order of precedence:

- [Logical-or](https://dart.dev/language/pattern-types#logical-or) patterns are lower-precedence than [logical-and](https://dart.dev/language/pattern-types#logical-and), logical-and patterns are lower-precedence than [relational](https://dart.dev/language/pattern-types#relational) patterns, and so on.

- Post-fix unary patterns ([cast](https://dart.dev/language/pattern-types#cast), [null-check](https://dart.dev/language/pattern-types#null-check), and [null-assert](https://dart.dev/language/pattern-types#null-assert)) share the same level of precedence.

- The remaining primary patterns share the highest precedence. Collection-type ([record](https://dart.dev/language/pattern-types#record), [list](https://dart.dev/language/pattern-types#list), and [map](https://dart.dev/language/pattern-types#map)) and [Object](https://dart.dev/language/pattern-types#object) patterns encompass other data, so are evaluated first as outer-patterns.
### 패턴 우선순위

연산자 우선순위와 유사하게, 패턴 평가도 우선순위 규칙을 따릅니다. 괄호로 묶인 패턴을 사용하여 낮은 우선순위 패턴을 먼저 평가할 수 있습니다.

이 문서는 패턴 유형을 우선순위 오름차순으로 나열합니다:

- 논리적 OR 패턴은 논리적 AND 패턴보다 우선순위가 낮고, 논리적 AND 패턴은 관계 패턴보다 우선순위가 낮습니다.

- 후위 단항 패턴(캐스트, null 체크, null 단언)은 동일한 우선순위 레벨을 공유합니다.

- 나머지 기본 패턴은 가장 높은 우선순위를 공유합니다. 컬렉션 유형(레코드, 리스트, 맵)과 객체 패턴은 다른 데이터를 포함하므로 외부 패턴으로서 먼저 평가됩니다.

## Logical-or

`subpattern1 || subpattern2`

A logical-or pattern separates subpatterns by `||` and matches if any of the branches match. Branches are evaluated left-to-right. Once a branch matches, the rest are not evaluated.

### 논리적 OR

`subpattern1 || subpattern2`

논리적 OR 패턴은 subpattern들을 ||로 구분하며, 어느 한 분기가 일치하면 매칭됩니다. 분기는 왼쪽에서 오른쪽으로 평가됩니다. 한 분기가 일치하면 나머지는 평가되지 않습니다.

```dart
var isPrimary = switch (color) {
  Color.red || Color.yellow || Color.blue => true,
  _ => false
};
```

Subpatterns in a logical-or pattern can bind variables, but the branches must define the same set of variables, because only one branch will be evaluated when the pattern matches.

논리적 OR 패턴의 하위 패턴들은 변수를 바인딩할 수 있지만, 분기들은 동일한 변수 집합을 정의해야 합니다. 왜냐하면 패턴이 일치할 때 오직 한 분기만 평가되기 때문입니다.
## Logical-and

`subpattern1 && subpattern2`

A pair of patterns separated by `&&` matches only if both subpatterns match. If the left branch does not match, the right branch is not evaluated.

Subpatterns in a logical-and pattern can bind variables, but the variables in each subpattern must not overlap, because they will both be bound if the pattern matches:
### 논리적 AND

`subpattern1 && subpattern2`

&&로 구분된 패턴 쌍은 두 하위 패턴이 모두 일치할 때만 일치합니다. 왼쪽 분기가 일치하지 않으면, 오른쪽 분기는 평가되지 않습니다.

논리적 AND 패턴의 하위 패턴들도 변수를 바인딩할 수 있지만, 각 하위 패턴의 변수들은 겹치지 않아야 합니다. 왜냐하면 패턴이 일치할 경우 두 패턴의 변수들이 모두 바인딩되기 때문입니다.

```dart
switch ((1, 2)) {
  // Error, both subpatterns attempt to bind 'b'.
  case (var a, var b) && (var b, var c): // ...
}
```
## Relational

[#](https://dart.dev/language/pattern-types#relational)

`== expression`

`< expression`

Relational patterns compare the matched value to a given constant using any of the equality or relational operators: `==`, `!=`, `<`, `>`, `<=`, and `>=`.

The pattern matches when calling the appropriate operator on the matched value with the constant as an argument returns `true`.

Relational patterns are useful for matching on numeric ranges, especially when combined with the [logical-and pattern](https://dart.dev/language/pattern-types#logical-and):

### 관계 패턴

`== expression`

`< expression`

관계 패턴은 일치하는 값을 주어진 상수와 비교하여 동등성 또는 관계 연산자(\==, !=, <, >, <=, >=)를 사용합니다.

패턴은 적절한 연산자를 호출하여 일치하는 값과 상수를 인수로 사용할 때 true를 반환하면 일치합니다.

관계 패턴은 논리적 AND 패턴과 결합하여 특히 숫자 범위를 일치시키는 데 유용합니다.

```dart
String asciiCharType(int char) {
  const space = 32;
  const zero = 48;
  const nine = 57;

  return switch (char) {
    < space => 'control',
    == space => 'space',
    > space && < zero => 'punctuation',
    >= zero && <= nine => 'digit',
    _ => ''
  };
}
```
## Cast

`foo as String`

A cast pattern lets you insert a [type cast](https://dart.dev/language/operators#type-test-operators) in the middle of destructuring, before passing the value to another subpattern:

### 캐스트 패턴

`foo as String`

캐스트 패턴은 값을 다른 하위 패턴에 전달하기 전에 구조 분해 중간에 타입 캐스트를 삽입할 수 있게 해줍니다:

```dart
(num, Object) record = (1, 's');
var (i as int, s as String) = record;
```

Cast patterns will [throw](https://dart.dev/language/error-handling#throw) if the value doesn't have the stated type. Like the [null-assert pattern](https://dart.dev/language/pattern-types#null-assert), this lets you forcibly assert the expected type of some destructured value.

캐스트 패턴은 값이 명시된 타입을 갖지 않으면 예외를 발생시킵니다. null-단언 패턴처럼, 구조 분해된 값의 예상 타입을 강제로 단언할 수 있게 해줍니다.
## Null-check

`subpattern?`

Null-check patterns match first if the value is not null, and then match the inner pattern against that same value. They let you bind a variable whose type is the non-nullable base type of the nullable value being matched.

To treat `null` values as match failures without throwing, use the null-check pattern.
### 널 체크 패턴

`subpattern?`

널 체크 패턴은 값이 null이 아닌 경우 먼저 일치한 다음, 동일한 값에 대해 내부 패턴과 일치합니다. 이를 통해 일치하는 nullable 값의 non-nullable 기본 타입의 변수를 바인딩할 수 있습니다.

널 값을 일치 실패로 처리하지만 예외를 발생시키지 않으려면, 널 체크 패턴을 사용하세요.

```dart
String? maybeString = 'nullable with base type String';
switch (maybeString) {
  case var s?:
  // 's' has type non-nullable String here.
}
```

To match when the value _is_ null, use the [constant pattern](https://dart.dev/language/pattern-types#constant) `null`.

값이 null일 때 일치시키려면 상수 패턴 `null`을 사용하세요.
## Null-assert

`subpattern!`

Null-assert patterns match first if the object is not null, then on the value. They permit non-null values to flow through, but [throw](https://dart.dev/language/error-handling#throw) if the matched value is null.

To ensure `null` values are not silently treated as match failures, use a null-assert pattern while matching:

## 널 단언 패턴

`subpattern!`

널 단언 패턴은 객체가 null이 아닌 경우 먼저 일치한 다음, 그 값에 대해 일치합니다. 이는 non-null 값을 통과시키지만, 일치하는 값이 null일 경우 예외를 발생시킵니다.

널 값을 조용히 일치 실패로 처리하지 않도록 하려면, 일치 시 널 단언 패턴을 사용하세요.

```dart
List<String?> row = ['user', null];
switch (row) {
  case ['user', var name!]: // ...
  // 'name' is a non-nullable string here.
}
```

To eliminate `null` values from variable declaration patterns, use the null-assert pattern:

널 값을 변수 선언 패턴에서 제거하려면, 널 단언 패턴을 사용하세요:

```dart
(int?, int?) position = (2, 3);

var (x!, y!) = position;
```

To match when the value _is_ null, use the [constant pattern](https://dart.dev/language/pattern-types#constant) `null`.

값이 null일 때 일치시키려면 상수 패턴 `null`을 사용하세요.

## Constant

`123, null, 'string', math.pi, SomeClass.constant, const Thing(1, 2), const (1 + 2)`

Constant patterns match when the value is equal to the constant:

### 상수 패턴

`123, null, 'string', math.pi, SomeClass.constant, const Thing(1, 2), const (1 + 2)`

상수 패턴은 값이 상수와 동일할 때 일치합니다. 값이 null일 때 일치시키려면 상수 패턴 `null`을 사용하세요.

```dart
switch (number) {
  // Matches if 1 == number.
  case 1: // ...
}
```

You can use simple literals and references to named constants directly as constant patterns:

- Number literals (`123`, `45.56`)
- Boolean literals (`true`)
- String literals (`'string'`)
- Named constants (`someConstant`, `math.pi`, `double.infinity`)
- Constant constructors (`const Point(0, 0)`)
- Constant collection literals (`const []`, `const {1, 2}`)

More complex constant expressions must be parenthesized and prefixed with `const` (`const (1 + 2)`):

간단한 리터럴과 이름이 지정된 상수에 대한 참조를 직접 상수 패턴으로 사용할 수 있습니다:

- 숫자 리터럴 (예: `123`, `45.56`)
- 불리언 리터럴 (예: `true`)
- 문자열 리터럴 (예: `'string'`)
- 이름이 지정된 상수 (예: `someConstant`, `math.pi`, `double.infinity`)
- 상수 생성자 (예: `const Point(0, 0)`)
- 상수 컬렉션 리터럴 (예: `const []`, `const {1, 2}`)

더 복잡한 상수 표현식은 괄호로 묶고 `const`를 접두사로 사용해야 합니다 (예: `const (1 + 2)`).

```dart
// List or map pattern:
case [a, b]: // ...

// List or map literal:
case const [a, b]: // ...
```
## Variable

`var bar, String str, final int _`

Variable patterns bind new variables to values that have been matched or destructured. They usually occur as part of a [destructuring pattern](https://dart.dev/language/patterns#destructuring) to capture a destructured value.

The variables are in scope in a region of code that is only reachable when the pattern has matched.
### 변수 패턴

`var bar, String str, final int _`

변수 패턴은 매치되거나 구조 분해된 값에 새 변수를 바인딩합니다. 일반적으로 구조 분해 패턴의 일부로 발생하여 구조 분해된 값을 캡처합니다.

이 변수들은 패턴이 일치한 경우에만 도달할 수 있는 코드 영역에서 유효합니다.

```dart
switch ((1, 2)) {
  // 'var a' and 'var b' are variable patterns that bind to 1 and 2, respectively.
  case (var a, var b): // ...
  // 'a' and 'b' are in scope in the case body.
}
```

A _typed_ variable pattern only matches if the matched value has the declared type, and fails otherwise:

타입이 지정된 변수 패턴은 매치된 값이 선언된 타입과 일치할 때만 일치하고, 그렇지 않으면 실패합니다:

```dart
switch ((1, 2)) {
  // Does not match.
  case (int a, String b): // ...
}
```

You can use a [wildcard pattern](https://dart.dev/language/pattern-types#wildcard) as a variable pattern.

와일드카드 패턴 (`_`)을 변수 패턴으로 사용할 수 있습니다
## Identifier

`foo, _`

Identifier patterns may behave like a [constant pattern](https://dart.dev/language/pattern-types#constant) or like a [variable pattern](https://dart.dev/language/pattern-types#variable), depending on the context where they appear:

- [Declaration](https://dart.dev/language/patterns#variable-declaration) context: declares a new variable with identifier name: `var (a, b) = (1, 2);`
- [Assignment](https://dart.dev/language/patterns#variable-assignment) context: assigns to existing variable with identifier name: `(a, b) = (3, 4);`
- [Matching](https://dart.dev/language/patterns#matching) context: treated as a named constant pattern (unless its name is `_`):
### 식별자 패턴

`foo, _`

식별자 패턴은 나중에 참조할 수 있도록 새 변수를 선언하거나 이미 존재하는 변수에 값을 할당하는 데 사용될 수 있습니다. 사용되는 문맥에 따라 다음과 같이 동작할 수 있습니다:

- **선언 문맥 (Declaration context)**: 식별자 패턴은 새 변수를 선언합니다. 예를 들어, `var (a, b) = (1, 2);`에서 `a`와 `b`는 새 변수로 선언됩니다.

- **할당 문맥 (Assignment context)**: 식별자 패턴은 이미 선언된 변수에 값을 할당합니다. 예를 들어, `(a, b) = (3, 4);`에서 `a`와 `b`는 이미 존재하는 변수에 새 값을 할당받습니다.

- **매칭 문맥 (Matching context)**: 식별자 패턴은 이름이 `_`가 아닌 경우에는 상수 패턴처럼 취급됩니다. 즉, 해당 이름의 값이 일치해야 합니다. `_`는 일반적으로 "don't care" 패턴으로 사용되며, 다른 이름과 달리 특정 값을 일치시키지 않습니다.

```dart
    const c = 1;
    switch (2) {
      case c:
	      print('match $c');
      default:
        print('no match'); // Prints "no match".
    }
    ```

- [Wildcard](https://dart.dev/language/pattern-types#wildcard) identifier in any context: matches any value and discards it: `case [_, var y, _]: print('The middle element is $y');

- 와일드카드 식별자는 모든 값과 매치되며 그 값을 버립니다: `case [_, var y, _] print('The middle element is $y');

## Parenthesized

`(subpattern)`

Like parenthesized expressions, parentheses in a pattern let you control [pattern precedence](https://dart.dev/language/pattern-types#pattern-precedence) and insert a lower-precedence pattern where a higher precedence one is expected.

For example, imagine the boolean constants `x`, `y`, and `z` equal `true`, `true`, and `false`, respectively. Though the following example resembles boolean expression evaulation, the example matches patterns.

## 괄호 패턴

`(subpattern)`

괄호 패턴은 괄호가 표현식에서와 같이 패턴에서도 우선순위를 제어하고, 높은 우선순위가 기대되는 곳에 낮은 우선순위 패턴을 삽입할 수 있게 합니다.

예를 들어, 불리언 상수 x, y, z가 각각 true, true, false로 설정되어 있다고 가정해봅시다. 다음 예제는 불리언 표현식 평가처럼 보이지만, 실제로는 패턴을 매칭합니다.

```dart
// ...
x || y => 'matches true',
x || y && z => 'matches true',
x || (y && z) => 'matches true',
// `x || y && z` is the same thing as `x || (y && z)`.
(x || y) && z => 'matches nothing',
// ...
```

Dart starts matching the pattern from left to right.

1. The first pattern matches `true` as `x` matches `true`.
    
2. The second pattern matches `true` as `x` matches `true`.
    
3. The third pattern matches `true` as `x` matches `true`.
    
4. The fourth pattern `(x || y) && z` has no match.
    
    - The `x` matches `true`, so Dart doesn't try to match `y`.
    - Though `(x || y)` matches `true`, `z` doesn't match `true`
    - Therefore, pattern `(x || y) && z` doesn't match `true`.
    - The subpattern `(x || y)` doesn't match `false`, so Dart doesn't try to match `z`.
    - Therefore, pattern `(x || y) && z` doesn't match `false`.
    - As a conclusion, `(x || y) && z` has no match.

다트는 패턴 매칭을 왼쪽에서 오른쪽으로 시작합니다.

첫 번째 패턴은 x가 true와 일치하므로 true를 일치시킵니다.
두 번째 패턴은 x가 true와 일치하므로 true를 일치시킵니다.
세 번째 패턴은 x가 true와 일치하므로 true를 일치시킵니다.
네 번째 패턴인 (x || y) && z는 일치하지 않습니다.

- x가 true이므로 Dart는 y를 일치시키지 않습니다.
- (x || y)는 true이지만, z가 true와 일치하지 않습니다.
- 따라서 패턴 (x || y) && z는 true와 일치하지 않습니다.
- (x || y) 패턴이 false와 일치하지 않기 때문에 Dart는 z를 일치시키지 않습니다.
- 따라서 패턴 (x || y) && z는 false와 일치하지 않습니다.
- 결론적으로, (x || y) && z는 어떤 경우에도 일치하지 않습니다.

## List

`[subpattern1, subpattern2]`

A list pattern matches values that implement [`List`](https://dart.dev/language/collections#lists), and then recursively matches its subpatterns against the list's elements to destructure them by position:

### 리스트 패턴

`[subpattern1, subpattern2]`

리스트 패턴은 List를 구현하는 값들과 일치하며, 리스트의 각 요소에 대해 그 하위 패턴들을 재귀적으로 일치시켜 위치에 따라 구조 분해합니다:

```dart
const a = 'a';
const b = 'b';
switch (obj) {
  // List pattern [a, b] matches obj first if obj is a list with two fields,
  // then if its fields match the constant subpatterns 'a' and 'b'.
  case [a, b]:
    print('$a, $b');
}
```

List patterns require that the number of elements in the pattern match the entire list. You can, however, use a [rest element](https://dart.dev/language/pattern-types#rest-element) as a place holder to account for any number of elements in a list.

리스트 패턴은 패턴에 있는 요소 수가 전체 리스트와 일치해야 합니다. 그러나 리스트 패턴에는 하나의 나머지 요소 (`...`)를 사용할 수 있습니다. 이 나머지 요소를 사용하면 리스트의 임의 길이에 맞추어 일치시킬 수 있습니다.
### Rest element

List patterns can contain _one_ rest element (`...`) which allows matching lists of arbitrary lengths.

### 나머지 요소

리스트 패턴에는 하나의 나머지 요소 (`...`)를 포함할 수 있습니다. 이를 사용하면 임의의 길이를 가진 리스트와 일치시킬 수 있습니다.

```dart
var [a, b, ..., c, d] = [1, 2, 3, 4, 5, 6, 7];
// Prints "1 2 6 7".
print('$a $b $c $d');
```

A rest element can also have a subpattern that collects elements that don't match the other subpatterns in the list, into a new list:

나머지 요소는 다른 리스트 패턴의 하위 패턴과 일치하지 않는 요소들을 새 리스트로 모을 수 있는 서브패턴을 가질 수도 있습니다:

```dart
var [a, b, ...rest, c, d] = [1, 2, 3, 4, 5, 6, 7];
// Prints "1 2 [3, 4, 5] 6 7".
print('$a $b $rest $c $d');
```
### Map

[#](https://dart.dev/language/pattern-types#map)

`{"key": subpattern1, someConst: subpattern2}`

Map patterns match values that implement [`Map`](https://dart.dev/language/collections#maps), and then recursively match its subpatterns against the map's keys to destructure them.

Map patterns don't require the pattern to match the entire map. A map pattern ignores any keys that the map contains that aren't matched by the pattern.
### 맵 패턴

`{"key": subpattern1, someConst: subpattern2}`

맵 패턴은 Map을 구현하는 값들과 일치하며, 맵의 각 키를 기준으로 그 하위 패턴들을 재귀적으로 일치시켜 구조를 분해합니다.

맵 패턴은 패턴이 전체 맵과 일치할 필요는 없습니다. 패턴에 일치하지 않는 맵의 다른 키들은 무시됩니다.
## Record

`(subpattern1, subpattern2)`

`(x: subpattern1, y: subpattern2)`

Record patterns match a [record](https://dart.dev/language/records) object and destructure its fields. If the value isn't a record with the same [shape](https://dart.dev/language/records#record-types) as the pattern, the match fails. Otherwise, the field subpatterns are matched against the corresponding fields in the record.

Record patterns require that the pattern match the entire record. To destructure a record with _named_ fields using a pattern, include the field names in the pattern:

### 레코드

`(subpattern1, subpattern2)`
`(x: subpattern1, y: subpattern2)`

레코드 패턴은 레코드 객체와 일치하며, 그 필드들을 구조 분해합니다. 만약 값이 패턴과 동일한 구조의 레코드가 아니라면 일치하지 않습니다. 그렇지 않으면 필드의 서브패턴들이 레코드의 해당 필드와 일치하게 됩니다.

레코드 패턴은 패턴이 전체 레코드와 일치해야 합니다. 패턴을 사용하여 명명된 필드를 가진 레코드를 구조 분해하려면 패턴에 필드 이름을 포함해야 합니다:

```dart
var (myString: foo, myNumber: bar) = (myString: 'string', myNumber: 1);
```

The getter name can be omitted and inferred from the [variable pattern](https://dart.dev/language/pattern-types#variable) or [identifier pattern](https://dart.dev/language/pattern-types#identifier) in the field subpattern. These pairs of patterns are each equivalent:

게터 이름은 필드 서브패턴의 변수 패턴이나 식별자 패턴에서 생략하고 추론할 수 있습니다. 다음은 각각 동등한 패턴 쌍입니다:

```dart
// Record pattern with variable subpatterns:
var (untyped: untyped, typed: int typed) = record;
var (:untyped, :int typed) = record;

switch (record) {
  case (untyped: var untyped, typed: int typed): // ...
  case (:var untyped, :int typed): // ...
}

// Record pattern with null-check and null-assert subpatterns:
switch (record) {
  case (checked: var checked?, asserted: var asserted!): // ...
  case (:var checked?, :var asserted!): // ...
}

// Record pattern with cast subpattern:
var (untyped: untyped as int, typed: typed as String) = record;
var (:untyped as int, :typed as String) = record;
```
## Object

`SomeClass(x: subpattern1, y: subpattern2)`

Object patterns check the matched value against a given named type to destructure data using getters on the object's properties. They are [refuted](https://dart.dev/resources/glossary#refutable-pattern) if the value doesn't have the same type.

### 객체 패턴

`SomeClass(x: subpattern1, y: subpattern2)`

객체 패턴은 매치된 값을 특정한 명명된 타입과 비교하여 해당 객체의 속성에 대한 게터를 사용하여 데이터를 구조 분해합니다. 만약 값이 같은 타입이 아니라면 패턴은 거짓으로 처리됩니다.

```dart
switch (shape) {
  // Matches if shape is of type Rect, and then against the properties of Rect.
  case Rect(width: var w, height: var h): // ...
}
```

The getter name can be omitted and inferred from the [variable pattern](https://dart.dev/language/pattern-types#variable) or [identifier pattern](https://dart.dev/language/pattern-types#identifier) in the field subpattern:

게터 이름은 필드 서브패턴의 변수 패턴이나 식별자 패턴에서 생략하고 추론할 수 있습니다.

```dart
// Binds new variables x and y to the values of Point's x and y properties.
var Point(:x, :y) = Point(1, 2);
```

Object patterns don't require the pattern to match the entire object. If an object has extra fields that the pattern doesn't destructure, it can still match.

객체 패턴은 패턴이 전체 객체와 일치할 필요는 없습니다. 패턴이 구조 분해하지 않는 추가 필드가 있는 객체도 여전히 일치할 수 있습니다.
## Wildcard

`_`

A pattern named `_` is a wildcard, either a [variable pattern](https://dart.dev/language/pattern-types#variable) or [identifier pattern](https://dart.dev/language/pattern-types#identifier), that doesn't bind or assign to any variable.

It's useful as a placeholder in places where you need a subpattern in order to destructure later positional values:

### 와일드카드

_

이름이 _인 패턴은 변수 패턴이나 식별자 패턴으로, 어떤 변수에도 바인딩되지 않고 할당되지 않습니다.

이는 나중에 위치 기반 값들을 구조 분해하기 위해 서브패턴이 필요한 경우에 자리 표시자로 유용합니다.

```dart
var list = [1, 2, 3];
var [_, two, _] = list;
```

A wildcard name with a type annotation is useful when you want to test a value's type but not bind the value to a name:

와일드카드 이름에 타입 주석을 사용하는 것은 값의 타입을 테스트하고 해당 값을 이름에 바인딩하지 않고자 할 때 유용합니다:


```dart 
switch (record) {
  case (int _, String _):
    print('First field is int and second is String.');
}
```
