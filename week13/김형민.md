## 이번에 알아볼 내용

- 플러터 아키텍처 개요
- 디자인 구성의 핵심 원칙, 개념

### 플러터는 크로스 플랫폼 UI 툴킷

다음이 가능하도록 설계됨

- 다양한 운영체제에서 코드 재사용 허용
- 앱이 기본 플랫폼 서비스와 직접 인터페이스 가능

기본 플랫폼 서비스
- 파일 시스템, 카메라 접근 등

직접 인터페이스
- 기본 플랫폼 서비스와 직접적으로 상호작용 가능
- 네이티브 API를 통해 접근 가능하다는 뜻

### 이 내용의 섹션

1. 레이어 모델: Flutter가 구성되는 부분

2. 반응형 사용자 인터페이스: Flutter 사용자 인터페이스 개발의 핵심 개념

3. 위젯 소개: Flutter 사용자 인터페이스의 기본 구성 요소

### 아키텍처 레이어

Flutter는 계층적이고 확장 가능한 구조로 설계된 프레임워크

각 레이어는 독립적인 라이브러리로 구성되어 있음

서로 다른 레이어에 접근 권한이 없음

레이어는 세 가지가 존재함

- 임베더
- 엔진
- 프레임워크

#### 임베더

플러터 엔진이 각각의 플랫폼(혹은 운영체제)에서 실행할 수 있도록 함

각 플랫폼에 맞는 환경을 제공

렌더링 표면, 접근성, 입력 등 서비스 제공을 위해 운영체제와 조율

메시지 이벤트 루프(이벤트 큐에 들어있는 이벤트를 메시지라고 하는 것 같다)를 관리

각 플랫폼 별로 다른 언어로 작성되었음

임베더를 사용해 기존 앱(다른 언어로 작성된)에 플러터를 모듈로 추가할 수 있음

앱 전체를 플러터로 만드는 것도 당연히 가능

#### 엔진

대부분 C++로 작성됨

플러터 앱의 기본요소를 지원

새 프레임을 그려야 할 때마다 합성된 장면을 래스터화함

- 합성(composition): 

  Flutter는 다양한 위젯을 사용하여 UI를 만듦 
  
  위젯들은 화면에 표시할 그래픽 요소(버튼, 텍스트, 이미지 등)를 정의
  
  여러 위젯들이 모여서 하나의 장면(scene)을 구성
  
  이 과정에서 Flutter는 위젯들이 어떻게 배치되고 어떻게 겹쳐지는지(투명도, 그림자 등)를 계산
  
  이 계산된 결과가 합성된 장면

- 래스터화(rasterization): 

  합성된 장면은 아직 '그림'이 아님
  
  Flutter의 엔진은 이 장면을 픽셀 단위로 변환하여 실제로 화면에 그려야 함 
  
  이 픽셀 단위로 변환하는 과정을 래스터화라고 부름
  
  엔진은 합성된 장면의 정보를 가져와 이를 화면에 보이는 형태로 하나하나 그려내어 사용자가 볼 수 있게 만듦
  
  렌더링, 파일과 네트워크 입출력, 플랫폼 채널 등 플러터 핵심 API의 저수준 구현을 제공

##### 프레임워크

개발자가 일반적으로 사용하는 레이어

- 파운데이셔널 : 기본 클래스, 애니메이션, 페인팅, 제스처의 구성의 추상화를 제공

- 렌더링 레이어 : 레이아웃 처리의 추상화를 제공, 변경 사항 자동 업데이트

- 위젯 레이어 : UI의 구성을 추상화, 화면에 그려지는 렌더 객체에 대응하는 위젯을 제공, 여러 클래스를 조합하여 새로운 UI 정의 가능하며 재사용이 가능. 반응형 프로그래밍 모델이란 상태 변화에 자동으로 업데이트 되도록 하는 모델

- 머티리얼, 쿠퍼티노 라이브러리 : 위젯 레이어의 조합 원리를 활용하여 android와 ios에 맞는 UI를 제공

플러터 프레임워크는 기본적인 기능만 제공함

플랫폼에 특화된 기능 등 다양한 기능은 패키지로 구현됨

개발자는 선택적으로 추가 가능

### 앱 분석

일반적인 플러터 앱의 구성요소

- 다트앱 : UI 구성과 비즈니스 로직을 구현
- 프레임워크 : 동작 감지, 텍스트 입력 등 고수준 API 제공
- 엔진 : 쉽게 말해 렌더링을 담당.  핵심 API의 저수준 구현 제공. 임베더 API로 각 플랫폼과 통합
- 임베더 : 운영체제와 조율하는 부분. 이벤트 루프 관리.
- 러너 : 각 플랫폼에 맞는 앱 패키지를 생성해 플랫폼에서 실행될 수 있게 함

### 반응형 사용자 인터페이스

플러터는 반응형, 선언형 UI 프레임워크

- 반응형 : 앱 상태 변경 시 UI 자동 업데이트

- 선언형 : UI를 어떻게 그릴지 직접 명시하지 않고 상태에 따라 UI가 어떻게 변할지 설명

앱 상태를 인터페이스 상태로 매핑 = 개발자는 앱 상태에 따라 화면이 어떻게 변할지 정의함

프레임워크가 변경 사항을 자동으로 업데이트

전통적인 UI 프레임워크(명령형)는 UI 초기 상태를 한 번 설명

상태가 변할 때의 코드를 직접 써야 함

복잡해지면 하나하나 알고 있기 어려움

MVC 패턴(데이터를 컨트롤러가 모델에 푸시, 상태를 뷰가 컨트롤러에 푸시)으로 해결할 수 있지만 UI 생성과 업데이트가 분리되어 있음 = 동기화에 문제의 여지가 있음

플러터는 상태를 별도로 관리하고 상태를 기반으로 생성과 업데이트를 프레임워크가 자동으로 해줌

플러터에서 위젯들은 불변 객체로 표현됨

불변 객체는 객체 트리를 구성

위젯 들은 레이아웃을 위한 별도 객체 트리로 관리와 화면에 그려지는 객체 트리를 관리하는데 사용됨

플러터는 트리의 수정된 부분을 효율적으로 탐색, 변경 사항을 전파하는 메커니즘을 가짐

위젯은 build 메서드를 오버라이드하여 UI를 정의, 현재 상태를 바탕으로 함

즉, 상태에 따라 UI를 만드는 메서드

build 메서드는 빠르고 부작용이 없게 설계됨 - dart의 빠르게 객체를 생성하고 삭제하는 특성을 이용함

### 위젯

플러터는 위젯 단위 = UI를 구성하는 기본 단위 = 위젯을 블록처럼 쌓는다

위젯은 부모 위젯 안에 중첩 되어 있음

부모로부터 받는 컨텍스트를 통해 자신의 위치를 알 수 있음

플러터는 상태에 따라 UI를 업데이트함

위젯을 새 위젯으로 교체 - 기존 위젯과 새 위젯을 비교하여 바뀐 부분만 효율적으로 업데이트

자체 UI 컨트롤(버튼, 토글, 텍스트 입력 등)을 통해 다른 플랫폼에도 일관된 UI를 제공하고 확장 가능함

### 구성

작은 위젯들을 조합하여 복잡한 위젯을 구성

위젯이라는 같은 개념을 이용해 화면 그리기, 레이아웃 등의 다양한 기능을 처리함

핵심 개념을 최소화하여 많은 조합이 가능하도록 설계됨

### 위젯 만들기

build 함수는 새 위젯 트리를 반환

위젯 트리는 위젯이 화면에 어떻게 보여야하는지 구체적으로 나타냄

프레임워크가 위젯에게 빌드 함수를 호출하게 해서 구체적인 렌더링 가능 객체 트리를 생성함

빌드 함수는 UI 정의의 핵심 부분 - 부작용 없고 빠른 반환, 자동으로 변경 부분을 비교해 업데이트

이 함수를 통해 효율적으로 UI를 업데이트, 위젯 구성 선언에 집중할 수 있게 함

### 위젯 상태

stateless와 stateful, 상태에 관한 설명

상태와 위젯을 분리 = 상태가 있는 위젯과 없는 위젯을 비슷하게 다룰 수 있음

상태가 없으면 신경 쓸 필요가 없고 상태가 있어도 분리되면 위젯을 만들 때 신경 쓸 필요가 없음

프레임워크가 상태 객체(State)를 생성하고 변경 시 재사용(상태 관리)하여 UI를 업데이트

### 상태 관리

1. 위젯 생성 시 생성자를 통해 데이터를 전달

```dart
ContentWidget(importantState);
```

트리가 깊어질수록 전달이 복잡해짐 최상위 위젯부터 계속 생성자로 전달해줘야함

2. InheritedWidget 사용

상위에서 상태를 InheritedWidget으로 래핑

```dart
SomeState.of(context)
```

위 코드를 호출하면 빌드 컨텍스트를 사용해 SomeState 타입의 가장 가까운 조상을 찾음

updateShouldNotify() 메서드로 상태에 따라 자식 위젯이 다시 그려져야하는 지 결정

플러터는 InheritedWidget을 광범위 하게 사용하여 공유 상태 관리

예시 : 시각적 테마 공유

```dart
Container(
  color: Theme.of(context).secondaryHeaderColor,
  child: Text(
    'Text with a background color',
    style: Theme.of(context).textTheme.titleLarge,
  ),
);
```

Theme.of(context)로 테마의 색과 스타일을 가져와서 적용

3. 상태 관리 패키지 사용

provider(내부적으로 InheritedWidget 사용), riverpod, BLoc 등

flutter_hooks 같은 패키지로 상태를 UI로 변환하는 접근도 가능
