# Flutter concepts - Flutter architectural overview

https://docs.flutter.dev/resources/architectural-overview

### 알아볼 것

- 디자인을 구성하는 핵심 원칙과 개념
- 플러터 아키텍처 개요

플러터의 구조와 기능을 이해하는 데 도움이 되는 주제를 알아본다.

### Overview sections

1. 레이어 모델(layer model): 플러터를 구성하는 요소들
2. 반응형 유저 인터페이스(reactive user interfaces): 사용자 인터페이스 개발 핵심 개념
3. 위젯 소개(an introduction to widgets): 사용자 인터페이스 기본 구성 요소
4. 렌더링 과정(the rendering process): UI 코드를 어떻게 필셀로 변환하는지 설명
5. 플랫폼 임베더 개요(an overview of the platform embedders): 모바일 및 데스크탑 운영체제가 플러터 앱을 실행할 수 있게 해주는 코드에 대한 설명
6. 플러터와 다른 코드 통합하기(integrating Flutter with other code): 플러터 앱에서 사용할 수 있는 다양한 기술에 대한 정보
7. 웹 지원(support for the web): 브라우저 환경에서의 플러터 특성에 대한 언급

### Flutter

- 크로스 플랫폼 UI 툴킷이다.
    - IOS 및 Android와 같은 운영체제 전반에서 코드 재사용을 허용
    - 가능한 한 많은 코드를 운영체제 간에 공유
    - 배포 시 운영체제에 맞는 언어로 변환
- 전체 재컴파일 없이 상태를 유지하면서 빠르게 변경된 부분만 업데이트하는 핫 리로드 지원
- 오픈 소스, BSD 라이선스
    - 자유롭게 사용, 수정, 배포하며 개발자들이 함께 발전시킬 수 있는 프레임워크

### Flutter의 목표

- 다양한 플랫폼에서 자연스럽게 느껴지는 고성능 앱을 개발자가 쉽게 만들 수 있도록 돕는 것
    - IOS 사용자에게는 IOS답게, Android 사용자에게는 Android답게 보이고 작동하는 앱을 만드는 것
    - 이 과정에서 가능한 한 많은 코드를 공유해서 여러 플랫폼에서 쓰이도록 하여 생산성 향상

## Architectural layers

플러터 프레임워크는 필요한 부분만 사용하거나 다른 것으로 쉽게 교체할 수 있다.

그림처럼 확장 가능한 계층화된 구조로 설계됐다. 독립적인 라이브러리들의 집합으로 구성됐으며, 각 라이브러리는 그 아래에 있는 계층에 의존한다. 어떤 계층도 아래 계층에 대한 특권적 접근 권한을 가지지 않으며, 프레임워크의 모든 부분은 선택적으로 사용 가능하고 교체할 수 있도록 만들어졌다.

<img width="717" alt="스크린샷 2024-09-04 오후 1 00 16" src="https://github.com/user-attachments/assets/2819d60c-1ef9-4269-afc6-bc37ab78bec7">


### Embedder, 플랫폼별 임베더

임베더를 사용해서 플러터 코드를 기존 애플리케이션 모듈로 통합하거나, 애플리케이션의 전체 컨텐츠로 사용할 수 있다. 일반적인 플랫폼을 위한 여러 임베더를 포함하고 있으며, 다른 임베더도 존재한다.

1. 진입점 제공: 애플리케이션이 시작되는 위치 설정
2. 운영체제와의 조정: 렌더링 표면, 접근성, 입력 등의 서비스에 대한 접근을 위해 운영체제와 협력
3. 메시지 이벤트 루프 관리: 사용자 입력이나 시스템 메시지를 처리하는 루프 관리

임베더는 각 플랫폼에 적합한 언어로 작성된다.

- Android: Java와 C++
- IOS 및 maxOS: Objective-C/Objective-C++
- Windows와 Linux: C++

### Engine, 엔진

플러터 애플리케이션의 기본 작동을 지원하는 구성 요소다.

엔진은 대부분 C++로 작성됐고, 모든 플러터 애플리케이션을 지원하는 기본 요소를 제공한다. 엔진은 새로운 프레임을 그릴 필요가 있을 때마다 합쳐진 장면을 래스터화(이미지로 변환)하는 역할을 한다.

핵심 API에 대한 로우 레벨 구현을 제공한다. 다음과 같은 기능이 포함된다.

- 그래픽스: iOS에서는 Impeller를 사용하고, Android와 macOS에서도 지원 예정이며, 다른 플랫폼에서는 Skia를 사용
- 텍스트 레이아웃: 텍스트 배치 관리
- 파일 및 네트워크 입출력(I/O): 파일 작업과 네트워크 통신 처리
- 접근성 지원: 장애인을 위한 기능 제공
- 플러그인 아키텍처: 다양한 기능을 확장할 수 있는 구조 제공
- Dart 런타임 및 컴파일 도구: Dart 언어를 컴파일하고 실행하는 데 필요한 도구

엔진은 `dart:ui` 라이브러리를 통해 플러터 프레임워크와 연결된다. `dart:ui` 는 C++로 작성된 엔진의 코드를 Dart 언어에서 사용할 수 있도록 감싸주는 역할을 한다.

- 입력 처리: 사용자 입력(터치, 키보드 입력)을 처리하는 기능
- 그래픽스: 화면에 그리기 위한 그래픽 관련 기능
- 텍스트 렌더링: 텍스트를 화면에 표시하기 위한 기능

`dart:ui` 는 개발자가 엔진의 로우 레벨 기능을 쉽게 사용할 수 있도록 다리 역할을 하며, C++ 코드를 직접 다루지 않고도 필요한 기능을 구현할 수 있게 한다.

### Framework, 프레임워크

프레임워크를 통해 플러터와 상호작용한다. 프레임워크는 여러 레이어로 구성된 풍부한 플랫폼, 레이아웃 및 기본 라이브러리를 포함한다.

다음은 레이어 구성을 아래에서 위로 설명한 것이다.

1. Foundation
    1. 애니메이션, 페인팅, 제스처와 같은 기본적인 서비스 포함
    2. 기본 기능에 대한 일반적인 추상화를 제공하여 자주 사용하는 기능을 쉽게 접근할 수 있게 함
2. Rendering
    1. 레이아웃을 다루기 위한 추상화 제공
    2. 이 레이어를 사용하면 렌더링 가능한 객체의 트리를 만들 수 있으며, 이 객체들을 동적으로 조작 가능. 트리는 자동으로 업데이트되어 변경 사항 반영
3. Widget
    1. 조합의 추상화 제공
    2. 렌더링 레이어의 각 렌더 객체는 위젯 레이어의 해당 클래스와 연결되어 있음
    3. 위젯 레이어에서는 재사용할 수 있는 클래스 조합을 정의 가능
    4. 이 레이어에서 반응형 프로그래밍 모델 도입
4. Material 및 Cupertino 라이브러리
    1. Material 디자인 언어와 iOS 디자인 언어를 구현하는 포괄적인 컨트롤 세트를 제공
    2. 이 라이브러리들은 위젯 레이어의 기본 조합 기능을 사용하여 디자인 언어를 효과적으로 구현

플러터 프레임워크는 상대적으로 작다. 개발자들이 사용할 수 있는 하이 레벨 기능들은 프레임워크에 기본적으로 포함돼 있지 않고, 별도 패키지 형태로 구현돼 있다. 여기에는 카메라와 웹뷰와 같은 플랫폼 플러그인뿐만 아니라, 문자 처리, HTTP 통신, 애니메이션과 같이 기본 Dart 및 Flutter 라이브러리를 기반으로 한 플랫폼에 구애받지 않는 기능들이 포함된다. 이러한 패키지 중 일부는 더 넓은 생태계에서 제공되며, 인앱 결제, Apple 인증, 애니메이션 등의 서비스를 포함한다.

## 앱 구조(Anatomy of an app)

이 다이어그램은 `flutter create` 명령어로 생성된 일반 플러터 앱의 구성요소를 개략적으로 보여준다.

플러터 엔진이 이 구조에서 어떤 위치에 있는지 나타내고, API 경계를 강조하며, 각 구성 요소가 저장된 리포지토리를 표시한다.  

<img width="449" alt="스크린샷 2024-09-04 오후 1 01 44" src="https://github.com/user-attachments/assets/c93319f2-38e4-4802-a3d9-77cf2b4c31eb">


### Dart 앱

- 위젯을 원하는 UI로 구성
- 비즈니스 로직을 구현
- 앱 개발자가 소유

### 프레임워크

https://github.com/flutter/flutter/tree/main/packages/flutter/lib

- 고품질 앱을 구축하기 위한 상위 수준 API 제공 (예: 위젯, 히트 테스트, 제스처 감지, 접근성, 텍스트 입력)
- 위젯 트리를 장면으로 조합

### 엔진

https://github.com/flutter/engine/tree/main/shell/common

- 합성된 장면을 래스터화하는 책임
- Flutter의 핵심 API에 대한 저수준 구현 제공 (예: 그래픽, 텍스트 레이아웃, Dart 런타임)
- dartAPI를 사용하여 프레임워크에 기능을 노출
- 엔진의 임베더 API를 사용하여 특정 플랫폼과 통합

### 임베더

https://github.com/flutter/engine/tree/main/shell/platform

- 렌더링 표면, 접근성 및 입력과 같은 서비스에 대한 액세스를 위해 기반 운영 체제와 협력
- 이벤트 루프 관리
- 임베더를 앱에 통합하기 위한 플랫폼 특정 API를 노출

### 러너

- 임베더의 플랫폼 특정 API에서 노출된 구성 요소를 조합하여 대상 플랫폼에서 실행 가능한 앱 패키지를 만듦
- `flutter create`로 생성된 앱 템플릿의 일부이며, 앱 개발자가 소유

## 반응형 사용자 인터페이스(Reactive user interfaces)

플러터는 표면적으로는 반응형(reactive)이고 선언적(declarative)인 UI 프레임워크다.

개발자는 애플리케이션 상태를 UI 상태에 매핑해 주기만 하면, 애플리케이션 상태가 변경될 때 런타임에서 UI를 자동으로 업데이트하는 작업을 프레임워크가 담당한다.

이 모델은 페이스북의 리액트 프레임워크에서 영감을 받을 것으로, 기존의 많은 디자인 원칙들을 새롭게 재해석한 것이다.

### 전통적인 UI 프레임워크 vs 반응형 UI 프레임워크

가장 큰 차이점은 **상태 변화에 따라 UI를 업데이트하는 방식**이다.

- **전통적인 UI 프레임워크**
    - **수동 업데이트**: 전통적인 프레임워크에서는 UI의 초기 상태를 설정한 후, 애플리케이션 상태가 변할 때마다 **개발자가 직접 UI를 업데이트하는 코드**를 작성
    - 버튼을 클릭하면 특정 UI 요소를 업데이트해야 한다면, 그 부분에 대한 명시적인 업데이트 로직을 작성 필요
- **반응형 UI 프레임워크**
    - **자동 업데이트**: Flutter에서는 애플리케이션 상태와 UI 상태 간의 매핑을 정의해 두면, 상태가 변경될 때마다 **프레임워크가 알아서 UI를 업데이트**
    - 개발자가 일일이 업데이트 코드를 작성할 필요가 없음

### 플러터와 같은 반응형 프레임워크는 상태 변화와 UI 업데이트를 어떻게 관리하는가?

<img width="484" alt="스크린샷 2024-09-04 오후 1 02 30" src="https://github.com/user-attachments/assets/030ad840-f313-4f6d-9b12-be7e34dfac2d">

상태가 변경될 수 있는 곳은 여러 군데 존재한다. 색상 상자, 색조 슬라이더, 라디오 버튼 등이 있다.

사용자가 UI와 상호작용할 때, 모든 다른 위치에서도 이러한 변화가 반영되어야 한다. 세심한 주의를 기울이지 않으면 사용자 인터페이스의 한 부분에서의 작은 변경이 관련이 없어 보이는 코드의 다른 부분에도 파급 효과를 일으킬 수도 있으니 주의해야 한다.

문제를 해결하는 하나의 방법은 MVC(Model-View-Controller)와 같은 접근 방식이다. 여기서는 데이터를 컨트롤러를 통해 모델로 푸시한 다음, 모델이 새로운 상태를 컨트롤러를 통해 뷰로 푸시한다. 그러나 이 접근 방식 역시 문제가 있다. UI 요소를 생성하고 업데이트하는 것이 두 개의 별개의 단계로 이루어지기 때문에, 이들이 쉽게 동기화되지 않을 수 있다.

플러터와 같은 반응형 프레임워크는 이 문제에 대한 대안적인 접근 방식을 취한다. **사용자 인터페이스와 그 하부 상태를 명확하게 분리**하는 것이다. React 스타일의 API를 사용하면, UI의 설명만 작성하며, 프레임워크가 이 하나의 설정을 사용해 UI를 생성하거나 업데이트하는 작업을 처리한다.

플러터에서 위젯(React의 컴포넌트와 유사한 것)은 불변 클래스(immutable classes)로 표현되며,  이는 객체의 트리를 구성하는 데 사용된다. 위젯은 레이아웃을 위한 별도의 객체 트리를 관리하는 데 사용되며, 그 후에는 합성을 위한 별도의 객체 트리를 관리하는 데 사용된다. 플러터의 핵심은 이러한 트리 구조에서 수정된 부분을 효율적으로 탐색하고, 이를 더 낮은 수준의 객체 트리로 변환하며, 이러한 변화를 전체 트리에 걸쳐 전파하는 일련의 메커니즘이다.

- **요약**
    - 전통적인 MVC 접근 방식에서는 상태 변화와 UI 업데이트가 별도로 처리되어 동기화 문제 발생 가능
    - 플러터는 UI와 상태를 분리해, UI 설명만 제공하면 나머지는 프레임워크가 자동으로 관리
    - 플러터는 불변 클래스인 위젯을 사용해 UI 트리를 구성하며, 이를 통해 상태 변화에 따라 효율적으로 UI를 업데이트

### 위젯이 UI를 어떻게 만드는가?

위젯은 build() 메서드를 사용해 UI를 정의한다. 현재 상태를 바탕으로 UI를 만들어주는 역할을 한다.

```java
UI = f(state)
```

build()는 설계상 빠르게 실행되고 부작용(예를 들어, 전역 변수를 변경하는 것)이 없어야 한다. 프레임워크가 필요할 때마다 호출할 수 있도록 되어 있으며, 렌더링하는 프레임마다 호출될 수도 있다.

이러한 방식이 잘 작동하려면 언어의 특성(특히, 객체를 빠르게 생성하고 삭제하는 기능)이 중요하다. 다트는 이러한 작업에 매우 적합하다.

https://medium.com/flutter/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30

## Widgets

- **역할**
    - 위젯은 플러터 앱 UI의 기본 구성 요소다. 각 위젯은 UI의 일부를 불변으로 선언한다.
- **구조**
    - 위젯들은 **구성을 기반으로 한 계층 구조**를 형성한다. 각 위젯은 자신의 부모 위젯 안에 중첩되어(nested) 있으며, 부모로부터 **컨텍스트**(context)를 받을 수 있다. 이 구조는 최상위 위젯(root widget)까지 이어지며, 일반적으로 Flutter 앱을 호스팅하는 **MaterialApp** 또는 **CupertinoApp**이 최상위 위젯 역할을 한다.

```java
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

void main() => runApp(const MyApp());

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('My Home Page'),
        ),
        body: Center(
          child: Builder(
            builder: (context) {
              return Column(
                children: [
                  const Text('Hello World'),
                  const SizedBox(height: 20),
                  ElevatedButton(
                    onPressed: () {
                      print('Click!');
                    },
                    child: const Text('A button'),
                  ),
                ],
              );
            },
          ),
        ),
      ),
    );
  }
}
```

앞서 언급한 코드에서는 모든 인스턴스화된 클래스가 위젯이다.

앱은 사용자 상호작용과 같은 이벤트에 응답하여 사용자 인터페이스를 업데이트합니다. 이 과정에서 프레임워크에 **위젯 계층 구조에서 한 위젯을 다른 위젯으로 교체**하라고 지시한다. 그러면 프레임워크는 새 위젯과 기존 위젯을 비교하여 사용자 인터페이스를 효율적으로 업데이트한다.

### 네이티브 기능을 사용하지 않고 자체 구현을 사용함으로써 얻는 이점

Flutter는 시스템에서 제공하는 UI 제어 요소 대신 자체 구현을 사용한다. 예를 들어, iOS의 토글 컨트롤과 Android의 동일한 컨트롤 모두 순수 Dart로 구현되어 있다.

이러한 접근 방식은 여러 이점을 제공한다.

1. **무제한 확장성**: 스위치 컨트롤의 변형이 필요하다면, 개발자는 OS에서 제공하는 확장 지점에 제한받지 않고 원하는 방식으로 새 컨트롤을 생성 가능
2. **성능 병목 현상 방지**: 플러터가 전체 장면을 한 번에 합성할 수 있도록 하여, 플러터 코드와 플랫폼 코드 간의 전환이 필요 없어 성능 저하 방지
3. **운영 체제 의존성 분리**: 애플리케이션은 모든 OS 버전에서 동일하게 보이고 느껴지며, OS가 컨트롤의 구현을 변경하더라도 애플리케이션의 동작에는 영향을 주지 않음

### Composition

플러터는 적은 수의 개념으로 다양한 기능을 제공한다.

예를 들어, 위젯 계층에서는 핵심 개념인 Widget을 사용하여 화면에 그리기, 레이아웃(위치 및 크기 조정), 사용자 상호작용, 상태 관리, 테마 설정, 애니메이션, 내비게이션 등을 표현한다.

애니메이션 계층에서는 Animations와 Tweens라는 두 가지 개념으로 대부분의 애니메이션 기능을 다룬다.

렌더링 계층에서는 Render Objects를 사용해 레이아웃, 페인팅, 히트 테스트, 접근성을 설명한다.

이런 식으로 각 계층에서 사용되는 개념은 적지만, 제공되는 기능은 매우 많다. 수백 개의 위젯과 렌더 객체, 그리고 수십 가지 애니메이션과 트윈 타입이 존재한다.

클래스 계층 구조는 가능한 많은 조합을 극대화하기 위해 의도적으로 얕고 넓게 설계되어 있으며, 각각의 위젯이 하나의 일을 잘 수행하도록 초점을 맞추고 있다.

핵심 기능들은 추상적이고, 패딩이나 정렬 같은 기본적인 기능도 Flutter의 중심에 내장되지 않고 별도의 컴포넌트로 구현된다. (다른 전통적인 API에서는 패딩 같은 기능이 모든 레이아웃 컴포넌트의 기본 기능에 포함되어 있다.)

예를 들어, 어떤 위젯을 중앙에 배치하고 싶다면, Align 속성을 조정하는 대신 Center 위젯으로 그 위젯을 감싸는 방식으로 작업한다.

즉, Flutter는 작은 위젯들을 조합해서 복잡한 UI를 만드는 방식에 중점을 두고 있으며, 패딩이나 정렬 같은 기본 기능도 독립된 위젯으로 제공되어 필요에 따라 조합할 수 있도록 설계되었다는 뜻이다.

Flutter에는 패딩, 정렬, 행, 열, 그리고 그리드를 위한 위젯들이 있다. 이런 레이아웃 위젯들은 그 자체로는 화면에 보이지 않는다. 대신, 다른 위젯들이 화면에 어떻게 배치되고 정렬될지를 제어하는 역할만 한다.  또한, Flutter는 이러한 구성 방식을 활용하는 유틸리티 위젯도 제공한다.

레이아웃 위젯들은 화면에 직접 보이는 요소가 아니라, 다른 위젯들이 화면에 어떻게 배치되고 정렬될지를 결정하는 역할을 한다.

예를 들어, **Container**는 자주 사용되는 위젯으로, 레이아웃, 페인팅, 위치 지정 및 크기 조정을 담당하는 여러 위젯으로 구성되어 있다. Container는 **LimitedBox**, **ConstrainedBox**, **Align**, **Padding**, **DecoratedBox**, **Transform** 위젯으로 구성되어 있으며, 이는 Container의 소스 코드를 읽어보면 알 수 있다. Flutter의 중요한 특징 중 하나는 모든 위젯의 소스를 들여다보고 분석할 수 있다는 점이다.

Container를 서브클래싱하여 맞춤형 효과를 만드는 대신 Container와 다른 위젯들을 새로운 방식으로 조합하거나, Container에서 영감을 받아 새로운 위젯을 만들 수 있다.

### Building widgets

위젯의 시각적 표현은 `build()` 함수를 재정의하여 새로운 요소 트리를 반환함으로써 결정된다.

필요에 따라 프레임워크는 각 위젯에게 재귀적으로 빌드를 요청하여 트리가 완전히 구체적인 렌더링 가능한 객체로 설명될 때까지 진행한다. 프레임워크는 이러한 렌더링 가능한 객체들을 결합하여 렌더링 가능한 객체 트리를 만든다.

위젯의 `build` 함수는 호출될 때마다, 위젯은 이전에 반환했던 것과는 관계없이 항상 새로운 위젯 트리를 반환해야 한다. 프레임워크는 렌더 객체 트리를 바탕으로 어떤 `build` 메서드를 호출해야 하는지를 결정하는 복잡한 작업을 수행한다.

https://docs.flutter.dev/resources/inside-flutter#linear-reconciliation

**각 렌더링 프레임에서 플러터는 상태가 변경된 UI의 일부만 다시 만들 수 있도록 해당 위젯의 `build()` 메서드를 호출**한다. 그래서 `build` 메서드는 가능한 한 빠르게 실행되어야 하고, 무거운 계산 작업은 비동기적으로 수행한 후 그 결과를 상태의 일부로 저장해 `build` 메서드에서 사용할 수 있도록 하는 것이 중요하다.

비교적 단순한 접근 방식이지만, 이 자동화된 비교는 매우 효과적이며, 고성능의 인터랙티브한 앱을 가능하게 한다. 또한, `build` 함수의 설계는 위젯이 무엇으로 구성되어 있는지를 선언하는 데 중점을 두어, 사용자 인터페이스를 한 상태에서 다른 상태로 업데이트하는 복잡성을 줄여준다.

### Widget state

플러터는 위젯을 두 가지 주요 클래스, 상태가 있는 위젯(stateful widget)과 상태가 없는 위젯(stateless widget)으로 구분한다.

- **상태가 없는 위젯(stateless widget)**
    
    많은 위젯은 변경 가능한 **상태**가 없다, **시간에 따라 변화하는 속성**을 가지고 있지 않다.(아이콘, 라벨 등)
    
    이러한 위젯은 StateleeWidget 클래스를 상속 받는다.
    
- **상태가 있는 위젯(stateful widget)**
    
    특정 위젯의 고유한 특성이 사용자 상호작용이나 기타 요인에 따라 변화하는 위젯이다.
    
    예를 들어, 사용자가 버튼을 탭할 때마다 증가하는 카운터가 있는 위젯의 경우, 카운터의 값이 해당 위젯의 상태(state)다. 이 값이 변경될 때, UI의 해당 부분을 업데이트하기 위해 위젯을 다시 빌드해야 한다.
    
    이러한 위젯들은 StatefulWidget 클래스를 상속 받는다.
    
    (위젯 자체는 불변이기 때문에) mutable state(변경 가능한 상태)는 `State 클래스`를 상속받는 별도의 클래스에 저장된다. `StatefulWidget 클래스`는 build 메서드를 직접 가지지 않고, 이 메서드는 상태를 관리하는 State 객체에서 관리한다.
    
    `State` 객체의 값을 변경할 때(예를 들어, 카운터 값을 증가시킬 때) `setState()`라는 메서드를 호출해야 프레임워크가 이 변화를 감지하고, `State`의 `build` 메서드를 다시 호출하여 화면을 업데이트한다.
    
    state와 widget 객체를 분리함으로써 다른 위젯들이 상태가 없는 위젯과 상태가 있는 위젯을 동일한 방식으로 처리할 수 있다. 상태를 잃어버릴 염려 없이 자식을 생성할 수 있는 것이다. 부모 위젯은 자식의 지속적인 상태를 잃어버리지 않고도 언제든지 자식의 새 인스턴스를 만들 수 있다. 프레임워크가 기존 상태를 찾고 재사용하는 모든 작업을 자동으로 처리한다.
    

### State management

위젯이 상태를 가질 수 있다면, 그 상태는 어떻게 관리되고 시스템 전체에서 전달되는지 알아보자.

다른 클래스와 마찬가지로, 위젯에서도 생성자를 사용하여 데이터를 초기화할 수 있다. 이렇게 하면 `build()` 메서드에서 자식 위젯을 생성할 때 필요한 데이터를 전달할 수 있다. 예를 들어, 아래 코드에서 `importantState`라는 상태를 `ContentWidget`이라는 자식 위젯에 전달한다.

```java
@override
Widget build(BuildContext context) {
   return ContentWidget(importantState);
}
```

**그러나 위젯 트리가 깊어질수록 트리 구조에서 상태 정보를 위아래로 전달하는 것이 번거로워진다.**

그래서 세 번째 유형의 위젯인 `InheritedWidget`이 등장하게 되었으며, 이를 통해 공통 조상으로부터 데이터를 쉽게 가져올 수 있다. `InheritedWidget`을 사용하여 위젯 트리에서 공통 조상을 감싸는 상태 위젯을 만들 수 있다.

<img width="491" alt="스크린샷 2024-09-04 오후 1 03 29" src="https://github.com/user-attachments/assets/bb6981a3-1194-4624-a908-058d79d7eb22">


`ExamWidget`이나 `GradeWidget` 객체 중 하나가 `StudentState`로부터 데이터를 필요로 할 때, 이제 다음과 같은 명령어로 접근할 수 있다.

```dart
final studentState = StudentState.of(context);
```

`context`를 통해 `StudentState`에 접근하여, 필요한 데이터를 `studentState` 변수에 저장하는 방식이다.

`of(context)` 호출은 현재 위젯의 위치에 대한 정보를 담고 있는 빌드 컨텍스트를 가져와, `StudentState` 유형과 일치하는 가장 가까운 조상 위젯을 반환한다.

또한, `InheritedWidgets`는 `updateShouldNotify()` 메서드를 제공하는데, 이는 Flutter가 상태 변경이 자식 위젯의 재빌드를 트리거해야 하는지를 결정하기 위해 호출하는 메서드다.

InheritedWidget은 광범위하게 사용되어 애플리케이션의 공유 상태를 관리한다. 애플리케이션 전반에 걸쳐 적용되는 시각적 테마, 즉 색상과 텍스트 스타일과 같은 속성이 포함된다.

`MaterialApp`의 `build()` 메서드는 위젯 트리를 구성할 때 테마를 삽입하고, 그 이후 위젯 트리의 더 깊은 곳에서 `.of()` 메서드를 사용하여 관련된 테마 데이터를 조회할 수 있다.

```dart
Container(
  color: Theme.of(context).secondaryHeaderColor,
  child: Text(
    'Text with a background color',
    style: Theme.of(context).textTheme.titleLarge,
  ),
);
```

이 코드는 `Theme.of(context)`를 사용하여 현재 테마의 `secondaryHeaderColor`를 배경색으로 설정하고, `textTheme.titleLarge`를 사용하여 텍스트 스타일을 적용하는 예시다.

애플리케이션이 성장함에따라, 상태가 있는 위젯을 만들고 사용하는 데 필요한 번거로움을 줄이는 더 발전된 상태 관리 방법이 필요해진다. 그래서 많은 Flutter 앱에서는 `provider`와 같은 유틸리티 패키지를 사용한다. 이 패키지는 InheritedWidget을 감싸서 사용하기 쉽게 만들어준다.

또한, Flutter의 계층화된 아키텍처는 상태를 UI로 변환하는 다른 방법들을 구현할 수 있게 해주며, 그 중 하나가 `flutter_hooks` 패키지다.

대규모 애플리케이션에서는 상태 관리를 보다 효율적으로 할 수 있는 다양한 도구와 접근 방식이 중요해진다.
