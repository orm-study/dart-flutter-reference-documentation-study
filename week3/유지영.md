ğŸ”— [[í˜ì´ì§€ ë§í¬]](https://dart.dev/language/error-handling)

# Error handling ì˜¤ë¥˜ ì²˜ë¦¬

## **Exceptions**[#](https://dart.dev/language/error-handling#exceptions) ì˜ˆì™¸

**Your Dart code can throw and catch exceptions. Exceptions are errors indicating that something unexpected happened. If the exception isn't caught, the [isolate](https://dart.dev/language/concurrency#isolates) that raised the exception is suspended, and typically the isolate and its program are terminated.**

Dart ì½”ë“œì—ì„œëŠ” ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¤ê³  ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤. ì˜ˆì™¸ëŠ” ì˜ˆìƒì¹˜ ëª»í•œ ì¼ì´ ë°œìƒí–ˆìŒì„ ë‚˜íƒ€ë‚´ëŠ” ì˜¤ë¥˜ì´ë‹¤. ì˜ˆì™¸ê°€ ì²˜ë¦¬ë˜ì§€ ì•Šìœ¼ë©´ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¨ ê²©ë¦¬ëœ ì‹¤í–‰ í™˜ê²½(isolate)ì´ ì¼ì‹œ ì¤‘ë‹¨ë˜ê³ , ì¼ë°˜ì ìœ¼ë¡œ ê·¸ ê²©ë¦¬ëœ ì‹¤í–‰ í™˜ê²½ê³¼ í•´ë‹¹ í”„ë¡œê·¸ë¨ì€ ì¢…ë£Œëœë‹¤.

-   **[Q] ê²©ë¦¬ëœ ì‹¤í–‰ ë‹¨ìœ„(isolate)? â†’ ê²©ë¦¬ëœ ì‹¤í–‰ í™˜ê²½**
    
    â€œê²©ë¦¬ëœ ì‹¤í–‰ ë‹¨ìœ„â€ëŠ” Dartì˜ â€œisolateâ€ë¥¼ ë²ˆì—­í•œ ê²ƒì´ë‹¤. IsolateëŠ” ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ìŠ¤ë ˆë“œì™€ ë¹„ìŠ·í•œ ê°œë…ìœ¼ë¡œ, ì„œë¡œ ë©”ëª¨ë¦¬ë¥¼ ê³µìœ í•˜ì§€ ì•ŠëŠ” ë…ë¦½ì ì¸ ì‹¤í–‰ í™˜ê²½ì„ ì˜ë¯¸í•œë‹¤.
    
    ë”°ë¼ì„œ ë” ìì—°ìŠ¤ëŸ¬ìš´ ë²ˆì—­ì€ â€œê²©ë¦¬ëœ ì‹¤í–‰ í™˜ê²½â€ ë˜ëŠ” â€œê²©ë¦¬ëœ ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸â€ë¼ê³  í•  ìˆ˜ ìˆë‹¤.
    
-   **[note] Dartì˜ isolateë€?**
    
    Dartì˜ isolateëŠ” Dart ì–¸ì–´ì˜ ë…íŠ¹í•œ ê¸°ëŠ¥ìœ¼ë¡œ, ê²©ë¦¬ëœ ì‹¤í–‰ í™˜ê²½ì„ ì œê³µí•œë‹¤. ì´ëŠ” íŠ¹íˆ **ë³‘ë ¬ ì²˜ë¦¬ë¥¼ ìœ„í•´ ì„¤ê³„ëœ ê°œë…**ì´ë‹¤. IsolateëŠ” ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ë‹¨ìœ„ë¡œ, ë©”ëª¨ë¦¬ë¥¼ ë‹¤ë¥¸ isolateì™€ ê³µìœ í•˜ì§€ ì•ŠëŠ”ë‹¤. ì´ë¡œ ì¸í•´ ìŠ¤ë ˆë“œì™€ ìœ ì‚¬í•œ ë³‘ë ¬ ì‹¤í–‰ì„ ê°€ëŠ¥í•˜ê²Œ í•˜ì§€ë§Œ, ì „í†µì ì¸ ìŠ¤ë ˆë“œ ëª¨ë¸ê³¼ëŠ” ë‹¤ë¥¸ ì¥ì ì„ ì œê³µí•œë‹¤.
    
    **íŠ¹ì§•**
    
    -   **ë…ë¦½ì ì¸ ë©”ëª¨ë¦¬ ê³µê°„**
        
        ê° isolateëŠ” ë…ë¦½ì ì¸ ë©”ëª¨ë¦¬ ê³µê°„ì„ ê°–ê³  ìˆë‹¤. ë‹¤ë¥¸ isolateì™€ ë©”ëª¨ë¦¬ë¥¼ ê³µìœ í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ë™ê¸°í™” ë¬¸ì œë¥¼ ê±±ì •í•  í•„ìš”ê°€ ì—†ë‹¤.
        
    -   **ë©”ì‹œì§€ ê¸°ë°˜ í†µì‹ **
        
        isolate ê°„ì˜ í†µì‹ ì€ ë©”ì‹œì§€ë¥¼ í†µí•´ ì´ë£¨ì–´ì§„ë‹¤. ì´ëŠ” SendPortì™€ ReceivePortë¥¼ í†µí•´ êµ¬í˜„ëœë‹¤. í•œ isolateê°€ ë‹¤ë¥¸ isolateë¡œ ë°ì´í„°ë¥¼ ë³´ë‚´ë ¤ë©´, ë°ì´í„°ë¥¼ ë©”ì‹œì§€ë¡œ ë³€í™˜í•˜ì—¬ SendPortë¥¼ ì‚¬ìš©í•´ ë³´ë‚¸ë‹¤.
        
    -   **ë™ì‹œì„± ëª¨ë¸**
        
        Dartì˜ isolate ëª¨ë¸ì€ ì—¬ëŸ¬ isolateê°€ ë™ì‹œì— ì‹¤í–‰ë  ìˆ˜ ìˆë„ë¡ ì„¤ê³„ë˜ì—ˆë‹¤. ì´ëŠ” ë‹¤ì¤‘ ì½”ì–´ í”„ë¡œì„¸ì„œì—ì„œ íš¨ìœ¨ì ì¸ ë³‘ë ¬ ì²˜ë¦¬ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•œë‹¤.
        
    
    **ì¥ì **
    
    -   **ì•ˆì „í•œ ë³‘ë ¬ ì²˜ë¦¬**
        
        ë©”ëª¨ë¦¬ë¥¼ ê³µìœ í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ë°ì´í„° **ê²½ìŸ(data race)ì´ë‚˜ ë°ë“œë½(deadlock) ê°™ì€ ë¬¸ì œ**ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤.
        
    -   **ì˜ˆì¸¡ ê°€ëŠ¥í•œ ì„±ëŠ¥**
        
        isolateëŠ” ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰ë˜ê¸° ë•Œë¬¸ì— ê° isolateì˜ ì„±ëŠ¥ì´ ë‹¤ë¥¸ isolateì— ì˜í•´ ì˜í–¥ì„ ë°›ì§€ ì•ŠëŠ”ë‹¤.
        
    
    **ë‹¨ì **
    
    -   **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰**
        
        ê° isolateê°€ ë…ë¦½ì ì¸ ë©”ëª¨ë¦¬ ê³µê°„ì„ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì— ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ì¦ê°€í•  ìˆ˜ ìˆë‹¤.
        
    -   **ë³µì¡í•œ í†µì‹ **
        
        ë©”ì‹œì§€ ê¸°ë°˜ í†µì‹ ì€ ë°ì´í„° ì „ë‹¬ ì‹œ ì¶”ê°€ì ì¸ ì½”ë“œì™€ ì˜¤ë²„í—¤ë“œê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.
        

**In contrast to Java, all of Dart's exceptions are unchecked exceptions. Methods don't declare which exceptions they might throw, and you aren't required to catch any exceptions.**

Javaì™€ëŠ” ë‹¬ë¦¬, Dartì˜ ëª¨ë“  ì˜ˆì™¸ëŠ” ì²´í¬ë˜ì§€ ì•Šì€ ì˜ˆì™¸ì´ë‹¤. ë©”ì„œë“œê°€ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆëŠ” ì˜ˆì™¸ë¥¼ ì„ ì–¸í•˜ì§€ ì•Šìœ¼ë©°, ì˜ˆì™¸ë¥¼ ë°˜ë“œì‹œ ì²˜ë¦¬í•  í•„ìš”ë„ ì—†ë‹¤.

**Dart provides [`Exception`](https://api.dart.dev/stable/dart-core/Exception-class.html) and [`Error`](https://api.dart.dev/stable/dart-core/Error-class.html) types, as well as numerous predefined subtypes. You can, of course, define your own exceptions. However, Dart programs can throw any non-null objectâ€”not just Exception and Error objectsâ€”as an exception.**

DartëŠ” Exceptionê³¼ Error íƒ€ì…ì„ ì œê³µí•˜ë©°, ì—¬ëŸ¬ ê°€ì§€ ë¯¸ë¦¬ ì •ì˜ëœ í•˜ìœ„ íƒ€ì…ë“¤ë„ ì œê³µí•œë‹¤. ë¬¼ë¡ , ì‚¬ìš©ì ì •ì˜ ì˜ˆì™¸ë¥¼ ì •ì˜í•  ìˆ˜ë„ ìˆë‹¤. í•˜ì§€ë§Œ Dart í”„ë¡œê·¸ë¨ì€ Exception ë° Error ê°ì²´ë¿ë§Œ ì•„ë‹ˆë¼ nullì´ ì•„ë‹Œ ëª¨ë“  ê°ì²´ë¥¼ ì˜ˆì™¸ë¡œ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆë‹¤.

### **Throw[#](https://dart.dev/language/error-handling#throw) ì˜ˆì™¸ ë°œìƒ**

**Here's an example of throwing, or _raising_, an exception:**

ë‹¤ìŒì€ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¤ëŠ” ì˜ˆì œì´ë‹¤:

```dart
throw FormatException('Expected at least 1 section');

```

**You can also throw arbitrary objects:**

ì„ì˜ì˜ ê°ì²´ë„ ì˜ˆì™¸ë¡œ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆë‹¤:

```dart
throw 'Out of llamas!';

```

<aside> â„¹ï¸ **infoNote ì°¸ê³ **

**Production-quality code usually throws types that implement [`Error`](https://api.dart.dev/stable/dart-core/Error-class.html) or [`Exception`](https://api.dart.dev/stable/dart-core/Exception-class.html).**

í”„ë¡œë•ì…˜ ìˆ˜ì¤€ì˜ ì½”ë“œëŠ” ì¼ë°˜ì ìœ¼ë¡œ Error ë˜ëŠ” Exceptionì„ êµ¬í˜„í•˜ëŠ” íƒ€ì…ì„ ì˜ˆì™¸ë¡œ ë°œìƒì‹œí‚¨ë‹¤.

</aside>

**Because throwing an exception is an expression, you can throw exceptions in => statements, as well as anywhere else that allows expressions:**

ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¤ëŠ” ê²ƒì€ í•˜ë‚˜ì˜ í‘œí˜„ì‹ì´ê¸° ë•Œë¬¸ì—, => ë¬¸ì´ë‚˜ í‘œí˜„ì‹ì„ í—ˆìš©í•˜ëŠ” ëª¨ë“  ê³³ì—ì„œ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆë‹¤:

```dart
void distanceTo(Point other) => throw UnimplementedError();

```

### **Catch[#](https://dart.dev/language/error-handling#catch) ì˜ˆì™¸ ì¡ê¸°**

**Catching, or capturing, an exception stops the exception from propagating (unless you rethrow the exception). Catching an exception gives you a chance to handle it:**

ì˜ˆì™¸ë¥¼ ì¡ê±°ë‚˜ í¬ì°©í•˜ë©´ ì˜ˆì™¸ê°€ ì „íŒŒë˜ëŠ” ê²ƒì„ ë§‰ì„ ìˆ˜ ìˆë‹¤(ì˜ˆì™¸ë¥¼ ë‹¤ì‹œ ë˜ì§€ì§€ ì•ŠëŠ” í•œ). ì˜ˆì™¸ë¥¼ ì¡ìœ¼ë©´ ì´ë¥¼ ì²˜ë¦¬í•  ê¸°íšŒë¥¼ ì–»ê²Œ ëœë‹¤:

```dart
try {
  breedMoreLlamas();
} on OutOfLlamasException {
  buyMoreLlamas();
}

```

**To handle code that can throw more than one type of exception, you can specify multiple catch clauses. The first catch clause that matches the thrown object's type handles the exception. If the catch clause does not specify a type, that clause can handle any type of thrown object:**

ì—¬ëŸ¬ ìœ í˜•ì˜ ì˜ˆì™¸ë¥¼ ë˜ì§ˆ ìˆ˜ ìˆëŠ” ì½”ë“œë¥¼ ì²˜ë¦¬í•˜ë ¤ë©´ ì—¬ëŸ¬ ê°œì˜ catch ì ˆì„ ì§€ì •í•  ìˆ˜ ìˆë‹¤. ë˜ì ¸ì§„ ê°ì²´ì˜ ìœ í˜•ê³¼ ì¼ì¹˜í•˜ëŠ” ì²« ë²ˆì§¸ catch ì ˆì´ ì˜ˆì™¸ë¥¼ ì²˜ë¦¬í•œë‹¤. catch ì ˆì— ìœ í˜•ì„ ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´, ê·¸ ì ˆì€ ë˜ì ¸ì§„ ëª¨ë“  ìœ í˜•ì˜ ê°ì²´ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤:

```dart
try {
  breedMoreLlamas();
} on OutOfLlamasException {
  // A specific exception íŠ¹ì • ì˜ˆì™¸
  buyMoreLlamas();
} on Exception catch (e) {
  // Anything else that is an exception ê·¸ ì™¸ì˜ ì˜ˆì™¸
  print('Unknown exception: $e');
} catch (e) {
  // No specified type, handles all ìœ í˜•ì„ ì§€ì •í•˜ì§€ ì•Šì€ ê²½ìš°, ëª¨ë“  ì˜ˆì™¸ ì²˜ë¦¬
  print('Something really unknown: $e');
}

```

**As the preceding code shows, you can use either `on` or `catch` or both. Use `on` when you need to specify the exception type. Use `catch` when your exception handler needs the exception object.**

ì•ì˜ ì½”ë“œì—ì„œ ë³¼ ìˆ˜ ìˆë“¯ì´, onì´ë‚˜ catch ë˜ëŠ” ë‘˜ ë‹¤ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ì˜ˆì™¸ ìœ í˜•ì„ ì§€ì •í•´ì•¼ í•  ë•ŒëŠ” onì„ ì‚¬ìš©í•˜ê³ , ì˜ˆì™¸ ê°ì²´ê°€ í•„ìš”í•œ ê²½ìš°ì—ëŠ” catchë¥¼ ì‚¬ìš©í•œë‹¤.

**You can specify one or two parameters to `catch()`. The first is the exception that was thrown, and the second is the stack trace (a [`StackTrace`](https://api.dart.dev/stable/dart-core/StackTrace-class.html) object).**

catch()ì— í•˜ë‚˜ ë˜ëŠ” ë‘ ê°œì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ì§€ì •í•  ìˆ˜ ìˆë‹¤. ì²« ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ëŠ” ë˜ì ¸ì§„ ì˜ˆì™¸ì´ê³ , ë‘ ë²ˆì§¸ëŠ” ìŠ¤íƒ ì¶”ì (StackTrace) ê°ì²´ì´ë‹¤.

```dart
try {
  // Â·Â·Â·
} on Exception catch (e) {
  print('Exception details:\\n $e');
} catch (e, s) {
  print('Exception details:\\n $e');
  print('Stack trace:\\n $s');
}

```

-   **[Q] ìŠ¤íƒì¶”ì (StackTrace)ë€?**
    
    ìŠ¤íƒ ì¶”ì (Stack trace)ì€ **í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆ í˜¸ì¶œëœ í•¨ìˆ˜ì˜ í˜¸ì¶œ ìŠ¤íƒì„ ì¶”ì í•œ ì •ë³´**ì´ë‹¤. í”„ë¡œê·¸ë¨ì´ ì˜ˆì™¸ë¥¼ ë˜ì§€ê¸° ì „ì— ì–´ë–¤ í•¨ìˆ˜ë“¤ì´ í˜¸ì¶œë˜ì—ˆëŠ”ì§€ë¥¼ ë³´ì—¬ì£¼ëŠ” ê¸°ë¡ìœ¼ë¡œ, ì˜ˆì™¸ê°€ ë°œìƒí•œ ì •í™•í•œ ìœ„ì¹˜ì™€ ê·¸ ì˜ˆì™¸ë¡œ ì´ì–´ì§„ ì½”ë“œ ê²½ë¡œë¥¼ íŒŒì•…í•˜ëŠ” ë° ìœ ìš©í•˜ë‹¤.
    
    ìŠ¤íƒ ì¶”ì ì„ í†µí•´ ì˜ˆì™¸ê°€ ë°œìƒí•œ ê²½ë¡œë¥¼ ë”°ë¼ê°€ë©° ë¬¸ì œë¥¼ ì§„ë‹¨í•˜ê³  ë””ë²„ê¹…í•  ìˆ˜ ìˆë‹¤. ì´ë¥¼ í†µí•´ ì½”ë“œì˜ ì–´ëŠ ë¶€ë¶„ì—ì„œ ë¬¸ì œê°€ ë°œìƒí–ˆëŠ”ì§€, ì–´ë–¤ í•¨ìˆ˜ í˜¸ì¶œì´ ë¬¸ì œë¥¼ ì¼ìœ¼ì¼°ëŠ”ì§€ ì•Œ ìˆ˜ ìˆë‹¤.
    

**To partially handle an exception, while allowing it to propagate, use the `rethrow` keyword.**

ì˜ˆì™¸ë¥¼ ë¶€ë¶„ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ë©´ì„œ ì „íŒŒë˜ë„ë¡ í•˜ë ¤ë©´ rethrow í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ë¼.

```dart
void misbehave() {
  try {
    dynamic foo = true;
    print(foo++); // Runtime error ëŸ°íƒ€ì„ ì˜¤ë¥˜
  } catch (e) {
    print('misbehave() partially handled ${e.runtimeType}.');
    rethrow; // Allow callers to see the exception. í˜¸ì¶œìê°€ ì˜ˆì™¸ë¥¼ ë³¼ ìˆ˜ ìˆë„ë¡ í—ˆìš©.
  }
}

void main() {
  try {
    misbehave();
  } catch (e) {
    print('main() finished handling ${e.runtimeType}.');
  }
}

```

-   **[Q]ì˜ˆì™¸ì „íŒŒ(Exception propagation)ë€?**
    
    ì˜ˆì™¸ê°€ ë°œìƒí•œ í›„, ì´ë¥¼ ì²˜ë¦¬í•˜ëŠ” ì½”ë“œ ë¸”ë¡ì´ ë‚˜íƒ€ë‚  ë•Œê¹Œì§€ í˜¸ì¶œ ìŠ¤íƒì„ ë”°ë¼ **ì˜ˆì™¸ê°€ ì „ë‹¬ë˜ëŠ” ê³¼ì •**ì„ ì˜ë¯¸í•œë‹¤.
    
    **ì „íŒŒ ê³¼ì •**
    
    1.  **ì˜ˆì™¸ ë°œìƒ**:
        -   ì½”ë“œì—ì„œ ì˜ˆì™¸ê°€ ë°œìƒí•œë‹¤(ì˜ˆ: throw Exception('Error occurred')).
    2.  **ì˜ˆì™¸ ì²˜ë¦¬ ì½”ë“œ íƒìƒ‰**:
        -   ë°œìƒí•œ ì˜ˆì™¸ëŠ” í˜„ì¬ ë©”ì„œë“œì˜ try-catch ë¸”ë¡ì—ì„œ ì²˜ë¦¬ë  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•œë‹¤.
        -   ë§Œì•½ í˜„ì¬ ë©”ì„œë“œì— ì˜ˆì™¸ë¥¼ ì²˜ë¦¬í•  catch ë¸”ë¡ì´ ì—†ë‹¤ë©´, ì˜ˆì™¸ëŠ” í˜¸ì¶œ ìŠ¤íƒì„ ë”°ë¼ ìƒìœ„ ë©”ì„œë“œë¡œ ì „ë‹¬(ì „íŒŒ)ëœë‹¤.
    3.  **ìƒìœ„ ë©”ì„œë“œì—ì„œ ì˜ˆì™¸ ì²˜ë¦¬**:
        -   ì˜ˆì™¸ê°€ ìƒìœ„ ë©”ì„œë“œë¡œ ì „ë‹¬ë˜ë©´, í•´ë‹¹ ë©”ì„œë“œì—ì„œë„ ì˜ˆì™¸ë¥¼ ì²˜ë¦¬í•  try-catch ë¸”ë¡ì„ ì°¾ëŠ”ë‹¤.
        -   ìƒìœ„ ë©”ì„œë“œì—ì„œë„ catch ë¸”ë¡ì´ ì—†ë‹¤ë©´, ì˜ˆì™¸ëŠ” ê³„ì†í•´ì„œ í˜¸ì¶œ ìŠ¤íƒì„ ë”°ë¼ ë” ìƒìœ„ ë©”ì„œë“œë¡œ ì „íŒŒëœë‹¤.
    4.  **ìµœì¢… ì²˜ë¦¬**:
        -   ì˜ˆì™¸ê°€ ì²˜ë¦¬ë˜ì§€ ì•Šê³  ìµœìƒìœ„ ë©”ì„œë“œ(ì˜ˆ: main í•¨ìˆ˜)ê¹Œì§€ ì „íŒŒë˜ë©´, í”„ë¡œê·¸ë¨ì€ ë¹„ì •ìƒ ì¢…ë£Œë  ìˆ˜ ìˆë‹¤.
    
    **ì˜ˆì™¸ ì „íŒŒë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ **
    
    â€¢ **ì½”ë“œ êµ¬ì¡°í™”**: ì˜ˆì™¸ê°€ ë°œìƒí•œ ì¦‰ì‹œ ëª¨ë“  ì˜ˆì™¸ë¥¼ ì²˜ë¦¬í•˜ì§€ ì•Šê³ , ìƒìœ„ ë©”ì„œë“œì—ì„œ ì˜ˆì™¸ë¥¼ ì²˜ë¦¬í•˜ë„ë¡ êµ¬ì¡°í™”í•  ìˆ˜ ìˆë‹¤.
    
    â€¢ **ì±…ì„ ë¶„ë¦¬**: ê° ë©”ì„œë“œëŠ” ìì‹ ì˜ ë¡œì§ì— ì§‘ì¤‘í•˜ê³ , ì˜ˆì™¸ ì²˜ë¦¬ëŠ” í˜¸ì¶œìì—ê²Œ ë§¡ê¸¸ ìˆ˜ ìˆë‹¤.
    
    â€¢ **ìœ ì—°ì„±**: ì˜ˆì™¸ë¥¼ ë‹¤ì–‘í•œ ìˆ˜ì¤€ì—ì„œ ì²˜ë¦¬í•  ìˆ˜ ìˆì–´, ì˜ˆì™¸ ë°œìƒ ìœ„ì¹˜ì™€ ìƒê´€ì—†ì´ ì¼ê´€ëœ ì˜ˆì™¸ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•˜ë‹¤.
    
-   **[Q] rethrowëŠ” ì–´ë–¤ ìƒí™©ì— ì‚¬ìš©í•˜ë©° ì™œ ì‚¬ìš©í• ê¹Œ?**
    
    rethrowëŠ” **ì˜ˆì™¸ë¥¼ ë¶€ë¶„ì ìœ¼ë¡œ ì²˜ë¦¬í•œ í›„ ì˜ˆì™¸ë¥¼ ë‹¤ì‹œ ë˜ì ¸ì„œ ì˜ˆì™¸ê°€ ê³„ì† ì „íŒŒë˜ë„ë¡ í•  ë•Œ** ì‚¬ìš©í•˜ëŠ” í‚¤ì›Œë“œì´ë‹¤. rethrowë¥¼ ì‚¬ìš©í•˜ë©´ catch ë¸”ë¡ ë‚´ì—ì„œ ì˜ˆì™¸ë¥¼ ë¶€ë¶„ì ìœ¼ë¡œ ì²˜ë¦¬í•œ í›„, ìƒìœ„ í˜¸ì¶œ ìŠ¤íƒì—ì„œ ì¶”ê°€ì ì¸ ì²˜ë¦¬ë¥¼ í•  ìˆ˜ ìˆë„ë¡ ì˜ˆì™¸ë¥¼ ë‹¤ì‹œ ë˜ì§ˆ ìˆ˜ ìˆë‹¤.
    
    rethrowë¥¼ ì‚¬ìš©í•˜ë©´ **ì˜ˆì™¸ ì²˜ë¦¬ ë¡œì§ì„ ì—¬ëŸ¬ ë‹¨ê³„ë¡œ ë‚˜ëˆ ì„œ ì²˜ë¦¬**í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ë¡œê¹…, ë¦¬ì†ŒìŠ¤ í•´ì œ, ì‚¬ìš©ìì—ê²Œ ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ë³´ì—¬ì£¼ëŠ” ë“±ì˜ ì²˜ë¦¬ë¥¼ ê°ê¸° ë‹¤ë¥¸ ë ˆë²¨ì—ì„œ í•  ìˆ˜ ìˆë‹¤.
    

### **Finally[#](https://dart.dev/language/error-handling#finally)**

**To ensure that some code runs whether or not an exception is thrown, use a `finally` clause. If no `catch` clause matches the exception, the exception is propagated after the `finally` clause runs:**

ì˜ˆì™¸ê°€ ë°œìƒí•˜ë“  ë°œìƒí•˜ì§€ ì•Šë“  í•­ìƒ ì–´ë–¤ ì½”ë“œë¥¼ ì‹¤í–‰í•´ì•¼ í•  ë•ŒëŠ” finally ì ˆì„ ì‚¬ìš©í•œë‹¤. catch ì ˆì—ì„œ ì˜ˆì™¸ë¥¼ ì²˜ë¦¬í•˜ì§€ ëª»í•œ ê²½ìš°ì—ë„ finally ì ˆì´ ì‹¤í–‰ëœ í›„ ì˜ˆì™¸ê°€ ì „íŒŒëœë‹¤:

```dart
try {
  breedMoreLlamas();
} finally {
  // ì˜ˆì™¸ê°€ ë°œìƒí•˜ë”ë¼ë„ í•­ìƒ ì •ë¦¬ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
  cleanLlamaStalls();
}

```

**The `finally` clause runs after any matching `catch` clauses:**

finally ì ˆì€ ë§¤ì¹­ë˜ëŠ” catch ì ˆì´ ì‹¤í–‰ëœ í›„ì— ì‹¤í–‰ëœë‹¤:

```dart
try {
  breedMoreLlamas();
} catch (e) {
  print('Error: $e'); // ë¨¼ì € ì˜ˆì™¸ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.
} finally {
  cleanLlamaStalls(); // ê·¸ í›„ì— ì •ë¦¬ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
}

```

**To learn more, check out the [core library exception docs](https://dart.dev/libraries/dart-core#exceptions).**

ìì„¸í•œ ë‚´ìš©ì€ ì½”ì–´ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ì˜ˆì™¸ ë¬¸ì„œë¥¼ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤.

### **Assert[#](https://dart.dev/language/error-handling#assert)**

**During development, use an assert statementâ€” `assert(<condition>, <optionalMessage>);` â€”to disrupt normal execution if a boolean condition is false.**

ê°œë°œ ì¤‘ì— assert ë¬¸ì„ ì‚¬ìš©í•˜ì—¬ bool ì¡°ê±´ì´ ê±°ì§“ì¸ ê²½ìš° ì •ìƒ ì‹¤í–‰ì„ ì¤‘ë‹¨í•  ìˆ˜ ìˆë‹¤.

```dart
// ë³€ìˆ˜ê°€ nullì´ ì•„ë‹Œ ê°’ì„ ê°€ì§€ë„ë¡ í•©ë‹ˆë‹¤.
assert(text != null);

// ê°’ì´ 100ë³´ë‹¤ ì‘ì€ì§€ í™•ì¸í•©ë‹ˆë‹¤.
assert(number < 100);

// ì´ê²ƒì´ https URLì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
assert(urlString.startsWith('https'));

```

**To attach a message to an assertion, add a string as the second argument to `assert` (optionally with a [trailing comma](https://dart.dev/language/collections#trailing-comma)):**

ì–´ì„¤ì…˜ì— ë©”ì‹œì§€ë¥¼ ì²¨ë¶€í•˜ë ¤ë©´, assertì˜ ë‘ ë²ˆì§¸ ì¸ìˆ˜ë¡œ ë¬¸ìì—´ì„ ì¶”ê°€í•œë‹¤(ì„ íƒì ìœ¼ë¡œ ëì— ì‰¼í‘œë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤):

```dart
assert(urlString.startsWith('https'),
    'URL ($urlString) should start with "https".');

```

-   **[Q] assertì™€ assertionì€ ë‹¤ë¥¸ê±´ê°€?**
    
    ----------
    
    â€œassertâ€ì™€ â€œassertionâ€ì€ ê´€ë ¨ì´ ìˆì§€ë§Œ ì„œë¡œ ë‹¤ë¥¸ ê°œë…ì´ë‹¤.
    
    -   assertëŠ” í‚¤ì›Œë“œë¡œì„œ ì¡°ê±´ì„ ê²€ì¦í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë˜ë©°, Assertionì€ assert í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•œ ê²€ì¦ ë¬¸ì¥ ìì²´ë¥¼ ì˜ë¯¸í•œë‹¤.
    -   assertëŠ” íŠ¹ì • ì¡°ê±´ì„ í™•ì¸í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” í‚¤ì›Œë“œì´ê³ , assertionì€ ì´ëŸ¬í•œ ê²€ì¦ì„ í‘œí˜„í•˜ëŠ” êµ¬ë¬¸ì´ë‹¤.
    
    **assert**
    
    assertëŠ” **íŠ¹ì • ì¡°ê±´ì´ ì°¸ì¸ì§€ í™•ì¸í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì˜ í‚¤ì›Œë“œ**ì´ë‹¤. ì¡°ê±´ì´ ê±°ì§“ì¼ ê²½ìš° í”„ë¡œê·¸ë¨ ì‹¤í–‰ì„ ì¤‘ë‹¨í•˜ê³  ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•œë‹¤.
    
    **ìš©ë„**
    
    -   ë””ë²„ê¹… ëª©ì ìœ¼ë¡œ ì‚¬ìš©ë˜ë©°, í”„ë¡œê·¸ë¨ì˜ ìƒíƒœë¥¼ ê²€ì¦í•˜ëŠ”ë° ì‚¬ìš©ëœë‹¤.
    
    ```dart
    assert(x > 0, 'x must be greater than 0');
    
    ```
    
    **assertion**
    
    Assertionì€ assertë¥¼ ì‚¬ìš©í•˜ì—¬ **ì¡°ê±´ì„ í™•ì¸í•˜ëŠ” êµ¬ë¬¸**ì„ ì˜ë¯¸í•œë‹¤. ì¦‰, assert í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•œ ê²€ì¦ ë¬¸ì¥ì„ â€œassertionâ€ì´ë¼ê³  í•˜ëŠ” ê²ƒì´ë‹¤.
    
    **ìš©ë„**
    
    -   ì½”ë“œì˜ íŠ¹ì • ìƒíƒœë‚˜ ì¡°ê±´ì´ ë§Œì¡±ë¨ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•œë‹¤.
    
    ```dart
    // This is an assertion
    assert(y != null, 'y should not be null');
    
    ```
   
    

**The first argument to `assert` can be any expression that resolves to a boolean value. If the expression's value is true, the assertion succeeds and execution continues. If it's false, the assertion fails and an exception (an [`AssertionError`](https://api.dart.dev/stable/dart-core/AssertionError-class.html)) is thrown.**

assertì˜ ì²« ë²ˆì§¸ ì¸ìˆ˜ëŠ” ë¶€ìš¸ ê°’ìœ¼ë¡œ í‰ê°€ë˜ëŠ” ëª¨ë“  í‘œí˜„ì‹ì¼ ìˆ˜ ìˆë‹¤. í‘œí˜„ì‹ì˜ ê°’ì´ ì°¸ì´ë©´ ì–´ì„¤ì…˜ì´ ì„±ê³µí•˜ê³  ì‹¤í–‰ì´ ê³„ì†ëœë‹¤. ê±°ì§“ì´ë©´ ì–´ì„¤ì…˜ì´ ì‹¤íŒ¨í•˜ê³  ì˜ˆì™¸(AssertionError)ê°€ ë°œìƒí•œë‹¤.

-   **[code] ë¶€ìš¸ ê°’ìœ¼ë¡œ í‰ê°€ë˜ëŠ” ëª¨ë“  í‘œí˜„ì‹ ì˜ˆì œ**
    
    ì—¬ê¸°ì„œ ë§í•˜ëŠ” â€œí‘œí˜„ì‹â€ì€ í”„ë¡œê·¸ë¨ì˜ ì‹¤í–‰ ì¤‘ í‰ê°€ë˜ì–´ í•˜ë‚˜ì˜ ê°’, íŠ¹íˆ ì°¸(true) ë˜ëŠ” ê±°ì§“(false)ì„ ë°˜í™˜í•˜ëŠ” ì½”ë“œ ë¶€ë¶„ì„ ì˜ë¯¸í•œë‹¤.
    
    **í‘œí˜„ì‹(expression)**
    
    ê°’ì„ ë°˜í™˜í•˜ëŠ” ì½”ë“œ ì¡°ê°. ë³€ìˆ˜, ìƒìˆ˜, ì—°ì‚°ì, í•¨ìˆ˜ í˜¸ì¶œ ë“±ì„ í¬í•¨í•  ìˆ˜ ìˆë‹¤.
    
    **ë¶€ìš¸ í‘œí˜„ì‹**
    
    ì°¸(true) ë˜ëŠ” ê±°ì§“(false)ìœ¼ë¡œ í‰ê°€ë  ìˆ˜ ìˆëŠ” í‘œí˜„ì‹
    
    **ë³€ìˆ˜ ë¹„êµ í‘œí˜„ì‹**
    
    ```dart
    	int x = 5;
    assert(x > 0); // x > 0ëŠ” ì°¸ì´ë¯€ë¡œ ì–´ì„¤ì…˜ ì„±ê³µ
    
    ```
    
    **ë…¼ë¦¬ ì—°ì‚° í‘œí˜„ì‹**
    
    ```dart
    bool isValid = true;
    assert(isValid && (x < 10)); // isValid && (x < 10)ëŠ” ì°¸ì´ë¯€ë¡œ ì–´ì„¤ì…˜ ì„±ê³µ
    
    ```
    
    **í•¨ìˆ˜ í˜¸ì¶œ í‘œí˜„ì‹**
    
    ```dart
    bool isPositive(int number) => number > 0;
    assert(isPositive(x)); // isPositive(x)ëŠ” ì°¸ì´ë¯€ë¡œ ì–´ì„¤ì…˜ ì„±ê³µ
    
    ```
    

**When exactly do assertions work? That depends on the tools and framework you're using:**

ì–´ì„¤ì…˜ì´ ì–¸ì œ ì‘ë™í•˜ëŠ”ì§€ëŠ” ì‚¬ìš© ì¤‘ì¸ ë„êµ¬ì™€ í”„ë ˆì„ì›Œí¬ì— ë”°ë¼ ë‹¤ë¥´ë‹¤:

-   **Flutter enables assertions in [debug mode.](https://docs.flutter.dev/testing/debugging#debug-mode-assertions)**
    
    FlutterëŠ” ë””ë²„ê·¸ ëª¨ë“œì—ì„œ ì–´ì„¤ì…˜ì„ í™œì„±í™”í•œë‹¤.
    
-   **Development-only tools such as [`webdev serve`](https://dart.dev/tools/webdev#serve) typically enable assertions by default.**
    
    webdev serveì™€ ê°™ì€ ê°œë°œ ì „ìš© ë„êµ¬ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ê¸°ë³¸ì ìœ¼ë¡œ ì–´ì„¤ì…˜ì„ í™œì„±í™”í•œë‹¤.
    
-   **Some tools, such as [`dart run`](https://dart.dev/tools/dart-run) and [`dart compile js`](https://dart.dev/tools/dart-compile#js) support assertions through a command-line flag: `-enable-asserts`.**
    
    dart run ë° dart compile jsì™€ ê°™ì€ ì¼ë¶€ ë„êµ¬ëŠ” ëª…ë ¹ì¤„ í”Œë˜ê·¸ --enable-assertsë¥¼ í†µí•´ ì–´ì„¤ì…˜ì„ ì§€ì›í•œë‹¤.
    

**In production code, assertions are ignored, and the arguments to `assert` aren't evaluated.**

í”„ë¡œë•ì…˜ ì½”ë“œì—ì„œëŠ” ì–´ì„¤ì…˜ì´ ë¬´ì‹œë˜ë©°, assertì˜ ì¸ìˆ˜ëŠ” í‰ê°€ë˜ì§€ ì•ŠëŠ”ë‹¤.

---

ğŸ”— [[í˜ì´ì§€ ë§í¬]](https://dart.dev/language/classes)

# Classes í´ë˜ìŠ¤

**Dart is an object-oriented language with classes and mixin-based inheritance. Every object is an instance of a class, and all classes except `Null` descend from [`Object`](https://api.dart.dev/stable/dart-core/Object-class.html). _Mixin-based inheritance_ means that although every class (except for the [top class](https://dart.dev/null-safety/understanding-null-safety#top-and-bottom), `Object?`) has exactly one superclass, a class body can be reused in multiple class hierarchies. [Extension methods](https://dart.dev/language/extension-methods) are a way to add functionality to a class without changing the class or creating a subclass. [Class modifiers](https://dart.dev/language/class-modifiers) allow you to control how libraries can subtype a class.**

DartëŠ” í´ë˜ìŠ¤ì™€ ë¯¹ìŠ¤ì¸ ê¸°ë°˜ ìƒì†ì„ ì‚¬ìš©í•˜ëŠ” ê°ì²´ ì§€í–¥ ì–¸ì–´ë‹¤. ëª¨ë“  ê°ì²´ëŠ” í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ì´ë©°, Nullì„ ì œì™¸í•œ ëª¨ë“  í´ë˜ìŠ¤ëŠ” Objectë¥¼ ìƒì†í•œë‹¤. ë¯¹ìŠ¤ì¸ ê¸°ë°˜ ìƒì†ì´ë€ ìµœìƒìœ„ í´ë˜ìŠ¤(Object)ë¥¼ ì œì™¸í•œ ëª¨ë“  í´ë˜ìŠ¤ê°€ ì •í™•íˆ í•˜ë‚˜ì˜ ìŠˆí¼í´ë˜ìŠ¤ë¥¼ ê°€ì§€ì§€ë§Œ, í´ë˜ìŠ¤ ë³¸ë¬¸ì€ ì—¬ëŸ¬ í´ë˜ìŠ¤ ê³„ì¸µ êµ¬ì¡°ì—ì„œ ì¬ì‚¬ìš©ë  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. í™•ì¥ ë©”ì„œë“œëŠ” í´ë˜ìŠ¤ë¥¼ ë³€ê²½í•˜ê±°ë‚˜ ì„œë¸Œí´ë˜ìŠ¤ë¥¼ ìƒì„±í•˜ì§€ ì•Šê³  í´ë˜ìŠ¤ì— ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ëŠ” ë°©ë²•ì´ë‹¤. í´ë˜ìŠ¤ ìˆ˜ì •ìëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ í´ë˜ìŠ¤ë¥¼ í•˜ìœ„ ìœ í˜•ìœ¼ë¡œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ë°©ë²•ì„ ì œì–´í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤.

----------

## **Using class members[#](https://dart.dev/language/classes#using-class-members)

í´ë˜ìŠ¤ ë©¤ë²„ ì‚¬ìš©**

**Objects have _members_ consisting of functions and data (_methods_ and _instance variables_, respectively). When you call a method, you _invoke_ it on an object: the method has access to that object's functions and data.**

ê°ì²´ëŠ” í•¨ìˆ˜ì™€ ë°ì´í„°ë¡œ êµ¬ì„±ëœ ë©¤ë²„ë¥¼ ê°€ì§„ë‹¤ (ê°ê° ë©”ì„œë“œì™€ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜). ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë©´, ê°ì²´ì—ì„œ ê·¸ ë©”ì„œë“œë¥¼ ì‹¤í–‰í•˜ê²Œ ëœë‹¤: ë©”ì„œë“œëŠ” ê·¸ ê°ì²´ì˜ í•¨ìˆ˜ì™€ ë°ì´í„°ì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.

-   **[Q] ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜(Instance Variable)ë€ í•„ë“œ(fields), ì†ì„±(properties)ë‘ ê°™ì€ ë§ì¸ê°€?**
    
    ê°™ì€ ë§ì´ë‹¤. í´ë˜ìŠ¤ ë‚´ì—ì„œ ì •ì˜ëœ ë³€ìˆ˜ë¡œ, ê° ê°ì²´ê°€ ë…ë¦½ì ìœ¼ë¡œ ê°€ì§€ëŠ” ë°ì´í„°ë¥¼ ì €ì¥í•œë‹¤.
    

**Use a dot (`.`) to refer to an instance variable or method:**

ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë‚˜ ë©”ì„œë“œë¥¼ ì°¸ì¡°í•˜ë ¤ë©´ ì (.)ì„ ì‚¬ìš©í•œë‹¤:

```dart
var p = Point(2, 2);

// Get the value of y.
// yì˜ ê°’ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
assert(p.y == 2);

// Invoke distanceTo() on p.
// pì—ì„œ distanceTo()ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
double distance = p.distanceTo(Point(4, 4));

```

**Use `?.` instead of `.` to avoid an exception when the leftmost operand is null:**

ì™¼ìª½ í”¼ì—°ì‚°ìê°€ nullì¼ ë•Œ ì˜ˆì™¸ë¥¼ í”¼í•˜ë ¤ë©´ ì (.) ëŒ€ì‹  ?.ì„ ì‚¬ìš©í•œë‹¤:

```dart
// If p is non-null, set a variable equal to its y value.
// pê°€ nullì´ ì•„ë‹Œ ê²½ìš°, ë³€ìˆ˜ì— pì˜ y ê°’ì„ í• ë‹¹í•©ë‹ˆë‹¤.
var a = p?.y;

```


## **Using constructors[#](https://dart.dev/language/classes#using-constructors) ìƒì„±ì ì‚¬ìš©**

**You can create an object using a _constructor_. Constructor names can be either `*ClassName*` or `*ClassName*.*identifier*`. For example, the following code creates `Point` objects using the `Point()` and `Point.fromJson()` constructors:**

ìƒì„±ìë¥¼ ì‚¬ìš©í•˜ì—¬ ê°ì²´ë¥¼ ìƒì„±í•  ìˆ˜ ìˆë‹¤. ìƒì„±ì ì´ë¦„ì€ ClassName ë˜ëŠ” ClassName.identifierê°€ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ë‹¤ìŒ ì½”ë“œëŠ” Point()ì™€ Point.fromJson() ìƒì„±ìë¥¼ ì‚¬ìš©í•˜ì—¬ Point ê°ì²´ë¥¼ ìƒì„±í•œë‹¤:

```dart
var p1 = Point(2, 2);
var p2 = Point.fromJson({'x': 1, 'y': 2});

```

**The following code has the same effect, but uses the optional `new` keyword before the constructor name:**

ë‹¤ìŒ ì½”ë“œëŠ” ë™ì¼í•œ íš¨ê³¼ë¥¼ ê°€ì§€ì§€ë§Œ, ìƒì„±ì ì´ë¦„ ì•ì— ì„ íƒì ì¸ new í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•œë‹¤:

```dart
var p1 = new Point(2, 2);
var p2 = new Point.fromJson({'x': 1, 'y': 2});

```

**Some classes provide [constant constructors](https://dart.dev/language/constructors#constant-constructors). To create a compile-time constant using a constant constructor, put the `const` keyword before the constructor name:**

ì¼ë¶€ í´ë˜ìŠ¤ëŠ” ìƒìˆ˜ ìƒì„±ìë¥¼ ì œê³µí•©ë‹ˆë‹¤. ìƒìˆ˜ ìƒì„±ìë¥¼ ì‚¬ìš©í•˜ì—¬ ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜ë¥¼ ìƒì„±í•˜ë ¤ë©´ ìƒì„±ì ì´ë¦„ ì•ì— const í‚¤ì›Œë“œë¥¼ ì¶”ê°€í•œë‹¤:

```dart
var p = const ImmutablePoint(2, 2);

```

**Constructing two identical compile-time constants results in a single, canonical instance:**

ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜ë¥¼ ë‘ ê°œ ë™ì¼í•˜ê²Œ êµ¬ì„±í•˜ë©´ í•˜ë‚˜ì˜ ì •ê·œ ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ëœë‹¤.

```dart
var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a, b)); // They are the same instance! ë™ì¼í•œ ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤!

```

-   **[Q] ì™œ aì™€ bê°€ ê°™ì€ ì¸ìŠ¤í„´ìŠ¤ê°€ ë ê¹Œ?**
    
    ```dart
    var a = const ImmutablePoint(1, 1);
    var b = const ImmutablePoint(1, 1);
    
    ```
    
    ë™ì¼í•œ ì¸ìŠ¤í„´ìŠ¤ì´ë‹¤. ë™ì¼í•œ ì¸ìŠ¤í„´ìŠ¤ë¡œ ì·¨ê¸‰í•˜ëŠ” ì´ìœ ëŠ” Dartì˜ ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜ ìµœì í™” ë•Œë¬¸ì´ë‹¤. `const` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒì„±ëœ ê°ì²´ëŠ” ë¶ˆë³€(immutable)ì´ë©°, ë™ì¼í•œ ê°’ìœ¼ë¡œ ìƒì„±ëœ ìƒìˆ˜ ê°ì²´ëŠ” í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤ë¡œë§Œ ì €ì¥ëœë‹¤.
    
    `const` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë¶ˆë³€ê°ì²´ë¥¼ ìƒì„±í•˜ë©´, ì»´íŒŒì¼ëŸ¬ëŠ” ë™ì¼í•œ ê°’ì„ ê°€ì§€ëŠ” ê°ì²´ê°€ ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•œë‹¤. ë§Œì•½ ì¡´ì¬í•œë‹¤ë©´ ìƒˆë¡œìš´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ëŠ” ëŒ€ì‹  ê¸°ì¡´ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì¬ì‚¬ìš©í•œë‹¤. ì´ë ‡ê²Œ aì™€ bëŠ” ë™ì¼í•œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê°€ë¥´í‚¤ê²Œ ë˜ëŠ” ê²ƒì´ë‹¤(ë©”ëª¨ë¦¬ ë‚´ì—ì„œ ë™ì¼í•œ ì£¼ì†Œë¥¼ ì°¸ì¡°í•˜ê²Œ ë˜ëŠ” ê²ƒ).
    
    ì´ëŸ¬í•œ ë™ì‘ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©ì„ ìµœì í™”í•˜ê³  ë¶ˆí•„ìš”í•œ ê°ì²´ ìƒì„±ì„ ì¤„ì—¬ ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆë‹¤.
    

**Within a _constant context_, you can omit the `const` before a constructor or literal. For example, look at this code, which creates a const map:**

ìƒìˆ˜ ì»¨í…ìŠ¤íŠ¸ ë‚´ì—ì„œëŠ” ìƒì„±ìë‚˜ ë¦¬í„°ëŸ´ ì•ì— constë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ë‹¤ìŒ ì½”ë“œëŠ” ìƒìˆ˜ ë§µì„ ìƒì„±í•œë‹¤:

```dart
// Lots of const keywords here.
// ì—¬ê¸°ì—ëŠ” ë§ì€ const í‚¤ì›Œë“œê°€ ìˆìŠµë‹ˆë‹¤.
const pointAndLine = const {
  'point': const [const ImmutablePoint(0, 0)],
  'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],
};

```

**You can omit all but the first use of the `const` keyword:**

ëª¨ë“  const í‚¤ì›Œë“œë¥¼ ì²« ë²ˆì§¸ ì‚¬ìš© ì™¸ì—ëŠ” ìƒëµí•  ìˆ˜ ìˆë‹¤:

```dart
// Only one const, which establishes the constant context.
// ì²« ë²ˆì§¸ constë§Œ ì‚¬ìš©í•˜ì—¬ ìƒìˆ˜ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
const pointAndLine = {
  'point': [ImmutablePoint(0, 0)],
  'line': [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],
};

```

**If a constant constructor is outside of a constant context and is invoked without `const`, it creates a non-constant object:**

ìƒìˆ˜ ìƒì„±ìê°€ ìƒìˆ˜ ì»¨í…ìŠ¤íŠ¸ ì™¸ë¶€ì— ìˆê³  const ì—†ì´ í˜¸ì¶œë˜ë©´ ë¹„ìƒìˆ˜ ê°ì²´ê°€ ìƒì„±ëœë‹¤:

```dart
var a = const ImmutablePoint(1, 1); // Creates a constant ìƒìˆ˜ë¥¼ ìƒì„±í•©ë‹ˆë‹¤
var b = ImmutablePoint(1, 1); // Does NOT create a constant ìƒìˆ˜ë¥¼ ìƒì„±í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤

assert(!identical(a, b)); // NOT the same instance! ë™ì¼í•œ ì¸ìŠ¤í„´ìŠ¤ê°€ ì•„ë‹™ë‹ˆë‹¤!

```

## **Getting an object's type[#](https://dart.dev/language/classes#getting-an-objects-type) ê°ì²´ì˜ íƒ€ì… ì–»ê¸°**

**To get an object's type at runtime, you can use the `Object` property `runtimeType`, which returns a [`Type`](https://api.dart.dev/stable/dart-core/Type-class.html) object.**

ëŸ°íƒ€ì„ì— ê°ì²´ì˜ íƒ€ì…ì„ ì–»ìœ¼ë ¤ë©´ Object ì†ì„±ì¸ runtimeTypeì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ì´ëŠ” Type ê°ì²´ë¥¼ ë°˜í™˜í•œë‹¤.

```dart
print('The type of a is ${a.runtimeType}');

```

<aside> â„¹ï¸ **Warning ê²½ê³ **

**Use a [type test operator](https://dart.dev/language/operators#type-test-operators) rather than `runtimeType` to test an object's type. In production environments, the test `object is Type` is more stable than the test `object.runtimeType == Type`.**

ê°ì²´ì˜ íƒ€ì…ì„ í…ŒìŠ¤íŠ¸í•  ë•ŒëŠ” runtimeTypeë³´ë‹¤ëŠ” íƒ€ì… í…ŒìŠ¤íŠ¸ ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤. í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œëŠ” object is Type í…ŒìŠ¤íŠ¸ê°€ object.runtimeType == Type í…ŒìŠ¤íŠ¸ë³´ë‹¤ ë” ì•ˆì •ì ì´ë‹¤.

</aside>

**Up to here, you've seen how to _use_ classes. The rest of this section shows how to _implement_ classes.**

ì—¬ê¸°ê¹Œì§€ í´ë˜ìŠ¤ ì‚¬ìš© ë°©ë²•ì„ ì‚´í´ë³´ì•˜ë‹¤. ì´ ì„¹ì…˜ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì—ì„œëŠ” í´ë˜ìŠ¤ êµ¬í˜„ ë°©ë²•ì„ ë³´ì—¬ì¤€ë‹¤.


## **Instance variables[#](https://dart.dev/language/classes#instance-variables) ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜**

**Here's how you declare instance variables:**

ë‹¤ìŒì€ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ëŠ” ë°©ë²•ì´ë‹¤:

```dart
class Point {
  double? x; // Declare instance variable x, initially null. ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ xë¥¼ ì„ ì–¸, ì´ˆê¸°ê°’ì€ null.
  double? y; // Declare y, initially null. yë¥¼ ì„ ì–¸, ì´ˆê¸°ê°’ì€ null.
  double z = 0; // Declare z, initially 0. zë¥¼ ì„ ì–¸, ì´ˆê¸°ê°’ì€ 0.
}

```

**An uninitialized instance variable declared with a [nullable type](https://dart.dev/null-safety/understanding-null-safety#using-nullable-types) has the value `null`. Non-nullable instance variables [must be initialized](https://dart.dev/null-safety/understanding-null-safety#uninitialized-variables) at declaration.**

ë„ëŸ¬ë¸” íƒ€ì…ìœ¼ë¡œ ì„ ì–¸ëœ ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ëŠ” ê°’ì´ nullì´ë‹¤. ë„ì´ ë  ìˆ˜ ì—†ëŠ” ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ëŠ” ì„ ì–¸ ì‹œ ë°˜ë“œì‹œ ì´ˆê¸°í™”í•´ì•¼ í•œë‹¤.

**All instance variables generate an implicit _getter_ method. Non-final instance variables and `late final` instance variables without initializers also generate an implicit _setter_ method. For details, check out [Getters and setters](https://dart.dev/language/methods#getters-and-setters).**

ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ëŠ” ì•”ì‹œì  getter ë©”ì„œë“œë¥¼ ìƒì„±í•œë‹¤. ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ final ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ì™€ late final ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ëŠ” ì•”ì‹œì ì¸ setter ë©”ì„œë“œë„ ìƒì„±í•œë‹¤. ìì„¸í•œ ë‚´ìš©ì€ Getters and settersë¥¼ ì°¸ì¡°í•˜ë¼.

```dart
class Point {
  double? x; // Declare instance variable x, initially null. ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ xë¥¼ ì„ ì–¸, ì´ˆê¸°ê°’ì€ null.
  double? y; // Declare y, initially null. yë¥¼ ì„ ì–¸, ì´ˆê¸°ê°’ì€ null.
}

void main() {
  var point = Point();
  point.x = 4; // Use the setter method for x. xì˜ setter ë©”ì„œë“œë¥¼ ì‚¬ìš©.
  assert(point.x == 4); // Use the getter method for x. xì˜ getter ë©”ì„œë“œë¥¼ ì‚¬ìš©.
  assert(point.y == null); // Values default to null. ê°’ì´ ê¸°ë³¸ì ìœ¼ë¡œ null.
}

```

**Initializing a non-`late` instance variable where it's declared sets the value when the instance is created, before the constructor and its initializer list execute. As a result, the initializing expression (after the `=`) of a non-`late` instance variable can't access `this`.**

non-late ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ëŠ” ìœ„ì¹˜ì—ì„œ ì´ˆê¸°í™”í•˜ë©´ ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë  ë•Œ ê°’ì´ ì„¤ì •ëœë‹¤. ì´ëŠ” ìƒì„±ìì™€ ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸ê°€ ì‹¤í–‰ë˜ê¸° ì „ì— ì´ë£¨ì–´ì§„ë‹¤. ê²°ê³¼ì ìœ¼ë¡œ non-late ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ì˜ ì´ˆê¸°í™” í‘œí˜„ì‹(= ë’¤)ì€ thisì— ì ‘ê·¼í•  ìˆ˜ ì—†ë‹¤.

```dart
double initialX = 1.5;

class Point {
  // OK, can access declarations that do not depend on `this`:
  // OK, `this`ì— ì˜ì¡´í•˜ì§€ ì•ŠëŠ” ì„ ì–¸ì— ì ‘ê·¼ ê°€ëŠ¥:

  double? x = initialX;

  // ERROR, can't access `this` in non-`late` initializer:
  // ì˜¤ë¥˜, non-`late` ì´ˆê¸°í™”ì—ì„œ `this`ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŒ:
  double? y = this.x;

  // OK, can access `this` in `late` initializer:
  // OK, `late` ì´ˆê¸°í™”ì—ì„œ `this`ì— ì ‘ê·¼ ê°€ëŠ¥:
  late double? z = this.x;

  // OK, `this.x` and `this.y` are parameter declarations, not expressions:
  // OK, `this.x`ì™€ `this.y`ëŠ” í‘œí˜„ì‹ì´ ì•„ë‹Œ íŒŒë¼ë¯¸í„° ì„ ì–¸:
  Point(this.x, this.y);
}

```

**Instance variables can be `final`, in which case they must be set exactly once. Initialize `final`, non-`late` instance variables at declaration, using a constructor parameter, or using a constructor's [initializer list](https://dart.dev/language/constructors#use-an-initializer-list):**

ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ëŠ” finalì¼ ìˆ˜ ìˆìœ¼ë©°, ì´ ê²½ìš° ì •í™•íˆ í•œ ë²ˆë§Œ ì„¤ì •ë˜ì–´ì•¼ í•œë‹¤. final, non-late ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ëŠ” ì„ ì–¸ ì‹œ, ìƒì„±ì íŒŒë¼ë¯¸í„°ë¥¼ ì‚¬ìš©í•˜ì—¬, ë˜ëŠ” ìƒì„±ìì˜ ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ˆê¸°í™”í•œë‹¤:

```dart
class ProfileMark {
  final String name;
  final DateTime start = DateTime.now();

  ProfileMark(this.name);
  ProfileMark.unnamed() : name = '';
}

```

-   **[code] final ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ ì´ˆê¸°í™” ë°©ë²•**
    
    ì„¸ ê°€ì§€ ë°©ë²• ì¤‘ í•˜ë‚˜ë¡œ final ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”í•´ì•¼ í•œë‹¤. ì´ë¥¼ í†µí•´ ë³€ìˆ˜ëŠ” ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë  ë•Œ í•œ ë²ˆë§Œ ê°’ì„ ê°€ì§€ê²Œ ëœë‹¤.
    
    **ì„ ì–¸í•  ë•Œ ì´ˆê¸°í™” :** ë³€ìˆ˜ ì„ ì–¸ ì‹œ ë°”ë¡œ ê°’ì„ í• ë‹¹í•œë‹¤.
    
    ```dart
    class Example {
      final int x = 10; // ì„ ì–¸í•  ë•Œ ì´ˆê¸°í™”
    }
    
    ```
    
    **ìƒì„±ì íŒŒë¼ë¯¸í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ˆê¸°í™” :** ìƒì„±ìì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°’ì„ ì„¤ì •í•œë‹¤.
    
    ```dart
    class Example {
      final int x;
    
      Example(this.x); // ìƒì„±ì íŒŒë¼ë¯¸í„° ì‚¬ìš©
    }
    
    void main() {
      var example = Example(10);
      print(example.x); // 10
    }
    
    ```
    
    **ìƒì„±ìì˜ ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ˆê¸°í™” :** ìƒì„±ìì˜ ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°’ì„ ì„¤ì •í•œë‹¤.
    
    ```dart
    class Example {
      final int x;
    
      Example(int value) : x = value; // ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸ ì‚¬ìš©
    }
    
    void main() {
      var example = Example(10);
      print(example.x); // 10
    }
    
    ```
    

**If you need to assign the value of a `final` instance variable after the constructor body starts, you can use one of the following:**

ìƒì„±ì ë³¸ë¬¸ì´ ì‹œì‘ëœ í›„ì— final ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ì˜ ê°’ì„ í• ë‹¹í•´ì•¼ í•˜ëŠ” ê²½ìš°, ë‹¤ìŒ ì¤‘ í•˜ë‚˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤:

-   **Use a [factory constructor](https://dart.dev/language/constructors#factory-constructors).**
    
    íŒ©í† ë¦¬ ìƒì„±ìë¥¼ ì‚¬ìš©í•˜ë¼.
    
-   **Use `late final`, but [_be careful:_](https://dart.dev/effective-dart/design#avoid-public-late-final-fields-without-initializers) a `late final` without an initializer adds a setter to the API.**
    
    late finalì„ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤. í•˜ì§€ë§Œ ì£¼ì˜í•˜ì‹­ì‹œì˜¤: ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ late finalì€ APIì— setterë¥¼ ì¶”ê°€í•œë‹¤.
    
-   **[code] ë³¸ë¬¸ ì‹œì‘ í›„ final ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ ê°’ í• ë‹¹í•˜ëŠ” ë°©ë²•**
    
    **íŒ©í† ë¦¬ ìƒì„±ì ì‚¬ìš©**
    
    íŒ©í† ë¦¬ ìƒì„±ìëŠ” ìƒˆë¡œìš´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•˜ê±°ë‚˜ ê¸°ì¡´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•  ìˆ˜ ìˆëŠ” ìƒì„±ìì´ë‹¤. ì´ ìƒì„±ìë¥¼ ì‚¬ìš©í•˜ë©´, ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ëœ í›„ì— final ë³€ìˆ˜ì˜ ê°’ì„ ì„¤ì •í•  ìˆ˜ ìˆë‹¤.
    
    ```dart
    class Example {
      final int x;
    
      factory Example(int value) {
        return Example._internal(value);
      }
    
      Example._internal(this.x);
    }
    
    void main() {
      var example = Example(10);
      print(example.x); // 10
    }
    
    ```
    
    **late final ì‚¬ìš©**
    
    late final í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ë©´ ë³€ìˆ˜ë¥¼ ë‚˜ì¤‘ì— ì´ˆê¸°í™”í•  ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ ì´ˆê¸°í™”í•  ë•Œê¹Œì§€ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì£¼ì˜ê°€ í•„ìš”í•˜ë‹¤. ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ late final ë³€ìˆ˜ëŠ” setterë¥¼ í†µí•´ í•œ ë²ˆë§Œ ê°’ì„ ì„¤ì •í•  ìˆ˜ ìˆë‹¤.
    
    -   late final ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•  ë•ŒëŠ” ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ìƒíƒœë¡œ ì ‘ê·¼í•˜ì§€ ì•Šë„ë¡ ì£¼ì˜í•´ì•¼ í•œë‹¤.
    -   ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ late final ë³€ìˆ˜ëŠ” setterë¥¼ í†µí•´ ê°’ì„ ì„¤ì •í•  ìˆ˜ ìˆì§€ë§Œ, ì´ëŠ” APIì— setterë¥¼ ì¶”ê°€í•˜ê²Œ ë˜ì–´ ì›í•˜ì§€ ì•ŠëŠ” ë¶€ì‘ìš©ì„ ì¼ìœ¼í‚¬ ìˆ˜ ìˆë‹¤.
    
    ```dart
    class Example {
      late final int x;
    
      Example(int value) {
        x = value; // ìƒì„±ì ë³¸ë¬¸ì—ì„œ ê°’ì„ ì„¤ì •
      }
    }
    
    void main() {
      var example = Example(10);
      print(example.x); // 10
    }
    
    ```
    
-   **[Q] ì™œ ìœ„ì˜ ë‘ ë°©ë²•ë§Œ ìˆì„ê¹Œ?**
    
    Dartì—ì„œ final ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ì˜ ê°’ì„ ìƒì„±ì ë³¸ë¬¸ì´ ì‹œì‘ëœ í›„ì— í• ë‹¹í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì´ ì œí•œì ì¸ ì´ìœ ëŠ” final í‚¤ì›Œë“œì˜ íŠ¹ì„± ë•Œë¬¸ì´ë‹¤. final ë³€ìˆ˜ëŠ” ì´ˆê¸°í™”ëœ í›„ ê°’ì„ ë³€ê²½í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì—, ì´ˆê¸°í™”ë¥¼ í•œ ë²ˆë§Œ ìˆ˜í–‰í•´ì•¼ í•˜ëŠ” ì œì•½ì´ ìˆë‹¤. ì´ë¥¼ ìœ„í•´ Dartì—ì„œëŠ” íŠ¹ì •í•œ ë°©ë²•ë“¤ë§Œì„ í—ˆìš©í•œë‹¤.
    
    **ë¶ˆë³€ì„± ìœ ì§€**
    
    final í‚¤ì›Œë“œëŠ” ë³€ìˆ˜ì˜ ê°’ì„ í•œ ë²ˆë§Œ ì„¤ì •í•  ìˆ˜ ìˆê²Œ ë³´ì¥í•œë‹¤. ì´ëŠ” ê°ì²´ê°€ ìƒì„±ëœ í›„ í•´ë‹¹ ê°’ì´ ë³€ê²½ë˜ì§€ ì•ŠìŒì„ ì˜ë¯¸í•œë‹¤. ë¶ˆë³€ì„±ì€ í”„ë¡œê·¸ë¨ì˜ ì•ˆì •ì„±ê³¼ ì˜ˆì¸¡ ê°€ëŠ¥ì„±ì„ ë†’ì´ëŠ” ì¤‘ìš”í•œ íŠ¹ì„±ì´ë‹¤.
    
    **ì•ˆì „í•œ ì´ˆê¸°í™” ë³´ì¥**
    
    final ë³€ìˆ˜ëŠ” ìƒì„±ìì—ì„œ ë°˜ë“œì‹œ ì´ˆê¸°í™”í•´ì•¼ í•œë‹¤. ì´ëŠ” ê°ì²´ê°€ ì™„ì „íˆ ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ìƒíƒœë¡œ ì‚¬ìš©ë˜ëŠ” ê²ƒì„ ë°©ì§€í•œë‹¤.
    
    ìƒì„±ì ë³¸ë¬¸ì´ ì‹œì‘ëœ í›„ì— ì´ˆê¸°í™”ê°€ í•„ìš”í•œ ê²½ìš°, íŒ©í† ë¦¬ ìƒì„±ìë‚˜ late finalì„ ì‚¬ìš©í•´ì•¼ë§Œ ì•ˆì „í•˜ê²Œ ì´ˆê¸°í™”ë¥¼ ë³´ì¥í•  ìˆ˜ ìˆë‹¤.
    
    **íŒ©í† ë¦¬ ìƒì„±ì**
    
    -   íŒ©í† ë¦¬ ìƒì„±ìëŠ” ê°ì²´ë¥¼ ìƒì„±í•  ë•Œ ì¶”ê°€ì ì¸ ì´ˆê¸°í™” ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆëŠ” ìœ ì—°ì„±ì„ ì œê³µí•œë‹¤. íŒ©í† ë¦¬ ìƒì„±ìë¥¼ ì‚¬ìš©í•˜ë©´ ê°ì²´ë¥¼ ë°˜í™˜í•˜ê¸° ì „ì— í•„ìš”í•œ ì´ˆê¸°í™” ì‘ì—…ì„ ì™„ë£Œí•  ìˆ˜ ìˆë‹¤.
    -   íŒ©í† ë¦¬ ìƒì„±ìëŠ” í´ë˜ìŠ¤ ì™¸ë¶€ì—ì„œ ê°ì²´ë¥¼ ìƒì„±í•  ìˆ˜ ìˆëŠ” ë©”ì»¤ë‹ˆì¦˜ì„ ì œê³µí•˜ë©°, ì´ëŠ” ê°ì²´ì˜ ìƒì„± ê³¼ì •ì„ ì œì–´í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤.
    
    **late final**
    
    -   late í‚¤ì›Œë“œëŠ” ë³€ìˆ˜ë¥¼ ë‚˜ì¤‘ì— ì´ˆê¸°í™”í•  ìˆ˜ ìˆê²Œ í•œë‹¤. late final ë³€ìˆ˜ëŠ” í•œ ë²ˆë§Œ ì´ˆê¸°í™”ë  ìˆ˜ ìˆë‹¤ëŠ” finalì˜ íŠ¹ì„±ì„ ìœ ì§€í•˜ë©´ì„œë„, ì´ˆê¸°í™”ë¥¼ ë‚˜ì¤‘ìœ¼ë¡œ ë¯¸ë£° ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤.
    -   ì´ëŠ” ìƒì„±ì ë³¸ë¬¸ ë‚´ì—ì„œ ë³µì¡í•œ ì´ˆê¸°í™” ë…¼ë¦¬ë¥¼ ì²˜ë¦¬í•´ì•¼ í•  ë•Œ ìœ ìš©í•˜ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ìƒì„±ì ë‚´ì—ì„œ íŠ¹ì • ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ê²½ìš°ì—ë§Œ ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”í•  ìˆ˜ ìˆë‹¤.
    
    **ì œì•½ì˜ ì´ìœ **
    
    ì´ëŸ¬í•œ ì œì•½ì€ Dartì˜ íƒ€ì… ì‹œìŠ¤í…œê³¼ ì´ˆê¸°í™” ê·œì¹™ì„ ì—„ê²©í•˜ê²Œ ì ìš©í•¨ìœ¼ë¡œì¨ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë²„ê·¸ë¥¼ ì¤„ì´ê³ , ì½”ë“œì˜ ì•ˆì •ì„±ê³¼ ì˜ˆì¸¡ ê°€ëŠ¥ì„±ì„ ë†’ì´ê¸° ìœ„í•œ ê²ƒì´ë‹¤. final ë³€ìˆ˜ì˜ ê°’ì„ ë‚˜ì¤‘ì— í• ë‹¹í•˜ëŠ” ë°©ë²•ì„ ì œí•œí•¨ìœ¼ë¡œì¨, ê°œë°œìê°€ ì˜ë„í•˜ì§€ ì•Šì€ ë°©ì‹ìœ¼ë¡œ ê°’ì„ ë³€ê²½í•˜ê±°ë‚˜ ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ë°©ì§€í•  ìˆ˜ ìˆë‹¤.
    
    ë”°ë¼ì„œ Dartì—ì„œëŠ” ìƒì„±ì ë³¸ë¬¸ì´ ì‹œì‘ëœ í›„ì— final ë³€ìˆ˜ë¥¼ ì•ˆì „í•˜ê²Œ ì´ˆê¸°í™”í•  ìˆ˜ ìˆëŠ” ë°©ë²•ìœ¼ë¡œ íŒ©í† ë¦¬ ìƒì„±ìì™€ late final ë³€ìˆ˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì´ ë‘ ê°€ì§€ ë°©ë²•ì€ final ë³€ìˆ˜ì˜ ì´ˆê¸°í™” ê·œì¹™ì„ ì¤€ìˆ˜í•˜ë©´ì„œë„ í•„ìš”í•œ ì´ˆê¸°í™” ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤.
    


## **Implicit interfaces[#](https://dart.dev/language/classes#implicit-interfaces) ì•”ì‹œì  ì¸í„°í˜ì´ìŠ¤**

**Every class implicitly defines an interface containing all the instance members of the class and of any interfaces it implements. If you want to create a class A that supports class B's API without inheriting B's implementation, class A should implement the B interface.**

ëª¨ë“  í´ë˜ìŠ¤ëŠ” í´ë˜ìŠ¤ì™€ êµ¬í˜„í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ ë©¤ë²„ë¥¼ í¬í•¨í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ ì•”ì‹œì ìœ¼ë¡œ ì •ì˜í•œë‹¤. í´ë˜ìŠ¤ Aê°€ í´ë˜ìŠ¤ Bì˜ êµ¬í˜„ì„ ìƒì†í•˜ì§€ ì•Šìœ¼ë©´ì„œ Bì˜ APIë¥¼ ì§€ì›í•˜ë ¤ë©´, í´ë˜ìŠ¤ AëŠ” B ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•´ì•¼ í•œë‹¤.

**A class implements one or more interfaces by declaring them in an `implements` clause and then providing the APIs required by the interfaces. For example:**

í´ë˜ìŠ¤ëŠ” implements ì ˆì—ì„œ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì„ ì–¸í•˜ê³  ì¸í„°í˜ì´ìŠ¤ê°€ ìš”êµ¬í•˜ëŠ” APIë¥¼ ì œê³µí•¨ìœ¼ë¡œì¨ í•˜ë‚˜ ì´ìƒì˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´:

```dart
// A person. The implicit interface contains greet().
// ì‚¬ëŒ í´ë˜ìŠ¤. ì•”ì‹œì  ì¸í„°í˜ì´ìŠ¤ëŠ” greet()ì„ í¬í•¨í•©ë‹ˆë‹¤.
class Person {
  // In the interface, but visible only in this library.
    // ì¸í„°í˜ì´ìŠ¤ì— í¬í•¨ë˜ì§€ë§Œ, ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œë§Œ ë³´ì…ë‹ˆë‹¤.
	final String _name;

  // Not in the interface, since this is a constructor.
  // ìƒì„±ìì´ë¯€ë¡œ ì¸í„°í˜ì´ìŠ¤ì— í¬í•¨ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
  Person(this._name);

  // In the interface.
  // ì¸í„°í˜ì´ìŠ¤ì— í¬í•¨ë©ë‹ˆë‹¤.
  String greet(String who) => 'Hello, $who. I am $_name.';
}

// An implementation of the Person interface.
// Person ì¸í„°í˜ì´ìŠ¤ì˜ êµ¬í˜„ì²´.
class Impostor implements Person {
  String get _name => '';

  String greet(String who) => 'Hi $who. Do you know who I am?';
}

String greetBob(Person person) => person.greet('Bob');

void main() {
  print(greetBob(Person('Kathy')));
  print(greetBob(Impostor()));
}

```

**Here's an example of specifying that a class implements multiple interfaces:**

ì—¬ê¸° í´ë˜ìŠ¤ê°€ ì—¬ëŸ¬ ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ëŠ” ì˜ˆì œê°€ ìˆë‹¤:

```dart
class Point implements Comparable, Location {...}

```


## **Class variables and methods[#](https://dart.dev/language/classes#class-variables-and-methods) í´ë˜ìŠ¤ ë³€ìˆ˜ì™€ ë©”ì„œë“œ**

**Use the `static` keyword to implement class-wide variables and methods.**

í´ë˜ìŠ¤ ì „ì—­ ë³€ìˆ˜ì™€ ë©”ì„œë“œë¥¼ êµ¬í˜„í•˜ë ¤ë©´ static í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ë¼.

### **Static variables[#](https://dart.dev/language/classes#static-variables) ì •ì  ë³€ìˆ˜**

**Static variables (class variables) are useful for class-wide state and constants:**

í´ë˜ìŠ¤ ë³€ìˆ˜(static ë³€ìˆ˜)ëŠ” í´ë˜ìŠ¤ ì „ì²´ì—ì„œ ìƒíƒœì™€ ìƒìˆ˜ë¥¼ ê³µìœ í•  ë•Œ ìœ ìš©í•˜ë‹¤:

```dart
class Queue {
  static const initialCapacity = 16;
  // Â·Â·Â·
}

void main() {
  assert(Queue.initialCapacity == 16);
}

```

**Static variables aren't initialized until they're used.**

ì •ì  ë³€ìˆ˜ëŠ” ì‚¬ìš©ë  ë•Œê¹Œì§€ ì´ˆê¸°í™”ë˜ì§€ ì•ŠëŠ”ë‹¤.

-   **[Q] í´ë˜ìŠ¤ ë³€ìˆ˜ì— static ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ìƒíƒœì™€ ìƒìˆ˜ë¥¼ ê³µìœ í•  ë•Œ ìœ ìš©í•˜ë‹¤?**
    
    Dartì—ì„œ í´ë˜ìŠ¤ ë©¤ë²„ì— static í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ë©´, í•´ë‹¹ ë©¤ë²„ëŠ” í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ ì•„ë‹Œ í´ë˜ìŠ¤ ìì²´ì— ì†í•˜ê²Œ ëœë‹¤. ì¦‰, static ë©¤ë²„ëŠ” í´ë˜ìŠ¤ì˜ ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ê°€ ê³µìœ í•˜ëŠ” ë©¤ë²„ê°€ ë˜ë©°, í´ë˜ìŠ¤ ì´ë¦„ì„ í†µí•´ ì§ì ‘ ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.
    
    ```dart
    class MathUtil {
      // static ë³€ìˆ˜
      static const double pi = 3.14159;
    
      // static ë©”ì„œë“œ
      static double calculateCircleArea(double radius) {
        return pi * radius * radius;
      }
    }
    
    void main() {
      // í´ë˜ìŠ¤ ì´ë¦„ì„ í†µí•´ static ë³€ìˆ˜ì™€ ë©”ì„œë“œì— ì ‘ê·¼
      print(MathUtil.pi); // ì¶œë ¥: 3.14159
      print(MathUtil.calculateCircleArea(10)); // ì¶œë ¥: 314.159
    }
    
    ```
    
    **í´ë˜ìŠ¤ ìˆ˜ì¤€ì˜ ë©¤ë²„**
    
    static ë©¤ë²„ëŠ” í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ ì•„ë‹ˆë¼ í´ë˜ìŠ¤ ìì²´ì— ì†í•œë‹¤. ë”°ë¼ì„œ í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì§€ ì•Šê³ ë„ ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.
    
    **ê³µìœ ëœ ìƒíƒœ**
    
    static ë³€ìˆ˜ëŠ” í´ë˜ìŠ¤ì˜ ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ ê°„ì— ê³µìœ ëœë‹¤. ì´ëŠ” í´ë˜ìŠ¤ì˜ ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ê°€ ë™ì¼í•œ static ë³€ìˆ˜ë¥¼ ì°¸ì¡°í•˜ê³  ë³€ê²½í•  ìˆ˜ ìˆìŒì„ ì˜ë¯¸í•œë‹¤.
    
    **ë©”ëª¨ë¦¬ ì‚¬ìš© ìµœì í™”**
    
    static ë©¤ë²„ëŠ” í´ë˜ìŠ¤ë‹¹ í•˜ë‚˜ë§Œ ì¡´ì¬í•˜ë¯€ë¡œ, ë§ì€ ì¸ìŠ¤í„´ìŠ¤ê°€ ìˆëŠ” ê²½ìš° ë©”ëª¨ë¦¬ë¥¼ ì ˆì•½í•  ìˆ˜ ìˆë‹¤.
    
    **ì¸ìŠ¤í„´ìŠ¤ ë©¤ë²„ì™€ êµ¬ë¶„**
    
    static ë©¤ë²„ëŠ” ì¸ìŠ¤í„´ìŠ¤ ë©¤ë²„ì™€ ë‹¬ë¦¬, í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ í†µí•´ ì ‘ê·¼í•  ìˆ˜ ì—†ë‹¤. ì¸ìŠ¤í„´ìŠ¤ë¥¼ í†µí•´ static ë©¤ë²„ì— ì ‘ê·¼í•˜ë ¤ê³  í•˜ë©´ ê²½ê³  ë˜ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤. ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ë‚˜ í—¬í¼ í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ ë•Œ ìœ ìš©í•˜ë‹¤. ì´ëŸ¬í•œ í´ë˜ìŠ¤ëŠ” ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§Œë“¤ í•„ìš” ì—†ì´ static ë©”ì„œë“œë§Œ ì œê³µí•˜ëŠ” ê²½ìš°ê°€ ë§ë‹¤.
    
    ```dart
    class Example {
      static int staticVar = 10;
      int instanceVar = 20;
    }
    
    void main() {
      Example ex = Example();
      
      // ì˜¬ë°”ë¥¸ ì ‘ê·¼ ë°©ë²•
      print(Example.staticVar); // static ë©¤ë²„ëŠ” í´ë˜ìŠ¤ ì´ë¦„ì„ í†µí•´ ì ‘ê·¼
      
      // ì˜ëª»ëœ ì ‘ê·¼ ë°©ë²•
      // print(ex.staticVar); // ì˜¤ë¥˜: ì¸ìŠ¤í„´ìŠ¤ë¥¼ í†µí•´ static ë©¤ë²„ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŒ
      
      // ì¸ìŠ¤í„´ìŠ¤ ë©¤ë²„ëŠ” ì¸ìŠ¤í„´ìŠ¤ë¥¼ í†µí•´ ì ‘ê·¼
      print(ex.instanceVar);
    }
    
    ```
    

<aside> â„¹ï¸ **Note ì°¸ê³ **

**This page follows the [style guide recommendation](https://dart.dev/effective-dart/style#identifiers) of preferring `lowerCamelCase` for constant names.**

ì´ í˜ì´ì§€ëŠ” ìƒìˆ˜ ì´ë¦„ì— ëŒ€í•´ ì†Œë¬¸ì ë‚™íƒ€ í‘œê¸°ë²•(lowerCamelCase)ì„ ì„ í˜¸í•˜ëŠ” ìŠ¤íƒ€ì¼ ê°€ì´ë“œ ê¶Œì¥ ì‚¬í•­ì„ ë”°ë¦…ë‹ˆë‹¤.

</aside>

### **Static methods[#](https://dart.dev/language/classes#static-methods)** ì •ì  ë©”ì„œë“œ

**Static methods (class methods) don't operate on an instance, and thus don't have access to `this`. They do, however, have access to static variables. As the following example shows, you invoke static methods directly on a class:**

ì •ì  ë©”ì„œë“œ(í´ë˜ìŠ¤ ë©”ì„œë“œ)ëŠ” ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ì‘ë™í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ thisì— ì ‘ê·¼í•  ìˆ˜ ì—†ë‹¤. ê·¸ëŸ¬ë‚˜ ì •ì  ë³€ìˆ˜ì—ëŠ” ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤. ë‹¤ìŒ ì˜ˆì œì—ì„œ ì•Œ ìˆ˜ ìˆë“¯ì´, ì •ì  ë©”ì„œë“œëŠ” í´ë˜ìŠ¤ì—ì„œ ì§ì ‘ í˜¸ì¶œí•œë‹¤:

```dart
import 'dart:math';

class Point {
  double x, y;
  Point(this.x, this.y);

  static double distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
  }
}

void main() {
  var a = Point(2, 2);
  var b = Point(4, 4);
  var distance = Point.distanceBetween(a, b);
  assert(2.8 < distance && distance < 2.9);
  print(distance);
}

```

<aside> â„¹ï¸ **Note ì°¸ê³ **

**Consider using top-level functions, instead of static methods, for common or widely used utilities and functionality.**

ê³µí†µì ì´ê±°ë‚˜ ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” ìœ í‹¸ë¦¬í‹°ì™€ ê¸°ëŠ¥ì—ëŠ” ì •ì  ë©”ì„œë“œ ëŒ€ì‹  ìµœìƒìœ„ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ê³ ë ¤í•˜ì‹­ì‹œì˜¤.

</aside>

**You can use static methods as compile-time constants. For example, you can pass a static method as a parameter to a constant constructor.**

ì •ì  ë©”ì„œë“œë¥¼ ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì •ì  ë©”ì„œë“œë¥¼ ìƒìˆ˜ ìƒì„±ìì˜ ë§¤ê°œë³€ìˆ˜ë¡œ ì „ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

ğŸ”— [í˜ì´ì§€ ë§í¬]

# **Constructors ìƒì„±ì**

**Constructors are special functions that create instances of classes.**

ìƒì„±ìëŠ” í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ëŠ” íŠ¹ë³„í•œ í•¨ìˆ˜ì´ë‹¤.

**Dart implements many types of constructors. Except for default constructors, these functions use the same name as their class.**

DartëŠ” ì—¬ëŸ¬ ìœ í˜•ì˜ ìƒì„±ìë¥¼ êµ¬í˜„í•œë‹¤. ê¸°ë³¸ ìƒì„±ìë¥¼ ì œì™¸í•˜ê³ , ì´ í•¨ìˆ˜ë“¤ì€ í´ë˜ìŠ¤ì™€ ê°™ì€ ì´ë¦„ì„ ì‚¬ìš©í•œë‹¤.

-   **[Generative constructors](https://dart.dev/language/constructors#generative-constructors): Creates new instances and initializes instance variables.**
    
    ìƒì„± ìƒì„±ì : ìƒˆë¡œìš´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ê³  ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”í•œë‹¤.
    
-   **[Default constructors](https://dart.dev/language/constructors#default-constructors): Used to create a new instance when a constructor hasn't been specified. It doesn't take arguments and isn't named.**
    
    ê¸°ë³¸ ìƒì„±ì : ìƒì„±ìê°€ ì§€ì •ë˜ì§€ ì•Šì€ ê²½ìš° ìƒˆ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ì¸ìˆ˜ë¥¼ ë°›ì§€ ì•Šìœ¼ë©° ì´ë¦„ì´ ì—†ë‹¤.
    
-   **[Named constructors](https://dart.dev/language/constructors#named-constructors): Clarifies the purpose of a constructor or allows the creation of multiple constructors for the same class.**
    
    ëª…ëª…ëœ ìƒì„±ì : ìƒì„±ìì˜ ëª©ì ì„ ëª…í™•íˆ í•˜ê±°ë‚˜ ë™ì¼í•œ í´ë˜ìŠ¤ì— ëŒ€í•´ ì—¬ëŸ¬ ìƒì„±ìë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.
    
-   **[Constant constructors](https://dart.dev/language/constructors#constant-constructors): Creates instances as compile-type constants.**
    
    ìƒìˆ˜ ìƒì„±ì : ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜ë¡œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•œë‹¤.
    
-   **[Factory constructors](https://dart.dev/language/constructors#factory-constructors): Either creates a new instance of a subtype or returns an existing instance from cache.**
    
    íŒ©í† ë¦¬ ìƒì„±ì : í•˜ìœ„ ìœ í˜•ì˜ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ê±°ë‚˜ ìºì‹œì—ì„œ ê¸°ì¡´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•œë‹¤.
    
-   **[Redirecting constructor](https://dart.dev/language/constructors#redirecting-constructors): Forwards calls to another constructor in the same class.**
    
    ë¦¬ë””ë ‰íŒ… ìƒì„±ì : ë™ì¼í•œ í´ë˜ìŠ¤ì˜ ë‹¤ë¥¸ ìƒì„±ìë¡œ í˜¸ì¶œì„ ì „ë‹¬í•œë‹¤.
    


## **Types of constructors[#](https://dart.dev/language/constructors#types-of-constructors) ìƒì„±ì ìœ í˜•**

### **Generative constructors[#](https://dart.dev/language/constructors#generative-constructors) ìƒì„± ìƒì„±ì**

**To instantiate a class, use a generative constructor.**

í´ë˜ìŠ¤ë¥¼ ì¸ìŠ¤í„´ìŠ¤í™”í•˜ë ¤ë©´ ìƒì„± ìƒì„±ìë¥¼ ì‚¬ìš©í•œë‹¤.

```dart
class Point {
  // Initializer list of variables and values
	// ë³€ìˆ˜ì™€ ê°’ì˜ ì´ˆê¸°í™” ëª©ë¡
  double x = 2.0;
  double y = 2.0;

  // Generative constructor with initializing formal parameters:
  // ì´ˆê¸°í™” í˜•ì‹ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ìƒì„± ìƒì„±ì:
  Point(this.x, this.y);
}

```

### **Default constructors[#](https://dart.dev/language/constructors#default-constructors) ê¸°ë³¸ ìƒì„±ì**

**If you don't declare a constructor, Dart uses the default constructor. The default constructor is a generative constructor without arguments or name.**

ìƒì„±ìë¥¼ ì„ ì–¸í•˜ì§€ ì•Šìœ¼ë©´ DartëŠ” ê¸°ë³¸ ìƒì„±ìë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ê¸°ë³¸ ìƒì„±ìëŠ” ì¸ìˆ˜ë‚˜ ì´ë¦„ì´ ì—†ëŠ” ìƒì„± ìƒì„±ìì´ë‹¤.

-   **[code] ê¸°ë³¸ ìƒì„±ì ì˜ˆì‹œ**
    
    ```dart
    class Person {
      String name;
      int age;
    
      // ê¸°ë³¸ ìƒì„±ì: Person() {} (ìë™ìœ¼ë¡œ ì œê³µë¨)
    }
    
    void main() {
      // ê¸°ë³¸ ìƒì„±ìë¥¼ ì‚¬ìš©í•˜ì—¬ ê°ì²´ ìƒì„±
      var person = Person();
      person.name = "Alice";
      person.age = 30;
    
      print('Name: ${person.name}, Age: ${person.age}'); // ì¶œë ¥: Name: Alice, Age: 30
    }
    
    ```
    

### **Named constructors[#](https://dart.dev/language/constructors#named-constructors) ëª…ëª…ëœ ìƒì„±ì**

**Use a named constructor to implement multiple constructors for a class or to provide extra clarity:**

í´ë˜ìŠ¤ì— ëŒ€í•´ ì—¬ëŸ¬ ìƒì„±ìë¥¼ êµ¬í˜„í•˜ê±°ë‚˜ ì¶”ê°€ì ì¸ ëª…í™•ì„±ì„ ì œê³µí•˜ë ¤ë©´ ëª…ëª…ëœ ìƒì„±ìë¥¼ ì‚¬ìš©í•˜ë¼:

```dart
const double xOrigin = 0;
const double yOrigin = 0;

class Point {
  final double x;
  final double y;

  // Sets the x and y instance variables
  // before the constructor body runs.
  // ìƒì„±ì ë³¸ë¬¸ì´ ì‹¤í–‰ë˜ê¸° ì „ì— xì™€ y ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
  Point(this.x, this.y);

  // ëª…ëª…ëœ ìƒì„±ì
  // Named constructor
  Point.origin()
      : x = xOrigin,
        y = yOrigin;
}

```

**A subclass doesn't inherit a superclass's named constructor. To create a subclass with a named constructor defined in the superclass, implement that constructor in the subclass.**

í•˜ìœ„ í´ë˜ìŠ¤ëŠ” ìƒìœ„ í´ë˜ìŠ¤ì˜ ëª…ëª…ëœ ìƒì„±ìë¥¼ ìƒì†í•˜ì§€ ì•ŠëŠ”ë‹¤. ìƒìœ„ í´ë˜ìŠ¤ì—ì„œ ì •ì˜ëœ ëª…ëª…ëœ ìƒì„±ìë¡œ í•˜ìœ„ í´ë˜ìŠ¤ë¥¼ ìƒì„±í•˜ë ¤ë©´, í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ í•´ë‹¹ ìƒì„±ìë¥¼ êµ¬í˜„í•´ì•¼ í•œë‹¤.

-   **[code] ì˜ˆì‹œ ì½”ë“œ**
    
    ```dart
    class Shape {
      double width;
      double height;
    
      // ê¸°ë³¸ ìƒì„±ì
      Shape(this.width, this.height);
    
      // ëª…ëª…ëœ ìƒì„±ì
      Shape.square(double size) : width = size, height = size;
    }
    
    class Rectangle extends Shape {
      String color;
    
      // ê¸°ë³¸ ìƒì„±ì
      Rectangle(double width, double height, this.color) : super(width, height);
    
      // ëª…ëª…ëœ ìƒì„±ìë¥¼ ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ êµ¬í˜„
      Rectangle.square(double size, this.color) : super.square(size);
    }
    
    void main() {
      // ê¸°ë³¸ ìƒì„±ìë¥¼ ì‚¬ìš©í•˜ì—¬ ê°ì²´ ìƒì„±
      var rect1 = Rectangle(10, 20, "red");
      print('Rectangle 1: width=${rect1.width}, height=${rect1.height}, color=${rect1.color}');
    
      // ëª…ëª…ëœ ìƒì„±ìë¥¼ ì‚¬ìš©í•˜ì—¬ ê°ì²´ ìƒì„±
      var rect2 = Rectangle.square(15, "blue");
      print('Rectangle 2: width=${rect2.width}, height=${rect2.height}, color=${rect2.color}');
    }
    
    ```
    

### **Constant constructors[#](https://dart.dev/language/constructors#constant-constructors) ìƒìˆ˜ ìƒì„±ì**

**If your class produces unchanging objects, make these objects compile-time constants. To make objects compile-time constants, define a `const` constructor with all instance variables set as `final`.**

í´ë˜ìŠ¤ê°€ ë³€ê²½ë˜ì§€ ì•ŠëŠ” ê°ì²´ë¥¼ ìƒì„±í•˜ëŠ” ê²½ìš° ì´ëŸ¬í•œ ê°ì²´ë¥¼ ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜ë¡œ ë§Œë“¤ì–´ë¼. ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜ë¥¼ ë§Œë“¤ë ¤ë©´ ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¥¼ finalë¡œ ì„¤ì •í•œ const ìƒì„±ìë¥¼ ì •ì˜í•˜ë¼.

-   **[Q] í´ë˜ìŠ¤ê°€ ë³€ê²½ë˜ì§€ ì•ŠëŠ” ê°ì²´?**
    
    í´ë˜ìŠ¤ê°€ ìƒì„±í•œ ê°ì²´ì˜ ìƒíƒœê°€ í•œ ë²ˆ ì„¤ì •ëœ ì´í›„ì—ëŠ” ë³€ê²½ë˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤. ì¦‰, ì´ëŸ¬í•œ ê°ì²´ëŠ” ë¶ˆë³€(immutable) ê°ì²´ì…ë‹ˆë‹¤. ë¶ˆë³€ ê°ì²´ëŠ” ìƒì„±ëœ ì´í›„ì— ê·¸ ì†ì„±ì´ë‚˜ ìƒíƒœê°€ ë³€ê²½ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ, ì•ˆì •ì ì´ê³  ì˜ˆì¸¡ ê°€ëŠ¥í•œ ë™ì‘ì„ ë³´ì¥í•œë‹¤.
    
-   **[Q] Constant constructorëŠ” ì–¸ì œ ì‚¬ìš©í•˜ë‚˜?**
    
    const ìƒì„±ìëŠ” ê°ì²´ë¥¼ ë¶ˆë³€(immutable)ìœ¼ë¡œ ë§Œë“¤ê³ , ì»´íŒŒì¼ ì‹œê°„ì— ìƒìˆ˜ë¡œ ê°„ì£¼ë  ìˆ˜ ìˆëŠ” ê°ì²´ë¥¼ ìƒì„±í•  ë•Œ ì‚¬ìš©ëœë‹¤.
    
    Dartì—ì„œ const ìƒì„±ìë¥¼ ì‚¬ìš©í•˜ë©´ í•´ë‹¹ ê°ì²´ëŠ” ë¶ˆë³€ì´ë©°, ë™ì¼í•œ ê°’ì˜ const ê°ì²´ëŠ” ë©”ëª¨ë¦¬ ë‚´ì—ì„œ ë‹¨ í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤ë§Œ ìƒì„±ëœë‹¤. ì´ëŠ” ë©”ëª¨ë¦¬ ì‚¬ìš©ì„ ìµœì í™”í•˜ê³  ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆë‹¤.
    

```dart
class ImmutablePoint {
  static const ImmutablePoint origin = ImmutablePoint(0, 0);

  final double x, y;

  const ImmutablePoint(this.x, this.y);
}

```

**Constant constructors don't always create constants. They might be invoked in a non-`const` context. To learn more, consult the section on [using constructors](https://dart.dev/language/classes#using-constructors).**

ìƒìˆ˜ ìƒì„±ìëŠ” í•­ìƒ ìƒìˆ˜ë¥¼ ìƒì„±í•˜ì§€ëŠ” ì•ŠëŠ”ë‹¤. ë¹„ìƒìˆ˜ ì»¨í…ìŠ¤íŠ¸ì—ì„œ í˜¸ì¶œë  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ ìƒì„±ì ì‚¬ìš© ì„¹ì…˜ì„ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤.

-   **[Q] í•­ìƒ ìƒìˆ˜ ìƒì„±ìë¥¼ ìƒì •í•˜ì§€ ì•ŠëŠ”ë‹¤?**
    
    const ìƒì„±ìëŠ” ê°ì²´ë¥¼ ë¶ˆë³€ìœ¼ë¡œ ë§Œë“¤ê³  ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•˜ì§€ë§Œ, const ìƒì„±ìê°€ í˜¸ì¶œë˜ëŠ” ë¬¸ë§¥ì— ë”°ë¼ ì‹¤ì œë¡œ ìƒìˆ˜ê°€ ë˜ì§€ ì•Šì„ ìˆ˜ë„ ìˆë‹¤. ì¦‰, const ìƒì„±ìëŠ” ìƒìˆ˜ ì»¨í…ìŠ¤íŠ¸ì—ì„œ í˜¸ì¶œë  ë•Œë§Œ ìƒìˆ˜ë¥¼ ìƒì„±í•œë‹¤.
    
    **ìƒìˆ˜ ì»¨í…ìŠ¤íŠ¸**
    
    const ìƒì„±ìê°€ ìƒìˆ˜ ì»¨í…ìŠ¤íŠ¸ì—ì„œ í˜¸ì¶œë˜ë©´, ìƒì„±ëœ ê°ì²´ëŠ” ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜ë¡œ ê°„ì£¼ëœë‹¤. ì´ ê²½ìš°, ë™ì¼í•œ ê°’ì„ ê°€ì§€ëŠ” const ê°ì²´ëŠ” ë©”ëª¨ë¦¬ ë‚´ì—ì„œ í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤ë§Œ ê³µìœ í•˜ê²Œ ëœë‹¤.
    
    ```dart
    class ImmutablePoint {
      final double x;
      final double y;
    
      // const ìƒì„±ì
      const ImmutablePoint(this.x, this.y);
    }
    
    void main() {
      // ìƒìˆ˜ ì»¨í…ìŠ¤íŠ¸ì—ì„œ const ê°ì²´ ìƒì„±
      const point1 = ImmutablePoint(1, 1);
      const point2 = ImmutablePoint(1, 1);
    
      // ë™ì¼í•œ ê°’ì„ ê°€ì§„ const ê°ì²´ëŠ” ë©”ëª¨ë¦¬ë¥¼ ê³µìœ 
      print(identical(point1, point2)); // ì¶œë ¥: true
    }
    
    ```
    
    **ë¹„ìƒìˆ˜ ì»¨í…ìŠ¤íŠ¸**
    
    const ìƒì„±ìê°€ ë¹„ìƒìˆ˜ ì»¨í…ìŠ¤íŠ¸ì—ì„œ í˜¸ì¶œë˜ë©´, ìƒì„±ëœ ê°ì²´ëŠ” ìƒìˆ˜ë¡œ ê°„ì£¼ë˜ì§€ ì•ŠëŠ”ë‹¤. ì´ ê²½ìš°, ë™ì¼í•œ ê°’ì„ ê°€ì§€ë”ë¼ë„ ê°ê¸° ë‹¤ë¥¸ ì¸ìŠ¤í„´ìŠ¤ë¡œ ìƒì„±ë  ìˆ˜ ìˆë‹¤.
    
    ```dart
    class ImmutablePoint {
      final double x;
      final double y;
    
      // const ìƒì„±ì
      const ImmutablePoint(this.x, this.y);
    }
    
    void main() {
      // ë¹„ìƒìˆ˜ ì»¨í…ìŠ¤íŠ¸ì—ì„œ const ê°ì²´ ìƒì„±
      var point1 = ImmutablePoint(1, 1); // constê°€ ì•„ë‹Œ var ì‚¬ìš©
      var point2 = ImmutablePoint(1, 1);
    
      // ë™ì¼í•œ ê°’ì„ ê°€ì§€ë”ë¼ë„ ì„œë¡œ ë‹¤ë¥¸ ì¸ìŠ¤í„´ìŠ¤
      print(identical(point1, point2)); // ì¶œë ¥: false
    }
    
    ```
    

### **Redirecting constructors[#](https://dart.dev/language/constructors#redirecting-constructors) ë¦¬ë””ë ‰íŒ… ìƒì„±ì**

**A constructor might redirect to another constructor in the same class. A redirecting constructor has an empty body. The constructor uses `this` instead of the class name after a colon (:).**

ìƒì„±ìëŠ” ë™ì¼í•œ í´ë˜ìŠ¤ì˜ ë‹¤ë¥¸ ìƒì„±ìë¡œ í˜¸ì¶œì„ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤. ìœ„ì„(redirect) ìƒì„±ìëŠ” ë³¸ë¬¸ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤. ìƒì„±ìëŠ” ì½œë¡ (:) ë’¤ì— í´ë˜ìŠ¤ ì´ë¦„ ëŒ€ì‹  thisë¥¼ ì‚¬ìš©í•œë‹¤.

```dart
class Point {
  double x, y;

  // The main constructor for this class.
  // ì´ í´ë˜ìŠ¤ì˜ ì£¼ìš” ìƒì„±ì.
  Point(this.x, this.y);

  // Delegates to the main constructor.
  // ì£¼ìš” ìƒì„±ìë¡œ ìœ„ì„.
  Point.alongXAxis(double x) : this(x, 0);
}

```

### **Factory constructors[#](https://dart.dev/language/constructors#factory-constructors) íŒ©í† ë¦¬ ìƒì„±ì**

**When encountering one of following two cases of implementing a constructor, use the `factory` keyword:**

ë‹¤ìŒ ë‘ ê°€ì§€ ê²½ìš° ì¤‘ í•˜ë‚˜ì— í•´ë‹¹í•  ë•ŒëŠ” factory í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒì„±ìë¥¼ êµ¬í˜„í•˜ë¼:

-   **The constructor doesn't always create a new instance of its class. Although a factory constructor cannot return `null`, it might return:**
    
    ìƒì„±ìê°€ í•­ìƒ í•´ë‹¹ í´ë˜ìŠ¤ì˜ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì§€ ì•ŠëŠ” ê²½ìš°. íŒ©í† ë¦¬ ìƒì„±ìëŠ” nullì„ ë°˜í™˜í•  ìˆ˜ ì—†ì§€ë§Œ, ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš°ê°€ ìˆì„ ìˆ˜ ìˆë‹¤:
    
    -   **an existing instance from a cache instead of creating a new one**
        
        ìƒˆ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ëŠ” ëŒ€ì‹  ìºì‹œì—ì„œ ê¸°ì¡´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•˜ëŠ” ê²½ìš°
        
    -   **a new instance of a subtype**
        
        í•˜ìœ„ ìœ í˜•ì˜ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•˜ëŠ” ê²½ìš°
        
-   **You need to perform non-trivial work prior to constructing an instance. This could include checking arguments or doing any other processing that cannot be handled in the initializer list.**
    
    ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ê¸° ì „ì— ë³µì¡í•œ ì‘ì—…ì„ ìˆ˜í–‰í•´ì•¼ í•˜ëŠ” ê²½ìš°. ì—¬ê¸°ì—ëŠ” ì¸ìˆ˜ í™•ì¸ ë˜ëŠ” ì´ˆê¸°í™” ëª©ë¡ì—ì„œ ì²˜ë¦¬í•  ìˆ˜ ì—†ëŠ” ê¸°íƒ€ ì²˜ë¦¬ê°€ í¬í•¨ëœë‹¤.
    

<aside> â„¹ï¸ **Tip**

**You can also handle late initialization of a final variable with [`late final`](https://dart.dev/effective-dart/design#avoid-public-late-final-fields-without-initializers) (carefully!).**

late finalì„ ì‚¬ìš©í•˜ì—¬ final ë³€ìˆ˜ë¥¼ ë‚˜ì¤‘ì— ì´ˆê¸°í™”í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤(ì£¼ì˜í•´ì„œ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤!).

</aside>

**The following example includes two factory constructors.**

ë‹¤ìŒ ì˜ˆì œëŠ” ë‘ ê°œì˜ íŒ©í† ë¦¬ ìƒì„±ìë¥¼ í¬í•¨í•œë‹¤.

-   **`Logger` factory constructor returns objects from a cache.**
    
    Logger íŒ©í† ë¦¬ ìƒì„±ìëŠ” ìºì‹œì—ì„œ ê°ì²´ë¥¼ ë°˜í™˜í•œë‹¤.
    
-   **`Logger.fromJson` factory constructor initializes a final variable from a JSON object.**
    
    Logger.fromJson íŒ©í† ë¦¬ ìƒì„±ìëŠ” JSON ê°ì²´ë¡œë¶€í„° final ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”í•œë‹¤.
    

```dart
class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to
  // the _ in front of its name.
  static final Map<String, Logger> _cache = <String, Logger>{};

  factory Logger(String name) {
    return _cache.putIfAbsent(name, () => Logger._internal(name));
  }

  factory Logger.fromJson(Map<String, Object> json) {
    return Logger(json['name'].toString());
  }

  Logger._internal(this.name);

  void log(String msg) {
    if (!mute) print(msg);
  }
}

```

<aside> â„¹ï¸ **Warning**

**Factory constructors can't access `this`.**

íŒ©í† ë¦¬ ìƒì„±ìëŠ” thisì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

</aside>

**Use a factory constructor as any other constructor:**

íŒ©í† ë¦¬ ìƒì„±ìë¥¼ ë‹¤ë¥¸ ìƒì„±ìì²˜ëŸ¼ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤.

```dart
var logger = Logger('UI');
logger.log('Button clicked');

var logMap = {'name': 'UI'};
var loggerJson = Logger.fromJson(logMap);

```

### **Redirecting factory constructors[#](https://dart.dev/language/constructors#redirecting-factory-constructors) ë¦¬ë””ë ‰íŒ… íŒ©í† ë¦¬ ìƒì„±ì**

**A redirecting factory constructor specifies a call to a constructor of another class to use whenever someone makes a call to the redirecting constructor.**

ë¦¬ë””ë ‰íŒ… íŒ©í† ë¦¬ ìƒì„±ìëŠ” ë¦¬ë””ë ‰íŒ… ìƒì„±ìë¥¼ í˜¸ì¶œí•  ë•Œë§ˆë‹¤ ë‹¤ë¥¸ í´ë˜ìŠ¤ì˜ ìƒì„±ìë¥¼ í˜¸ì¶œí•˜ë„ë¡ ì§€ì •í•œë‹¤.

```dart
factory Listenable.merge(List<Listenable> listenables) = _MergingListenable;

```

**It might appear that ordinary factory constructors could create and return instances of other classes. This would make redirecting factories unnecessary. Redirecting factories have several advantages:**

ì¼ë°˜ íŒ©í† ë¦¬ ìƒì„±ìê°€ ë‹¤ë¥¸ í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ê³  ë°˜í™˜í•  ìˆ˜ ìˆì„ ê²ƒì²˜ëŸ¼ ë³´ì¼ ìˆ˜ ìˆë‹¤. ì´ê²ƒì€ ë¦¬ë””ë ‰íŒ… íŒ©í† ë¦¬ë¥¼ ë¶ˆí•„ìš”í•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ ë¦¬ë””ë ‰íŒ… íŒ©í† ë¦¬ì—ëŠ” ì—¬ëŸ¬ ê°€ì§€ ì¥ì ì´ ìˆë‹¤:

-   **An abstract class might provide a constant constructor that uses the constant constructor of another class.**
    
    ì¶”ìƒ í´ë˜ìŠ¤ëŠ” ë‹¤ë¥¸ í´ë˜ìŠ¤ì˜ ìƒìˆ˜ ìƒì„±ìë¥¼ ì‚¬ìš©í•˜ëŠ” ìƒìˆ˜ ìƒì„±ìë¥¼ ì œê³µí•  ìˆ˜ ìˆë‹¤.
    
-   **A redirecting factory constructor avoids the need for forwarders to repeat the formal parameters and their default values.**
    
    ë¦¬ë””ë ‰íŒ… íŒ©í† ë¦¬ ìƒì„±ìëŠ” í¬ì›Œë”ê°€ í˜•ì‹ ë§¤ê°œë³€ìˆ˜ì™€ ê¸°ë³¸ê°’ì„ ë°˜ë³µí•  í•„ìš”ë¥¼ ì—†ì•¤ë‹¤.
    

### **Constructor tear-offs[#](https://dart.dev/language/constructors#constructor-tear-offs) ìƒì„±ì í‹°ì–´ ì˜¤í”„**

**Dart allows you to supply a constructor as a parameter without calling it. Called a _tear-off_ (as you _tear off_ the parentheses) serves as a closure that invokes the constructor with the same parameters.**

Dartì—ì„œëŠ” ìƒì„±ìë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šê³  ë§¤ê°œë³€ìˆ˜ë¡œ ì œê³µí•  ìˆ˜ ìˆë‹¤. ì´ê²ƒì„ tear-offë¼ê³  í•˜ë©°, ê´„í˜¸ë¥¼ ë–¼ì–´ë‚¸ë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤. tear-offëŠ” ë™ì¼í•œ ë§¤ê°œë³€ìˆ˜ë¡œ ìƒì„±ìë¥¼ í˜¸ì¶œí•˜ëŠ” í´ë¡œì €ë¡œ ë™ì‘í•œë‹¤.

-   **[Q] ìƒì„±ìë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šê³  ë§¤ê°œë³€ìˆ˜ë¡œ ì œê³µ?**
    
    Dartì—ì„œëŠ” ìƒì„±ìë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šê³  ë§¤ê°œë³€ìˆ˜ë¡œ ì œê³µí•  ìˆ˜ ìˆë‹¤ëŠ” ë§ì€, **ìƒì„±ì ê·¸ ìì²´ë¥¼ í•¨ìˆ˜ë‚˜ ë©”ì„œë“œì˜ ì¸ìˆ˜ë¡œ ë„˜ê¸¸ ìˆ˜ ìˆë‹¤ëŠ” ëœ»**ì´ë‹¤. ì´ë¥¼ í†µí•´ í•´ë‹¹ ìƒì„±ìë¥¼ ë‚˜ì¤‘ì— í•„ìš”í•  ë•Œ í˜¸ì¶œ í•  ìˆ˜ ìˆë‹¤.
    
-   **[Q] í‹°ì–´ì˜¤í”„ì˜ ì¥ì ? ì‚¬ìš© ì´ìœ ?**
    
    **ì§€ì—° í˜¸ì¶œ**
    
    ìƒì„±ìë¥¼ ë‚˜ì¤‘ì— í•„ìš”í•  ë•Œ í˜¸ì¶œí•  ìˆ˜ ìˆë‹¤.
    
    **ì½œë°± í•¨ìˆ˜ë¡œ ì‚¬ìš©**
    
    ìƒì„±ìë¥¼ ì½œë°± í•¨ìˆ˜ë¡œ ì „ë‹¬í•˜ì—¬, í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ê°ì²´ë¥¼ ìƒì„±í•  ìˆ˜ ìˆë‹¤.
    
    **ì½”ë“œ ê°€ë…ì„± í–¥ìƒ**
    
    ìƒì„±ì ì°¸ì¡°ë¥¼ ì§ì ‘ ë„˜ê¹€ìœ¼ë¡œì¨, ì½”ë“œê°€ ë” ê°„ê²°í•˜ê³  ì´í•´í•˜ê¸° ì‰¬ì›Œì§„ë‹¤.
    

**If the tear-off is a constructor with the same signature and return type as the method accepts, you can use the tear-off as a parameter or variable.**

í‹°ì–´ ì˜¤í”„ê°€ ë©”ì„œë“œê°€ ë°›ì•„ë“¤ì´ëŠ” ë§¤ê°œë³€ìˆ˜ì™€ ë°˜í™˜ íƒ€ì…ì´ ë™ì¼í•œ ìƒì„±ìì¸ ê²½ìš°, ì´ë¥¼ ë§¤ê°œë³€ìˆ˜ë‚˜ ë³€ìˆ˜ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

**Tear-offs differ from lambdas or anonymous functions. Lambdas serve as a wrapper for the constructor whereas a tear-off is the constructor.**

í‹°ì–´ ì˜¤í”„ëŠ” ëŒë‹¤ ë˜ëŠ” ìµëª… í•¨ìˆ˜ì™€ ë‹¤ë¥´ë‹¤. ëŒë‹¤ëŠ” ìƒì„±ìë¥¼ ë˜í•‘í•˜ëŠ” ë°˜ë©´, í‹°ì–´ ì˜¤í”„ëŠ” ìƒì„±ìì´ë‹¤.

**Use Tear-Offs** í‹°ì–´ ì˜¤í”„ ì‚¬ìš© ì˜ˆì‹œ

**Good**

```dart
// Use a tear-off for a named constructor: 
// ëª…ëª…ëœ ìƒì„±ìì— ëŒ€í•œ í‹°ì–´ ì˜¤í”„ ì‚¬ìš©:
var strings = charCodes.map(String.fromCharCode);  

// Use a tear-off for an unnamed constructor: 
// ì´ë¦„ì´ ì—†ëŠ” ìƒì„±ìì— ëŒ€í•œ í‹°ì–´ ì˜¤í”„ ì‚¬ìš©:
var buffers = charCodes.map(StringBuffer.new);

```

-   **[code] í‹°ì–´ì˜¤í”„ ì‚¬ìš© ì˜ˆì‹œ**
    
    **í•¨ìˆ˜ tear-off**
    
    ```dart
    void sayHello(String name) {
      print('Hello, $name!');
    }
    
    void main() {
      // í•¨ìˆ˜ ì°¸ì¡°ë¥¼ ë³€ìˆ˜ì— ì €ì¥
      var greet = sayHello;
    
      // ë‚˜ì¤‘ì— í•¨ìˆ˜ í˜¸ì¶œ
      greet('Alice'); // ì¶œë ¥: Hello, Alice!
    }
    
    ```
    
    **ìƒì„±ì tear-off**
    
    ```dart
    class Person {
      String name;
    
      Person(this.name);
    
      @override
      String toString() => 'Person(name: $name)';
    }
    
    void main() {
      // ìƒì„±ì ì°¸ì¡°ë¥¼ ë³€ìˆ˜ì— ì €ì¥
      var personMaker = Person.new;
    
      // ë‚˜ì¤‘ì— ìƒì„±ì í˜¸ì¶œ
      var person = personMaker('Bob');
      print(person); // ì¶œë ¥: Person(name: Bob)
    }
    
    ```
    

**Not Lambdas** ëŒë‹¤ ëŒ€ì‹ 

**Bad**

```dart
// Instead of a lambda for a named constructor:
// ëª…ëª…ëœ ìƒì„±ìì— ëŒ€í•œ ëŒë‹¤ ëŒ€ì‹ :
var strings = charCodes.map((code) => String.fromCharCode(code));

// Instead of a lambda for an unnamed constructor:
// ì´ë¦„ì´ ì—†ëŠ” ìƒì„±ìì— ëŒ€í•œ ëŒë‹¤ ëŒ€ì‹ :
var buffers = charCodes.map((code) => StringBuffer(code));

```

-   **[Q] ëŒë‹¤ì™€ì˜ ì°¨ì´ì **
    
    **ëŒë‹¤**
    
    ëŒë‹¤ëŠ” í•¨ìˆ˜ë‚˜ ìƒì„±ìë¥¼ ê°ì‹¸ëŠ” ë˜í¼ì´ë‹¤. ëŒë‹¤ëŠ” ìƒˆë¡œìš´ í•¨ìˆ˜ë¡œ, ë‚´ë¶€ì—ì„œ ë‹¤ë¥¸ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œë‹¤.
    
    **tear-off**:
    
    tear-offëŠ” í•¨ìˆ˜ë‚˜ ìƒì„±ì ìì²´ë¥¼ ê°€ë¦¬í‚¨ë‹¤. ì¦‰, ì¶”ê°€ì ì¸ ë˜í¼ ì—†ì´ ì›ë˜ì˜ í•¨ìˆ˜ë‚˜ ìƒì„±ìë¥¼ ì°¸ì¡°í•œë‹¤.
    

**For visual learners, watch this Decoding Flutter video on tear-offs.**

ì‹œê°ì  í•™ìŠµì„ ìœ„í•´, ìƒì„±ì í‹°ì–´ ì˜¤í”„ì— ëŒ€í•œ Decoding Flutter ì˜ìƒì„ ì‹œì²­í•´ë³´ì„¸ìš”.


## **Instance Variable Initialization[#](https://dart.dev/language/constructors#instance-variable-initialization) ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ ì´ˆê¸°í™”**

**Dart can initialize variables in three ways.**

DartëŠ” ë³€ìˆ˜ë¥¼ ì„¸ ê°€ì§€ ë°©ì‹ìœ¼ë¡œ ì´ˆê¸°í™”í•  ìˆ˜ ìˆë‹¤.

### **Initialize instance variables in the declaration[#](https://dart.dev/language/constructors#initialize-instance-variables-in-the-declaration) ë³€ìˆ˜ ì„ ì–¸ ì‹œ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ ì´ˆê¸°í™”**

**Initialize the instance variables when you declare the variables.**

ë³€ìˆ˜ë¥¼ ì„ ì–¸í•  ë•Œ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”í•œë‹¤.

```dart
class PointA {
  double x = 1.0;
  double y = 2.0;

  // The implicit default constructor sets these variables to (1.0,2.0)
  // ê¸°ë³¸ ìƒì„±ìëŠ” ì´ ë³€ìˆ˜ë¥¼ (1.0, 2.0)ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
  // PointA();

  @override
  String toString() {
    return 'PointA($x, $y)';
  }
}

```

### **Use initializing formal parameters[#](https://dart.dev/language/constructors#use-initializing-formal-parameters) ì´ˆê¸°í™” í˜•ì‹ ë§¤ê°œë³€ìˆ˜ ì‚¬ìš©**

**To simplify the common pattern of assigning a constructor argument to an instance variable, Dart has _initializing formal parameters_.**

ìƒì„±ì ì¸ìˆ˜ë¥¼ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ì— í• ë‹¹í•˜ëŠ” ì¼ë°˜ì ì¸ íŒ¨í„´ì„ ë‹¨ìˆœí™”í•˜ê¸° ìœ„í•´ DartëŠ” ì´ˆê¸°í™” í˜•ì‹ ë§¤ê°œë³€ìˆ˜ë¥¼ ì œê³µí•œë‹¤.

**In the constructor declaration, include `this.<propertyName>` and omit the body. The `this` keyword refers to the current instance.**

ìƒì„±ì ì„ ì–¸ì—ì„œ this.<propertyName>ì„ í¬í•¨í•˜ê³  ë³¸ë¬¸ì„ ìƒëµí•œë‹¤. this í‚¤ì›Œë“œëŠ” í˜„ì¬ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì°¸ì¡°í•œë‹¤.

**When the name conflict exists, use `this`. Otherwise, Dart style omits the `this`. An exception exists for the generative constructor where you must prefix the initializing formal parameter name with `this`.**

ì´ë¦„ ì¶©ëŒì´ ë°œìƒí•˜ë©´ thisë¥¼ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ Dart ìŠ¤íƒ€ì¼ì—ì„œëŠ” thisë¥¼ ìƒëµí•œë‹¤. ìƒì„± ìƒì„±ìì˜ ê²½ìš°, ì´ˆê¸°í™” í˜•ì‹ ë§¤ê°œë³€ìˆ˜ ì´ë¦„ ì•ì— thisë¥¼ ì ‘ë‘ì‚¬ë¡œ ë¶™ì—¬ì•¼ í•œë‹¤.

**As noted earlier in this guide, certain constructors and certain parts of constructors can't access `this`. These include:**

ì´ ê°€ì´ë“œì—ì„œ ì•ì„œ ì–¸ê¸‰í•œ ê²ƒì²˜ëŸ¼, íŠ¹ì • ìƒì„±ìì™€ ìƒì„±ìì˜ íŠ¹ì • ë¶€ë¶„ì€ thisì— ì ‘ê·¼í•  ìˆ˜ ì—†ë‹¤. ì—¬ê¸°ì—ëŠ” ë‹¤ìŒì´ í¬í•¨ëœë‹¤:

-   **Factory constructors**
    
    íŒ©í† ë¦¬ ìƒì„±ì
    
-   **The right-hand side of an initializer list**
    
    ì´ˆê¸°í™” ëª©ë¡ì˜ ì˜¤ë¥¸ìª½
    
-   **Arguments to a superclass constructor**
    
    ìƒìœ„ í´ë˜ìŠ¤ ìƒì„±ìì˜ ì¸ìˆ˜
    

**Initializing formal parameters also allow you to initialize non-nullable or `final` instance variables. Both of these types of variables require initialization or a default value.**

ì´ˆê¸°í™” í˜•ì‹ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ë„ì´ ë  ìˆ˜ ì—†ëŠ” ë³€ìˆ˜ ë˜ëŠ” final ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”í•  ìˆ˜ ìˆë‹¤. ì´ëŸ¬í•œ ìœ í˜•ì˜ ë³€ìˆ˜ëŠ” ì´ˆê¸°í™” ë˜ëŠ” ê¸°ë³¸ê°’ì´ í•„ìš”í•˜ë‹¤.

```dart
class PointB {
  final double x;
  final double y;

  // Sets the x and y instance variables
  // before the constructor body runs.
  // ìƒì„±ì ë³¸ë¬¸ì´ ì‹¤í–‰ë˜ê¸° ì „ì— xì™€ y ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
  PointB(this.x, this.y);

  // Initializing formal parameters can also be optional.
	// ì´ˆê¸°í™” í˜•ì‹ ë§¤ê°œë³€ìˆ˜ëŠ” ì„ íƒ ì‚¬í•­ì¼ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
  PointB.optional([this.x = 0.0, this.y = 0.0]);
}

```

**Private fields can't be used as named initializing formals.**

í”„ë¼ì´ë¹— í•„ë“œëŠ” ëª…ëª…ëœ ì´ˆê¸°í™” í˜•ì‹ ë§¤ê°œë³€ìˆ˜ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.

```dart
class PointB {
// ...

  PointB.namedPrivate({required double x, required double y})
      : _x = x,
        _y = y;

// ...
}

```

**This also works with named variables.**

ì´ ë°©ë²•ì€ ì´ë¦„ ìˆëŠ” ë³€ìˆ˜ì—ë„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```dart
class PointC {
  double x; // must be set in constructor ìƒì„±ìì—ì„œ ì„¤ì •í•´ì•¼ í•¨
  double y; // must be set in constructor ìƒì„±ìì—ì„œ ì„¤ì •í•´ì•¼ í•¨

  // Generative constructor with initializing formal parameters
  // with default values
  // ê¸°ë³¸ê°’ì„ ê°–ëŠ” ì´ˆê¸°í™” í˜•ì‹ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ìƒì„± ìƒì„±ì
  PointC.named({this.x = 1.0, this.y = 1.0});

  @override
  String toString() {
    return 'PointC.named($x,$y)';
  }
}

// Constructor using named variables.
// ì´ë¦„ ìˆëŠ” ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ìƒì„±ì.
final pointC = PointC.named(x: 2.0, y: 2.0);

```

**All variables introduced from initializing formal parameters are both final and only in scope of the initialized variables.**

ì´ˆê¸°í™” í˜•ì‹ ë§¤ê°œë³€ìˆ˜ë¡œ ë„ì…ëœ ëª¨ë“  ë³€ìˆ˜ëŠ” finalì´ë©° ì´ˆê¸°í™”ëœ ë³€ìˆ˜ì˜ ë²”ìœ„ ë‚´ì—ë§Œ ì¡´ì¬í•œë‹¤.

**To perform logic that you can't express in the initializer list, create a [factory constructor](https://dart.dev/language/constructors#factory-constructors) or [static method](https://dart.dev/language/classes#static-methods) with that logic. You can then pass the computed values to a normal constructor.**

ì´ˆê¸°í™” ëª©ë¡ì—ì„œ í‘œí˜„í•  ìˆ˜ ì—†ëŠ” ë¡œì§ì„ ìˆ˜í–‰í•˜ë ¤ë©´ íŒ©í† ë¦¬ ìƒì„±ìë‚˜ í•´ë‹¹ ë¡œì§ì„ í¬í•¨í•˜ëŠ” ì •ì  ë©”ì„œë“œë¥¼ ìƒì„±í•˜ë¼. ê·¸ëŸ° ë‹¤ìŒ ê³„ì‚°ëœ ê°’ì„ ì¼ë°˜ ìƒì„±ìì— ì „ë‹¬í•  ìˆ˜ ìˆë‹¤.

**The constructor parameters could be set as nullable and not be initialized.**

ìƒì„±ì ë§¤ê°œë³€ìˆ˜ëŠ” nullableë¡œ ì„¤ì •ë  ìˆ˜ ìˆìœ¼ë©° ì´ˆê¸°í™”ë˜ì§€ ì•Šì„ ìˆ˜ë„ ìˆë‹¤.

```dart
class PointD {
  double? x; // null if not set in constructor ìƒì„±ìì—ì„œ ì„¤ì •ë˜ì§€ ì•Šìœ¼ë©´ null
  double? y; // null if not set in constructor ìƒì„±ìì—ì„œ ì„¤ì •ë˜ì§€ ì•Šìœ¼ë©´ null

  // Generative constructor with initializing formal parameters  
  // ì´ˆê¸°í™” í˜•ì‹ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ìƒì„± ìƒì„±ì
  PointD(this.x, this.y);

  @override
  String toString() {
    return 'PointD($x,$y)';
  }
}

```

### **Use an initializer list[#](https://dart.dev/language/constructors#use-an-initializer-list) ì´ˆê¸°í™” ëª©ë¡ ì‚¬ìš©**

**Before the constructor body runs, you can initialize instance variables. Separate initializers with commas.**

ìƒì„±ì ë³¸ë¬¸ì´ ì‹¤í–‰ë˜ê¸° ì „ì— ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”í•  ìˆ˜ ìˆë‹¤. ì´ˆê¸°í™”ìëŠ” ì½¤ë§ˆë¡œ êµ¬ë¶„í•œë‹¤.

```dart
// ì´ˆê¸°í™” ëª©ë¡ì€ ìƒì„±ì ë³¸ë¬¸ì´ ì‹¤í–‰ë˜ê¸° ì „ì— ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
Point.fromJson(Map<String, double> json)
    : x = json['x']!,
      y = json['y']! {
  print('In Point.fromJson(): ($x, $y)');
}

```

<aside> â„¹ï¸ **Warning**

**The right-hand side of an initializer list can't access `this`.**

ì´ˆê¸°í™” ëª©ë¡ì˜ ì˜¤ë¥¸ìª½ì—ì„œëŠ” thisì— ì ‘ê·¼í•  ìˆ˜ ì—†ë‹¤.

</aside>

**To validate inputs during development, use `assert` in the initializer list.**

ê°œë°œ ì¤‘ ì…ë ¥ê°’ì„ ê²€ì¦í•˜ë ¤ë©´ ì´ˆê¸°í™” ëª©ë¡ì—ì„œ assertë¥¼ ì‚¬ìš©í•˜ë¼.

```dart
Point.withAssert(this.x, this.y) : assert(x >= 0) {
  print('In Point.withAssert(): ($x, $y)');
}

```

**Initializer lists help set up `final` fields.**

ì´ˆê¸°í™” ëª©ë¡ì€ final í•„ë“œë¥¼ ì„¤ì •í•˜ëŠ” ë° ë„ì›€ì´ ëœë‹¤.

**The following example initializes three `final` fields in an initializer list. To execute the code, click Run.**

ë‹¤ìŒ ì˜ˆì œëŠ” ì´ˆê¸°í™” ëª©ë¡ì—ì„œ ì„¸ ê°œì˜ final í•„ë“œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤. ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë ¤ë©´ Runì„ í´ë¦­í•˜ë¼.

```dart
import 'dart:math';

class Point {
  final double x;
  final double y;
  final double distanceFromOrigin;

  Point(double x, double y)
      : x = x,
        y = y,
        distanceFromOrigin = sqrt(x * x + y * y);
}

void main() {
  var p = Point(2, 3);
  print(p.distanceFromOrigin);
}

```

```dart
// ì¶œë ¥ ê²°ê³¼
3.605551275463989

```

----------

## **Constructor inheritance[#](https://dart.dev/language/constructors#constructor-inheritance) ìƒì„±ì ìƒì†**

**_Subclasses_, or child classes, don't inherit _constructors_ from their _superclass_, or immediate parent class. If a class doesn't declare a constructor, it can only use the [default constructor](https://dart.dev/language/constructors#default-constructors).**

ì„œë¸Œí´ë˜ìŠ¤(ë˜ëŠ” ìì‹ í´ë˜ìŠ¤)ëŠ” ìƒìœ„ í´ë˜ìŠ¤(ë˜ëŠ” ì¦‰ì‹œ ìƒìœ„ í´ë˜ìŠ¤)ì˜ ìƒì„±ìë¥¼ ìƒì†í•˜ì§€ ì•ŠëŠ”ë‹¤. í´ë˜ìŠ¤ê°€ ìƒì„±ìë¥¼ ì„ ì–¸í•˜ì§€ ì•Šìœ¼ë©´ ê¸°ë³¸ ìƒì„±ìë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

**A class can inherit the _parameters_ of a superclass. These are called [super parameters](https://dart.dev/language/constructors#super-parameters)**

í´ë˜ìŠ¤ëŠ” ìƒìœ„ í´ë˜ìŠ¤ì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ìƒì†í•  ìˆ˜ ìˆë‹¤. ì´ëŸ¬í•œ ë§¤ê°œë³€ìˆ˜ë¥¼ super ë§¤ê°œë³€ìˆ˜ë¼ê³  í•œë‹¤.

**Constructors work in a somewhat similar way to how you call a chain of static methods. Each subclass can call its superclass's constructor to initialize an instance, like a subclass can call a superclass's static method. This process doesn't "inherit" constructor bodies or signatures.**

ìƒì„±ìëŠ” ì²´ì¸ìœ¼ë¡œ ì •ì  ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ë°©ì‹ê³¼ ë‹¤ì†Œ ìœ ì‚¬í•˜ê²Œ ì‘ë™í•œë‹¤. ê° ì„œë¸Œí´ë˜ìŠ¤ëŠ” ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì´ˆê¸°í™”í•˜ê¸° ìœ„í•´ ìƒìœ„ í´ë˜ìŠ¤ì˜ ìƒì„±ìë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” ì„œë¸Œí´ë˜ìŠ¤ê°€ ìƒìœ„ í´ë˜ìŠ¤ì˜ ì •ì  ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ë°©ì‹ê³¼ ìœ ì‚¬í•˜ë‹¤. ì´ ê³¼ì •ì€ ìƒì„±ì ë³¸ë¬¸ì´ë‚˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ â€œìƒì†â€í•˜ì§€ ì•ŠëŠ”ë‹¤.

### **Non-default superclass constructors[#](https://dart.dev/language/constructors#non-default-superclass-constructors) ê¸°ë³¸ê°’ì´ ì•„ë‹Œ ìƒìœ„ í´ë˜ìŠ¤ ìƒì„±ì**

**Dart executes constructors in the following order:**

DartëŠ” ìƒì„±ìë¥¼ ë‹¤ìŒ ìˆœì„œë¡œ ì‹¤í–‰í•œë‹¤:

1.  [**initializer list**](https://dart.dev/language/constructors#use-an-initializer-list)
    
    ì´ˆê¸°í™” ëª©ë¡
    
2.  **superclass's unnamed, no-arg constructor**
    
    ìƒìœ„ í´ë˜ìŠ¤ì˜ ì´ë¦„ì´ ì—†ëŠ” ì¸ìˆ˜ê°€ ì—†ëŠ” ìƒì„±ì
    
3.  **main class's no-arg constructor**
    
    ë©”ì¸ í´ë˜ìŠ¤ì˜ ì¸ìˆ˜ê°€ ì—†ëŠ” ìƒì„±ì
    

**If the superclass lacks an unnamed, no-argument constructor, call one of the constructors in the superclass. Before the constructor body (if any), specify the superclass constructor after a colon (`:`).**

ìƒìœ„ í´ë˜ìŠ¤ì— ì´ë¦„ì´ ì—†ëŠ” ì¸ìˆ˜ê°€ ì—†ëŠ” ìƒì„±ìê°€ ì—†ëŠ” ê²½ìš°, ìƒìœ„ í´ë˜ìŠ¤ì˜ ë‹¤ë¥¸ ìƒì„±ì ì¤‘ í•˜ë‚˜ë¥¼ í˜¸ì¶œí•´ì•¼ í•œë‹¤. ìƒì„±ì ë³¸ë¬¸(ìˆëŠ” ê²½ìš°) ì „ì— ì½œë¡ (:)ì„ ì‚¬ìš©í•˜ì—¬ ìƒìœ„ í´ë˜ìŠ¤ ìƒì„±ìë¥¼ ì§€ì •í•œë‹¤.

**In the following example, the `Employee` class constructor calls the named constructor for its superclass, `Person`. To execute the following code, click Run.**

ë‹¤ìŒ ì˜ˆì œì—ì„œ, Employee í´ë˜ìŠ¤ ìƒì„±ìëŠ” ìƒìœ„ í´ë˜ìŠ¤ Personì˜ ëª…ëª…ëœ ìƒì„±ìë¥¼ í˜¸ì¶œí•œë‹¤. ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë ¤ë©´ Runì„ í´ë¦­í•˜ë¼.

```dart
class Person {
  String? firstName;

  Person.fromJson(Map data) {
    print('in Person');
  }
}

class Employee extends Person {
  // Person does not have a default constructor;
  // you must call super.fromJson().
  Employee.fromJson(Map data) : super.fromJson(data) {
    print('in Employee');
  }
}

void main() {
  var employee = Employee.fromJson({});
  print(employee);
  // Prints:
  // in Person
  // in Employee
  // Instance of 'Employee'
}

```

```dart
// ì¶œë ¥ ê²°ê³¼
in Person
in Employee
Instance of 'Employee'

```

**As Dart evaluates the arguments to the superclass constructor _before_ invoking the constructor, an argument can be an expression like a function call.**

DartëŠ” ìƒì„±ìë¥¼ í˜¸ì¶œí•˜ê¸° ì „ì— ìƒìœ„ í´ë˜ìŠ¤ ìƒì„±ìì˜ ì¸ìˆ˜ë¥¼ í‰ê°€í•˜ë¯€ë¡œ, ì¸ìˆ˜ëŠ” í•¨ìˆ˜ í˜¸ì¶œê³¼ ê°™ì€ í‘œí˜„ì‹ì¼ ìˆ˜ ìˆë‹¤.

```dart
class Employee extends Person {
  Employee() : super.fromJson(fetchDefaultData());
  // Â·Â·Â·
}

```

<aside> â„¹ï¸ **Warning**

**Arguments to the superclass constructor can't access `this`. For example, arguments can call _static_ methods but not _instance_ methods.**

ìƒìœ„ í´ë˜ìŠ¤ ìƒì„±ìì— ì „ë‹¬ë˜ëŠ” ì¸ìˆ˜ëŠ” thisì— ì ‘ê·¼í•  ìˆ˜ ì—†ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì¸ìˆ˜ëŠ” ì •ì  ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆì§€ë§Œ ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ìˆ˜ëŠ” ì—†ë‹¤.

</aside>

### **Super parameters[#](https://dart.dev/language/constructors#super-parameters) ìŠˆí¼ ë§¤ê°œë³€ìˆ˜**

**To avoid passing each parameter into the super invocation of a constructor, use super-initializer parameters to forward parameters to the specified or default superclass constructor. You can't use this feature with [redirecting constructors](https://dart.dev/language/constructors#redirecting-constructors). Super-initializer parameters have syntax and semantics like [initializing formal parameters](https://dart.dev/language/constructors#use-initializing-formal-parameters).**

ê° ë§¤ê°œë³€ìˆ˜ë¥¼ ìƒì„±ìì˜ super í˜¸ì¶œì— ì „ë‹¬í•˜ëŠ” ê²ƒì„ í”¼í•˜ê¸° ìœ„í•´, super ì´ˆê¸°í™” ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì§€ì •ëœ ìƒìœ„ í´ë˜ìŠ¤ ìƒì„±ìë‚˜ ê¸°ë³¸ ìƒìœ„ í´ë˜ìŠ¤ ìƒì„±ìì— ë§¤ê°œë³€ìˆ˜ë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤. ì´ ê¸°ëŠ¥ì€ ë¦¬ë””ë ‰íŒ… ìƒì„±ìì—ì„œëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤. Super ì´ˆê¸°í™” ë§¤ê°œë³€ìˆ˜ëŠ” ì´ˆê¸°í™” í˜•ì‹ ë§¤ê°œë³€ìˆ˜ì™€ ìœ ì‚¬í•œ êµ¬ë¬¸ê³¼ ì˜ë¯¸ë¥¼ ê°€ì§„ë‹¤.

<aside> â„¹ï¸ **Version note**

**Using super-initializer parameters requires a [language version](https://dart.dev/guides/language/evolution#language-versioning) of at least 2.17. If you're using an earlier language version, you must manually pass in all super constructor parameters.**

ìŠˆí¼ ì´ˆê¸°í™” ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ì–¸ì–´ ë²„ì „ì´ ìµœì†Œ 2.17 ì´ìƒì´ì–´ì•¼ í•œë‹¤. ì´ì „ ì–¸ì–´ ë²„ì „ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš°, ëª¨ë“  ìŠˆí¼ ìƒì„±ì ë§¤ê°œë³€ìˆ˜ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì „ë‹¬í•´ì•¼ í•œë‹¤.

</aside>

**If the super-constructor invocation includes positional arguments, super-initializer parameters can't be positional.**

ìŠˆí¼ ìƒì„±ì í˜¸ì¶œì— ìœ„ì¹˜ ì¸ìˆ˜ê°€ í¬í•¨ëœ ê²½ìš°, ìŠˆí¼ ì´ˆê¸°í™” ë§¤ê°œë³€ìˆ˜ëŠ” ìœ„ì¹˜ ì¸ìˆ˜ê°€ ë  ìˆ˜ ì—†ë‹¤.

```dart
class Vector2d {
  final double x;
  final double y;

  Vector2d(this.x, this.y);
}

class Vector3d extends Vector2d {
  final double z;

  // Forward the x and y parameters to the default super constructor like:  
  // xì™€ y ë§¤ê°œë³€ìˆ˜ë¥¼ ê¸°ë³¸ ìƒìœ„ ìƒì„±ìë¡œ ì „ë‹¬:
  // Vector3d(final double x, final double y, this.z) : super(x, y);
  Vector3d(super.x, super.y, this.z);
}

```

**To further illustrate, consider the following example.**

ë” ì„¤ëª…í•˜ê¸° ìœ„í•´, ë‹¤ìŒ ì˜ˆì œë¥¼ ê³ ë ¤í•˜ë¼.

```dart
  // If you invoke the super constructor (`super(0)`) with any
  // positional arguments, using a super parameter (`super.x`)
  // results in an error.
  // ìœ„ì¹˜ ì¸ìˆ˜(`super(0)`)ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒìœ„ ìƒì„±ìë¥¼ í˜¸ì¶œí•˜ë©´
	// ìŠˆí¼ ë§¤ê°œë³€ìˆ˜(`super.x`)ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤.
  Vector3d.xAxisError(super.x): z = 0, super(0); // BAD

```

**This named constructor tries to set the `x` value twice: once in the super constructor and once as a positional super parameter. As both address the `x` positional parameter, this results in an error.**

ì´ ëª…ëª…ëœ ìƒì„±ìëŠ” ìƒìœ„ ìƒì„±ìì—ì„œ í•œ ë²ˆ, ìœ„ì¹˜ ìŠˆí¼ ë§¤ê°œë³€ìˆ˜ì—ì„œ í•œ ë²ˆ, ë‘ ë²ˆ x ê°’ì„ ì„¤ì •í•˜ë ¤ê³  í•œë‹¤. ë‘ ë§¤ê°œë³€ìˆ˜ê°€ x ìœ„ì¹˜ ì¸ìˆ˜ë¥¼ ì°¸ì¡°í•˜ë¯€ë¡œ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.

**When the super constructor has named arguments, you can split them between named super parameters (`super.y` in the next example) and named arguments to the super constructor invocation (`super.named(x: 0)`).**

ìƒìœ„ ìƒì„±ìì— ëª…ëª…ëœ ì¸ìˆ˜ê°€ ìˆëŠ” ê²½ìš°, ì´ë¥¼ ëª…ëª…ëœ ìŠˆí¼ ë§¤ê°œë³€ìˆ˜(super.yì™€ ê°™ì€)ì™€ ìƒìœ„ ìƒì„±ì í˜¸ì¶œì˜ ëª…ëª…ëœ ì¸ìˆ˜(super.named(x: 0))ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆë‹¤.

```dart
class Vector2d {
  // ...
  Vector2d.named({required this.x, required this.y});
}

class Vector3d extends Vector2d {
  final double z;

  // Forward the y parameter to the named super constructor like:
  // y ë§¤ê°œë³€ìˆ˜ë¥¼ ëª…ëª…ëœ ìŠˆí¼ ìƒì„±ìë¡œ ì „ë‹¬:  
  // Vector3d.yzPlane({required double y, required this.z})
  //       : super.named(x: 0, y: y);
  Vector3d.yzPlane({required super.y, required this.z}) : super.named(x: 0);
}

```

---

ğŸ”— [í˜ì´ì§€ ë§í¬]

# **Methods**

**Methods are functions that provide behavior for an object.**

ë©”ì„œë“œëŠ” ê°ì²´ì— ë™ì‘ì„ ì œê³µí•˜ëŠ” í•¨ìˆ˜ì´ë‹¤.


## **Instance methods[#](https://dart.dev/language/methods#instance-methods) ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œ**

**Instance methods on objects can access instance variables and `this`. The `distanceTo()` method in the following sample is an example of an instance method:**

ê°ì²´ì˜ ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œëŠ” ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ì™€ thisì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤. ë‹¤ìŒ ì˜ˆì œì˜ distanceTo() ë©”ì„œë“œëŠ” ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œì˜ ì˜ˆì´ë‹¤:

```dart
import 'dart:math';

class Point {
  final double x;
  final double y;

  // Sets the x and y instance variables
  // before the constructor body runs.
  Point(this.x, this.y);

  double distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}

```

----------

## **Operators[#](https://dart.dev/language/methods#operators) ì—°ì‚°ì**

**Most operators are instance methods with special names. Dart allows you to define operators with the following names:**

ëŒ€ë¶€ë¶„ì˜ ì—°ì‚°ìëŠ” íŠ¹ìˆ˜ ì´ë¦„ì„ ê°€ì§„ ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œì´ë‹¤. DartëŠ” ë‹¤ìŒ ì´ë¦„ì˜ ì—°ì‚°ìë¥¼ ì •ì˜í•  ìˆ˜ ìˆë‹¤:

<

>

<=

>=

==

~

-

+

/

~/

*

%

Ë†

&

<<

>>>

[]=

[]

<aside> â„¹ï¸ **Note**

**You may have noticed that some [operators](https://dart.dev/language/operators), like `!=`, aren't in the list of names. These operators aren't instance methods. Their behavior is built in to Dart.**

!= ê°™ì€ ì¼ë¶€ ì—°ì‚°ìê°€ ì´ë¦„ ëª©ë¡ì— ì—†ìŒì„ ëˆˆì¹˜ì±˜ì„ ê²ƒì´ë‹¤. ì´ëŸ¬í•œ ì—°ì‚°ìëŠ” ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œê°€ ì•„ë‹ˆë‹¤. ì´ë“¤ì˜ ë™ì‘ì€ Dartì— ë‚´ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

</aside>

**To declare an operator, use the built-in identifier `operator` then the operator you are defining. The following example defines vector addition (`+`), subtraction (`-`), and equality (`==`):**

ì—°ì‚°ìë¥¼ ì„ ì–¸í•˜ë ¤ë©´ ë‚´ì¥ ì‹ë³„ìì¸ operatorì™€ ì •ì˜í•  ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ë¼. ë‹¤ìŒ ì˜ˆì œëŠ” ë²¡í„° ë§ì…ˆ(+), ëº„ì…ˆ(-), ê·¸ë¦¬ê³  ë™ë“±ì„±(==)ì„ ì •ì˜í•œë‹¤:

```dart
class Vector {
  final int x, y;

  Vector(this.x, this.y);

  Vector operator +(Vector v) => Vector(x + v.x, y + v.y);
  Vector operator -(Vector v) => Vector(x - v.x, y - v.y);

  @override
  bool operator ==(Object other) =>
      other is Vector && x == other.x && y == other.y;

  @override
  int get hashCode => Object.hash(x, y);
}

void main() {
  final v = Vector(2, 3);
  final w = Vector(2, 2);

  assert(v + w == Vector(4, 5));
  assert(v - w == Vector(0, 1));
}

```

----------

## **Getters and setters[#](https://dart.dev/language/methods#getters-and-setters)** ê²Œí„°ì™€ ì„¸í„°

**Getters and setters are special methods that provide read and write access to an object's properties. Recall that each instance variable has an implicit getter, plus a setter if appropriate. You can create additional properties by implementing getters and setters, using the `get` and `set` keywords:**

getterì™€ setterëŠ” ê°ì²´ì˜ ì†ì„±ì— ëŒ€í•œ ì½ê¸° ë° ì“°ê¸° ì ‘ê·¼ì„ ì œê³µí•˜ëŠ” íŠ¹ìˆ˜ ë©”ì„œë“œì´ë‹¤. ê° ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ëŠ” ì•”ì‹œì ì¸ getterë¥¼ ê°€ì§€ë©°, í•„ìš”ì— ë”°ë¼ setterë„ ê°€ì§ˆ ìˆ˜ ìˆë‹¤. getê³¼ set í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ getterì™€ setterë¥¼ êµ¬í˜„í•¨ìœ¼ë¡œì¨ ì¶”ê°€ ì†ì„±ì„ ìƒì„±í•  ìˆ˜ ìˆë‹¤:

```dart
class Rectangle {
  double left, top, width, height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Define two calculated properties: right and bottom.
  double get right => left + width;
  set right(double value) => left = value - width;
  double get bottom => top + height;
  set bottom(double value) => top = value - height;
}

void main() {
  var rect = Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}

```

**With getters and setters, you can start with instance variables, later wrapping them with methods, all without changing client code.**

Getterì™€ setterë¥¼ ì‚¬ìš©í•˜ë©´ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¡œ ì‹œì‘í•˜ì—¬ ë‚˜ì¤‘ì— ë©”ì„œë“œë¡œ ë˜í•‘í•  ìˆ˜ ìˆìœ¼ë©°, í´ë¼ì´ì–¸íŠ¸ ì½”ë“œë¥¼ ë³€ê²½í•˜ì§€ ì•Šì•„ë„ ëœë‹¤.

<aside> â„¹ï¸ **Note**

**Operators such as increment (++) work in the expected way, whether or not a getter is explicitly defined. To avoid any unexpected side effects, the operator calls the getter exactly once, saving its value in a temporary variable.**

ì¦ê°€(++)ì™€ ê°™ì€ ì—°ì‚°ìëŠ” getterê°€ ëª…ì‹œì ìœ¼ë¡œ ì •ì˜ë˜ì§€ ì•Šì•˜ë”ë¼ë„ ì˜ˆìƒëŒ€ë¡œ ì‘ë™í•©ë‹ˆë‹¤. ì˜ˆê¸°ì¹˜ ì•Šì€ ë¶€ì‘ìš©ì„ í”¼í•˜ê¸° ìœ„í•´ ì—°ì‚°ìëŠ” getterë¥¼ ì •í™•íˆ í•œ ë²ˆ í˜¸ì¶œí•˜ì—¬ ì„ì‹œ ë³€ìˆ˜ì— ê°’ì„ ì €ì¥í•©ë‹ˆë‹¤.

</aside>


## **Abstract methods[#](https://dart.dev/language/methods#abstract-methods) ì¶”ìƒ ë©”ì„œë“œ**

**Instance, getter, and setter methods can be abstract, defining an interface but leaving its implementation up to other classes. Abstract methods can only exist in [abstract classes](https://dart.dev/language/class-modifiers#abstract) or [mixins](https://dart.dev/language/mixins).**

ì¸ìŠ¤í„´ìŠ¤, getter, ë° setter ë©”ì„œë“œëŠ” ì¶”ìƒì ì¼ ìˆ˜ ìˆìœ¼ë©°, ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•˜ì§€ë§Œ êµ¬í˜„ì€ ë‹¤ë¥¸ í´ë˜ìŠ¤ì— ë§¡ê¸´ë‹¤. ì¶”ìƒ ë©”ì„œë“œëŠ” ì¶”ìƒ í´ë˜ìŠ¤ë‚˜ ë¯¹ìŠ¤ì¸ì—ì„œë§Œ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.

**To make a method abstract, use a semicolon (`;`) instead of a method body:**

ë©”ì„œë“œë¥¼ ì¶”ìƒ ë©”ì„œë“œë¡œ ë§Œë“¤ë ¤ë©´ ë©”ì„œë“œ ë³¸ë¬¸ ëŒ€ì‹  ì„¸ë¯¸ì½œë¡ (;)ì„ ì‚¬ìš©í•˜ë¼:

```dart
abstract class Doer {
  // Define instance variables and methods...
  // ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ì™€ ë©”ì„œë“œë¥¼ ì •ì˜í•©ë‹ˆë‹¤...

  void doSomething(); // Define an abstract method.
  // ì¶”ìƒ ë©”ì„œë“œë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // Provide an implementation, so the method is not abstract here...
    // êµ¬í˜„ì„ ì œê³µí•˜ì—¬ ì´ ë©”ì„œë“œëŠ” ì—¬ê¸°ì—ì„œ ì¶”ìƒì ì´ì§€ ì•ŠìŠµë‹ˆë‹¤...
  }
}

```
