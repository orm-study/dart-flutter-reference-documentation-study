🔗 [[페이지 링크]](https://dart.dev/language/error-handling)

# Error handling 오류 처리

## **Exceptions**[#](https://dart.dev/language/error-handling#exceptions) 예외

**Your Dart code can throw and catch exceptions. Exceptions are errors indicating that something unexpected happened. If the exception isn't caught, the [isolate](https://dart.dev/language/concurrency#isolates) that raised the exception is suspended, and typically the isolate and its program are terminated.**

Dart 코드에서는 예외를 발생시키고 처리할 수 있다. 예외는 예상치 못한 일이 발생했음을 나타내는 오류이다. 예외가 처리되지 않으면 예외를 발생시킨 격리된 실행 환경(isolate)이 일시 중단되고, 일반적으로 그 격리된 실행 환경과 해당 프로그램은 종료된다.

-   **[Q] 격리된 실행 단위(isolate)? → 격리된 실행 환경**
    
    “격리된 실행 단위”는 Dart의 “isolate”를 번역한 것이다. Isolate는 독립적으로 실행되는 스레드와 비슷한 개념으로, 서로 메모리를 공유하지 않는 독립적인 실행 환경을 의미한다.
    
    따라서 더 자연스러운 번역은 “격리된 실행 환경” 또는 “격리된 실행 컨텍스트”라고 할 수 있다.
    
-   **[note] Dart의 isolate란?**
    
    Dart의 isolate는 Dart 언어의 독특한 기능으로, 격리된 실행 환경을 제공한다. 이는 특히 **병렬 처리를 위해 설계된 개념**이다. Isolate는 독립적으로 실행되는 단위로, 메모리를 다른 isolate와 공유하지 않는다. 이로 인해 스레드와 유사한 병렬 실행을 가능하게 하지만, 전통적인 스레드 모델과는 다른 장점을 제공한다.
    
    **특징**
    
    -   **독립적인 메모리 공간**
        
        각 isolate는 독립적인 메모리 공간을 갖고 있다. 다른 isolate와 메모리를 공유하지 않기 때문에 동기화 문제를 걱정할 필요가 없다.
        
    -   **메시지 기반 통신**
        
        isolate 간의 통신은 메시지를 통해 이루어진다. 이는 SendPort와 ReceivePort를 통해 구현된다. 한 isolate가 다른 isolate로 데이터를 보내려면, 데이터를 메시지로 변환하여 SendPort를 사용해 보낸다.
        
    -   **동시성 모델**
        
        Dart의 isolate 모델은 여러 isolate가 동시에 실행될 수 있도록 설계되었다. 이는 다중 코어 프로세서에서 효율적인 병렬 처리를 가능하게 한다.
        
    
    **장점**
    
    -   **안전한 병렬 처리**
        
        메모리를 공유하지 않기 때문에 데이터 **경쟁(data race)이나 데드락(deadlock) 같은 문제**가 발생하지 않는다.
        
    -   **예측 가능한 성능**
        
        isolate는 독립적으로 실행되기 때문에 각 isolate의 성능이 다른 isolate에 의해 영향을 받지 않는다.
        
    
    **단점**
    
    -   **메모리 사용량**
        
        각 isolate가 독립적인 메모리 공간을 사용하기 때문에 메모리 사용량이 증가할 수 있다.
        
    -   **복잡한 통신**
        
        메시지 기반 통신은 데이터 전달 시 추가적인 코드와 오버헤드가 발생할 수 있다.
        

**In contrast to Java, all of Dart's exceptions are unchecked exceptions. Methods don't declare which exceptions they might throw, and you aren't required to catch any exceptions.**

Java와는 달리, Dart의 모든 예외는 체크되지 않은 예외이다. 메서드가 발생시킬 수 있는 예외를 선언하지 않으며, 예외를 반드시 처리할 필요도 없다.

**Dart provides [`Exception`](https://api.dart.dev/stable/dart-core/Exception-class.html) and [`Error`](https://api.dart.dev/stable/dart-core/Error-class.html) types, as well as numerous predefined subtypes. You can, of course, define your own exceptions. However, Dart programs can throw any non-null object—not just Exception and Error objects—as an exception.**

Dart는 Exception과 Error 타입을 제공하며, 여러 가지 미리 정의된 하위 타입들도 제공한다. 물론, 사용자 정의 예외를 정의할 수도 있다. 하지만 Dart 프로그램은 Exception 및 Error 객체뿐만 아니라 null이 아닌 모든 객체를 예외로 발생시킬 수 있다.

### **Throw[#](https://dart.dev/language/error-handling#throw) 예외 발생**

**Here's an example of throwing, or _raising_, an exception:**

다음은 예외를 발생시키는 예제이다:

```dart
throw FormatException('Expected at least 1 section');

```

**You can also throw arbitrary objects:**

임의의 객체도 예외로 발생시킬 수 있다:

```dart
throw 'Out of llamas!';

```

<aside> ℹ️ **infoNote 참고**

**Production-quality code usually throws types that implement [`Error`](https://api.dart.dev/stable/dart-core/Error-class.html) or [`Exception`](https://api.dart.dev/stable/dart-core/Exception-class.html).**

프로덕션 수준의 코드는 일반적으로 Error 또는 Exception을 구현하는 타입을 예외로 발생시킨다.

</aside>

**Because throwing an exception is an expression, you can throw exceptions in => statements, as well as anywhere else that allows expressions:**

예외를 발생시키는 것은 하나의 표현식이기 때문에, => 문이나 표현식을 허용하는 모든 곳에서 예외를 발생시킬 수 있다:

```dart
void distanceTo(Point other) => throw UnimplementedError();

```

### **Catch[#](https://dart.dev/language/error-handling#catch) 예외 잡기**

**Catching, or capturing, an exception stops the exception from propagating (unless you rethrow the exception). Catching an exception gives you a chance to handle it:**

예외를 잡거나 포착하면 예외가 전파되는 것을 막을 수 있다(예외를 다시 던지지 않는 한). 예외를 잡으면 이를 처리할 기회를 얻게 된다:

```dart
try {
  breedMoreLlamas();
} on OutOfLlamasException {
  buyMoreLlamas();
}

```

**To handle code that can throw more than one type of exception, you can specify multiple catch clauses. The first catch clause that matches the thrown object's type handles the exception. If the catch clause does not specify a type, that clause can handle any type of thrown object:**

여러 유형의 예외를 던질 수 있는 코드를 처리하려면 여러 개의 catch 절을 지정할 수 있다. 던져진 객체의 유형과 일치하는 첫 번째 catch 절이 예외를 처리한다. catch 절에 유형을 지정하지 않으면, 그 절은 던져진 모든 유형의 객체를 처리할 수 있다:

```dart
try {
  breedMoreLlamas();
} on OutOfLlamasException {
  // A specific exception 특정 예외
  buyMoreLlamas();
} on Exception catch (e) {
  // Anything else that is an exception 그 외의 예외
  print('Unknown exception: $e');
} catch (e) {
  // No specified type, handles all 유형을 지정하지 않은 경우, 모든 예외 처리
  print('Something really unknown: $e');
}

```

**As the preceding code shows, you can use either `on` or `catch` or both. Use `on` when you need to specify the exception type. Use `catch` when your exception handler needs the exception object.**

앞의 코드에서 볼 수 있듯이, on이나 catch 또는 둘 다 사용할 수 있다. 예외 유형을 지정해야 할 때는 on을 사용하고, 예외 객체가 필요한 경우에는 catch를 사용한다.

**You can specify one or two parameters to `catch()`. The first is the exception that was thrown, and the second is the stack trace (a [`StackTrace`](https://api.dart.dev/stable/dart-core/StackTrace-class.html) object).**

catch()에 하나 또는 두 개의 매개변수를 지정할 수 있다. 첫 번째 매개변수는 던져진 예외이고, 두 번째는 스택 추적(StackTrace) 객체이다.

```dart
try {
  // ···
} on Exception catch (e) {
  print('Exception details:\\n $e');
} catch (e, s) {
  print('Exception details:\\n $e');
  print('Stack trace:\\n $s');
}

```

-   **[Q] 스택추적(StackTrace)란?**
    
    스택 추적(Stack trace)은 **프로그램이 실행되는 동안 호출된 함수의 호출 스택을 추적한 정보**이다. 프로그램이 예외를 던지기 전에 어떤 함수들이 호출되었는지를 보여주는 기록으로, 예외가 발생한 정확한 위치와 그 예외로 이어진 코드 경로를 파악하는 데 유용하다.
    
    스택 추적을 통해 예외가 발생한 경로를 따라가며 문제를 진단하고 디버깅할 수 있다. 이를 통해 코드의 어느 부분에서 문제가 발생했는지, 어떤 함수 호출이 문제를 일으켰는지 알 수 있다.
    

**To partially handle an exception, while allowing it to propagate, use the `rethrow` keyword.**

예외를 부분적으로 처리하면서 전파되도록 하려면 rethrow 키워드를 사용하라.

```dart
void misbehave() {
  try {
    dynamic foo = true;
    print(foo++); // Runtime error 런타임 오류
  } catch (e) {
    print('misbehave() partially handled ${e.runtimeType}.');
    rethrow; // Allow callers to see the exception. 호출자가 예외를 볼 수 있도록 허용.
  }
}

void main() {
  try {
    misbehave();
  } catch (e) {
    print('main() finished handling ${e.runtimeType}.');
  }
}

```

-   **[Q]예외전파(Exception propagation)란?**
    
    예외가 발생한 후, 이를 처리하는 코드 블록이 나타날 때까지 호출 스택을 따라 **예외가 전달되는 과정**을 의미한다.
    
    **전파 과정**
    
    1.  **예외 발생**:
        -   코드에서 예외가 발생한다(예: throw Exception('Error occurred')).
    2.  **예외 처리 코드 탐색**:
        -   발생한 예외는 현재 메서드의 try-catch 블록에서 처리될 수 있는지 확인한다.
        -   만약 현재 메서드에 예외를 처리할 catch 블록이 없다면, 예외는 호출 스택을 따라 상위 메서드로 전달(전파)된다.
    3.  **상위 메서드에서 예외 처리**:
        -   예외가 상위 메서드로 전달되면, 해당 메서드에서도 예외를 처리할 try-catch 블록을 찾는다.
        -   상위 메서드에서도 catch 블록이 없다면, 예외는 계속해서 호출 스택을 따라 더 상위 메서드로 전파된다.
    4.  **최종 처리**:
        -   예외가 처리되지 않고 최상위 메서드(예: main 함수)까지 전파되면, 프로그램은 비정상 종료될 수 있다.
    
    **예외 전파를 사용하는 이유**
    
    • **코드 구조화**: 예외가 발생한 즉시 모든 예외를 처리하지 않고, 상위 메서드에서 예외를 처리하도록 구조화할 수 있다.
    
    • **책임 분리**: 각 메서드는 자신의 로직에 집중하고, 예외 처리는 호출자에게 맡길 수 있다.
    
    • **유연성**: 예외를 다양한 수준에서 처리할 수 있어, 예외 발생 위치와 상관없이 일관된 예외 처리가 가능하다.
    
-   **[Q] rethrow는 어떤 상황에 사용하며 왜 사용할까?**
    
    rethrow는 **예외를 부분적으로 처리한 후 예외를 다시 던져서 예외가 계속 전파되도록 할 때** 사용하는 키워드이다. rethrow를 사용하면 catch 블록 내에서 예외를 부분적으로 처리한 후, 상위 호출 스택에서 추가적인 처리를 할 수 있도록 예외를 다시 던질 수 있다.
    
    rethrow를 사용하면 **예외 처리 로직을 여러 단계로 나눠서 처리**할 수 있게 해준다. 예를 들어, 로깅, 리소스 해제, 사용자에게 오류 메시지를 보여주는 등의 처리를 각기 다른 레벨에서 할 수 있다.
    

### **Finally[#](https://dart.dev/language/error-handling#finally)**

**To ensure that some code runs whether or not an exception is thrown, use a `finally` clause. If no `catch` clause matches the exception, the exception is propagated after the `finally` clause runs:**

예외가 발생하든 발생하지 않든 항상 어떤 코드를 실행해야 할 때는 finally 절을 사용한다. catch 절에서 예외를 처리하지 못한 경우에도 finally 절이 실행된 후 예외가 전파된다:

```dart
try {
  breedMoreLlamas();
} finally {
  // 예외가 발생하더라도 항상 정리 작업을 수행합니다.
  cleanLlamaStalls();
}

```

**The `finally` clause runs after any matching `catch` clauses:**

finally 절은 매칭되는 catch 절이 실행된 후에 실행된다:

```dart
try {
  breedMoreLlamas();
} catch (e) {
  print('Error: $e'); // 먼저 예외를 처리합니다.
} finally {
  cleanLlamaStalls(); // 그 후에 정리 작업을 수행합니다.
}

```

**To learn more, check out the [core library exception docs](https://dart.dev/libraries/dart-core#exceptions).**

자세한 내용은 코어 라이브러리의 예외 문서를 참조하십시오.

### **Assert[#](https://dart.dev/language/error-handling#assert)**

**During development, use an assert statement— `assert(<condition>, <optionalMessage>);` —to disrupt normal execution if a boolean condition is false.**

개발 중에 assert 문을 사용하여 bool 조건이 거짓인 경우 정상 실행을 중단할 수 있다.

```dart
// 변수가 null이 아닌 값을 가지도록 합니다.
assert(text != null);

// 값이 100보다 작은지 확인합니다.
assert(number < 100);

// 이것이 https URL인지 확인합니다.
assert(urlString.startsWith('https'));

```

**To attach a message to an assertion, add a string as the second argument to `assert` (optionally with a [trailing comma](https://dart.dev/language/collections#trailing-comma)):**

어설션에 메시지를 첨부하려면, assert의 두 번째 인수로 문자열을 추가한다(선택적으로 끝에 쉼표를 추가할 수 있다):

```dart
assert(urlString.startsWith('https'),
    'URL ($urlString) should start with "https".');

```

-   **[Q] assert와 assertion은 다른건가?**
    
    ----------
    
    “assert”와 “assertion”은 관련이 있지만 서로 다른 개념이다.
    
    -   assert는 키워드로서 조건을 검증하기 위해 사용되며, Assertion은 assert 키워드를 사용한 검증 문장 자체를 의미한다.
    -   assert는 특정 조건을 확인하기 위해 사용하는 키워드이고, assertion은 이러한 검증을 표현하는 구문이다.
    
    **assert**
    
    assert는 **특정 조건이 참인지 확인하는 데 사용되는 프로그래밍 언어의 키워드**이다. 조건이 거짓일 경우 프로그램 실행을 중단하고 오류 메시지를 출력한다.
    
    **용도**
    
    -   디버깅 목적으로 사용되며, 프로그램의 상태를 검증하는데 사용된다.
    
    ```dart
    assert(x > 0, 'x must be greater than 0');
    
    ```
    
    **assertion**
    
    Assertion은 assert를 사용하여 **조건을 확인하는 구문**을 의미한다. 즉, assert 키워드를 사용한 검증 문장을 “assertion”이라고 하는 것이다.
    
    **용도**
    
    -   코드의 특정 상태나 조건이 만족됨을 보장하기 위해 사용한다.
    
    ```dart
    // This is an assertion
    assert(y != null, 'y should not be null');
    
    ```
   
    

**The first argument to `assert` can be any expression that resolves to a boolean value. If the expression's value is true, the assertion succeeds and execution continues. If it's false, the assertion fails and an exception (an [`AssertionError`](https://api.dart.dev/stable/dart-core/AssertionError-class.html)) is thrown.**

assert의 첫 번째 인수는 부울 값으로 평가되는 모든 표현식일 수 있다. 표현식의 값이 참이면 어설션이 성공하고 실행이 계속된다. 거짓이면 어설션이 실패하고 예외(AssertionError)가 발생한다.

-   **[code] 부울 값으로 평가되는 모든 표현식 예제**
    
    여기서 말하는 “표현식”은 프로그램의 실행 중 평가되어 하나의 값, 특히 참(true) 또는 거짓(false)을 반환하는 코드 부분을 의미한다.
    
    **표현식(expression)**
    
    값을 반환하는 코드 조각. 변수, 상수, 연산자, 함수 호출 등을 포함할 수 있다.
    
    **부울 표현식**
    
    참(true) 또는 거짓(false)으로 평가될 수 있는 표현식
    
    **변수 비교 표현식**
    
    ```dart
    	int x = 5;
    assert(x > 0); // x > 0는 참이므로 어설션 성공
    
    ```
    
    **논리 연산 표현식**
    
    ```dart
    bool isValid = true;
    assert(isValid && (x < 10)); // isValid && (x < 10)는 참이므로 어설션 성공
    
    ```
    
    **함수 호출 표현식**
    
    ```dart
    bool isPositive(int number) => number > 0;
    assert(isPositive(x)); // isPositive(x)는 참이므로 어설션 성공
    
    ```
    

**When exactly do assertions work? That depends on the tools and framework you're using:**

어설션이 언제 작동하는지는 사용 중인 도구와 프레임워크에 따라 다르다:

-   **Flutter enables assertions in [debug mode.](https://docs.flutter.dev/testing/debugging#debug-mode-assertions)**
    
    Flutter는 디버그 모드에서 어설션을 활성화한다.
    
-   **Development-only tools such as [`webdev serve`](https://dart.dev/tools/webdev#serve) typically enable assertions by default.**
    
    webdev serve와 같은 개발 전용 도구는 일반적으로 기본적으로 어설션을 활성화한다.
    
-   **Some tools, such as [`dart run`](https://dart.dev/tools/dart-run) and [`dart compile js`](https://dart.dev/tools/dart-compile#js) support assertions through a command-line flag: `-enable-asserts`.**
    
    dart run 및 dart compile js와 같은 일부 도구는 명령줄 플래그 --enable-asserts를 통해 어설션을 지원한다.
    

**In production code, assertions are ignored, and the arguments to `assert` aren't evaluated.**

프로덕션 코드에서는 어설션이 무시되며, assert의 인수는 평가되지 않는다.

---

🔗 [[페이지 링크]](https://dart.dev/language/classes)

# Classes 클래스

**Dart is an object-oriented language with classes and mixin-based inheritance. Every object is an instance of a class, and all classes except `Null` descend from [`Object`](https://api.dart.dev/stable/dart-core/Object-class.html). _Mixin-based inheritance_ means that although every class (except for the [top class](https://dart.dev/null-safety/understanding-null-safety#top-and-bottom), `Object?`) has exactly one superclass, a class body can be reused in multiple class hierarchies. [Extension methods](https://dart.dev/language/extension-methods) are a way to add functionality to a class without changing the class or creating a subclass. [Class modifiers](https://dart.dev/language/class-modifiers) allow you to control how libraries can subtype a class.**

Dart는 클래스와 믹스인 기반 상속을 사용하는 객체 지향 언어다. 모든 객체는 클래스의 인스턴스이며, Null을 제외한 모든 클래스는 Object를 상속한다. 믹스인 기반 상속이란 최상위 클래스(Object)를 제외한 모든 클래스가 정확히 하나의 슈퍼클래스를 가지지만, 클래스 본문은 여러 클래스 계층 구조에서 재사용될 수 있다는 것을 의미한다. 확장 메서드는 클래스를 변경하거나 서브클래스를 생성하지 않고 클래스에 기능을 추가하는 방법이다. 클래스 수정자는 라이브러리가 클래스를 하위 유형으로 만들 수 있는 방법을 제어할 수 있게 해준다.

----------

## **Using class members[#](https://dart.dev/language/classes#using-class-members)

클래스 멤버 사용**

**Objects have _members_ consisting of functions and data (_methods_ and _instance variables_, respectively). When you call a method, you _invoke_ it on an object: the method has access to that object's functions and data.**

객체는 함수와 데이터로 구성된 멤버를 가진다 (각각 메서드와 인스턴스 변수). 메서드를 호출하면, 객체에서 그 메서드를 실행하게 된다: 메서드는 그 객체의 함수와 데이터에 접근할 수 있다.

-   **[Q] 인스턴스 변수(Instance Variable)란 필드(fields), 속성(properties)랑 같은 말인가?**
    
    같은 말이다. 클래스 내에서 정의된 변수로, 각 객체가 독립적으로 가지는 데이터를 저장한다.
    

**Use a dot (`.`) to refer to an instance variable or method:**

인스턴스 변수나 메서드를 참조하려면 점(.)을 사용한다:

```dart
var p = Point(2, 2);

// Get the value of y.
// y의 값을 가져옵니다.
assert(p.y == 2);

// Invoke distanceTo() on p.
// p에서 distanceTo()를 호출합니다.
double distance = p.distanceTo(Point(4, 4));

```

**Use `?.` instead of `.` to avoid an exception when the leftmost operand is null:**

왼쪽 피연산자가 null일 때 예외를 피하려면 점(.) 대신 ?.을 사용한다:

```dart
// If p is non-null, set a variable equal to its y value.
// p가 null이 아닌 경우, 변수에 p의 y 값을 할당합니다.
var a = p?.y;

```


## **Using constructors[#](https://dart.dev/language/classes#using-constructors) 생성자 사용**

**You can create an object using a _constructor_. Constructor names can be either `*ClassName*` or `*ClassName*.*identifier*`. For example, the following code creates `Point` objects using the `Point()` and `Point.fromJson()` constructors:**

생성자를 사용하여 객체를 생성할 수 있다. 생성자 이름은 ClassName 또는 ClassName.identifier가 될 수 있습니다. 예를 들어, 다음 코드는 Point()와 Point.fromJson() 생성자를 사용하여 Point 객체를 생성한다:

```dart
var p1 = Point(2, 2);
var p2 = Point.fromJson({'x': 1, 'y': 2});

```

**The following code has the same effect, but uses the optional `new` keyword before the constructor name:**

다음 코드는 동일한 효과를 가지지만, 생성자 이름 앞에 선택적인 new 키워드를 사용한다:

```dart
var p1 = new Point(2, 2);
var p2 = new Point.fromJson({'x': 1, 'y': 2});

```

**Some classes provide [constant constructors](https://dart.dev/language/constructors#constant-constructors). To create a compile-time constant using a constant constructor, put the `const` keyword before the constructor name:**

일부 클래스는 상수 생성자를 제공합니다. 상수 생성자를 사용하여 컴파일 타임 상수를 생성하려면 생성자 이름 앞에 const 키워드를 추가한다:

```dart
var p = const ImmutablePoint(2, 2);

```

**Constructing two identical compile-time constants results in a single, canonical instance:**

컴파일 타임 상수를 두 개 동일하게 구성하면 하나의 정규 인스턴스가 생성된다.

```dart
var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a, b)); // They are the same instance! 동일한 인스턴스입니다!

```

-   **[Q] 왜 a와 b가 같은 인스턴스가 될까?**
    
    ```dart
    var a = const ImmutablePoint(1, 1);
    var b = const ImmutablePoint(1, 1);
    
    ```
    
    동일한 인스턴스이다. 동일한 인스턴스로 취급하는 이유는 Dart의 컴파일 타임 상수 최적화 때문이다. `const` 키워드를 사용하여 생성된 객체는 불변(immutable)이며, 동일한 값으로 생성된 상수 객체는 하나의 인스턴스로만 저장된다.
    
    `const` 키워드를 사용하여 불변객체를 생성하면, 컴파일러는 동일한 값을 가지는 객체가 이미 존재하는지 확인한다. 만약 존재한다면 새로운 인스턴스를 생성하는 대신 기존의 인스턴스를 재사용한다. 이렇게 a와 b는 동일한 인스턴스를 가르키게 되는 것이다(메모리 내에서 동일한 주소를 참조하게 되는 것).
    
    이러한 동작은 메모리 사용을 최적화하고 불필요한 객체 생성을 줄여 성능을 향상시킬 수 있다.
    

**Within a _constant context_, you can omit the `const` before a constructor or literal. For example, look at this code, which creates a const map:**

상수 컨텍스트 내에서는 생성자나 리터럴 앞에 const를 생략할 수 있다. 예를 들어, 다음 코드는 상수 맵을 생성한다:

```dart
// Lots of const keywords here.
// 여기에는 많은 const 키워드가 있습니다.
const pointAndLine = const {
  'point': const [const ImmutablePoint(0, 0)],
  'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],
};

```

**You can omit all but the first use of the `const` keyword:**

모든 const 키워드를 첫 번째 사용 외에는 생략할 수 있다:

```dart
// Only one const, which establishes the constant context.
// 첫 번째 const만 사용하여 상수 컨텍스트를 설정합니다.
const pointAndLine = {
  'point': [ImmutablePoint(0, 0)],
  'line': [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],
};

```

**If a constant constructor is outside of a constant context and is invoked without `const`, it creates a non-constant object:**

상수 생성자가 상수 컨텍스트 외부에 있고 const 없이 호출되면 비상수 객체가 생성된다:

```dart
var a = const ImmutablePoint(1, 1); // Creates a constant 상수를 생성합니다
var b = ImmutablePoint(1, 1); // Does NOT create a constant 상수를 생성하지 않습니다

assert(!identical(a, b)); // NOT the same instance! 동일한 인스턴스가 아닙니다!

```

## **Getting an object's type[#](https://dart.dev/language/classes#getting-an-objects-type) 객체의 타입 얻기**

**To get an object's type at runtime, you can use the `Object` property `runtimeType`, which returns a [`Type`](https://api.dart.dev/stable/dart-core/Type-class.html) object.**

런타임에 객체의 타입을 얻으려면 Object 속성인 runtimeType을 사용할 수 있다. 이는 Type 객체를 반환한다.

```dart
print('The type of a is ${a.runtimeType}');

```

<aside> ℹ️ **Warning 경고**

**Use a [type test operator](https://dart.dev/language/operators#type-test-operators) rather than `runtimeType` to test an object's type. In production environments, the test `object is Type` is more stable than the test `object.runtimeType == Type`.**

객체의 타입을 테스트할 때는 runtimeType보다는 타입 테스트 연산자를 사용하는 것이 좋다. 프로덕션 환경에서는 object is Type 테스트가 object.runtimeType == Type 테스트보다 더 안정적이다.

</aside>

**Up to here, you've seen how to _use_ classes. The rest of this section shows how to _implement_ classes.**

여기까지 클래스 사용 방법을 살펴보았다. 이 섹션의 나머지 부분에서는 클래스 구현 방법을 보여준다.


## **Instance variables[#](https://dart.dev/language/classes#instance-variables) 인스턴스 변수**

**Here's how you declare instance variables:**

다음은 인스턴스 변수를 선언하는 방법이다:

```dart
class Point {
  double? x; // Declare instance variable x, initially null. 인스턴스 변수 x를 선언, 초기값은 null.
  double? y; // Declare y, initially null. y를 선언, 초기값은 null.
  double z = 0; // Declare z, initially 0. z를 선언, 초기값은 0.
}

```

**An uninitialized instance variable declared with a [nullable type](https://dart.dev/null-safety/understanding-null-safety#using-nullable-types) has the value `null`. Non-nullable instance variables [must be initialized](https://dart.dev/null-safety/understanding-null-safety#uninitialized-variables) at declaration.**

널러블 타입으로 선언된 초기화되지 않은 인스턴스 변수는 값이 null이다. 널이 될 수 없는 인스턴스 변수는 선언 시 반드시 초기화해야 한다.

**All instance variables generate an implicit _getter_ method. Non-final instance variables and `late final` instance variables without initializers also generate an implicit _setter_ method. For details, check out [Getters and setters](https://dart.dev/language/methods#getters-and-setters).**

모든 인스턴스 변수는 암시적 getter 메서드를 생성한다. 초기화되지 않은 final 인스턴스 변수와 late final 인스턴스 변수는 암시적인 setter 메서드도 생성한다. 자세한 내용은 Getters and setters를 참조하라.

```dart
class Point {
  double? x; // Declare instance variable x, initially null. 인스턴스 변수 x를 선언, 초기값은 null.
  double? y; // Declare y, initially null. y를 선언, 초기값은 null.
}

void main() {
  var point = Point();
  point.x = 4; // Use the setter method for x. x의 setter 메서드를 사용.
  assert(point.x == 4); // Use the getter method for x. x의 getter 메서드를 사용.
  assert(point.y == null); // Values default to null. 값이 기본적으로 null.
}

```

**Initializing a non-`late` instance variable where it's declared sets the value when the instance is created, before the constructor and its initializer list execute. As a result, the initializing expression (after the `=`) of a non-`late` instance variable can't access `this`.**

non-late 인스턴스 변수를 선언하는 위치에서 초기화하면 인스턴스가 생성될 때 값이 설정된다. 이는 생성자와 초기화 리스트가 실행되기 전에 이루어진다. 결과적으로 non-late 인스턴스 변수의 초기화 표현식(= 뒤)은 this에 접근할 수 없다.

```dart
double initialX = 1.5;

class Point {
  // OK, can access declarations that do not depend on `this`:
  // OK, `this`에 의존하지 않는 선언에 접근 가능:

  double? x = initialX;

  // ERROR, can't access `this` in non-`late` initializer:
  // 오류, non-`late` 초기화에서 `this`에 접근할 수 없음:
  double? y = this.x;

  // OK, can access `this` in `late` initializer:
  // OK, `late` 초기화에서 `this`에 접근 가능:
  late double? z = this.x;

  // OK, `this.x` and `this.y` are parameter declarations, not expressions:
  // OK, `this.x`와 `this.y`는 표현식이 아닌 파라미터 선언:
  Point(this.x, this.y);
}

```

**Instance variables can be `final`, in which case they must be set exactly once. Initialize `final`, non-`late` instance variables at declaration, using a constructor parameter, or using a constructor's [initializer list](https://dart.dev/language/constructors#use-an-initializer-list):**

인스턴스 변수는 final일 수 있으며, 이 경우 정확히 한 번만 설정되어야 한다. final, non-late 인스턴스 변수는 선언 시, 생성자 파라미터를 사용하여, 또는 생성자의 초기화 리스트를 사용하여 초기화한다:

```dart
class ProfileMark {
  final String name;
  final DateTime start = DateTime.now();

  ProfileMark(this.name);
  ProfileMark.unnamed() : name = '';
}

```

-   **[code] final 인스턴스 변수 초기화 방법**
    
    세 가지 방법 중 하나로 final 인스턴스 변수를 초기화해야 한다. 이를 통해 변수는 인스턴스가 생성될 때 한 번만 값을 가지게 된다.
    
    **선언할 때 초기화 :** 변수 선언 시 바로 값을 할당한다.
    
    ```dart
    class Example {
      final int x = 10; // 선언할 때 초기화
    }
    
    ```
    
    **생성자 파라미터를 사용하여 초기화 :** 생성자의 매개변수를 사용하여 값을 설정한다.
    
    ```dart
    class Example {
      final int x;
    
      Example(this.x); // 생성자 파라미터 사용
    }
    
    void main() {
      var example = Example(10);
      print(example.x); // 10
    }
    
    ```
    
    **생성자의 초기화 리스트를 사용하여 초기화 :** 생성자의 초기화 리스트를 사용하여 값을 설정한다.
    
    ```dart
    class Example {
      final int x;
    
      Example(int value) : x = value; // 초기화 리스트 사용
    }
    
    void main() {
      var example = Example(10);
      print(example.x); // 10
    }
    
    ```
    

**If you need to assign the value of a `final` instance variable after the constructor body starts, you can use one of the following:**

생성자 본문이 시작된 후에 final 인스턴스 변수의 값을 할당해야 하는 경우, 다음 중 하나를 사용할 수 있다:

-   **Use a [factory constructor](https://dart.dev/language/constructors#factory-constructors).**
    
    팩토리 생성자를 사용하라.
    
-   **Use `late final`, but [_be careful:_](https://dart.dev/effective-dart/design#avoid-public-late-final-fields-without-initializers) a `late final` without an initializer adds a setter to the API.**
    
    late final을 사용하십시오. 하지만 주의하십시오: 초기화되지 않은 late final은 API에 setter를 추가한다.
    
-   **[code] 본문 시작 후 final 인스턴스 변수 값 할당하는 방법**
    
    **팩토리 생성자 사용**
    
    팩토리 생성자는 새로운 인스턴스를 반환하거나 기존 인스턴스를 반환할 수 있는 생성자이다. 이 생성자를 사용하면, 인스턴스가 생성된 후에 final 변수의 값을 설정할 수 있다.
    
    ```dart
    class Example {
      final int x;
    
      factory Example(int value) {
        return Example._internal(value);
      }
    
      Example._internal(this.x);
    }
    
    void main() {
      var example = Example(10);
      print(example.x); // 10
    }
    
    ```
    
    **late final 사용**
    
    late final 키워드를 사용하면 변수를 나중에 초기화할 수 있다. 하지만 초기화할 때까지 변수를 사용할 수 없으므로 주의가 필요하다. 초기화되지 않은 late final 변수는 setter를 통해 한 번만 값을 설정할 수 있다.
    
    -   late final 변수를 사용할 때는 초기화되지 않은 상태로 접근하지 않도록 주의해야 한다.
    -   초기화되지 않은 late final 변수는 setter를 통해 값을 설정할 수 있지만, 이는 API에 setter를 추가하게 되어 원하지 않는 부작용을 일으킬 수 있다.
    
    ```dart
    class Example {
      late final int x;
    
      Example(int value) {
        x = value; // 생성자 본문에서 값을 설정
      }
    }
    
    void main() {
      var example = Example(10);
      print(example.x); // 10
    }
    
    ```
    
-   **[Q] 왜 위의 두 방법만 있을까?**
    
    Dart에서 final 인스턴스 변수의 값을 생성자 본문이 시작된 후에 할당할 수 있는 방법이 제한적인 이유는 final 키워드의 특성 때문이다. final 변수는 초기화된 후 값을 변경할 수 없기 때문에, 초기화를 한 번만 수행해야 하는 제약이 있다. 이를 위해 Dart에서는 특정한 방법들만을 허용한다.
    
    **불변성 유지**
    
    final 키워드는 변수의 값을 한 번만 설정할 수 있게 보장한다. 이는 객체가 생성된 후 해당 값이 변경되지 않음을 의미한다. 불변성은 프로그램의 안정성과 예측 가능성을 높이는 중요한 특성이다.
    
    **안전한 초기화 보장**
    
    final 변수는 생성자에서 반드시 초기화해야 한다. 이는 객체가 완전히 초기화되지 않은 상태로 사용되는 것을 방지한다.
    
    생성자 본문이 시작된 후에 초기화가 필요한 경우, 팩토리 생성자나 late final을 사용해야만 안전하게 초기화를 보장할 수 있다.
    
    **팩토리 생성자**
    
    -   팩토리 생성자는 객체를 생성할 때 추가적인 초기화 작업을 수행할 수 있는 유연성을 제공한다. 팩토리 생성자를 사용하면 객체를 반환하기 전에 필요한 초기화 작업을 완료할 수 있다.
    -   팩토리 생성자는 클래스 외부에서 객체를 생성할 수 있는 메커니즘을 제공하며, 이는 객체의 생성 과정을 제어할 수 있게 해준다.
    
    **late final**
    
    -   late 키워드는 변수를 나중에 초기화할 수 있게 한다. late final 변수는 한 번만 초기화될 수 있다는 final의 특성을 유지하면서도, 초기화를 나중으로 미룰 수 있게 해준다.
    -   이는 생성자 본문 내에서 복잡한 초기화 논리를 처리해야 할 때 유용하다. 예를 들어, 생성자 내에서 특정 조건을 만족하는 경우에만 변수를 초기화할 수 있다.
    
    **제약의 이유**
    
    이러한 제약은 Dart의 타입 시스템과 초기화 규칙을 엄격하게 적용함으로써 발생할 수 있는 버그를 줄이고, 코드의 안정성과 예측 가능성을 높이기 위한 것이다. final 변수의 값을 나중에 할당하는 방법을 제한함으로써, 개발자가 의도하지 않은 방식으로 값을 변경하거나 초기화되지 않은 변수를 사용하는 것을 방지할 수 있다.
    
    따라서 Dart에서는 생성자 본문이 시작된 후에 final 변수를 안전하게 초기화할 수 있는 방법으로 팩토리 생성자와 late final 변수를 제공합니다. 이 두 가지 방법은 final 변수의 초기화 규칙을 준수하면서도 필요한 초기화 작업을 수행할 수 있게 해줍니다.
    


## **Implicit interfaces[#](https://dart.dev/language/classes#implicit-interfaces) 암시적 인터페이스**

**Every class implicitly defines an interface containing all the instance members of the class and of any interfaces it implements. If you want to create a class A that supports class B's API without inheriting B's implementation, class A should implement the B interface.**

모든 클래스는 클래스와 구현하는 인터페이스의 모든 인스턴스 멤버를 포함하는 인터페이스를 암시적으로 정의한다. 클래스 A가 클래스 B의 구현을 상속하지 않으면서 B의 API를 지원하려면, 클래스 A는 B 인터페이스를 구현해야 한다.

**A class implements one or more interfaces by declaring them in an `implements` clause and then providing the APIs required by the interfaces. For example:**

클래스는 implements 절에서 인터페이스를 선언하고 인터페이스가 요구하는 API를 제공함으로써 하나 이상의 인터페이스를 구현한다. 예를 들어:

```dart
// A person. The implicit interface contains greet().
// 사람 클래스. 암시적 인터페이스는 greet()을 포함합니다.
class Person {
  // In the interface, but visible only in this library.
    // 인터페이스에 포함되지만, 이 라이브러리에서만 보입니다.
	final String _name;

  // Not in the interface, since this is a constructor.
  // 생성자이므로 인터페이스에 포함되지 않습니다.
  Person(this._name);

  // In the interface.
  // 인터페이스에 포함됩니다.
  String greet(String who) => 'Hello, $who. I am $_name.';
}

// An implementation of the Person interface.
// Person 인터페이스의 구현체.
class Impostor implements Person {
  String get _name => '';

  String greet(String who) => 'Hi $who. Do you know who I am?';
}

String greetBob(Person person) => person.greet('Bob');

void main() {
  print(greetBob(Person('Kathy')));
  print(greetBob(Impostor()));
}

```

**Here's an example of specifying that a class implements multiple interfaces:**

여기 클래스가 여러 인터페이스를 구현하는 예제가 있다:

```dart
class Point implements Comparable, Location {...}

```


## **Class variables and methods[#](https://dart.dev/language/classes#class-variables-and-methods) 클래스 변수와 메서드**

**Use the `static` keyword to implement class-wide variables and methods.**

클래스 전역 변수와 메서드를 구현하려면 static 키워드를 사용하라.

### **Static variables[#](https://dart.dev/language/classes#static-variables) 정적 변수**

**Static variables (class variables) are useful for class-wide state and constants:**

클래스 변수(static 변수)는 클래스 전체에서 상태와 상수를 공유할 때 유용하다:

```dart
class Queue {
  static const initialCapacity = 16;
  // ···
}

void main() {
  assert(Queue.initialCapacity == 16);
}

```

**Static variables aren't initialized until they're used.**

정적 변수는 사용될 때까지 초기화되지 않는다.

-   **[Q] 클래스 변수에 static 변수를 사용하면 상태와 상수를 공유할 때 유용하다?**
    
    Dart에서 클래스 멤버에 static 키워드를 사용하면, 해당 멤버는 클래스의 인스턴스가 아닌 클래스 자체에 속하게 된다. 즉, static 멤버는 클래스의 모든 인스턴스가 공유하는 멤버가 되며, 클래스 이름을 통해 직접 접근할 수 있다.
    
    ```dart
    class MathUtil {
      // static 변수
      static const double pi = 3.14159;
    
      // static 메서드
      static double calculateCircleArea(double radius) {
        return pi * radius * radius;
      }
    }
    
    void main() {
      // 클래스 이름을 통해 static 변수와 메서드에 접근
      print(MathUtil.pi); // 출력: 3.14159
      print(MathUtil.calculateCircleArea(10)); // 출력: 314.159
    }
    
    ```
    
    **클래스 수준의 멤버**
    
    static 멤버는 클래스의 인스턴스가 아니라 클래스 자체에 속한다. 따라서 클래스의 인스턴스를 생성하지 않고도 접근할 수 있다.
    
    **공유된 상태**
    
    static 변수는 클래스의 모든 인스턴스 간에 공유된다. 이는 클래스의 모든 인스턴스가 동일한 static 변수를 참조하고 변경할 수 있음을 의미한다.
    
    **메모리 사용 최적화**
    
    static 멤버는 클래스당 하나만 존재하므로, 많은 인스턴스가 있는 경우 메모리를 절약할 수 있다.
    
    **인스턴스 멤버와 구분**
    
    static 멤버는 인스턴스 멤버와 달리, 클래스의 인스턴스를 통해 접근할 수 없다. 인스턴스를 통해 static 멤버에 접근하려고 하면 경고 또는 오류가 발생할 수 있다. 유틸리티 클래스나 헬퍼 클래스를 만들 때 유용하다. 이러한 클래스는 인스턴스를 만들 필요 없이 static 메서드만 제공하는 경우가 많다.
    
    ```dart
    class Example {
      static int staticVar = 10;
      int instanceVar = 20;
    }
    
    void main() {
      Example ex = Example();
      
      // 올바른 접근 방법
      print(Example.staticVar); // static 멤버는 클래스 이름을 통해 접근
      
      // 잘못된 접근 방법
      // print(ex.staticVar); // 오류: 인스턴스를 통해 static 멤버에 접근할 수 없음
      
      // 인스턴스 멤버는 인스턴스를 통해 접근
      print(ex.instanceVar);
    }
    
    ```
    

<aside> ℹ️ **Note 참고**

**This page follows the [style guide recommendation](https://dart.dev/effective-dart/style#identifiers) of preferring `lowerCamelCase` for constant names.**

이 페이지는 상수 이름에 대해 소문자 낙타 표기법(lowerCamelCase)을 선호하는 스타일 가이드 권장 사항을 따릅니다.

</aside>

### **Static methods[#](https://dart.dev/language/classes#static-methods)** 정적 메서드

**Static methods (class methods) don't operate on an instance, and thus don't have access to `this`. They do, however, have access to static variables. As the following example shows, you invoke static methods directly on a class:**

정적 메서드(클래스 메서드)는 인스턴스에서 작동하지 않으므로 this에 접근할 수 없다. 그러나 정적 변수에는 접근할 수 있다. 다음 예제에서 알 수 있듯이, 정적 메서드는 클래스에서 직접 호출한다:

```dart
import 'dart:math';

class Point {
  double x, y;
  Point(this.x, this.y);

  static double distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
  }
}

void main() {
  var a = Point(2, 2);
  var b = Point(4, 4);
  var distance = Point.distanceBetween(a, b);
  assert(2.8 < distance && distance < 2.9);
  print(distance);
}

```

<aside> ℹ️ **Note 참고**

**Consider using top-level functions, instead of static methods, for common or widely used utilities and functionality.**

공통적이거나 널리 사용되는 유틸리티와 기능에는 정적 메서드 대신 최상위 함수를 사용하는 것을 고려하십시오.

</aside>

**You can use static methods as compile-time constants. For example, you can pass a static method as a parameter to a constant constructor.**

정적 메서드를 컴파일 타임 상수로 사용할 수 있습니다. 예를 들어, 정적 메서드를 상수 생성자의 매개변수로 전달할 수 있습니다.

---

🔗 [페이지 링크]

# **Constructors 생성자**

**Constructors are special functions that create instances of classes.**

생성자는 클래스의 인스턴스를 생성하는 특별한 함수이다.

**Dart implements many types of constructors. Except for default constructors, these functions use the same name as their class.**

Dart는 여러 유형의 생성자를 구현한다. 기본 생성자를 제외하고, 이 함수들은 클래스와 같은 이름을 사용한다.

-   **[Generative constructors](https://dart.dev/language/constructors#generative-constructors): Creates new instances and initializes instance variables.**
    
    생성 생성자 : 새로운 인스턴스를 생성하고 인스턴스 변수를 초기화한다.
    
-   **[Default constructors](https://dart.dev/language/constructors#default-constructors): Used to create a new instance when a constructor hasn't been specified. It doesn't take arguments and isn't named.**
    
    기본 생성자 : 생성자가 지정되지 않은 경우 새 인스턴스를 생성하는 데 사용됩니다. 인수를 받지 않으며 이름이 없다.
    
-   **[Named constructors](https://dart.dev/language/constructors#named-constructors): Clarifies the purpose of a constructor or allows the creation of multiple constructors for the same class.**
    
    명명된 생성자 : 생성자의 목적을 명확히 하거나 동일한 클래스에 대해 여러 생성자를 만들 수 있다.
    
-   **[Constant constructors](https://dart.dev/language/constructors#constant-constructors): Creates instances as compile-type constants.**
    
    상수 생성자 : 컴파일 타임 상수로 인스턴스를 생성한다.
    
-   **[Factory constructors](https://dart.dev/language/constructors#factory-constructors): Either creates a new instance of a subtype or returns an existing instance from cache.**
    
    팩토리 생성자 : 하위 유형의 새 인스턴스를 생성하거나 캐시에서 기존 인스턴스를 반환한다.
    
-   **[Redirecting constructor](https://dart.dev/language/constructors#redirecting-constructors): Forwards calls to another constructor in the same class.**
    
    리디렉팅 생성자 : 동일한 클래스의 다른 생성자로 호출을 전달한다.
    


## **Types of constructors[#](https://dart.dev/language/constructors#types-of-constructors) 생성자 유형**

### **Generative constructors[#](https://dart.dev/language/constructors#generative-constructors) 생성 생성자**

**To instantiate a class, use a generative constructor.**

클래스를 인스턴스화하려면 생성 생성자를 사용한다.

```dart
class Point {
  // Initializer list of variables and values
	// 변수와 값의 초기화 목록
  double x = 2.0;
  double y = 2.0;

  // Generative constructor with initializing formal parameters:
  // 초기화 형식 매개변수를 사용하는 생성 생성자:
  Point(this.x, this.y);
}

```

### **Default constructors[#](https://dart.dev/language/constructors#default-constructors) 기본 생성자**

**If you don't declare a constructor, Dart uses the default constructor. The default constructor is a generative constructor without arguments or name.**

생성자를 선언하지 않으면 Dart는 기본 생성자를 사용합니다. 기본 생성자는 인수나 이름이 없는 생성 생성자이다.

-   **[code] 기본 생성자 예시**
    
    ```dart
    class Person {
      String name;
      int age;
    
      // 기본 생성자: Person() {} (자동으로 제공됨)
    }
    
    void main() {
      // 기본 생성자를 사용하여 객체 생성
      var person = Person();
      person.name = "Alice";
      person.age = 30;
    
      print('Name: ${person.name}, Age: ${person.age}'); // 출력: Name: Alice, Age: 30
    }
    
    ```
    

### **Named constructors[#](https://dart.dev/language/constructors#named-constructors) 명명된 생성자**

**Use a named constructor to implement multiple constructors for a class or to provide extra clarity:**

클래스에 대해 여러 생성자를 구현하거나 추가적인 명확성을 제공하려면 명명된 생성자를 사용하라:

```dart
const double xOrigin = 0;
const double yOrigin = 0;

class Point {
  final double x;
  final double y;

  // Sets the x and y instance variables
  // before the constructor body runs.
  // 생성자 본문이 실행되기 전에 x와 y 인스턴스 변수를 설정합니다.
  Point(this.x, this.y);

  // 명명된 생성자
  // Named constructor
  Point.origin()
      : x = xOrigin,
        y = yOrigin;
}

```

**A subclass doesn't inherit a superclass's named constructor. To create a subclass with a named constructor defined in the superclass, implement that constructor in the subclass.**

하위 클래스는 상위 클래스의 명명된 생성자를 상속하지 않는다. 상위 클래스에서 정의된 명명된 생성자로 하위 클래스를 생성하려면, 하위 클래스에서 해당 생성자를 구현해야 한다.

-   **[code] 예시 코드**
    
    ```dart
    class Shape {
      double width;
      double height;
    
      // 기본 생성자
      Shape(this.width, this.height);
    
      // 명명된 생성자
      Shape.square(double size) : width = size, height = size;
    }
    
    class Rectangle extends Shape {
      String color;
    
      // 기본 생성자
      Rectangle(double width, double height, this.color) : super(width, height);
    
      // 명명된 생성자를 서브클래스에서 구현
      Rectangle.square(double size, this.color) : super.square(size);
    }
    
    void main() {
      // 기본 생성자를 사용하여 객체 생성
      var rect1 = Rectangle(10, 20, "red");
      print('Rectangle 1: width=${rect1.width}, height=${rect1.height}, color=${rect1.color}');
    
      // 명명된 생성자를 사용하여 객체 생성
      var rect2 = Rectangle.square(15, "blue");
      print('Rectangle 2: width=${rect2.width}, height=${rect2.height}, color=${rect2.color}');
    }
    
    ```
    

### **Constant constructors[#](https://dart.dev/language/constructors#constant-constructors) 상수 생성자**

**If your class produces unchanging objects, make these objects compile-time constants. To make objects compile-time constants, define a `const` constructor with all instance variables set as `final`.**

클래스가 변경되지 않는 객체를 생성하는 경우 이러한 객체를 컴파일 타임 상수로 만들어라. 컴파일 타임 상수를 만들려면 모든 인스턴스 변수를 final로 설정한 const 생성자를 정의하라.

-   **[Q] 클래스가 변경되지 않는 객체?**
    
    클래스가 생성한 객체의 상태가 한 번 설정된 이후에는 변경되지 않는다는 의미이다. 즉, 이러한 객체는 불변(immutable) 객체입니다. 불변 객체는 생성된 이후에 그 속성이나 상태가 변경되지 않으므로, 안정적이고 예측 가능한 동작을 보장한다.
    
-   **[Q] Constant constructor는 언제 사용하나?**
    
    const 생성자는 객체를 불변(immutable)으로 만들고, 컴파일 시간에 상수로 간주될 수 있는 객체를 생성할 때 사용된다.
    
    Dart에서 const 생성자를 사용하면 해당 객체는 불변이며, 동일한 값의 const 객체는 메모리 내에서 단 하나의 인스턴스만 생성된다. 이는 메모리 사용을 최적화하고 성능을 향상시킬 수 있다.
    

```dart
class ImmutablePoint {
  static const ImmutablePoint origin = ImmutablePoint(0, 0);

  final double x, y;

  const ImmutablePoint(this.x, this.y);
}

```

**Constant constructors don't always create constants. They might be invoked in a non-`const` context. To learn more, consult the section on [using constructors](https://dart.dev/language/classes#using-constructors).**

상수 생성자는 항상 상수를 생성하지는 않는다. 비상수 컨텍스트에서 호출될 수도 있습니다. 자세한 내용은 생성자 사용 섹션을 참조하십시오.

-   **[Q] 항상 상수 생성자를 생정하지 않는다?**
    
    const 생성자는 객체를 불변으로 만들고 컴파일 타임 상수로 사용할 수 있게 하지만, const 생성자가 호출되는 문맥에 따라 실제로 상수가 되지 않을 수도 있다. 즉, const 생성자는 상수 컨텍스트에서 호출될 때만 상수를 생성한다.
    
    **상수 컨텍스트**
    
    const 생성자가 상수 컨텍스트에서 호출되면, 생성된 객체는 컴파일 타임 상수로 간주된다. 이 경우, 동일한 값을 가지는 const 객체는 메모리 내에서 하나의 인스턴스만 공유하게 된다.
    
    ```dart
    class ImmutablePoint {
      final double x;
      final double y;
    
      // const 생성자
      const ImmutablePoint(this.x, this.y);
    }
    
    void main() {
      // 상수 컨텍스트에서 const 객체 생성
      const point1 = ImmutablePoint(1, 1);
      const point2 = ImmutablePoint(1, 1);
    
      // 동일한 값을 가진 const 객체는 메모리를 공유
      print(identical(point1, point2)); // 출력: true
    }
    
    ```
    
    **비상수 컨텍스트**
    
    const 생성자가 비상수 컨텍스트에서 호출되면, 생성된 객체는 상수로 간주되지 않는다. 이 경우, 동일한 값을 가지더라도 각기 다른 인스턴스로 생성될 수 있다.
    
    ```dart
    class ImmutablePoint {
      final double x;
      final double y;
    
      // const 생성자
      const ImmutablePoint(this.x, this.y);
    }
    
    void main() {
      // 비상수 컨텍스트에서 const 객체 생성
      var point1 = ImmutablePoint(1, 1); // const가 아닌 var 사용
      var point2 = ImmutablePoint(1, 1);
    
      // 동일한 값을 가지더라도 서로 다른 인스턴스
      print(identical(point1, point2)); // 출력: false
    }
    
    ```
    

### **Redirecting constructors[#](https://dart.dev/language/constructors#redirecting-constructors) 리디렉팅 생성자**

**A constructor might redirect to another constructor in the same class. A redirecting constructor has an empty body. The constructor uses `this` instead of the class name after a colon (:).**

생성자는 동일한 클래스의 다른 생성자로 호출을 전달할 수 있다. 위임(redirect) 생성자는 본문이 비어 있습니다. 생성자는 콜론(:) 뒤에 클래스 이름 대신 this를 사용한다.

```dart
class Point {
  double x, y;

  // The main constructor for this class.
  // 이 클래스의 주요 생성자.
  Point(this.x, this.y);

  // Delegates to the main constructor.
  // 주요 생성자로 위임.
  Point.alongXAxis(double x) : this(x, 0);
}

```

### **Factory constructors[#](https://dart.dev/language/constructors#factory-constructors) 팩토리 생성자**

**When encountering one of following two cases of implementing a constructor, use the `factory` keyword:**

다음 두 가지 경우 중 하나에 해당할 때는 factory 키워드를 사용하여 생성자를 구현하라:

-   **The constructor doesn't always create a new instance of its class. Although a factory constructor cannot return `null`, it might return:**
    
    생성자가 항상 해당 클래스의 새 인스턴스를 생성하지 않는 경우. 팩토리 생성자는 null을 반환할 수 없지만, 다음과 같은 경우가 있을 수 있다:
    
    -   **an existing instance from a cache instead of creating a new one**
        
        새 인스턴스를 생성하는 대신 캐시에서 기존 인스턴스를 반환하는 경우
        
    -   **a new instance of a subtype**
        
        하위 유형의 새 인스턴스를 반환하는 경우
        
-   **You need to perform non-trivial work prior to constructing an instance. This could include checking arguments or doing any other processing that cannot be handled in the initializer list.**
    
    인스턴스를 생성하기 전에 복잡한 작업을 수행해야 하는 경우. 여기에는 인수 확인 또는 초기화 목록에서 처리할 수 없는 기타 처리가 포함된다.
    

<aside> ℹ️ **Tip**

**You can also handle late initialization of a final variable with [`late final`](https://dart.dev/effective-dart/design#avoid-public-late-final-fields-without-initializers) (carefully!).**

late final을 사용하여 final 변수를 나중에 초기화할 수도 있습니다(주의해서 사용하십시오!).

</aside>

**The following example includes two factory constructors.**

다음 예제는 두 개의 팩토리 생성자를 포함한다.

-   **`Logger` factory constructor returns objects from a cache.**
    
    Logger 팩토리 생성자는 캐시에서 객체를 반환한다.
    
-   **`Logger.fromJson` factory constructor initializes a final variable from a JSON object.**
    
    Logger.fromJson 팩토리 생성자는 JSON 객체로부터 final 변수를 초기화한다.
    

```dart
class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to
  // the _ in front of its name.
  static final Map<String, Logger> _cache = <String, Logger>{};

  factory Logger(String name) {
    return _cache.putIfAbsent(name, () => Logger._internal(name));
  }

  factory Logger.fromJson(Map<String, Object> json) {
    return Logger(json['name'].toString());
  }

  Logger._internal(this.name);

  void log(String msg) {
    if (!mute) print(msg);
  }
}

```

<aside> ℹ️ **Warning**

**Factory constructors can't access `this`.**

팩토리 생성자는 this에 접근할 수 없습니다.

</aside>

**Use a factory constructor as any other constructor:**

팩토리 생성자를 다른 생성자처럼 사용하십시오.

```dart
var logger = Logger('UI');
logger.log('Button clicked');

var logMap = {'name': 'UI'};
var loggerJson = Logger.fromJson(logMap);

```

### **Redirecting factory constructors[#](https://dart.dev/language/constructors#redirecting-factory-constructors) 리디렉팅 팩토리 생성자**

**A redirecting factory constructor specifies a call to a constructor of another class to use whenever someone makes a call to the redirecting constructor.**

리디렉팅 팩토리 생성자는 리디렉팅 생성자를 호출할 때마다 다른 클래스의 생성자를 호출하도록 지정한다.

```dart
factory Listenable.merge(List<Listenable> listenables) = _MergingListenable;

```

**It might appear that ordinary factory constructors could create and return instances of other classes. This would make redirecting factories unnecessary. Redirecting factories have several advantages:**

일반 팩토리 생성자가 다른 클래스의 인스턴스를 생성하고 반환할 수 있을 것처럼 보일 수 있다. 이것은 리디렉팅 팩토리를 불필요하게 만들 수 있다. 하지만 리디렉팅 팩토리에는 여러 가지 장점이 있다:

-   **An abstract class might provide a constant constructor that uses the constant constructor of another class.**
    
    추상 클래스는 다른 클래스의 상수 생성자를 사용하는 상수 생성자를 제공할 수 있다.
    
-   **A redirecting factory constructor avoids the need for forwarders to repeat the formal parameters and their default values.**
    
    리디렉팅 팩토리 생성자는 포워더가 형식 매개변수와 기본값을 반복할 필요를 없앤다.
    

### **Constructor tear-offs[#](https://dart.dev/language/constructors#constructor-tear-offs) 생성자 티어 오프**

**Dart allows you to supply a constructor as a parameter without calling it. Called a _tear-off_ (as you _tear off_ the parentheses) serves as a closure that invokes the constructor with the same parameters.**

Dart에서는 생성자를 호출하지 않고 매개변수로 제공할 수 있다. 이것을 tear-off라고 하며, 괄호를 떼어낸다는 의미이다. tear-off는 동일한 매개변수로 생성자를 호출하는 클로저로 동작한다.

-   **[Q] 생성자를 호출하지 않고 매개변수로 제공?**
    
    Dart에서는 생성자를 호출하지 않고 매개변수로 제공할 수 있다는 말은, **생성자 그 자체를 함수나 메서드의 인수로 넘길 수 있다는 뜻**이다. 이를 통해 해당 생성자를 나중에 필요할 때 호출 할 수 있다.
    
-   **[Q] 티어오프의 장점? 사용 이유?**
    
    **지연 호출**
    
    생성자를 나중에 필요할 때 호출할 수 있다.
    
    **콜백 함수로 사용**
    
    생성자를 콜백 함수로 전달하여, 함수 내부에서 객체를 생성할 수 있다.
    
    **코드 가독성 향상**
    
    생성자 참조를 직접 넘김으로써, 코드가 더 간결하고 이해하기 쉬워진다.
    

**If the tear-off is a constructor with the same signature and return type as the method accepts, you can use the tear-off as a parameter or variable.**

티어 오프가 메서드가 받아들이는 매개변수와 반환 타입이 동일한 생성자인 경우, 이를 매개변수나 변수로 사용할 수 있다.

**Tear-offs differ from lambdas or anonymous functions. Lambdas serve as a wrapper for the constructor whereas a tear-off is the constructor.**

티어 오프는 람다 또는 익명 함수와 다르다. 람다는 생성자를 래핑하는 반면, 티어 오프는 생성자이다.

**Use Tear-Offs** 티어 오프 사용 예시

**Good**

```dart
// Use a tear-off for a named constructor: 
// 명명된 생성자에 대한 티어 오프 사용:
var strings = charCodes.map(String.fromCharCode);  

// Use a tear-off for an unnamed constructor: 
// 이름이 없는 생성자에 대한 티어 오프 사용:
var buffers = charCodes.map(StringBuffer.new);

```

-   **[code] 티어오프 사용 예시**
    
    **함수 tear-off**
    
    ```dart
    void sayHello(String name) {
      print('Hello, $name!');
    }
    
    void main() {
      // 함수 참조를 변수에 저장
      var greet = sayHello;
    
      // 나중에 함수 호출
      greet('Alice'); // 출력: Hello, Alice!
    }
    
    ```
    
    **생성자 tear-off**
    
    ```dart
    class Person {
      String name;
    
      Person(this.name);
    
      @override
      String toString() => 'Person(name: $name)';
    }
    
    void main() {
      // 생성자 참조를 변수에 저장
      var personMaker = Person.new;
    
      // 나중에 생성자 호출
      var person = personMaker('Bob');
      print(person); // 출력: Person(name: Bob)
    }
    
    ```
    

**Not Lambdas** 람다 대신

**Bad**

```dart
// Instead of a lambda for a named constructor:
// 명명된 생성자에 대한 람다 대신:
var strings = charCodes.map((code) => String.fromCharCode(code));

// Instead of a lambda for an unnamed constructor:
// 이름이 없는 생성자에 대한 람다 대신:
var buffers = charCodes.map((code) => StringBuffer(code));

```

-   **[Q] 람다와의 차이점**
    
    **람다**
    
    람다는 함수나 생성자를 감싸는 래퍼이다. 람다는 새로운 함수로, 내부에서 다른 함수를 호출한다.
    
    **tear-off**:
    
    tear-off는 함수나 생성자 자체를 가리킨다. 즉, 추가적인 래퍼 없이 원래의 함수나 생성자를 참조한다.
    

**For visual learners, watch this Decoding Flutter video on tear-offs.**

시각적 학습을 위해, 생성자 티어 오프에 대한 Decoding Flutter 영상을 시청해보세요.


## **Instance Variable Initialization[#](https://dart.dev/language/constructors#instance-variable-initialization) 인스턴스 변수 초기화**

**Dart can initialize variables in three ways.**

Dart는 변수를 세 가지 방식으로 초기화할 수 있다.

### **Initialize instance variables in the declaration[#](https://dart.dev/language/constructors#initialize-instance-variables-in-the-declaration) 변수 선언 시 인스턴스 변수 초기화**

**Initialize the instance variables when you declare the variables.**

변수를 선언할 때 인스턴스 변수를 초기화한다.

```dart
class PointA {
  double x = 1.0;
  double y = 2.0;

  // The implicit default constructor sets these variables to (1.0,2.0)
  // 기본 생성자는 이 변수를 (1.0, 2.0)으로 설정합니다.
  // PointA();

  @override
  String toString() {
    return 'PointA($x, $y)';
  }
}

```

### **Use initializing formal parameters[#](https://dart.dev/language/constructors#use-initializing-formal-parameters) 초기화 형식 매개변수 사용**

**To simplify the common pattern of assigning a constructor argument to an instance variable, Dart has _initializing formal parameters_.**

생성자 인수를 인스턴스 변수에 할당하는 일반적인 패턴을 단순화하기 위해 Dart는 초기화 형식 매개변수를 제공한다.

**In the constructor declaration, include `this.<propertyName>` and omit the body. The `this` keyword refers to the current instance.**

생성자 선언에서 this.<propertyName>을 포함하고 본문을 생략한다. this 키워드는 현재 인스턴스를 참조한다.

**When the name conflict exists, use `this`. Otherwise, Dart style omits the `this`. An exception exists for the generative constructor where you must prefix the initializing formal parameter name with `this`.**

이름 충돌이 발생하면 this를 사용하십시오. 그렇지 않으면 Dart 스타일에서는 this를 생략한다. 생성 생성자의 경우, 초기화 형식 매개변수 이름 앞에 this를 접두사로 붙여야 한다.

**As noted earlier in this guide, certain constructors and certain parts of constructors can't access `this`. These include:**

이 가이드에서 앞서 언급한 것처럼, 특정 생성자와 생성자의 특정 부분은 this에 접근할 수 없다. 여기에는 다음이 포함된다:

-   **Factory constructors**
    
    팩토리 생성자
    
-   **The right-hand side of an initializer list**
    
    초기화 목록의 오른쪽
    
-   **Arguments to a superclass constructor**
    
    상위 클래스 생성자의 인수
    

**Initializing formal parameters also allow you to initialize non-nullable or `final` instance variables. Both of these types of variables require initialization or a default value.**

초기화 형식 매개변수를 사용하면 널이 될 수 없는 변수 또는 final 인스턴스 변수를 초기화할 수 있다. 이러한 유형의 변수는 초기화 또는 기본값이 필요하다.

```dart
class PointB {
  final double x;
  final double y;

  // Sets the x and y instance variables
  // before the constructor body runs.
  // 생성자 본문이 실행되기 전에 x와 y 인스턴스 변수를 설정합니다.
  PointB(this.x, this.y);

  // Initializing formal parameters can also be optional.
	// 초기화 형식 매개변수는 선택 사항일 수도 있습니다.
  PointB.optional([this.x = 0.0, this.y = 0.0]);
}

```

**Private fields can't be used as named initializing formals.**

프라이빗 필드는 명명된 초기화 형식 매개변수로 사용할 수 없다.

```dart
class PointB {
// ...

  PointB.namedPrivate({required double x, required double y})
      : _x = x,
        _y = y;

// ...
}

```

**This also works with named variables.**

이 방법은 이름 있는 변수에도 사용할 수 있다.

```dart
class PointC {
  double x; // must be set in constructor 생성자에서 설정해야 함
  double y; // must be set in constructor 생성자에서 설정해야 함

  // Generative constructor with initializing formal parameters
  // with default values
  // 기본값을 갖는 초기화 형식 매개변수를 사용하는 생성 생성자
  PointC.named({this.x = 1.0, this.y = 1.0});

  @override
  String toString() {
    return 'PointC.named($x,$y)';
  }
}

// Constructor using named variables.
// 이름 있는 변수를 사용하는 생성자.
final pointC = PointC.named(x: 2.0, y: 2.0);

```

**All variables introduced from initializing formal parameters are both final and only in scope of the initialized variables.**

초기화 형식 매개변수로 도입된 모든 변수는 final이며 초기화된 변수의 범위 내에만 존재한다.

**To perform logic that you can't express in the initializer list, create a [factory constructor](https://dart.dev/language/constructors#factory-constructors) or [static method](https://dart.dev/language/classes#static-methods) with that logic. You can then pass the computed values to a normal constructor.**

초기화 목록에서 표현할 수 없는 로직을 수행하려면 팩토리 생성자나 해당 로직을 포함하는 정적 메서드를 생성하라. 그런 다음 계산된 값을 일반 생성자에 전달할 수 있다.

**The constructor parameters could be set as nullable and not be initialized.**

생성자 매개변수는 nullable로 설정될 수 있으며 초기화되지 않을 수도 있다.

```dart
class PointD {
  double? x; // null if not set in constructor 생성자에서 설정되지 않으면 null
  double? y; // null if not set in constructor 생성자에서 설정되지 않으면 null

  // Generative constructor with initializing formal parameters  
  // 초기화 형식 매개변수를 사용하는 생성 생성자
  PointD(this.x, this.y);

  @override
  String toString() {
    return 'PointD($x,$y)';
  }
}

```

### **Use an initializer list[#](https://dart.dev/language/constructors#use-an-initializer-list) 초기화 목록 사용**

**Before the constructor body runs, you can initialize instance variables. Separate initializers with commas.**

생성자 본문이 실행되기 전에 인스턴스 변수를 초기화할 수 있다. 초기화자는 콤마로 구분한다.

```dart
// 초기화 목록은 생성자 본문이 실행되기 전에 인스턴스 변수를 설정합니다.
Point.fromJson(Map<String, double> json)
    : x = json['x']!,
      y = json['y']! {
  print('In Point.fromJson(): ($x, $y)');
}

```

<aside> ℹ️ **Warning**

**The right-hand side of an initializer list can't access `this`.**

초기화 목록의 오른쪽에서는 this에 접근할 수 없다.

</aside>

**To validate inputs during development, use `assert` in the initializer list.**

개발 중 입력값을 검증하려면 초기화 목록에서 assert를 사용하라.

```dart
Point.withAssert(this.x, this.y) : assert(x >= 0) {
  print('In Point.withAssert(): ($x, $y)');
}

```

**Initializer lists help set up `final` fields.**

초기화 목록은 final 필드를 설정하는 데 도움이 된다.

**The following example initializes three `final` fields in an initializer list. To execute the code, click Run.**

다음 예제는 초기화 목록에서 세 개의 final 필드를 초기화합니다. 코드를 실행하려면 Run을 클릭하라.

```dart
import 'dart:math';

class Point {
  final double x;
  final double y;
  final double distanceFromOrigin;

  Point(double x, double y)
      : x = x,
        y = y,
        distanceFromOrigin = sqrt(x * x + y * y);
}

void main() {
  var p = Point(2, 3);
  print(p.distanceFromOrigin);
}

```

```dart
// 출력 결과
3.605551275463989

```

----------

## **Constructor inheritance[#](https://dart.dev/language/constructors#constructor-inheritance) 생성자 상속**

**_Subclasses_, or child classes, don't inherit _constructors_ from their _superclass_, or immediate parent class. If a class doesn't declare a constructor, it can only use the [default constructor](https://dart.dev/language/constructors#default-constructors).**

서브클래스(또는 자식 클래스)는 상위 클래스(또는 즉시 상위 클래스)의 생성자를 상속하지 않는다. 클래스가 생성자를 선언하지 않으면 기본 생성자만 사용할 수 있다.

**A class can inherit the _parameters_ of a superclass. These are called [super parameters](https://dart.dev/language/constructors#super-parameters)**

클래스는 상위 클래스의 매개변수를 상속할 수 있다. 이러한 매개변수를 super 매개변수라고 한다.

**Constructors work in a somewhat similar way to how you call a chain of static methods. Each subclass can call its superclass's constructor to initialize an instance, like a subclass can call a superclass's static method. This process doesn't "inherit" constructor bodies or signatures.**

생성자는 체인으로 정적 메서드를 호출하는 방식과 다소 유사하게 작동한다. 각 서브클래스는 인스턴스를 초기화하기 위해 상위 클래스의 생성자를 호출할 수 있으며, 이는 서브클래스가 상위 클래스의 정적 메서드를 호출하는 방식과 유사하다. 이 과정은 생성자 본문이나 시그니처를 “상속”하지 않는다.

### **Non-default superclass constructors[#](https://dart.dev/language/constructors#non-default-superclass-constructors) 기본값이 아닌 상위 클래스 생성자**

**Dart executes constructors in the following order:**

Dart는 생성자를 다음 순서로 실행한다:

1.  [**initializer list**](https://dart.dev/language/constructors#use-an-initializer-list)
    
    초기화 목록
    
2.  **superclass's unnamed, no-arg constructor**
    
    상위 클래스의 이름이 없는 인수가 없는 생성자
    
3.  **main class's no-arg constructor**
    
    메인 클래스의 인수가 없는 생성자
    

**If the superclass lacks an unnamed, no-argument constructor, call one of the constructors in the superclass. Before the constructor body (if any), specify the superclass constructor after a colon (`:`).**

상위 클래스에 이름이 없는 인수가 없는 생성자가 없는 경우, 상위 클래스의 다른 생성자 중 하나를 호출해야 한다. 생성자 본문(있는 경우) 전에 콜론(:)을 사용하여 상위 클래스 생성자를 지정한다.

**In the following example, the `Employee` class constructor calls the named constructor for its superclass, `Person`. To execute the following code, click Run.**

다음 예제에서, Employee 클래스 생성자는 상위 클래스 Person의 명명된 생성자를 호출한다. 코드를 실행하려면 Run을 클릭하라.

```dart
class Person {
  String? firstName;

  Person.fromJson(Map data) {
    print('in Person');
  }
}

class Employee extends Person {
  // Person does not have a default constructor;
  // you must call super.fromJson().
  Employee.fromJson(Map data) : super.fromJson(data) {
    print('in Employee');
  }
}

void main() {
  var employee = Employee.fromJson({});
  print(employee);
  // Prints:
  // in Person
  // in Employee
  // Instance of 'Employee'
}

```

```dart
// 출력 결과
in Person
in Employee
Instance of 'Employee'

```

**As Dart evaluates the arguments to the superclass constructor _before_ invoking the constructor, an argument can be an expression like a function call.**

Dart는 생성자를 호출하기 전에 상위 클래스 생성자의 인수를 평가하므로, 인수는 함수 호출과 같은 표현식일 수 있다.

```dart
class Employee extends Person {
  Employee() : super.fromJson(fetchDefaultData());
  // ···
}

```

<aside> ℹ️ **Warning**

**Arguments to the superclass constructor can't access `this`. For example, arguments can call _static_ methods but not _instance_ methods.**

상위 클래스 생성자에 전달되는 인수는 this에 접근할 수 없다. 예를 들어, 인수는 정적 메서드를 호출할 수 있지만 인스턴스 메서드를 호출할 수는 없다.

</aside>

### **Super parameters[#](https://dart.dev/language/constructors#super-parameters) 슈퍼 매개변수**

**To avoid passing each parameter into the super invocation of a constructor, use super-initializer parameters to forward parameters to the specified or default superclass constructor. You can't use this feature with [redirecting constructors](https://dart.dev/language/constructors#redirecting-constructors). Super-initializer parameters have syntax and semantics like [initializing formal parameters](https://dart.dev/language/constructors#use-initializing-formal-parameters).**

각 매개변수를 생성자의 super 호출에 전달하는 것을 피하기 위해, super 초기화 매개변수를 사용하여 지정된 상위 클래스 생성자나 기본 상위 클래스 생성자에 매개변수를 전달할 수 있다. 이 기능은 리디렉팅 생성자에서는 사용할 수 없다. Super 초기화 매개변수는 초기화 형식 매개변수와 유사한 구문과 의미를 가진다.

<aside> ℹ️ **Version note**

**Using super-initializer parameters requires a [language version](https://dart.dev/guides/language/evolution#language-versioning) of at least 2.17. If you're using an earlier language version, you must manually pass in all super constructor parameters.**

슈퍼 초기화 매개변수를 사용하려면 언어 버전이 최소 2.17 이상이어야 한다. 이전 언어 버전을 사용하는 경우, 모든 슈퍼 생성자 매개변수를 수동으로 전달해야 한다.

</aside>

**If the super-constructor invocation includes positional arguments, super-initializer parameters can't be positional.**

슈퍼 생성자 호출에 위치 인수가 포함된 경우, 슈퍼 초기화 매개변수는 위치 인수가 될 수 없다.

```dart
class Vector2d {
  final double x;
  final double y;

  Vector2d(this.x, this.y);
}

class Vector3d extends Vector2d {
  final double z;

  // Forward the x and y parameters to the default super constructor like:  
  // x와 y 매개변수를 기본 상위 생성자로 전달:
  // Vector3d(final double x, final double y, this.z) : super(x, y);
  Vector3d(super.x, super.y, this.z);
}

```

**To further illustrate, consider the following example.**

더 설명하기 위해, 다음 예제를 고려하라.

```dart
  // If you invoke the super constructor (`super(0)`) with any
  // positional arguments, using a super parameter (`super.x`)
  // results in an error.
  // 위치 인수(`super(0)`)를 사용하여 상위 생성자를 호출하면
	// 슈퍼 매개변수(`super.x`)를 사용하는 경우 오류가 발생합니다.
  Vector3d.xAxisError(super.x): z = 0, super(0); // BAD

```

**This named constructor tries to set the `x` value twice: once in the super constructor and once as a positional super parameter. As both address the `x` positional parameter, this results in an error.**

이 명명된 생성자는 상위 생성자에서 한 번, 위치 슈퍼 매개변수에서 한 번, 두 번 x 값을 설정하려고 한다. 두 매개변수가 x 위치 인수를 참조하므로 오류가 발생한다.

**When the super constructor has named arguments, you can split them between named super parameters (`super.y` in the next example) and named arguments to the super constructor invocation (`super.named(x: 0)`).**

상위 생성자에 명명된 인수가 있는 경우, 이를 명명된 슈퍼 매개변수(super.y와 같은)와 상위 생성자 호출의 명명된 인수(super.named(x: 0))로 나눌 수 있다.

```dart
class Vector2d {
  // ...
  Vector2d.named({required this.x, required this.y});
}

class Vector3d extends Vector2d {
  final double z;

  // Forward the y parameter to the named super constructor like:
  // y 매개변수를 명명된 슈퍼 생성자로 전달:  
  // Vector3d.yzPlane({required double y, required this.z})
  //       : super.named(x: 0, y: y);
  Vector3d.yzPlane({required super.y, required this.z}) : super.named(x: 0);
}

```

---

🔗 [페이지 링크]

# **Methods**

**Methods are functions that provide behavior for an object.**

메서드는 객체에 동작을 제공하는 함수이다.


## **Instance methods[#](https://dart.dev/language/methods#instance-methods) 인스턴스 메서드**

**Instance methods on objects can access instance variables and `this`. The `distanceTo()` method in the following sample is an example of an instance method:**

객체의 인스턴스 메서드는 인스턴스 변수와 this에 접근할 수 있다. 다음 예제의 distanceTo() 메서드는 인스턴스 메서드의 예이다:

```dart
import 'dart:math';

class Point {
  final double x;
  final double y;

  // Sets the x and y instance variables
  // before the constructor body runs.
  Point(this.x, this.y);

  double distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}

```

----------

## **Operators[#](https://dart.dev/language/methods#operators) 연산자**

**Most operators are instance methods with special names. Dart allows you to define operators with the following names:**

대부분의 연산자는 특수 이름을 가진 인스턴스 메서드이다. Dart는 다음 이름의 연산자를 정의할 수 있다:

<

>

<=

>=

==

~

-

+

/

~/

*

%

ˆ

&

<<

>>>

[]=

[]

<aside> ℹ️ **Note**

**You may have noticed that some [operators](https://dart.dev/language/operators), like `!=`, aren't in the list of names. These operators aren't instance methods. Their behavior is built in to Dart.**

!= 같은 일부 연산자가 이름 목록에 없음을 눈치챘을 것이다. 이러한 연산자는 인스턴스 메서드가 아니다. 이들의 동작은 Dart에 내장되어 있습니다.

</aside>

**To declare an operator, use the built-in identifier `operator` then the operator you are defining. The following example defines vector addition (`+`), subtraction (`-`), and equality (`==`):**

연산자를 선언하려면 내장 식별자인 operator와 정의할 연산자를 사용하라. 다음 예제는 벡터 덧셈(+), 뺄셈(-), 그리고 동등성(==)을 정의한다:

```dart
class Vector {
  final int x, y;

  Vector(this.x, this.y);

  Vector operator +(Vector v) => Vector(x + v.x, y + v.y);
  Vector operator -(Vector v) => Vector(x - v.x, y - v.y);

  @override
  bool operator ==(Object other) =>
      other is Vector && x == other.x && y == other.y;

  @override
  int get hashCode => Object.hash(x, y);
}

void main() {
  final v = Vector(2, 3);
  final w = Vector(2, 2);

  assert(v + w == Vector(4, 5));
  assert(v - w == Vector(0, 1));
}

```

----------

## **Getters and setters[#](https://dart.dev/language/methods#getters-and-setters)** 게터와 세터

**Getters and setters are special methods that provide read and write access to an object's properties. Recall that each instance variable has an implicit getter, plus a setter if appropriate. You can create additional properties by implementing getters and setters, using the `get` and `set` keywords:**

getter와 setter는 객체의 속성에 대한 읽기 및 쓰기 접근을 제공하는 특수 메서드이다. 각 인스턴스 변수는 암시적인 getter를 가지며, 필요에 따라 setter도 가질 수 있다. get과 set 키워드를 사용하여 getter와 setter를 구현함으로써 추가 속성을 생성할 수 있다:

```dart
class Rectangle {
  double left, top, width, height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Define two calculated properties: right and bottom.
  double get right => left + width;
  set right(double value) => left = value - width;
  double get bottom => top + height;
  set bottom(double value) => top = value - height;
}

void main() {
  var rect = Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}

```

**With getters and setters, you can start with instance variables, later wrapping them with methods, all without changing client code.**

Getter와 setter를 사용하면 인스턴스 변수로 시작하여 나중에 메서드로 래핑할 수 있으며, 클라이언트 코드를 변경하지 않아도 된다.

<aside> ℹ️ **Note**

**Operators such as increment (++) work in the expected way, whether or not a getter is explicitly defined. To avoid any unexpected side effects, the operator calls the getter exactly once, saving its value in a temporary variable.**

증가(++)와 같은 연산자는 getter가 명시적으로 정의되지 않았더라도 예상대로 작동합니다. 예기치 않은 부작용을 피하기 위해 연산자는 getter를 정확히 한 번 호출하여 임시 변수에 값을 저장합니다.

</aside>


## **Abstract methods[#](https://dart.dev/language/methods#abstract-methods) 추상 메서드**

**Instance, getter, and setter methods can be abstract, defining an interface but leaving its implementation up to other classes. Abstract methods can only exist in [abstract classes](https://dart.dev/language/class-modifiers#abstract) or [mixins](https://dart.dev/language/mixins).**

인스턴스, getter, 및 setter 메서드는 추상적일 수 있으며, 인터페이스를 정의하지만 구현은 다른 클래스에 맡긴다. 추상 메서드는 추상 클래스나 믹스인에서만 존재할 수 있다.

**To make a method abstract, use a semicolon (`;`) instead of a method body:**

메서드를 추상 메서드로 만들려면 메서드 본문 대신 세미콜론(;)을 사용하라:

```dart
abstract class Doer {
  // Define instance variables and methods...
  // 인스턴스 변수와 메서드를 정의합니다...

  void doSomething(); // Define an abstract method.
  // 추상 메서드를 정의합니다.
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // Provide an implementation, so the method is not abstract here...
    // 구현을 제공하여 이 메서드는 여기에서 추상적이지 않습니다...
  }
}

```
