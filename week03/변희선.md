Dart(Error handling)
공식문서 : https://dart.dev/language/error-handling

# Error handling

**Exceptions**

Your Dart code can throw and catch exceptions. Exceptions are errors indicating that something unexpected happened. If the exception isn't caught, the [isolate](https://dart.dev/language/concurrency#isolates) that raised the exception is suspended, and typically the isolate and its program are terminated.

In contrast to Java, all of Dart's exceptions are unchecked exceptions. Methods don't declare which exceptions they might throw, and you aren't required to catch any exceptions.

Dart provides [`Exception`](https://api.dart.dev/stable/dart-core/Exception-class.html) and [`Error`](https://api.dart.dev/stable/dart-core/Error-class.html) types, as well as numerous predefined subtypes. You can, of course, define your own exceptions. However, Dart programs can throw any non-null object—not just Exception and Error objects—as an exception.

> **예외**
> 
> 
> 
> Dart 코드는 예외를 던지고 잡을 수 있습니다. 예외는 예기치 않은 일이 발생했음을 나타내는 오류입니다. 
> 예외가 잡히지 않으면 예외를 발생시킨 고립이 일시 중단되고 일반적으로 고립과 해당 프로그램이 종료됩니다.
> 
> Java와 달리 Dart의 모든 예외는 체크되지 않은 예외입니다. 메서드는 어떤 예외를 던질지 선언하지 않으며, 예외를 잡을 필요도 없습니다.
> 
> Dart는 예외 및 오류 유형뿐만 아니라 미리 정의된 수많은 하위 유형을 제공합니다. 물론 예외를 직접 정의할 수도 있습니다. 그러나 Dart 프로그램은 예외 및 오류 객체뿐만 아니라 null이 아닌 모든 객체를 예외로 던질 수 있습니다.
> 

**Throw**

```dart
// 최소한 하나의 섹션이 있어야 하는데, 그렇지 않은 경우 발생하는 예외를 던집니다.
throw FormatException('Expected at least 1 section');

// "Out of llamas!"라는 문자열을 예외로 던집니다. 
// 이는 일반적인 예외 객체가 아닌 문자열 예외입니다.
throw 'Out of llamas!';

// 메서드가 아직 구현되지 않았음을 나타내는 예외를 던집니다.
// 이 메서드는 나중에 구현될 예정입니다.
void distanceTo(Point other) => throw UnimplementedError();

```

**Catch**

****

```dart
**// 예외를 잡거나 캡처하면 예외가 전파되는 것이 중지됩니다(예외를 다시 던지지 않는 한).
// 예외를 잡으면 예외를 처리할 수 있는 기회가 주어집니다**
try {
  breedMoreLlamas();
} on OutOfLlamasException {
  // OutOfLlamasException 예외가 발생할 때 
  // buyMoreLlamas()를 호출하여 추가적인 라마를 구매합니다.
  buyMoreLlamas();
}
**//두 가지 이상의 예외 유형을 던질 수 있는 코드를 처리하려면 여러 개의 catch 절을 지정할 수 있습니다**
try {
  breedMoreLlamas();
} on OutOfLlamasException {
  // 특정 예외인 OutOfLlamasException이 발생하면 buyMoreLlamas()를 호출합니다.
  // 특정 예외를 처리할 때 사용합니다.
  buyMoreLlamas();
} on Exception catch (e) {
  // 그 외의 Exception 타입의 예외가 발생하면 예외 정보를 출력합니다.
  // 특정 예외 외의 다른 예외를 처리할 때 사용합니다.
  print('Unknown exception: $e');
} catch (e) {
  // 위에서 처리하지 않은 모든 예외를 처리하고 예외 정보를 출력합니다.
  // 모든 예외를 포괄적으로 처리할 때 사용합니다.
  print('Something really unknown: $e');
}
**// catch()에 하나 또는 두 개의 매개 변수를 지정할 수 있습니다. 첫 번째는 발생한 예외이고,
// 두 번째는 스택 추적(StackTrace 객체)입니다.**
try {
  // 특정 작업을 수행합니다.
  // 예외가 발생할 수 있는 코드 블록입니다.
} on Exception catch (e) {
  // Exception 타입의 예외가 발생하면 예외 정보를 출력합니다.
  // 특정 타입의 예외를 처리하고 예외 정보를 출력할 때 사용합니다.
  print('Exception details:\n $e');
} catch (e, s) {
  // 그 외의 모든 예외를 처리하고 예외 정보와 스택 트레이스를 출력합니다.
  // 모든 예외를 포괄적으로 처리하고 스택 트레이스를 출력할 때 사용합니다.
  print('Exception details:\n $e');
  print('Stack trace:\n $s');
}
**// 예외를 부분적으로 처리하면서 예외가 전파되도록 허용하려면 재전송 키워드를 사용하세요.**
void misbehave() {
  try {
    dynamic foo = true;
    print(foo++); // 런타임 에러가 발생합니다.
  } catch (e) {
    // 예외를 부분적으로 처리하고 예외 타입을 출력합니다.
    // 예외를 다시 던져 호출자가 예외를 볼 수 있도록 할 때 사용합니다.
    print('misbehave() partially handled ${e.runtimeType}.');
    rethrow; // 예외를 다시 던집니다.
  }
}

void main() {
  try {
    misbehave();
  } catch (e) {
    // 예외를 처리하고 예외 타입을 출력합니다.
    // 호출된 함수에서 발생한 예외를 처리할 때 사용합니다.
    print('main() finished handling ${e.runtimeType}.');
  }
}

```

**Finally**

```dart
try {
  breedMoreLlamas();
} finally {
  // 항상 정리 작업을 수행합니다. 예외가 발생하더라도 finally 블록은 실행됩니다.
  cleanLlamaStalls();
}

try {
  breedMoreLlamas();
} catch (e) {
  // 예외를 먼저 처리합니다.
  print('Error: $e');
} finally {
  // 예외가 발생하든 안 하든 항상 정리 작업을 수행합니다.
  cleanLlamaStalls();
}

```

**Assert**

```dart
// 변수에 null이 아닌 값이 있는지 확인합니다.
assert(text != null);

// 값이 100보다 작은지 확인합니다.
assert(number < 100);

// 이 URL이 https로 시작하는지 확인합니다.
assert(urlString.startsWith('https'));

// 이 URL이 https로 시작하는지 확인하고, 그렇지 않을 경우 메시지를 출력합니다.
assert(urlString.startsWith('https'),
    'URL ($urlString) should start with "https".');

```

When exactly do assertions work? That depends on the tools and framework you're using:

- Flutter enables assertions in [debug mode.](https://docs.flutter.dev/testing/debugging#debug-mode-assertions)
- Development-only tools such as [`webdev serve`](https://dart.dev/tools/webdev#serve) typically enable assertions by default.
- Some tools, such as [`dart run`](https://dart.dev/tools/dart-run) and [`dart compile js`](https://dart.dev/tools/dart-compile#js) support assertions through a command-line flag: `-enable-asserts`.

In production code, assertions are ignored, and the arguments to `assert` aren't evaluated.

> 어설션은 정확히 언제 작동하나요? 사용 중인 도구와 프레임워크에 따라 다릅니다
> 
> - Flutter는 디버그 모드에서 어설션을 활성화합니다.
> - 웹 개발 서비스와 같은 개발 전용 도구는 일반적으로 기본적으로 어설션을 활성화합니다.
> - 닷 실행 및 닷 컴파일 js와 같은 일부 도구는 명령줄 플래그인 --enable-asserts를 통해 어설션을 지원합니다.
> 
> 프로덕션 코드에서는 어설션이 무시되며 어설션 인수는 평가되지 않습니다.
>
> Dart(Classes)
> # Classes

Dart is an object-oriented language with classes and mixin-based inheritance. Every object is an instance of a class, and all classes except `Null` descend from [`Object`](https://api.dart.dev/stable/dart-core/Object-class.html). *Mixin-based inheritance* means that although every class (except for the [top class](https://dart.dev/null-safety/understanding-null-safety#top-and-bottom), `Object?`) has exactly one superclass, a class body can be reused in multiple class hierarchies. [Extension methods](https://dart.dev/language/extension-methods) are a way to add functionality to a class without changing the class or creating a subclass. [Class modifiers](https://dart.dev/language/class-modifiers) allow you to control how libraries can subtype a class.

> **클래스**
Dart는 클래스와 믹스인 기반 상속을 사용하는 객체 지향 언어입니다. 모든 객체는 클래스의 인스턴스이며, Null을 제외한 모든 클래스는 Object에서 파생됩니다. 믹스인 기반 상속은 모든 클래스(최상위 클래스인 Object? 제외)에 정확히 하나의 슈퍼클래스가 있지만 클래스 본문은 여러 클래스 계층 구조에서 재사용할 수 있다는 것을 의미합니다. 확장 메서드는 클래스를 변경하거나 하위 클래스를 만들지 않고도 클래스에 기능을 추가할 수 있는 방법입니다. 클래스 수정자를 사용하면 라이브러리가 클래스의 하위 유형을 지정하는 방법을 제어할 수 있습니다.
> 

**Using class members**

Objects have *members* consisting of functions and data (*methods* and *instance variables*, respectively). When you call a method, you *invoke* it on an object: the method has access to that object's functions and data.

Use a dot (`.`) to refer to an instance variable or method:

> **클래스 멤버 사용**
> 
> 
> 객체에는 함수와 데이터(각각 메서드와 인스턴스 변수)로 구성된 멤버가 있습니다. 메서드를 호출하면 객체에서 메서드를 호출하게 되고, 메서드는 해당 객체의 함수와 데이터에 액세스할 수 있습니다.
> 
> 인스턴스 변수나 메서드를 참조하려면 점(.)을 사용합니다:
> 

```dart
**// 점(.)을 사용하여 인스턴스 변수 또는 메서드를 참조합니다:**
var p = Point(2, 2);

// y의 값을 가져옵니다.
assert(p.y == 2);

// p에서 distanceTo()를 호출합니다.
double distance = p.distanceTo(Point(4, 4));

**// 대신 ?. 을 사용하여 가장 왼쪽 피연산자가 null인 경우 예외를 피합니다:**
// p가 null이 아니면, 변수에 y 값을 설정합니다.
var a = p?.y;

```

**Using constructors**[#](https://dart.dev/language/classes#using-constructors)

You can create an object using a *constructor*. Constructor names can be either `*ClassName*` or `*ClassName*.*identifier*`. For example, the following code creates `Point` objects using the `Point()` and `Point.fromJson()` constructors:

> **생성자 사용**
> 
> 
> 
> 생성자를 사용하여 객체를 생성할 수 있습니다. 생성자 이름은 클래스명 또는 클래스명.식별자 중 하나가 될 수 있습니다. 예를 들어, 다음 코드는 Point() 및 Point.fromJson() 생성자를 사용하여 Point 객체를 생성합니다:
> 

```dart
var p1 = Point(2, 2); // 기본 생성자를 사용하여 Point 객체 생성
// 명명된 생성자를 사용하여 JSON으로부터 Point 객체 생성
var p2 = Point.fromJson({'x': 1, 'y': 2}); 

// 선택적 new 키워드 사용:
var p1 = new Point(2, 2);
var p2 = new Point.fromJson({'x': 1, 'y': 2});

// 상수 생성자 사용:
var p = const ImmutablePoint(2, 2);

// 동일한 컴파일 타임 상수는 하나의 인스턴스만 생성:
var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);
assert(identical(a, b)); // 동일한 인스턴스 확인

// 상수 컨텍스트 내에서는 const 생략 가능:
const pointAndLine = {
  'point': [ImmutablePoint(0, 0)],
  'line': [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],
};

// const 없이 호출된 경우 상수가 아닌 객체 생성:
var a = const ImmutablePoint(1, 1); // 상수 생성
var b = ImmutablePoint(1, 1); // 상수가 아닌 객체 생성
assert(!identical(a, b)); // 동일한 인스턴스 아님

```

**Getting an object's type**

To get an object's type at runtime, you can use the `Object` property `runtimeType`, which returns a [`Type`](https://api.dart.dev/stable/dart-core/Type-class.html) object.

> **객체의 유형 가져오기**
> 
> 
> 
> 런타임에 객체의 유형을 가져오려면 Type 객체를 반환하는 객체 속성 runtimeType을 사용하면 됩니다.
> 

```dart
// 📌 객체의 유형을 테스트하려면 runtimeType 대신 유형 테스트 연산자를 사용하세요.
// 프로덕션 환경에서는 `object.runtimeType == Type`보다 `object is Type`이 더 안정적입니다.

print('The type of a is ${a.runtimeType}');
```

여기까지 클래스를 사용하는 방법을 살펴보았습니다. 

이 섹션의 나머지 부분에서는 클래스를 구현하는 방법을 설명합니다.

      **Instance variables**

```dart
// 인스턴스 선언
class Point {
  // x는 nullable double 타입으로 선언, 초기값은 null
  double? x; 
  // y는 nullable double 타입으로 선언, 초기값은 null
  double? y; 
  // z는 double 타입으로 선언, 초기값은 0
  double z = 0; 
}
```

An uninitialized instance variable declared with a [nullable type](https://dart.dev/null-safety/understanding-null-safety#using-nullable-types) has the value `null`. Non-nullable instance variables [must be initialized](https://dart.dev/null-safety/understanding-null-safety#uninitialized-variables) at declaration.

All instance variables generate an implicit *getter* method. Non-final instance variables and `late final` instance variables without initializers also generate an implicit *setter* method. For details, check out [Getters and setters](https://dart.dev/language/methods#getters-and-setters).

> 널 가능 타입으로 선언된 초기화되지 않은 인스턴스 변수는 널 값을 갖습니다. 널러블이 아닌 인스턴스 변수는 선언 시 초기화해야 합니다.
> 
> 
> 모든 인스턴스 변수는 암시적 getter 메서드를 생성합니다. 최종 인스턴스가 아닌 변수와 초기화자가 없는 후기 최종 인스턴스 변수도 암시적 세터 메서드를 생성합니다. 자세한 내용은 게터와 세터에서 확인하세요.
> 
> ```dart
> class Point {
>  // x는 nullable double 타입으로 선언, 초기값은 null
>   double? x; 
>  // y는 nullable double 타입으로 선언, 초기값은 null
>   double? y; 
> }
> 
> void main() {
>   var point = Point();
>   // x에 세터 메서드 사용
>   point.x = 4; 
>   // x에 게터 메서드 사용
>   assert(point.x == 4);
>   // 기본값 null
>   assert(point.y == null);
> }
> ```
> 

Initializing a non-`late` instance variable where it's declared sets the value when the instance is created, before the constructor and its initializer list execute. As a result, the initializing expression (after the `=`) of a non-`late` instance variable can't access `this`.

> 선언된 위치에서 늦지 않은 인스턴스 변수를 초기화하면 인스턴스가 생성될 때 생성자와 그 이니셜라이저 목록이 실행되기 전에 값이 설정됩니다. 따라서 늦지 않은 인스턴스 변수의 초기화 표현식(= 뒤)은 이 값에 액세스할 수 없습니다.
> 

```dart
double initialX = 1.5;

class Point {
  // OK, `this`에 의존하지 않는 선언에는 접근할 수 있음:
  double? x = initialX;

  // 오류, non-`late` 초기화에서 `this`에 접근할 수 없음:
  double? y = this.x;

  // OK, `late` 초기화에서는 `this`에 접근할 수 있음:
  late double? z = this.x;

  // OK, `this.x`와 `this.y`는 표현식이 아니라 매개변수 선언임:
  Point(this.x, this.y);
}
```

nstance variables can be `final`, in which case they must be set exactly once. Initialize `final`, non-`late` instance variables at declaration, using a constructor parameter, or using a constructor's [initializer list](https://dart.dev/language/constructors#use-an-initializer-list):

> 인스턴스 변수는 최종적일 수 있으며, 이 경우 정확히 한 번만 설정해야 합니다. 선언 시, 생성자 매개변수를 사용하거나 생성자의 이니셜라이저 목록을 사용하여 늦지 않은 최종 인스턴스 변수를 초기화하세요:
> 
> 
> ```dart
> class ProfileMark {
>   // `name`은 final로 선언된 문자열 변수로, 생성 시 초기화되어야 합니다.
>   final String name;
>   
>   // `start`는 현재 시간을 나타내는 DateTime 객체로, 클래스가 인스턴스화될 때 자동으로 초기화됩니다.
>   final DateTime start = DateTime.now();
> 
>   // 기본 생성자. `name`을 매개변수로 받아서 초기화합니다.
>   ProfileMark(this.name);
> 
>   // 이름이 없는 생성자. `name`을 빈 문자열로 초기화합니다.
>   ProfileMark.unnamed() : name = '';
> }
> ```
> 

If you need to assign the value of a `final` instance variable after the constructor body starts, you can use one of the following:

- Use a [factory constructor](https://dart.dev/language/constructors#factory-constructors).
- Use `late final`, but [*be careful:*](https://dart.dev/effective-dart/design#avoid-public-late-final-fields-without-initializers) a `late final` without an initializer adds a setter to the API.

> 생성자 본문이 시작된 후 최종 인스턴스 변수의 값을 할당해야 하는 경우 다음 중 하나를 사용할 수 있습니다:
> 
> - 팩토리 생성자를 사용합니다.
> - **late final**을 사용하되 주의하세요. 이니셜라이저가 없는 **late final**은 API에 설정자를 추가합니다.
> 
> **Implicit interfaces**[#](https://dart.dev/language/classes#implicit-interfaces)
> 
> Every class implicitly defines an interface containing all the instance members of the class and of any interfaces it implements. If you want to create a class A that supports class B's API without inheriting B's implementation, class A should implement the B interface.
> 
> A class implements one or more interfaces by declaring them in an `implements` clause and then providing the APIs required by the interfaces. For example:
> 

> **암시적 인터페이스**
> 
> 
> 
> 모든 클래스는 클래스와 클래스가 구현하는 인터페이스의 모든 인스턴스 멤버를 포함하는 인터페이스를 암시적으로 정의합니다. B 클래스의 구현을 상속하지 않고 B 클래스의 API를 지원하는 A 클래스를 만들려면 A 클래스가 B 인터페이스를 구현해야 합니다.
> 
> 클래스는 구현 절에서 하나 이상의 인터페이스를 선언한 다음 인터페이스에 필요한 API를 제공함으로써 인터페이스를 구현합니다. 예를 들어
> 

```dart
// 사람을 나타내는 클래스입니다. 암묵적으로 greet() 메서드를 포함하는 인터페이스를 가집니다.
class Person {
  // 인터페이스에는 포함되지만, 이 라이브러리 내에서만 볼 수 있습니다.
  final String _name;

  // 인터페이스에 포함되지 않습니다. 이는 생성자이기 때문입니다.
  Person(this._name);

  // 인터페이스에 포함됩니다.
  String greet(String who) => 'Hello, $who. I am $_name.';
}

// Person 인터페이스의 구현입니다.
class Impostor implements Person {
  // _name의 getter를 정의합니다. 빈 문자열을 반환합니다.
  String get _name => '';

  // 인터페이스에 정의된 greet 메서드를 구현합니다.
  String greet(String who) => 'Hi $who. Do you know who I am?';
}

// Person 객체를 받아서 'Bob'에게 인사하는 메서드입니다.
String greetBob(Person person) => person.greet('Bob');

void main() {
  // Person 클래스의 인스턴스와 Impostor 클래스의 인스턴스를 생성하여 greetBob 메서드를 호출합니다.
  print(greetBob(Person('Kathy')));
  print(greetBob(Impostor()));
}
// Point 클래스는 Comparable 인터페이스와 Location 인터페이스를 구현합니다.
class Point implements Comparable, Location {...}

```

**Class variables and methods**[#](https://dart.dev/language/classes#class-variables-and-methods)

Use the `static` keyword to implement class-wide variables and methods.

**Static variables**[#](https://dart.dev/language/classes#static-variables)

Static variables (class variables) are useful for class-wide state and constants:

> **클래스 변수와 메서드**
> 
> 
> 클래스 전체 변수와 메서드를 구현하려면 정적 키워드를 사용합니다.
> 
> **정적 변수**
> 
> 정적 변수(클래스 변수)는 클래스 전체의 상태와 상수에 유용합니다:
> 

```dart
// 정적 변수는 사용될 때까지 초기화되지 않습니다.
class Queue {
  static const initialCapacity = 16;  // 정적 상수 변수입니다.
  // ···
}

void main() {
  assert(Queue.initialCapacity == 16);  // 정적 변수의 값을 확인하는 assert 문입니다.
}

```

**Static methods**[#](https://dart.dev/language/classes#static-methods)

Static methods (class methods) don't operate on an instance, and thus don't have access to `this`. They do, however, have access to static variables. As the following example shows, you invoke static methods directly on a class:

> **정적 메서드**
> 
> 
> 
> 정적 메서드(클래스 메서드)는 인스턴스에서 동작하지 않으므로 이에 액세스할 수 없습니다. 하지만 정적 변수에는 액세스할 수 있습니다. 다음 예제에서 볼 수 있듯이 클래스에서 정적 메서드를 직접 호출합니다:
> 

```dart
import 'dart:math';

// Point 클래스를 정의합니다.
class Point {
  double x, y;  // x와 y 좌표를 나타내는 인스턴스 변수입니다.

  // 생성자입니다. 주어진 x와 y 값을 사용하여 Point 객체를 초기화합니다.
  Point(this.x, this.y);

  // 두 점 사이의 거리를 계산하는 정적 메서드입니다.
  static double distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;  // x 좌표의 차이를 계산합니다.
    var dy = a.y - b.y;  // y 좌표의 차이를 계산합니다.
     // 피타고라스 정리를 사용하여 두 점 사이의 거리를 계산합니다.
    return sqrt(dx * dx + dy * dy); 
  }
}

void main() {
  var a = Point(2, 2);  // (2, 2) 좌표에 있는 점 a를 생성합니다.
  var b = Point(4, 4);  // (4, 4) 좌표에 있는 점 b를 생성합니다.
  var distance = Point.distanceBetween(a, b);  // a와 b 사이의 거리를 계산합니다.
  assert(2.8 < distance && distance < 2.9);  // 거리가 2.8과 2.9 사이에 있는지 확인합니다.
  print(distance);  // 거리를 출력합니다.
}

```

<aside>
💡 **참고**

일반적이거나 널리 사용되는 유틸리티 및 기능에는 정적 메서드 대신 **최상위 함수**를 사용하는 것을 고려하세요.

### **이유**

**최상위 함수를 사용하는 것이 권장되는 이유는 다음과 같습니다:**

**간결성: 최상위 함수는 클래스나 객체의 맥락이 필요 없기 때문에 더 간단하고 직관적입니다.재사용성: 유틸리티 함수는 특정 클래스에 종속되지 않기 때문에 재사용성이 높습니다.명확성: 함수가 특정 클래스에 속하지 않으면, 해당 함수가 클래스의 상태나 동작에 의존하지 않는다는 것을 명확히 할 수 있습니다.**

</aside>

You can use static methods as compile-time constants. For example, you can pass a static method as a parameter to a constant constructor.

> 정적 메서드를 컴파일 타임 상수로 사용할 수 있습니다. 예를 들어 정적 메서드를 상수 생성자에 매개변수로 전달할 수 있습니다
> 

# **Constructors**

Constructors are special functions that create instances of classes.

Dart implements many types of constructors. Except for default constructors, these functions use the same name as their class.

- [Generative constructors](https://dart.dev/language/constructors#generative-constructors): Creates new instances and initializes instance variables.
- [Default constructors](https://dart.dev/language/constructors#default-constructors): Used to create a new instance when a constructor hasn't been specified. It doesn't take arguments and isn't named.
- [Named constructors](https://dart.dev/language/constructors#named-constructors): Clarifies the purpose of a constructor or allows the creation of multiple constructors for the same class.
- [Constant constructors](https://dart.dev/language/constructors#constant-constructors): Creates instances as compile-type constants.
- [Factory constructors](https://dart.dev/language/constructors#factory-constructors): Either creates a new instance of a subtype or returns an existing instance from cache.
- [Redirecting constructor](https://dart.dev/language/constructors#redirecting-constructors): Forwards calls to another constructor in the same class.

> 생성자는 클래스의 인스턴스를 생성하는 특수 함수입니다.
> 
> 
> Dart는 다양한 유형의 생성자를 구현합니다. 기본 생성자를 제외하고 이러한 함수는 클래스와 동일한 이름을 사용합니다.
> 
> - 생성 생성자: 새 인스턴스를 생성하고 인스턴스 변수를 초기화합니다.
> - 기본 생성자: 생성자가 지정되지 않은 경우 새 인스턴스를 생성하는 데 사용됩니다. 인수를 받지 않으며 이름이 지정되지 않습니다.
> - 명명된 생성자: 생성자의 목적을 명확히 하거나 같은 클래스에 대해 여러 개의 생성자를 만들 수 있습니다.
> - 상수 생성자: 인스턴스를 컴파일 유형 상수로 생성합니다.
> - 팩토리 생성자: 하위 유형의 새 인스턴스를 생성하거나 캐시에서 기존 인스턴스를 반환합니다.
> - 생성자 리디렉션: 같은 클래스에 있는 다른 생성자로 호출을 전달합니다.

**Types of constructors**[#](https://dart.dev/language/constructors#types-of-constructors)

**Generative constructors**[#](https://dart.dev/language/constructors#generative-constructors)

To instantiate a class, use a generative constructor.

> **생성자 유형**
> 
> 
> **생성 생성자**
> 
> 클래스를 인스턴스화하려면 생성 생성자를 사용합니다.
> 

```dart
class Point {
  // 변수 및 값의 이니셜라이저 목록
  double x = 2.0;
  double y = 2.0;

  // 공식 매개변수를 초기화하는 생성자 생성자
  Point(this.x, this.y);
}
```

**Default constructors**[#](https://dart.dev/language/constructors#default-constructors)

If you don't declare a constructor, Dart uses the default constructor. The default constructor is a generative constructor without arguments or name.

**Named constructors**[#](https://dart.dev/language/constructors#named-constructors)

Use a named constructor to implement multiple constructors for a class or to provide extra clarity:

> **기본 생성자**
> 
> 
> 
> 생성자를 선언하지 않으면 Dart는 기본 생성자를 사용합니다. 기본 생성자는 인수나 이름이 없는 생성 생성자입니다.
> 
> **명명된 생성자**
> 
> 명명된 생성자를 사용하면 클래스에 대해 여러 개의 생성자를 구현하거나 명확성을 더할 수 있습니다:
> 

```dart
const double xOrigin = 0;
const double yOrigin = 0;

class Point {
  final double x;
  final double y;

  // 생성자 본문이 실행되기 전 x 및 y 인스턴스 변수를 설정합니다.
  Point(this.x, this.y);

  // x와 y를 각각 xOrigin과 yOrigin으로 초기화하는 명명된 생성자입니다.
  Point.origin()
      : x = xOrigin,
        y = yOrigin;
}
```

A subclass doesn't inherit a superclass's named constructor. To create a subclass with a named constructor defined in the superclass, implement that constructor in the subclass.

> 서브클래스는 슈퍼클래스의 명명된 생성자를 상속하지 않습니다. 슈퍼클래스에 정의된 명명된 생성자가 있는 서브클래스를 생성하려면 서브클래스에서 해당 생성자를 구현하세요.
> 

**Constant constructors**[#](https://dart.dev/language/constructors#constant-constructors)

If your class produces unchanging objects, make these objects compile-time constants. To make objects compile-time constants, define a `const` constructor with all instance variables set as `final`.

> **상수 생성자**
> 
> 
> 
> 클래스가 변경되지 않는 객체를 생성하는 경우 이러한 객체를 컴파일 타임 상수로 만드세요. 객체를 컴파일 타임 상수로 만들려면 모든 인스턴스 변수를 최종 변수로 설정한 생성자를 정의하세요.
> 

```dart
// ImmutablePoint 클래스 정의
class ImmutablePoint {
  // 정적 상수 필드 'origin'을 선언
  // 이 필드는 ImmutablePoint(0, 0) 객체를 가리키며, (0, 0) 좌표를 가지는 포인트를 의미
  static const ImmutablePoint origin = ImmutablePoint(0, 0);

  // 인스턴스 필드 'x'와 'y'를 선언
  // 이 필드들은 한 번 초기화되면 변경될 수 없음 (final 키워드 사용)
  final double x, y;

  // 생성자 정의
  // const 키워드를 사용하여 불변 객체를 생성
  // 생성자는 두 개의 매개변수 'x'와 'y'를 받아서 인스턴스 필드에 할당
  const ImmutablePoint(this.x, this.y);
}

```

Constant constructors don't always create constants. They might be invoked in a non-`const` context. To learn more, consult the section on [using constructors](https://dart.dev/language/classes#using-constructors).

> 상수 생성자가 항상 상수를 생성하는 것은 아닙니다. 상수가 아닌 컨텍스트에서 호출될 수도 있습니다. 자세한 내용은 생성자 사용 섹션을 참조하세요.
> 

**Redirecting constructors**[#](https://dart.dev/language/constructors#redirecting-constructors)

A constructor might redirect to another constructor in the same class. A redirecting constructor has an empty body. The constructor uses `this` instead of the class name after a colon (:).

> **생성자 리디렉션**
> 
> 
> 
> 생성자는 같은 클래스에 있는 다른 생성자로 리디렉션될 수 있습니다. 리디렉션 생성자에는 빈 본문이 있습니다. 생성자는 콜론(:) 뒤에 클래스 이름 대신 이를 사용합니다.
> 

```dart
// Point 클래스 정의
class Point {
  // 인스턴스 필드 'x'와 'y'를 선언
  double x, y;

  // 이 클래스의 주요 생성자
  // 'x'와 'y' 값을 받아서 인스턴스 필드에 할당
  Point(this.x, this.y);

  // 주요 생성자에 위임하는 명명된 생성자
  // 'x' 값을 받아서 'y'는 0으로 설정
  Point.alongXAxis(double x) : this(x, 0);
}

```

**Factory constructors**[#](https://dart.dev/language/constructors#factory-constructors)

When encountering one of following two cases of implementing a constructor, use the `factory` keyword:

- The constructor doesn't always create a new instance of its class. Although a factory constructor cannot return `null`, it might return:
    - an existing instance from a cache instead of creating a new one
    - a new instance of a subtype
- You need to perform non-trivial work prior to constructing an instance. This could include checking arguments or doing any other processing that cannot be handled in the initializer list.

> **팩토리 생성자**
> 
> 
> 
> 생성자를 구현하는 다음 두 가지 경우 중 하나가 발생하면 팩토리 키워드를 사용하세요:
> 
> 생성자가 항상 해당 클래스의 새 인스턴스를 생성하는 것은 아닙니다. 팩토리 생성자는 null을 반환할 수는 없지만 반환할 수 있습니다:
> 
> 새 인스턴스를 생성하는 대신 캐시에서 기존 인스턴스를 반환할 수 있습니다.
> 하위 유형의 새 인스턴스
> 인스턴스를 생성하기 전에 사소하지 않은 작업을 수행해야 합니다. 여기에는 인수를 확인하거나 이니셜라이저 목록에서 처리할 수 없는 기타 처리 작업이 포함될 수 있습니다.
> 

<aside>
💡 **Tip**

You can also handle late initialization of a final variable with [`late final`](https://dart.dev/effective-dart/design#avoid-public-late-final-fields-without-initializers) (carefully!).

### `late final`의 유용성

**지연 초기화 (Lazy Initialization)**:`late final` 키워드는 변수를 선언할 때 즉시 초기화하지 않고, 나중에 필요할 때 초기화할 수 있게 합니다. 이는 변수의 초기화가 복잡하거나 초기화 시점이 명확하지 않을 때 유용합니다.

**불변성 유지**:`final` 키워드는 변수의 값을 한 번 설정하면 변경할 수 없도록 합니다. `late final`을 사용하면 나중에 초기화하더라도 불변성을 유지할 수 있습니다.

**초기화 순서 제어:**클래스의 다른 필드나 메서드에 의존하는 변수의 경우, 초기화 순서를 제어해야 할 때 `late final`을 사용할 수 있습니다. 이를 통해 의존성 문제를 해결할 수 있습니다.

### **주의사항**

 `late final`은 매우 유용하지만, 초기화를 잊어버리거나 잘못된 시점에 초기화하는 경우 런타임 오류가 발생할 수 있습니다. 따라서 사용 시 주의가 필요합니다.

</aside>

The following example includes two factory constructors.

- `Logger` factory constructor returns objects from a cache.
- `Logger.fromJson` factory constructor initializes a final variable from a JSON object.

> 다음 예제에는 두 개의 팩토리 생성자가 포함되어 있습니다.
> 
> 
> Logger 팩토리 생성자는 캐시에서 객체를 반환합니다.
> Logger.fromJson 팩토리 생성자는 JSON 객체에서 최종 변수를 초기화합니다.
> 

```dart
// 클래스의 정의로, 팩토리 생성자를 사용하여 인스턴스를 생성하거나
// 캐싱된 인스턴스를 반환하는 방식
class Logger {
  final String name;
  bool mute = false;

  // _cache는 이름 앞의 _ 덕분에 라이브러리 내에서만 접근 가능합니다.
  static final Map<String, Logger> _cache = <String, Logger>{};

  // 팩토리 생성자: 이미 존재하는 인스턴스를 반환하거나, 새로운 인스턴스를 생성합니다.
  factory Logger(String name) {
    return _cache.putIfAbsent(name, () => Logger._internal(name));
  }

  // JSON 데이터를 통해 Logger 인스턴스를 생성하는 팩토리 생성자
  factory Logger.fromJson(Map<String, Object> json) {
    return Logger(json['name'].toString());
  }

  **// 내부 생성자: 외부에서는 접근할 수 없고, 팩토리 생성자 내에서만 사용됩니다.**
  Logger._internal(this.name);

  // 로그 메시지를 출력하는 메서드
  void log(String msg) {
    if (!mute) print(msg);
  }
}
// Logger 클래스의 인스턴스를 생성하고, 로그 메시지를 출력
var logger = Logger('UI');
logger.log('Button clicked');

var logMap = {'name': 'UI'};
var loggerJson = Logger.fromJson(logMap);

```

**Redirecting factory constructors**[#](https://dart.dev/language/constructors#redirecting-factory-constructors)

A redirecting factory constructor specifies a call to a constructor of another class to use whenever someone makes a call to the redirecting constructor.

> **팩토리 생성자 리디렉션**
> 
> 
> 
> 리디렉션 팩토리 생성자는 누군가 리디렉션 생성자를 호출할 때마다 사용할 다른 클래스의 생성자에 대한 호출을 지정합니다.
> 

```dart
factory Listenable.merge(List<Listenable> listenables) = _MergingListenable
```

It might appear that ordinary factory constructors could create and return instances of other classes. This would make redirecting factories unnecessary. Redirecting factories have several advantages:

- An abstract class might provide a constant constructor that uses the constant constructor of another class.
- A redirecting factory constructor avoids the need for forwarders to repeat the formal parameters and their default values.

> 일반 팩토리 생성자가 다른 클래스의 인스턴스를 생성하고 반환할 수 있는 것처럼 보일 수 있습니다. 이렇게 하면 팩토리 리디렉션이 불필요해집니다. 팩토리 리디렉션에는 몇 가지 장점이 있습니다:
> 
> - 추상 클래스는 다른 클래스의 상수 생성자를 사용하는 상수 생성자를 제공할 수 있습니다.
> - 리디렉션 팩토리 생성자를 사용하면 전달자가 공식 매개변수와 기본값을 반복할 필요가 없습니다.

**Constructor tear-offs**[#](https://dart.dev/language/constructors#constructor-tear-offs)

Dart allows you to supply a constructor as a parameter without calling it. Called a *tear-off* (as you *tear off* the parentheses) serves as a closure that invokes the constructor with the same parameters.

If the tear-off is a constructor with the same signature and return type as the method accepts, you can use the tear-off as a parameter or variable.

Tear-offs differ from lambdas or anonymous functions. Lambdas serve as a wrapper for the constructor whereas a tear-off is the constructor.

> **생성자 찢어짐**
> 
> 
> 
> Dart에서는 생성자를 호출하지 않고 매개변수로 제공할 수 있습니다. 괄호를 뜯어내는 티어 오프는 동일한 매개변수로 생성자를 호출하는 클로저 역할을 합니다.
> 
> 티어 오프가 메서드가 허용하는 것과 동일한 서명 및 반환 유형을 가진 생성자라면 티어 오프를 매개변수 또는 변수로 사용할 수 있습니다.
> 
> 티어 오프는 람다나 익명 함수와 다릅니다. 람다는 생성자의 래퍼 역할을 하는 반면, 티어오프는 생성자 역할을 합니다.
> 

**Instance Variable Initialization**[#](https://dart.dev/language/constructors#instance-variable-initialization)

Dart can initialize variables in three ways.

**Initialize instance variables in the declaration**[#](https://dart.dev/language/constructors#initialize-instance-variables-in-the-declaration)

Initialize the instance variables when you declare the variables.

> **인스턴스 변수 초기화**
> 
> 
> Dart는 세 가지 방법으로 변수를 초기화할 수 있습니다.
> 
> **선언에서 인스턴스 변수를 초기화합니다.**
> 
> 변수를 선언할 때 인스턴스 변수를 초기화합니다.
> 

```dart
// PointA 클래스는 기본 생성자를 사용하여 초기값을 설정합니다. 
class PointA {
  double x = 1.0;
  double y = 2.0;

  // 기본 생성자를 암시적으로 사용하여 초기화 값이 설정됨
  // PointA();

  @override
  String toString() {
    return 'PointA($x,$y)';
  }
}

// 생성자가 명시적으로 정의되어 있지 않으므로, Dart는 기본 생성자를 사용하여 x와 y를 초기화합니다.
// - x = 1.0, y = 2.0

// PointB 클래스는 두 가지 생성자를 사용합니다. 
class PointB {
  final double x;
  final double y;

  // 인스턴스 변수를 생성자 본문이 실행되기 전에 설정합니다.
  PointB(this.x, this.y);

  // 초기화된 포멀 매개변수는 선택 사항이 될 수도 있습니다.
  PointB.optional([this.x = 0.0, this.y = 0.0]);
}

// 첫 번째 생성자는 필수 매개변수를 사용하여 x와 y를 초기화합니다. 
// 두 번째 생성자는 선택적 매개변수를 사용하여 x와 y를 초기화합니다.
// - 필수 생성자: x와 y를 지정해야 함
// - 선택적 생성자: x와 y를 지정하지 않으면 기본값으로 초기화됨 (x = 0.0, y = 0.0)

// PointC 클래스는 명명된 매개변수를 사용하는 생성자를 가집니다.
class PointC {
  double x; // 생성자에서 설정되어야 함
  double y; // 생성자에서 설정되어야 함

  // 초기화된 포멀 매개변수를 사용한 생성자 (기본값 포함)
  PointC.named({this.x = 1.0, this.y = 1.0});

  @override
  String toString() {
    return 'PointC.named($x,$y)';
  }
}
 
// 이 생성자는 기본값을 포함하여 x와 y를 초기화합니다.
// - 기본값: x = 1.0, y = 1.0
// - 명명된 매개변수를 사용하여 초기화 가능

// 명명된 매개변수를 사용한 생성자 호출 예시
final pointC = PointC.named(x: 2.0, y: 2.0);

// PointD 클래스는 널러블(double?) 타입의 인스턴스 변수를 가집니다
class PointD {
  double? x; // 생성자에서 설정되지 않으면 null
  double? y; // 생성자에서 설정되지 않으면 null

  // 초기화된 포멀 매개변수를 사용한 생성자
  PointD(this.x, this.y);

  @override
  String toString() {
    return 'PointD($x,$y)';
  }
}
. 
// 생성자에서 x와 y를 초기화하지만, 초기화되지 않은 경우에는 null이 될 수 있습니다.
// - x와 y는 생성자에서 설정되며, 설정되지 않으면 null

```

**Use an initializer list**[#](https://dart.dev/language/constructors#use-an-initializer-list)

Before the constructor body runs, you can initialize instance variables. Separate initializers with commas.

> **이니셜라이저 목록 사용**
> 
> 
> 
> 생성자 본문이 실행되기 전에 인스턴스 변수를 초기화할 수 있습니다. 쉼표로 이니셜라이저를 구분하세요.
> 

```dart
// 이니셜라이즈 목록은 생성자 본문이 실행되기 전에 인스턴스 변수를 설정
// 생성자 본문이 실행되 전에 인스턴스 변수를 설정
Point.fromJson(Map<String, double> json)
    : x = json['x']!,
    // y = x + 1 라는 표현 사용하면 안됌!  사용하면 오류 왜?  
    // 이 시점에서 x는 아직 초기화되지 않았기 때문,
    // 이니셜라이저 목록의 표현식들은 서로의 값에 접근할 수 없으며, 순서대로 실행
    // 따라서 x가 초기화된 후에야 x를 사용할 수 있습니다.
      y = json['y']! {
  print('In Point.fromJson(): ($x, $y)');
}
```

```dart
import 'dart:math'; 

// 이니셜라이저 목록을 사용함으로써, 
// distanceFromOrigin은 x와 y가 초기화된 직후에 바로 계산되고 초기화됩니다.
class Point {
  final double x; // x 좌표
  final double y; // y 좌표
  final double distanceFromOrigin; // 원점으로부터의 거리

  // 생성자
  Point(double x, double y)
      : x = x,
        y = y,
        // 이니셜라이저 목록을 사용하여 distanceFromOrigin을 계산하고 초기화
        distanceFromOrigin = sqrt(x * x + y * y);
}

void main() {
  var p = Point(2, 3); // Point 클래스의 인스턴스 생성
  print(p.distanceFromOrigin); // 원점으로부터의 거리를 출력
}

```

**Constructor inheritance**[#](https://dart.dev/language/constructors#constructor-inheritance)

*Subclasses*, or child classes, don't inherit *constructors* from their *superclass*, or immediate parent class. If a class doesn't declare a constructor, it can only use the [default constructor](https://dart.dev/language/constructors#default-constructors).

A class can inherit the *parameters* of a superclass. These are called [super parameters](https://dart.dev/language/constructors#super-parameters)

Constructors work in a somewhat similar way to how you call a chain of static methods. Each subclass can call its superclass's constructor to initialize an instance, like a subclass can call a superclass's static method. This process doesn't "inherit" constructor bodies or signatures

> **생성자 상속**
> 
> 
> 
> 하위 클래스 또는 자식 클래스는 상위 클래스 또는 바로 상위 클래스로부터 생성자를 상속하지 않습니다. 클래스가 생성자를 선언하지 않으면 기본 생성자만 사용할 수 있습니다.
> 
> 클래스는 수퍼클래스의 매개변수를 상속할 수 있습니다. 이를 수퍼 파라미터라고 합니다.
> 
> 생성자는 정적 메서드 체인을 호출하는 방식과 다소 유사한 방식으로 작동합니다. 서브클래스가 슈퍼클래스의 정적 메서드를 호출하는 것처럼 각 서브클래스는 슈퍼클래스의 생성자를 호출하여 인스턴스를 초기화할 수 있습니다. 이 프로세스는 생성자 본문이나 서명을 "상속"하지 않습니다.
> 

**Non-default superclass constructors**[#](https://dart.dev/language/constructors#non-default-superclass-constructors)

Dart executes constructors in the following order:

1. [initializer list](https://dart.dev/language/constructors#use-an-initializer-list)
2. superclass's unnamed, no-arg constructor
3. main class's no-arg constructor

If the superclass lacks an unnamed, no-argument constructor, call one of the constructors in the superclass. Before the constructor body (if any), specify the superclass constructor after a colon (`:`).

> **기본값이 아닌 슈퍼클래스 생성자**
> 
> 
> 
> Dart는 다음과 같은 순서로 생성자를 실행합니다:
> 
> 1. 이니셜라이저 목록
> 2. 슈퍼클래스의 이름 없는, no-arg 생성자
> 3. 메인 클래스의 인자 없는 생성자
> 
> 수퍼클래스에 명명되지 않은 인자 없는 생성자가 없는 경우, 수퍼클래스의 생성자 중 하나를 호출합니다. 생성자 본문(있는 경우) 앞에 콜론(:) 뒤에 슈퍼클래스 생성자를 지정합니다.
> 

```dart
class Person {
  String? firstName;

  // 기본 생성자가 없는 대신 named constructor인 fromJson이 있음
  Person.fromJson(Map data) {
    print('in Person');
  }
}

class Employee extends Person {
  // Employee 클래스도 named constructor인 fromJson을 가지고 있음
  // super.fromJson(data)를 통해 부모 클래스의 fromJson 생성자를 호출
  Employee.fromJson(Map data) : super.fromJson(data) {
    print('in Employee');
  }
}

void main() {
  var employee = Employee.fromJson({});
  print(employee);
  // Prints:
  // in Person
  // in Employee
  // Instance of 'Employee'
}
// 생성자를 호출하기 전에 슈퍼클래스 생성자에 대한 인수를 평가하므로 
// 인수는 함수 호출과 같은 표현식이 될 수 있습니다.
class Employee extends Person {
  Employee() : super.fromJson(fetchDefaultData());
  // ···
}

```

As Dart evaluates the arguments to the superclass constructor *before* invoking the constructor, an argument can be an expression like a function call.

> Dart는 생성자를 호출하기 전에 슈퍼클래스 생성자에 대한 인수를 평가하므로 인수는 함수 호출과 같은 표현식이 될 수 있습니다.
> 

<aside>
💡 **부모 클래스의 생성자를 호출할 때 `this` 키워드를 사용할 수 없음**

1. **객체가 완전히 초기화되지 않음:`this` 키워드는 현재 객체를 참조합니다. 그러나 부모 클래스의 생성자를 호출하는 시점에서는 객체가 완전히 초기화되지 않았기 때문에, `this`를 사용할 수 없습니다. 이는 아직 객체의 모든 필드와 메서드가 사용 가능한 상태가 아니기 때문입니다.**
2. **안정성 문제:객체 초기화 도중에 `this`를 사용하면, 아직 초기화되지 않은 필드나 메서드를 호출할 수 있어 예기치 않은 오류가 발생할 수 있습니다. 이는 프로그램의 안정성을 해칠 수 있습니다.**
3. **정적 메서드 사용 가능:반면, 정적 메서드는 클래스 레벨에서 호출되므로 객체의 초기화 상태와 무관하게 사용할 수 있습니다. 따라서 부모 클래스 생성자 호출 시 정적 메서드를 인자로 넘기는 것은 안전합니다.**

### **객체 초기화 순서**

**부모 클래스의 생성자 호출:자식 클래스의 생성자가 호출되기 전에 부모 클래스의 생성자가 먼저 호출됩니다. 이는 객체의 기본 구조를 설정하기 위해 필요합니다.**

**자식 클래스의 생성자 호출:부모 클래스의 생성자가 완료된 후에 자식 클래스의 생성자가 호출됩니다.**

</aside>

**Super parameters**[#](https://dart.dev/language/constructors#super-parameters)

To avoid passing each parameter into the super invocation of a constructor, use super-initializer parameters to forward parameters to the specified or default superclass constructor. You can't use this feature with [redirecting constructors](https://dart.dev/language/constructors#redirecting-constructors). Super-initializer parameters have syntax and semantics like [initializing formal parameters](https://dart.dev/language/constructors#use-initializing-formal-parameters).

> **슈퍼 매개변수**
> 
> 
> 
> 생성자의 슈퍼 호출에 각 매개 변수를 전달하지 않으려면 슈퍼 이니셜라이저 매개 변수를 사용하여 지정된 또는 기본 슈퍼 클래스 생성자로 매개 변수를 전달하세요. 이 기능은 리디렉션 생성자와 함께 사용할 수 없습니다. 슈퍼 이니셜라이저 매개변수는 정식 매개변수를 초기화하는 것과 같은 구문과 의미를 갖습니다.
> 

```dart
// 1.생성자 호출의 기본 개념
class Vector2d {
  final double x;
  final double y;

  Vector2d(this.x, this.y);
}

class Vector3d extends Vector2d {
  final double z;

  // x와 y 매개변수를 기본 부모 생성자로 전달
  // Vector3d(final double x, final double y, this.z) : super(x, y);
  Vector3d(super.x, super.y, this.z);
}

// 2.오류 발생 예시
// 부모 생성자 (`super(0)`)를 위치 매개변수로 호출하면,
// super 매개변수 (`super.x`)를 사용하는 것은 오류를 발생시킵니다.
Vector3d.xAxisError(super.x): z = 0, super(0); 

// 3.명명된 생성자 사용
class Vector2d {
  // ...
  Vector2d.named({required this.x, required this.y});
}

class Vector3d extends Vector2d {
  final double z;

  // y 매개변수를 명명된 부모 생성자로 전달
  // Vector3d.yzPlane({required double y, required this.z})
  //       : super.named(x: 0, y: y);
  Vector3d.yzPlane({required super.y, required this.z}) : super.named(x: 0);
}

```

# **Methods**

**Instance methods**[#](https://dart.dev/language/methods#instance-methods)

Instance methods on objects can access instance variables and `this`. The `distanceTo()` method in the following sample is an example of an instance method:

> **인스턴스 메서드**
> 
> 
> 
> 객체의 인스턴스 메서드는 인스턴스 변수와 이 메서드에 접근할 수 있습니다. 다음 샘플의 distanceTo() 메서드는 인스턴스 메서드의 예시입니다
> 

```dart
import 'dart:math';

class Point {
  final double x;
  final double y;

  // Sets the x and y instance variables
  // before the constructor body runs.
  Point(this.x, this.y);

  double distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}
```

**Operators**[#](https://dart.dev/language/methods#operators)

Most operators are instance methods with special names. Dart allows you to define operators with the following names:

> **연산자**
> 
> 
> 
> 대부분의 연산자는 특별한 이름을 가진 인스턴스 메서드입니다. Dart에서는 다음과 같은 이름으로 연산자를 정의할 수 있습니다:
> 

|          산술 연산자 |            비교 연산자
 |            **비트 연산자** |            **할당 연산자** |
| --- | --- | --- | --- |
| + : 덧셈
- : 뺄셈
* : 곱셈
/ : 나눗셈 (실수 결과)
~/ : 정수 나눗셈
% : 나머지 | < : 작다
> : 크다
<= : 작거나 같다
>= : 크거나 같다
== : 같다 | & : 비트 AND
| : 비트 OR
^ : 비트 XOR
~ : 비트 NOT
<< : 비트 왼쪽 시프트
>> : 비트 오른쪽 시프트
>>> : 비트 오른쪽 시프트 (논리적 시프트) | []= : 리스트 또는 맵 요소의 할당
[] : 리스트 또는 맵 요소의 접근 |

**Getters and setters**[#](https://dart.dev/language/methods#getters-and-setters)

Getters and setters are special methods that provide read and write access to an object's properties. Recall that each instance variable has an implicit getter, plus a setter if appropriate. You can create additional properties by implementing getters and setters, using the `get` and `set` keywords:

> **게터와 세터**
> 
> 
> 
> 게터와 세터는 객체의 프로퍼티에 대한 읽기 및 쓰기 액세스를 제공하는 특수 메서드입니다. 각 인스턴스 변수에는 암시적 게터와 적절한 경우 설정자가 있다는 것을 기억하세요. get 및 set 키워드를 사용하여 게터와 세터를 구현하여 추가 프로퍼티를 만들 수 있습니다:
> 

```dart
// 게터와 세터를 사용하면 클라이언트 코드를 변경하지 않고도 인스턴스 변수로 시작하여 
// 나중에 메서드로 래핑할 수 있습니다.
class Rectangle {
  double left, top, width, height;

  Rectangle(this.left, this.top, this.width, this.height);

  // 두 개의 계산된 속성 정의: right와 bottom.
  double get right => left + width;
  set right(double value) => left = value - width;
  double get bottom => top + height;
  set bottom(double value) => top = value - height;
}

void main() {
  var rect = Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);

  // 증분(++)과 같은 연산자는 게터가 명시적으로 정의되어 있는지 여부에 관계없이
  // 예상되는 방식으로 작동합니다. 예기치 않은 부작용을 방지하기 위해 연산자는
  // 정확히 한 번만 게터를 호출하여 임시 변수에 값을 저장합니다.
  // 아래 예제는 이 동작을 설명합니다.

  double get width => 10;
  double widthValue = width;
  widthValue++;  // width 게터는 한 번만 호출됩니다.
  assert(widthValue == 11);  // 임시 변수에 저장된 값이 증분됩니다.
}

```

**Abstract methods**[#](https://dart.dev/language/methods#abstract-methods)

Instance, getter, and setter methods can be abstract, defining an interface but leaving its implementation up to other classes. Abstract methods can only exist in [abstract classes](https://dart.dev/language/class-modifiers#abstract) or [mixins](https://dart.dev/language/mixins).

To make a method abstract, use a semicolon (`;`) instead of a method body:

> **추상 메서드**
> 
> 
> 
> 인스턴스, 게터 및 세터 메서드는 추상적일 수 있으며, 인터페이스를 정의하지만 구현은 다른 클래스에 맡길 수 있습니다. 추상 메서드는 추상 클래스 또는 믹스인에서만 존재할 수 있습니다.
> 
> 메서드를 추상화하려면 메서드 본문 대신 세미콜론(;)을 사용하세요:
> 

```dart
// 추상 클래스 Doer 정의
abstract class Doer {
  // 인스턴스 변수와 메서드를 정의...

  // 추상 메서드 정의
  void doSomething(); // 추상 메서드 정의
}

// 추상 클래스 Doer를 상속받는 클래스 EffectiveDoer 정의
class EffectiveDoer extends Doer {
  // 추상 메서드 doSomething의 구현 제공
  void doSomething() {
    // 메서드가 여기서는 추상적이지 않음...
  }
}

```

# **Extend a class**

```dart
**//하위 클래스를 만들려면 확장자를 사용하고 슈퍼클래스를 참조하려면 슈퍼를 사용합니다**
class Television {
  void turnOn() {
    // TV를 켜기 위해 디스플레이를 밝히는 메서드를 호출합니다.
    _illuminateDisplay();
    // 적외선 센서를 활성화하는 메서드를 호출합니다.
    _activateIrSensor();
  }
  // ···
}

class SmartTelevision extends Television {
  void turnOn() {
    // 부모 클래스(Television)의 turnOn 메서드를 호출하여 기본적인 TV 켜기 동작을 수행합니다.
    super.turnOn();
    // 네트워크 인터페이스를 부팅하는 메서드를 호출합니다.
    _bootNetworkInterface();
    // 메모리를 초기화하는 메서드를 호출합니다.
    _initializeMemory();
    // 애플리케이션을 업그레이드하는 메서드를 호출합니다.
    _upgradeApps();
  }
  // ···
}

```

**Overriding members**[#](https://dart.dev/language/extend#overriding-members)

Subclasses can override instance methods (including [operators](https://dart.dev/language/methods#operators)), getters, and setters. You can use the `@override` annotation to indicate that you are intentionally overriding a member:

> 멤버 재정의
> 
> 
> 
> 서브클래스는 인스턴스 메서드(연산자 포함), 겟터 및 세터를 재정의할 수 있습니다. 오버라이드 어노테이션을 사용하여 멤버를 의도적으로 재정의하고 있음을 나타낼 수 있습니다:
> 

```dart
class Television {
  // ···
  // 명암비를 설정하는 세터 메서드입니다. value는 int 타입이어야 합니다.
  set contrast(int value) {...}
}

class SmartTelevision extends Television {
  @override
  // 부모 클래스의 contrast 세터를 오버라이드하지만, 파라미터 타입이 num으로 다릅니다.
  // 이는 상속 규칙 위반으로 경고를 발생시킵니다.
  set contrast(num value) {...}
  // ···
}

// 주의사항:
// Dart에서 객체의 == 연산자를 재정의하면, hashCode도 재정의해야 합니다.
// 이는 객체가 해시 테이블(예: Map의 키)에서 올바르게 작동하도록 하기 위함입니다.
class SmartTelevision extends Television {
  @override
  // int 타입으로 변경해주면 사용가능!
  set contrast(int value) {...}
  // ···
}

```

An overriding method declaration must match the method (or methods) that it overrides in several ways:

- The return type must be the same type as (or a subtype of) the overridden method's return type.
- Parameter types must be the same type as (or a supertype of) the overridden method's parameter types. In the preceding example, the `contrast` setter of `SmartTelevision` changes the parameter type from `int` to a supertype, `num`.
- If the overridden method accepts *n* positional parameters, then the overriding method must also accept *n* positional parameters.
- A [generic method](https://dart.dev/language/generics#using-generic-methods) can't override a non-generic one, and a non-generic method can't override a generic one.

Sometimes you might want to narrow the type of a method parameter or an instance variable. This violates the normal rules, and it's similar to a downcast in that it can cause a type error at runtime. Still, narrowing the type is possible if the code can guarantee that a type error won't occur. In this case, you can use the [`covariant` keyword](https://dart.dev/guides/language/sound-problems#the-covariant-keyword) in a parameter declaration. For details, see the [Dart language specification](https://dart.dev/guides/language/spec).

> 재정의 메서드 선언은 재정의하는 메서드와 여러 가지 방식으로 일치해야 합니다:
> 
> - 반환 유형은 재정의된 메서드의 반환 유형과 동일한 유형(또는 그 하위 유형)이어야 합니다.
> - 매개변수 유형은 재정의된 메서드의 매개변수 유형과 동일한 유형(또는 상위 유형)이어야 합니다. 앞의 예제에서 SmartTelevision의 대비 설정자는 매개변수 유형을 int에서 상위 유형인 num으로 변경합니다.
> - 재정의된 메서드가 n개의 위치 매개변수를 허용하는 경우, 재정의된 메서드도 n개의 위치 매개변수를 허용해야 합니다.
> - 제네릭 메서드는 제네릭이 아닌 메서드를 재정의할 수 없고, 제네릭이 아닌 메서드는 제네릭 메서드를 재정의할 수 없습니다.
> 
> 때로는 메서드 매개변수나 인스턴스 변수의 유형을 좁히고 싶을 수도 있습니다. 이는 일반적인 규칙을 위반하는 것이며, 런타임에 유형 오류가 발생할 수 있다는 점에서 다운캐스트와 유사합니다. 하지만 코드에서 유형 오류가 발생하지 않도록 보장할 수 있는 경우에는 유형을 좁힐 수 있습니다. 이 경우 매개변수 선언에 공변량 키워드를 사용할 수 있습니다. 자세한 내용은 Dart 언어 사양을 참조하세요.
> 

**noSuchMethod()**[#](https://dart.dev/language/extend#nosuchmethod)

To detect or react whenever code attempts to use a non-existent method or instance variable, you can override `noSuchMethod()`:

> **noSuchMethod()**
> 
> 
> 
> 코드가 존재하지 않는 메서드나 인스턴스 변수를 사용하려고 할 때마다 이를 감지하거나 반응하려면 noSuchMethod()를 재정의할 수 있습니다:
> 

```dart
class A {
  // 만약 noSuchMethod를 재정의하지 않으면,
  // 존재하지 않는 멤버를 사용하려고 할 때 NoSuchMethodError가 발생합니다.
  @override
  void noSuchMethod(Invocation invocation) {
    // 존재하지 않는 멤버를 사용하려고 했음을 출력합니다.
    print('You tried to use a non-existent member: '
        '${invocation.memberName}');
  }
}
```

You **can't invoke** an unimplemented method unless **one** of the following is true:

- The receiver has the static type `dynamic`.
- The receiver has a static type that defines the unimplemented method (abstract is OK), and the dynamic type of the receiver has an implementation of `noSuchMethod()` that's different from the one in class `Object`.

For more information, see the informal [noSuchMethod forwarding specification.](https://github.com/dart-lang/language/blob/main/archive/feature-specifications/nosuchmethod-forwarding.md)

> 다음 중 하나에 해당하지 않는 한 구현되지 않은 메서드는 호출할 수 없습니다:
> 
> - 수신자의 정적 유형이 동적입니다.
> - 수신자에 구현되지 않은 메서드를 정의하는 정적 유형이 있고(추상도 가능), 수신자의 동적 유형에 Object 클래스에 있는 것과 다른 noSuchMethod() 구현이 있는 경우.
> 
> 자세한 내용은 비공식 noSuchMethod 전달 사양을 참조하세요.
> 

# Mixins

Mixins are a way of defining code that can be reused in multiple class hierarchies. They are intended to provide member implementations en masse.

To use a mixin, use the `with` keyword followed by one or more mixin names. The following example shows two classes that use (or, are subclasses of) mixins:

> 믹스인은 여러 클래스 계층 구조에서 재사용할 수 있는 코드를 정의하는 방법입니다. 믹스인은 멤버 구현을 한꺼번에 제공하기 위한 것입니다.
> 
> 
> 믹스인을 사용하려면 with 키워드 뒤에 하나 이상의 믹스인 이름을 사용합니다. 다음 예시는 믹스인을 사용하는(또는 믹스인의 서브클래스인) 두 개의 클래스를 보여줍니다:
> 

```dart
// Musical 믹스인 정의
mixin Musical {
  bool canPlayPiano = false; // 피아노 연주 가능 여부 플래그
  bool canCompose = false; // 작곡 가능 여부 플래그
  bool canConduct = false; // 지휘 가능 여부 플래그

  // 엔터테인먼트 메서드
  void entertainMe() {
    if (canPlayPiano) {
      print('Playing piano'); // 피아노를 연주할 수 있으면 "Playing piano" 출력
    } else if (canConduct) {
      print('Waving hands'); // 지휘할 수 있으면 "Waving hands" 출력
    } else {
      print('Humming to self'); // 아무것도 할 수 없으면 "Humming to self" 출력
    }
  }
}

// Musician 클래스는 Performer를 상속받고 Musical 믹스인을 사용
class Musician extends Performer with Musical {
  // Performer의 기능과 Musical의 기능을 모두 사용 가능
  // 추가적인 코드나 변수 정의 없음
}

// Maestro 클래스는 Person을 상속받고 여러 믹스인 사용
class Maestro extends Person with Musical, Aggressive, Demented {
  // 생성자에서 이름을 설정하고 지휘 가능 여부를 true로 설정
  Maestro(String maestroName) {
    name = maestroName; // 이름 설정
    canConduct = true; // 지휘 가능 여부 설정
  }
}
```

**Specify members a mixin can call on itself**[#](https://dart.dev/language/mixins#specify-members-a-mixin-can-call-on-itself)

Sometimes a mixin depends on being able to invoke a method or access fields, but can't define those members itself (because mixins can't use constructor parameters to instantiate their own fields).

The following sections cover different strategies for ensuring any subclass of a mixin defines any members the mixin's behavior depends on.

**Define abstract members in the mixin**[#](https://dart.dev/language/mixins#define-abstract-members-in-the-mixin)

Declaring an abstract method in a mixin forces any type that uses the mixin to define the abstract method upon which its behavior depends

> **믹스인 자체에서 호출할 수 있는 멤버 지정**
> 
> 
> 때로는 믹스인이 메서드를 호출하거나 필드에 액세스할 수 있지만 해당 멤버 자체를 정의할 수 없는 경우가 있습니다(믹스인은 생성자 매개 변수를 사용하여 자체 필드를 인스턴스화할 수 없기 때문입니다).
> 
> 다음 섹션에서는 믹스인의 서브클래스가 믹스인의 동작이 의존하는 멤버를 정의하도록 하기 위한 다양한 전략을 다룹니다.
> 
> **믹스인에서 추상 멤버 정의하기**
> 
> 믹스인에서 추상 메서드를 선언하면 믹스인을 사용하는 모든 유형이 해당 동작이 의존하는 추상 메서드를 정의하도록 강제합니다.
> 

```dart
// Musician 믹스인 정의
mixin Musician {
  // 추상 메서드로, 특정 악기를 연주하는 기능을 정의
  void playInstrument(String instrumentName); 

  // 피아노 연주 메서드
  void playPiano() {
    playInstrument('Piano'); // 피아노를 연주하는 playInstrument 메서드 호출
  }

  // 플루트 연주 메서드
  void playFlute() {
    playInstrument('Flute'); // 플루트를 연주하는 playInstrument 메서드 호출
  }
}

// Virtuoso 클래스는 Musician 믹스인을 사용
class Virtuoso with Musician { 
  // playInstrument 메서드를 구현
  void playInstrument(String instrumentName) {
    print('Plays the $instrumentName beautifully'); // 악기를 아름답게 연주한다는 메시지 출력
  }  
}

```

**Access state in the mixin's subclass**[#](https://dart.dev/language/mixins#access-state-in-the-mixins-subclass)

Declaring abstract members also allows you to access state on the subclass of a mixin, by calling getters which are defined as abstract on the mixin:

> **믹스인의 서브클래스에서 상태에 접근하기**
> 
> 
> 추상 멤버를 선언하면 믹스인에서 추상적으로 정의된 getter를 호출하여 믹스인의 서브클래스에 있는 상태에 액세스할 수도 있습니다:
> 

```dart
/// [name] 속성이 있는 모든 타입에 적용할 수 있으며,
/// 이를 기반으로 [hashCode]와 `==` 연산자의 구현을 제공합니다.
mixin NameIdentity {
  // 추상 getter로, 이를 사용하는 클래스에서 구현해야 합니다.
  String get name;

  // name 속성을 기반으로 hashCode를 반환합니다.
  int get hashCode => name.hashCode;

  // name 속성을 기반으로 동일성 비교를 수행하는 연산자입니다.
  bool operator ==(other) => other is NameIdentity && name == other.name;
}

// NameIdentity 믹스인을 사용하는 Person 클래스
class Person with NameIdentity {
  final String name;

  // 생성자에서 name 속성을 초기화합니다.
  Person(this.name);
}

```

**Implement an interface**[#](https://dart.dev/language/mixins#implement-an-interface)

Similar to declaring the mixin abstract, putting an `implements` clause on the mixin while not actually implementing the interface will also ensure any member dependencies are defined for the mixin.

> **인터페이스 구현**
> 
> 
> 믹스인 추상 선언과 마찬가지로, 인터페이스를 실제로 구현하지 않으면서 믹스인에 구현 절을 넣으면 믹스인에 대한 모든 멤버 종속성이 정의됩니다.
> 

```dart
// 추상 인터페이스 클래스 Tuner 정의
abstract interface class Tuner {
  // 악기를 조율하는 추상 메서드
  void tuneInstrument();
}

// Guitarist 믹스인이 Tuner 인터페이스를 구현
mixin Guitarist implements Tuner {
  // 노래를 연주하는 메서드
  void playSong() {
    tuneInstrument(); // 악기를 조율

    print('Strums guitar majestically.'); // 기타를 장엄하게 연주
  }
}

// Guitarist 믹스인을 사용하는 PunkRocker 클래스 
class PunkRocker with Guitarist {
  // tuneInstrument 메서드를 구현
  void tuneInstrument() {
    print("Don't bother, being out of tune is punk rock."); // 조율하지 않음, 조율되지 않은 것이 펑크 록이다.
  }
}
```

- ？**의문**
    1. `mixin`과 `implements`의 차이가 뭔가요?
    
    1. 기능 제공 방식:`mixin`은 상태(필드)와 메서드를 포함할 수 있으며, 여러 클래스에 공통적으로 사용될 수 있는 기능을 제공합니다.`implements`는 메서드 시그니처만 제공하며, 이를 구현하는 클래스에서 실제 메서드 구현을 강제합니다.
    2.사용 사례:`mixin`은 여러 클래스에서 공통적으로 사용되는 기능을 정의하고 이를 재사용할 때 유용합니다.`implements`는 특정 인터페이스를 구현하여 클래스가 특정 계약을 준수하도록 할 때 유용합니다.
    3.다중 상속:`mixin`은 다트에서 다중 상속을 흉내내기 위해 사용됩니다. 여러 믹스인을 한 클래스에 적용할 수 있습니다.`implements`는 다트에서 클래스가 여러 인터페이스를 구현할 수 있게 합니다. 따라서 한 클래스가 여러 인터페이스를 구현할 수 있습니다.
    
     
    
    1. 왜 `mixin`과 `implements`를 사용하는가?
    
    1. 다중 상속의 유연성:다트는 클래스의 다중 상속을 지원하지 않지만, `mixin`을 사용하면 여러 클래스에서 동일한 기능을 공유할 수 있습니다.`Guitarist` 믹스인은 여러 클래스에서 기타 연주 기능을 추가할 수 있도록 합니다.
    2.구현 강제:`implements`는 특정 메서드의 구현을 강제합니다. `Tuner` 인터페이스를 사용하면, 모든 클래스가 `tuneInstrument` 메서드를 반드시 구현해야 합니다.이는 인터페이스를 통해 특정 계약을 강제함으로써 코드의 일관성을 유지하는 데 도움이 됩니다.
    3.역할 분리:`mixin`은 특정 기능(예: 기타 연주)을 여러 클래스에 쉽게 추가할 수 있게 해줍니다.인터페이스(`implements`)는 특정 메서드가 구현되어야 함을 명확히 정의합니다. 예를 들어, `PunkRocker` 클래스는 `tuneInstrument` 메서드를 반드시 구현해야 합니다.
    2. 추상 클래스가 아닌 Mixins을 사용해야 하는 이유
        
        **Mixins을 사용하여 다중 기능을 쉽게 조합할 수 있는 반면, 추상 클래스는 단일 상속에서만 사용됩니다.**
        
        1. 다중 상속의 대안: Dart는 다중 상속을 지원하지 않지만, Mixins을 사용하면 여러 클래스에서 기능을 재사용할 수 있습니다. 추상 클래스는 단일 상속만 가능하기 때문에, 여러 기능을 조합하려면 Mixins이 더 적합합니다.
        2. 독립적인 기능 분리: Mixins은 특정 기능을 분리하여 제공하는데 유리합니다. 예를 들어, 로깅, 데이터 검증 등 다양한 기능을 Mixins으로 분리하면, 필요한 클래스에 쉽게 추가할 수 있습니다.상속 계층의 단순화: 추상 클래스를 사용하면 상속 계층이 복잡해질 수 있지만, Mixins을 사용하면 이러한 계층을 단순화할 수 있습니다
        3. .명확한 역할 구분: 추상 클래스는 주로 공통 인터페이스나 기본 구현을 제공하기 위해 사용되며, Mixins은 특정 기능을 추가하기 위해 사용됩니다. Mixins을 사용하면 클래스의 역할과 기능이 명확하게 구분됩니다.
    
    ****
    

**Use the `on` clause to declare a superclass**[#](https://dart.dev/language/mixins#use-the-on-clause-to-declare-a-superclass)

The `on` clause exists to define the type that `super` calls are resolved against. So, you should only use it if you need to have a `super` call inside a mixin.

The `on` clause forces any class that uses a mixin to also be a subclass of the type in the `on` clause. If the mixin depends on members in the superclass, this ensures those members are available where the mixin is used:

> **슈퍼클래스를 선언하려면 on 절을 사용합니다.**
> 
> 
> 
> on 절은 슈퍼 호출이 확인되는 유형을 정의하기 위해 존재합니다. 따라서 믹스인 내부에 슈퍼 호출이 필요한 경우에만 사용해야 합니다.
> 
> on 절은 믹스인을 사용하는 모든 클래스가 on 절에 있는 타입의 서브클래스가 되도록 강제합니다. 믹스인이 슈퍼클래스의 멤버에 의존하는 경우 믹스인이 사용되는 곳에서 해당 멤버를 사용할 수 있도록 합니다:
> 

```dart
// Musician 클래스를 정의합니다.
class Musician {
  // musicianMethod라는 메서드를 정의합니다.
  musicianMethod() {
    // "Playing music!"를 출력합니다.
    print('Playing music!');
  }
}

// MusicalPerformer라는 믹스인을 정의합니다. 이 믹스인은 Musician 클래스에 종속적입니다.
mixin MusicalPerformer on Musician {
  // perfomerMethod라는 메서드를 정의합니다.
  perfomerMethod() {
    // "Performing music!"를 출력합니다.
    print('Performing music!');
    // super 키워드를 사용하여 Musician 클래스의 musicianMethod를 호출합니다.
    super.musicianMethod();
  }
}

// SingerDancer 클래스를 정의합니다. 이 클래스는 Musician 클래스를 상속받고,
// MusicalPerformer 믹스인을 포함합니다.
class SingerDancer extends Musician with MusicalPerformer { }

// main 함수입니다. 프로그램의 시작 지점입니다.
main() {
  // SingerDancer 객체를 생성하고 performerMethod를 호출합니다.
  SingerDance().performerMethod();
}
```

In this example, only classes that extend or implement the `Musician` class can use the mixin `MusicalPerformer`. Because `SingerDancer` extends `Musician`, `SingerDancer` can mix in `MusicalPerformer`.

> 이 예제에서는 Musician 클래스를 확장하거나 구현하는 클래스만 MusicalPerformer 믹스인을 사용할 수 있습니다. SingerDancer는 Musician을 확장하기 때문에 SingerDancer는 MusicalPerformer를 믹싱할 수 있습니다.
> 

**class, mixin, or mixin class?**

A `mixin` declaration defines a mixin. A `class` declaration defines a [class](https://dart.dev/language/classes). A `mixin class` declaration defines a class that is usable as both a regular class and a mixin, with the same name and the same type.

> 믹스인 선언은 믹스인을 정의합니다. 클래스 선언은 클래스를 정의합니다. 믹스인 클래스 선언은 같은 이름과 같은 유형으로 일반 클래스와 믹스인으로 모두 사용할 수 있는 클래스를 정의합니다.
> 

```dart
// Musician 클래스를 정의합니다. 이 클래스는 믹스인으로도 사용할 수 있습니다.
mixin class Musician {
  // Musician 클래스의 메서드나 속성은 여기에 정의됩니다.
  // ...
}

// Novice 클래스에서 Musician 클래스를 믹스인으로 사용합니다.
class Novice with Musician { // Use Musician as a mixin
  // Novice 클래스의 메서드나 속성은 여기에 정의됩니다.
  // ...
}

// Novice 클래스를 상속받아 정의합니다.
class Novice extends Musician { // Use Musician as a class
  // Novice 클래스의 메서드나 속성은 여기에 정의됩니다.
  // ...
}
```

Any restrictions that apply to classes or mixins also apply to mixin classes:

- Mixins can't have `extends` or `with` clauses, so neither can a `mixin class`.
- Classes can't have an `on` clause, so neither can a `mixin class`.

> 
> 
> - 확장(extends) 사용 불가:Mixins은 다른 클래스를 확장(extends)할 수 없습니다.Mixins은 단일 상속 구조가 아닌, 특정 기능을 다른 클래스에 추가하기 위해 설계되었습니다.
> - 절(on clause) 사용 불가:Mixins은 특정 클래스에 대한 제한을 설정하는 `on` 절을 사용할 수 없습니다.`on` 절은 주로 Mixin이 적용될 수 있는 클래스의 타입을 제한하는 데 사용됩니다.

# Enums

Enumerated types, often called *enumerations* or *enums*, are a special kind of class used to represent a fixed number of constant values.

> 열거형 타입은 고정된 수의 상수 값을 나타내는 데 사용되는 특별한 종류의 클래스입니다.
> 

**Declaring simple enums**[#](https://dart.dev/language/enums#declaring-simple-enums)

To declare a simple enumerated type, use the `enum` keyword and list the values you want to be enumerated:

> 간단한 열거형 선언
> 
> 
> 단순 열거형 유형을 선언하려면 열거형 키워드를 사용하여 열거할 값을 나열합니다:
> 

```dart
// 열거형 유형을 선언할 때 후행 쉼표를 사용하면 복사-붙여넣기 오류를 방지할 수 있습니다.
enum Color { red, green, blue }
```

**Declaring enhanced enums**[#](https://dart.dev/language/enums#declaring-enhanced-enums)

Dart also allows enum declarations to declare classes with fields, methods, and const constructors which are limited to a fixed number of known constant instances.

To declare an enhanced enum, follow a syntax similar to normal [classes](https://dart.dev/language/classes), but with a few extra requirements:

- Instance variables must be `final`, including those added by [mixins](https://dart.dev/language/mixins).
- All [generative constructors](https://dart.dev/language/constructors#constant-constructors) must be constant.
- [Factory constructors](https://dart.dev/language/constructors#factory-constructors) can only return one of the fixed, known enum instances.
- No other class can be extended as [`Enum`](https://api.dart.dev/stable/dart-core/Enum-class.html) is automatically extended.
- There cannot be overrides for `index`, `hashCode`, the equality operator `==`.
- A member named `values` cannot be declared in an enum, as it would conflict with the automatically generated static `values` getter.
- All instances of the enum must be declared in the beginning of the declaration, and there must be at least one instance declared.

Instance methods in an enhanced enum can use `this` to reference the current enum value.

Here is an example that declares an enhanced enum with multiple instances, instance variables, getters, and an implemented interface:

> **향상된 열거형 선언하기**
> 
> 
> 또한 Dart에서는 열거형 선언을 통해 필드, 메서드 및 생성자가 있는 클래스를 선언할 수 있으며, 이는 알려진 상수 인스턴스의 고정된 수로 제한됩니다.
> 
> 향상된 열거형을 선언하려면 일반 클래스와 유사한 구문을 따르지만 몇 가지 추가 요구 사항이 있습니다:
> 
> - 인스턴스 변수는 믹스인에 의해 추가된 변수를 포함하여 최종 변수여야 합니다.
>     - **인스턴스 변수는 final 이어야한다**
> - 모든 생성 생성자는 상수여야 합니다.
>     - **모든 생성자는 const여야한다**
> - 팩토리 생성자는 고정된 알려진 열거형 인스턴스 중 하나만 반환할 수 있습니다.
>     - **팩토리 생성자는 미리정의된 인스턴스만 반환할수있다. → 새로운 인스턴스생성불가**
> - 열거형은 자동으로 확장되므로 다른 클래스는 확장할 수 없습니다.
>     - **열거형은 기본적으로 `Enum` 클래스를 확장하므로, 다른 클래스를 확장할 수 없습니다. → 다중상속방지**
> - 인덱스, 해시코드, 등호 연산자 ==에 대한 오버라이드는 있을 수 없습니다. ****
>     - **`index`, `hashCode`, `==` 연산자는 오버라이드할 수 없습니다. → 일관성유지**
> - 값이라는 이름의 멤버는 자동으로 생성된 정적 값 가져 오기와 충돌하므로 열거형에 선언할 수 없습니다.
>     - **`values`라는 이름의 멤버는 열거형에서 선언할 수 없습니다. → 자동생성된 values와 충돌방지**
> - 열거형의 모든 인스턴스는 선언의 시작 부분에 선언되어야 하며, 선언된 인스턴스가 하나 이상 있어야 합니다.
> 
> 향상된 열거형의 인스턴스 메서드는 이를 사용하여 현재 열거형 값을 참조할 수 있습니다.
> 
> 다음은 여러 인스턴스, 인스턴스 변수, 게터 및 구현된 인터페이스로 향상된 열거형을 선언하는 예제입니다:
> 

```dart
// Vehicle 열거형을 정의하고, Comparable<Vehicle> 인터페이스를 구현합니다.
enum Vehicle implements Comparable<Vehicle> {
  // 각 Vehicle 항목을 정의합니다.
  car(tires: 4, passengers: 5, carbonPerKilometer: 400), // 자동차
  bus(tires: 6, passengers: 50, carbonPerKilometer: 800), // 버스
  bicycle(tires: 2, passengers: 1, carbonPerKilometer: 0); // 자전거

  // 상수 생성자를 정의합니다.
  const Vehicle({
    required this.tires, // 타이어 수
    required this.passengers, // 탑승자 수
    required this.carbonPerKilometer, // 킬로미터당 탄소 배출량
  });

  // 속성을 정의합니다.
  final int tires; // 타이어 수
  final int passengers; // 탑승자 수
  final int carbonPerKilometer; // 킬로미터당 탄소 배출량

  // 탄소 발자국을 계산하여 반환하는 게터를 정의합니다.
  int get carbonFootprint => (carbonPerKilometer / passengers).round();

  // 차량이 자전거인지 여부를 반환하는 게터를 정의합니다.
  bool get isTwoWheeled => this == Vehicle.bicycle;

  // Comparable 인터페이스의 compareTo 메서드를 구현하여 탄소 발자국을 기준으로 비교합니다.
  @override
  int compareTo(Vehicle other) => carbonFootprint - other.carbonFootprint;
}

```

- ？
    
    **열거형(enum): 고정된 값 집합을 정의하고, 이 값들에 관련된 메서드와 속성을 추가합니다.
    믹스인(mixin): 클래스에 기능을 추가하기 위해 사용되며, 다른 클래스와 조합하여 사용할 수 있습니다.**
    

**Using enums**[#](https://dart.dev/language/enums#using-enums)

Access the enumerated values like any other [static variable](https://dart.dev/language/classes#class-variables-and-methods):

> **열거형 사용**
> 

```dart
**// 다른 정적 변수처럼 열거형 값에 액세스합니다:**
// 'favoriteColor'라는 변수를 'Color.blue'로 초기화합니다.
final favoriteColor = Color.blue;

if (favoriteColor == Color.blue) {
  print('Your favorite color is blue!');
}
-----------------------------------------------------------
**// 열거형에 있는 각 값에는 열거형 선언에서 값의 0 기준 위치를 반환하는 인덱스 가져 오기가 있습니다. 
// 예를 들어 첫 번째 값의 인덱스는 0이고 두 번째 값의 인덱스는 1입니다.**

// 'Color.red'의 인덱스가 0인지 확인합니다.
assert(Color.red.index == 0);

// 'Color.green'의 인덱스가 1인지 확인합니다.
assert(Color.green.index == 1);

// 'Color.blue'의 인덱스가 2인지 확인합니다.
assert(Color.blue.index == 2);

// 'Color' 열거형의 모든 값을 리스트로 가져옵니다.
List<Color> colors = Color.values;
-----------------------------------------------------------
// 열거된 모든 값의 목록을 가져오려면 열거형 값 상수를 사용합니다.
// 'colors' 리스트의 세 번째 요소가 'Color.blue'인지 확인합니다.
assert(colors[2] == Color.blue);

// 'aColor' 변수를 'Color.blue'로 초기화합니다.

-----------------------------------------------------------

// 스위치 문에서 열거형을 사용할 수 있으며, 열거형의 모든 값을 처리하지 않으면 경고가 표시됩니다:
var aColor = Color.blue;

// 'aColor'의 값에 따라 다른 메시지를 출력하는 switch 문입니다.
switch (aColor) {
  case Color.red:
    print('Red as roses!');
    break; // 'Color.red'에 해당하는 경우를 처리하고 종료합니다.
  case Color.green:
    print('Green as grass!');
    break; // 'Color.green'에 해당하는 경우를 처리하고 종료합니다.
  default: // 'Color.red'와 'Color.green'이 아닌 경우를 처리합니다.
    print(aColor); // 'Color.blue'를 출력합니다.
}
-----------------------------------------------------------
// Color.blue의 'blue'와 같이 열거형 값의 이름에 액세스해야 하는 경우 .name 속성을 사용합니다:
// 'Color.blue'의 이름을 출력합니다. (Dart 2.15부터 사용 가능)
print(Color.blue.name); // 'blue'를 출력합니다.
-----------------------------------------------------------
// 일반 객체에서와 마찬가지로 열거형 값의 멤버에 액세스할 수 있습니다:
// 'Vehicle.car'의 탄소 발자국을 출력합니다.
print(Vehicle.car.carbonFootprint);

```

- ?
    
    **열거형을 사용했을 때의 단점이나 주의사항은 무엇인가요?**
    
    열거형은 상수 집합이 고정되어 있어, 런타임에 값이 변하지 않습니다. 따라서 동적으로 변하는 값이 필요할 경우 열거형은 적절하지 않습니다.열거형 값의 인덱스는 정의된 순서에 따라 자동으로 할당되므로, 중간에 값을 추가하면 기존 인덱스가 변경될 수 있습니다.
    

# **Extension methods**

Extension methods add functionality to existing libraries. You might use extension methods without even knowing it. For example, when you use code completion in an IDE, it suggests extension methods alongside regular methods.

If watching videos helps you learn, check out this overview of extension methods.

> 확장 메서드는 기존 라이브러리에 기능을 추가합니다. 자신도 모르게 확장 메서드를 사용할 수도 있습니다. 예를 들어 IDE에서 코드 완성 기능을 사용하면 일반 메서드와 함께 확장 메서드를 제안합니다.
> 
> 
> 동영상을 보는 것이 학습에 도움이 된다면 확장 메서드에 대한 개요를 확인하세요.
> 

**Overview**[#](https://dart.dev/language/extension-methods#overview)

When you're using someone else's API or when you implement a library that's widely used, it's often impractical or impossible to change the API. But you might still want to add some functionality.

For example, consider the following code that parses a string into an integer:

> **개요**
> 
> 
> 다른 사람의 API를 사용하거나 널리 사용되는 라이브러리를 구현하는 경우 API를 변경하는 것이 비현실적이거나 불가능한 경우가 많습니다. 하지만 여전히 일부 기능을 추가하고 싶을 수도 있습니다.
> 
> 예를 들어 문자열을 정수로 파싱하는 다음 코드를 생각해 보세요
> 

```dart
// 파싱방법1)
int.parse('42')
// 파싱방법2)
import 'string_apis.dart';
// ···
print('42'.parseInt()); // Use an extension method.
```

Extensions can define not just methods, but also other members such as getter, setters, and operators. Also, extensions can have names, which can be helpful if an API conflict arises. Here's how you might implement the extension method `parseInt()`, using an extension (named `NumberParsing`) that operates on strings:

> 확장자는 메서드뿐만 아니라 게터, 세터, 연산자 등의 다른 멤버도 정의할 수 있습니다. 또한 확장에는 이름을 가질 수 있으므로 API 충돌이 발생할 경우 유용할 수 있습니다. 다음은 문자열에 대해 작업하는 확장 메서드(NumberParsing이라는 이름의 확장)를 사용하여 확장 메서드 parseInt()를 구현하는 방법입니다:
> 

```dart
extension NumberParsing on String {
  int parseInt() {
    return int.parse(this);
  }
  // ···
}
```

**Using extension methods**[#](https://dart.dev/language/extension-methods#using-extension-methods)

Like all Dart code, extension methods are in libraries. You've already seen how to use an extension method—just import the library it's in, and use it like an ordinary method:

> **확장 메서드 사용**
> 
> 
> 모든 Dart 코드와 마찬가지로 확장 메서드는 라이브러리에 있습니다. 확장 메서드를 사용하는 방법은 이미 살펴보았습니다. 확장 메서드가 있는 라이브러리를 가져와서 일반 메서드처럼 사용하기만 하면 됩니다:
> 

```dart
// 문자열에 확장자가 포함된 라이브러리 임포트
import 'string_apis.dart';
// 문자열 메서드 사용해서
print('42'.padLeft(5));
// 확장메서드 사용해서
print('42'.parseInt()); 
```

That's all you usually need to know to use extension methods. As you write your code, you might also need to know how extension methods depend on static types (as opposed to `dynamic`) and how to resolve [API conflicts](https://dart.dev/language/extension-methods#api-conflicts).

> 이것이 일반적으로 확장 메서드를 사용하기 위해 알아야 할 전부입니다. 코드를 작성할 때 확장 메서드가 정적 유형(동적 유형이 아닌)에 의존하는 방식과 API 충돌을 해결하는 방법도 알아야 할 수 있습니다.
> 

**Static types and dynamic**[#](https://dart.dev/language/extension-methods#static-types-and-dynamic)

You can't invoke extension methods on variables of type `dynamic`. For example, the following code results in a runtime exception:

> **정적 유형과 동적 유형**
> 
> 
> 동적 타입의 변수에 대해서는 확장 메서드를 호출할 수 없습니다. 예를 들어 다음 코드는 런타임 예외를 발생시킵니다:
> 

```dart
dynamic d = '2';
 // 런타임 예외: NoSuchMethodError
print(d.parseInt()); 
// 확장 메서드는 Dart의 유형 추론과 함께 작동합니다.
// 다음 코드는 변수 v가 String 유형으로 추론되기 때문에 괜찮습니다:
var v = '2';
print(v.parseInt()); // Output: 2
```

The reason that `dynamic` doesn't work is that extension methods are resolved against the static type of the receiver. Because extension methods are resolved statically, they're as fast as calling a static function.

For more information about static types and `dynamic`, see [The Dart type system](https://dart.dev/language/type-system).

> 동적이 작동하지 않는 이유는 확장 메서드가 수신자의 정적 유형에 대해 확인되기 때문입니다. 확장 메서드는 정적으로 확인되기 때문에 정적 함수를 호출하는 것만큼 빠릅니다.
> 
> 
> 정적 타입과 동적 타입에 대한 자세한 내용은 Dart 타입 시스템을 참조하세요.
> 

**API conflicts**[#](https://dart.dev/language/extension-methods#api-conflicts)

If an extension member conflicts with an interface or with another extension member, then you have a few options.

One option is changing how you import the conflicting extension, using `show` or `hide` to limit the exposed API:

> API 충돌
> 
> 
> 확장 멤버가 인터페이스 또는 다른 확장 멤버와 충돌하는 경우 몇 가지 옵션이 있습니다.
> 
> 한 가지 옵션은 충돌하는 확장 프로그램을 가져오는 방법을 변경하여 표시 또는 숨기기를 사용하여 노출되는 API를 제한하는 것입니다:
> 

```dart
// String 확장 메서드 parseInt()를 정의합니다.
import 'string_apis.dart';

// 또한 parseInt()를 정의하지만, NumberParsing2를 숨기면
// 해당 확장 메서드를 숨깁니다.
import 'string_apis_2.dart' hide NumberParsing2;

// ···
// 'string_apis.dart'에 정의된 parseInt()를 사용합니다.
print('42'.parseInt());
// 또 다른 옵션은 확장자를 명시적으로 적용하는 것으로, 
// 확장자가 래퍼 클래스인 것처럼 보이는 코드를 생성하는 것입니다:
// 두 라이브러리는 String의 확장을 정의하며, 각 확장은 다른 이름을 가지고 있습니다.
import 'string_apis.dart'; // NumberParsing 확장을 포함합니다.
import 'string_apis_2.dart'; // NumberParsing2 확장을 포함합니다.

// ···
// print('42'.parseInt()); // 작동하지 않습니다.
print(NumberParsing('42').parseInt());
print(NumberParsing2('42').parseInt());
// 두 확장 프로그램의 이름이 같은 경우 접두사를 사용하여 가져와야 할 수 있습니다:
// 두 라이브러리는 NumberParsing이라는 이름의 확장을 정의합니다.
// 이 중 하나의 NumberParsing 확장('string_apis_3.dart')은 parseNum()도 정의합니다.
import 'string_apis.dart';
import 'string_apis_3.dart' as rad;

// ···
// print('42'.parseInt()); // 작동하지 않습니다.

// string_apis.dart의 ParseNumbers 확장을 사용합니다.
print(NumberParsing('42').parseInt());

// string_apis_3.dart의 ParseNumbers 확장을 사용합니다.
print(rad.NumberParsing('42').parseInt());

// string_apis_3.dart만 parseNum()을 가지고 있습니다.
print('42'.parseNum());
```

**Implementing extension methods**[#](https://dart.dev/language/extension-methods#implementing-extension-methods)

Use the following syntax to create an extension:

> **확장 메서드 구현**
> 
> 
> 다음 구문을 사용하여 확장을 만들 수 있습니다:
> 

```dart
// 기본형
extension <extension name>? on <type> { // <extension-name> is optional
  (<member definition>)* // Can provide one or more <member definition>.
}

// 예를 들어 String 클래스에서 확장 기능을 구현하는 방법은 다음과 같습니다:
extension NumberParsing on String {
  int parseInt() {
    return int.parse(this);
  }

  double parseDouble() {
    return double.parse(this);
  }
}
```

The members of an extension can be methods, getters, setters, or operators. Extensions can also have static fields and static helper methods. To access static members outside the extension declaration, invoke them through the declaration name like [class variables and methods](https://dart.dev/language/classes#class-variables-and-methods).

> 확장의 멤버는 메서드, 게터, 세터 또는 연산자가 될 수 있습니다. 확장에는 정적 필드와 정적 헬퍼 메서드도 포함될 수 있습니다. 확장 선언 외부에서 정적 멤버에 액세스하려면 클래스 변수 및 메서드처럼 선언 이름을 통해 호출하세요.
> 

**Unnamed extensions**[#](https://dart.dev/language/extension-methods#unnamed-extensions)

When declaring an extension, you can omit the name. Unnamed extensions are visible only in the library where they're declared. Since they don't have a name, they can't be explicitly applied to resolve [API conflicts](https://dart.dev/language/extension-methods#api-conflicts).

> **이름 없는 확장명**
> 
> 
> 확장 프로그램을 선언할 때 이름을 생략할 수 있습니다. 이름 없는 확장은 선언된 라이브러리에서만 볼 수 있습니다. 이름이 없으므로 API 충돌을 해결하기 위해 명시적으로 적용할 수 없습니다.
> 

```dart
// **확장 선언 내에서만 명명되지 않은 확장 프로그램의 정적 멤버를 호출할 수 있습니다.**
extension on String {
  bool get isBlank => trim().isEmpty;
}
```

**Implementing generic extensions**[#](https://dart.dev/language/extension-methods#implementing-generic-extensions)

Extensions can have generic type parameters. For example, here's some code that extends the built-in `List<T>` type with a getter, an operator, and a method:

> **일반 확장 구현**
> 
> 
> 확장에는 일반 타입 매개변수를 사용할 수 있습니다. 예를 들어 다음은 기본 제공 List<T> 유형을 게터, 연산자 및 메서드로 확장하는 몇 가지 코드입니다:
> 

```dart
// 유형 T는 메서드가 호출되는 목록의 정적 유형에 따라 바인딩됩니다.
extension MyFancyList<T> on List<T> {
  int get doubleLength => length * 2;
  List<T> operator -() => reversed.toList();
  List<List<T>> split(int at) => [sublist(0, at), sublist(at)];
}
```

# **Extension types**

An extension type is a compile-time abstraction that "wraps" an existing type with a different, static-only interface. They are a major component of [static JS interop](https://dart.dev/go/next-gen-js-interop) because they can easily modify an existing type's interface (crucial for any kind of interop) without incurring the cost of an actual wrapper.

Extension types enforce discipline on the set of operations (or interface) available to objects of an underlying type, called the *representation type*. When defining the interface of an extension type, you can choose to reuse some members of the representation type, omit others, replace others, and add new functionality.

The following example wraps the `int` type to create an extension type that only allows operations that make sense for ID numbers:

> 확장 타입은 기존 타입을 다른 정적 전용 인터페이스로 "래핑"하는 컴파일 타임 추상화입니다. 실제 래퍼 비용을 들이지 않고도 기존 타입의 인터페이스를 쉽게 수정할 수 있기 때문에 정적 JS 인터롭의 주요 구성 요소입니다(모든 종류의 인터롭에 중요).
> 
> 
> 확장 타입은 표현 타입이라고 하는 기본 타입의 객체에 사용할 수 있는 연산 집합(또는 인터페이스)에 규율을 적용합니다. 확장 유형의 인터페이스를 정의할 때 표현 유형의 일부 멤버를 재사용하거나, 생략하거나, 다른 멤버를 대체하거나, 새로운 기능을 추가하도록 선택할 수 있습니다.
> 
> 다음 예에서는 int 유형을 래핑하여 ID 번호에 적합한 연산만 허용하는 확장 유형을 만듭니다:
> 

```dart
extension type IdNumber(int id) {
  // 'int' 타입의 '<' 연산자를 감쌉니다:
  operator <(IdNumber other) => id < other.id;
  // 예를 들어, ID 숫자에 덧셈은 의미가 없기 때문에 '+' 연산자를 선언하지 않습니다.
}

void main() {
  // 확장 타입의 규율이 없으면,
  // 'int'는 ID 숫자를 안전하지 않은 연산에 노출시킵니다:
  int myUnsafeId = 42424242;
  myUnsafeId = myUnsafeId + 10; // 이게 동작하지만, ID에 대해서는 허용되지 않아야 합니다.

  var safeId = IdNumber(42424242);
  safeId + 10; // 컴파일 시간 오류: '+' 연산자가 없습니다.
  myUnsafeId = safeId; // 컴파일 시간 오류: 잘못된 타입입니다.
  myUnsafeId = safeId as int; // OK: 런타임 캐스트로 표현 타입으로 변환합니다.
  safeId < IdNumber(42424241); // OK: 감싸진 '<' 연산자를 사용합니다.
}
```

<aside>
💡 **참고**

확장 유형은 래퍼 클래스와 같은 용도로 사용되지만, 많은 객체를 래핑해야 할 때 비용이 많이 드는 런타임 객체를 추가로 생성할 필요가 없습니다. 확장 유형은 정적 전용이며 런타임에 컴파일되므로 기본적으로 비용이 들지 않습니다.

확장 메서드("확장"이라고도 함)는 확장 유형과 유사한 정적 추상화입니다. 그러나 확장 메서드는 기본 유형의 모든 인스턴스에 직접 기능을 추가합니다. 확장 타입은 다르며, 확장 타입의 인터페이스는 정적 타입이 해당 확장 타입인 표현식에만 적용됩니다. 기본적으로 기본 유형의 인터페이스와 구별됩니다.

![스크린샷 2024-07-01 오후 10.59.15.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/638f156c-ab35-4f7a-9b1f-c5ded03b6195/84e93459-c6d7-4471-b085-2ddfd9d2634b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-01_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.59.15.png)

[]()

</aside>

**Syntax**[#](https://dart.dev/language/extension-types#syntax)

**Declaration**[#](https://dart.dev/language/extension-types#declaration)

Define a new extension type with the `extension type` declaration and a name, followed by the *representation type declaration* in parenthesis

> **선언**
> 
> 
> 확장 유형 선언과 이름 뒤에 괄호 안에 표현 유형 선언을 사용하여 새 확장 유형을 정의합니다.
> 

```dart
extension type E(int i) {
  // 이 확장 타입은 정수(int) 타입을 감싸고, 특정 연산 집합을 정의할 수 있습니다.
  // 여기서 'E'는 정수에 대한 확장 타입입니다.
  // 예를 들어, 특정 연산자나 메서드를 정의하여 'int' 타입의 값을 더 안전하게 사용할 수 있습니다.
}

extension type E<T>(List<T> elements) {
  // 이 확장 타입은 제네릭 타입 T의 리스트(List<T>)를 감쌉니다.
  // 여기서 'E'는 리스트에 대한 확장 타입입니다.
  // 리스트 요소에 대해 특정 연산자나 메서드를 정의할 수 있습니다.
  // 예를 들어, 리스트의 요소를 더 안전하게 접근하거나 조작할 수 있는 방법을 제공할 수 있습니다.
}

// 이 두 확장 타입은 각각 다른 기본 타입(int와 List<T>)을 감싸고 있으며,
// 각 타입에 대해 특정 연산을 정의하여 더 안전하고 명확하게 사용할 수 있도록 합니다.
// 첫 번째 확장 타입은 정수 연산을, 두 번째 확장 타입은 리스트 연산을 정의할 수 있습니다.
```

**Constructors**[#](https://dart.dev/language/extension-types#constructors)

You can optionally declare [constructors](https://dart.dev/language/constructors) in an extension type's body. The representation declaration itself is an implicit constructor, so by default takes the place of an unnamed constructor for the extension type. Any additional non-redirecting generative constructors must initialize the representation object's instance variable using `this.i` in its initializer list or formal parameters.

> **생성자**
> 
> 
> 선택적으로 확장 타입의 본문에서 생성자를 선언할 수 있습니다. 표현 선언 자체는 암시적 생성자이므로 기본적으로 확장 타입의 이름 없는 생성자를 대신합니다. 리디렉션되지 않는 추가 생성 생성자는 이니셜라이저 목록 또는 공식 매개변수에서 this.i를 사용하여 표현 객체의 인스턴스 변수를 초기화해야 합니다.
> 

```dart
extension type E(int i) {
  // 기본 생성자 및 명명된 생성자를 정의합니다.
  E.n(this.i); // 명명된 생성자 'n', 'i'에 값을 직접 할당합니다.
  E.m(int j, String foo) : i = j + foo.length; // 명명된 생성자 'm', 'i'에 'j'와 'foo'의 길이를 더한 값을 할당합니다.
}

void main() {
  E(4); // 묵시적 이름 없는 생성자.
  E.n(3); // 명명된 생성자 'n'.
  E.m(5, "Hello!"); // 명명된 생성자 'm'과 추가 매개변수.
}

extension type const E._(int it) {
  // const 확장 타입과 명명된 생성자를 정의합니다.
  E(): this._(42); // 기본 생성자, 'it'에 42를 할당합니다.
  E.otherName(this.it); // 명명된 생성자 'otherName', 'it'에 값을 직접 할당합니다.
}

void main2() {
  E(); // 기본 생성자 호출.
  const E._(2); // const 생성자 호출.
  E.otherName(3); // 명명된 생성자 'otherName' 호출.
}

extension type E._(int i) {
  // 문자열을 정수로 변환하는 명명된 생성자를 정의합니다.
  // -> 또한 생성 생성자 또는 팩토리 생성자(하위 확장 유형의 생성자에게도 전달할 수 있음) 전달을 선언할 수도 있습니다.
  E.fromString(String foo) : i = int.parse(foo); // 문자열 'foo'를 파싱하여 'i'에 할당합니다.
}
```

**Members**[#](https://dart.dev/language/extension-types#members)

Declare members in the body of an extension type to define its interface the same way you would for class members. Extension type members can be methods, getters, setters, or operators (non-[`external`](https://dart.dev/language/functions#external) [instance variables](https://dart.dev/language/classes#instance-variables) and [abstract members](https://dart.dev/language/methods#abstract-methods) are not allowed):

> **회원**
> 
> 
> 확장 타입의 본문에서 멤버를 선언하여 클래스 멤버와 동일한 방식으로 인터페이스를 정의합니다. 확장 타입 멤버는 메서드, 게터, 세터 또는 연산자(비외부 인스턴스 변수 및 추상 멤버는 허용되지 않음)일 수 있습니다:
> 

```dart
extension type NumberE(int value) {
  // 연산자:
  NumberE operator +(NumberE other) => NumberE(value + other.value);
  
  // 게터:
  NumberE get myNum => this;
  
  // 메서드:
  bool isValid() => !value.isNegative;
}
```

Interface members of the representation type are not interface members of the extension type [by default](https://dart.dev/language/extension-types#transparency). To make a single member of the representation type available on the extension type, you must write a declaration for it in the extension type definition, like the `operator +` in `NumberE`. You also can define new members unrelated to the representation type, like the `i` getter and `isValid` method.

> 표현 타입의 인터페이스 멤버는 기본적으로 확장 타입의 인터페이스 멤버가 아닙니다. 확장 타입에서 표현 타입의 단일 멤버를 사용하려면 NumberE의 + 연산자처럼 확장 타입 정의에 해당 멤버에 대한 선언을 작성해야 합니다. 또한 표현 유형과 관련이 없는 새로운 멤버를 정의할 수도 있습니다(예: i getter 및 isValid 메서드).
> 

**Implements**[#](https://dart.dev/language/extension-types#implements)

You can optionally use the `implements` clause to:

- Introduce a subtype relationship on an extension type, AND
- Add the members of the representation object to the extension type interface.

The `implements` clause introduces an [applicability](https://github.com/dart-lang/language/blob/main/accepted/2.7/static-extension-methods/feature-specification.md#examples) relationship like the one between an [extension method](https://dart.dev/language/extension-methods) and its `on` type. Members that are applicable to the supertype are applicable to the subtype as well, unless the subtype has a declaration with the same member name.

An extension type can only implement:

> **구현**
> 
> 
> 선택적으로 구현 절을 사용할 수 있습니다:
> 
> 확장 유형에 하위 유형 관계를 도입하고, 그리고
> 표현 객체의 멤버를 확장 타입 인터페이스에 추가합니다.
> implements 절은 확장 메서드와 그 온 타입 사이의 관계와 같은 적용 가능성 관계를 도입합니다. 상위 유형에 적용 가능한 멤버는 하위 유형에 동일한 멤버 이름을 가진 선언이 없는 한 하위 유형에도 적용 가능합니다.
> 
> 확장 유형은 구현만 가능합니다:
> 
- **표현 타입 자체**

```dart
extension type NumberI(int i) implements int {
  // 'NumberI'는 'int'의 모든 멤버를 호출할 수 있으며,
  // 여기서 선언한 다른 멤버도 추가로 사용할 수 있습니다.
}
```

- **표현 타입의 슈퍼타입**

```dart
extension type Sequence<T>(List<T> _) implements Iterable<T> {
  // List보다 나은 연산을 제공합니다.
}
extension type Id(int _id) implements Object {
  // 확장 타입을 null이 될 수 없게 만듭니다.
  static Id? tryParse(String source) => int.tryParse(source) as Id?;
}
```

- **동일한 표현 타입에 유효한 다른 확장 타입**

```dart

// 이를 통해 여러 확장 유형에서 작업을 재사용할 수 있습니다(다중 상속과 유사).
// Opt<T> 확장 타입 정의
extension type const Opt<T>._(({T value})? _) { 
  // Val<T> 인스턴스를 생성하는 팩토리 생성자
  const factory Opt(T value) = Val<T>;
  // Non<T> 인스턴스를 생성하는 팩토리 생성자
  const factory Opt.none() = Non<T>;
}

// 값을 가지는 선택적 타입 Val<T> 정의
extension type const Val<T>._(({T value}) _) implements Opt<T> { 
  // Val 생성자: 값을 받아서 저장
  const Val(T value) : this._((value: value));
  // 저장된 값을 반환하는 게터
  T get value => _.value;
}

// 값을 가지지 않는 선택적 타입 Non<T> 정의
extension type const Non<T>._(Null _) implements Opt<Never> {
  // Non 생성자: 항상 null 값을 저장
  const Non() : this._(null);
}
```

**`@redeclare`**[#](https://dart.dev/language/extension-types#redeclare)

Declaring an extension type member that shares a name with a member of a supertype is *not* an override relationship like it is between classes, but rather a *redeclaration*. An extension type member declaration *completely replaces* any supertype member with the same name. It's not possible to provide an alternative implementation for the same function.

You can use the `@redeclare` annotation to tell the compiler you are *knowingly* choosing to use the same name as a supertype's member. The analyzer will then warn you if that's not actually true, for example if one of the names are mistyped.

> 재선언
> 
> 
> 슈퍼타입의 멤버와 이름이 같은 확장 타입 멤버를 선언하는 것은 클래스 간의 오버라이드 관계와는 다릅니다. 대신, 다시 선언(redeclaration)이라고 합니다. 확장 타입 멤버 선언은 동일한 이름을 가진 슈퍼타입 멤버를 완전히 대체합니다.
> 
> `@redeclare` 애노테이션을 사용하여 동일한 이름을 사용하기로 의도적으로 선택했음을 컴파일러에 알릴 수 있습니다. 분석기는 실제로 그렇지 않은 경우(예: 이름이 잘못 입력된 경우) 경고를 표시합니다.
> 

```dart
extension type MyString(String _) implements String {
  // 'String.operator[]'을 대체합니다.
  @redeclare
  int operator [](int index) => codeUnitAt(index);
}
```

**Usage**[#](https://dart.dev/language/extension-types#usage)

To use an extension type, create an instance the same as you would with a class: by calling a constructor:

> **사용법**
> 
> 
> 확장 유형을 사용하려면 클래스를 사용할 때와 동일하게 생성자를 호출하여 인스턴스를 생성합니다:
> 

### 1. 기존 타입에 확장된 인터페이스 제공

**기존 타입의 인터페이스를 확장하면서, 새로운 멤버를 추가하거나 기존 멤버를 재정의하여 더 많은 기능을 제공할 수 있습니다. 이런 타입을 "투명한 확장 유형"이라고 부릅니다. 투명한 확장 유형은 기본 타입의 멤버들을 호출할 수 있습니다.**

```dart
extension type NumberT(int value) implements int {
  NumberT get i => this;
}

void main() {
  var v1 = NumberT(1); // v1 타입: NumberT
  int v2 = NumberT(2); // v2 타입: int
  var v3 = v1.i - v1;  // v3 타입: int
  var v4 = v2 + v1; // v4 타입: int
  var v5 = 2 + v1; // v5 타입: int
  // 오류: 확장 유형 인터페이스는 기본 타입에서 사용할 수 없음
  v2.i;
}
```

### 2. 기존 타입에 다른 인터페이스 제공

**투명하지 않은 확장 유형은 기존 타입과 완전히 다른 새로운 타입으로 취급됩니다. 이 경우, 확장 유형은 기본 타입의 멤버를 노출하지 않으며, 기본 타입과 상호 변환이 불가능합니다.**

```dart
extension type NumberE(int value) {
  NumberE operator +(NumberE other) => NumberE(value + other.value);

  NumberE get next => NumberE(value + 1);
  bool isValid() => !value.isNegative;
}

void testE() {
  var num1 = NumberE(1);
  int num2 = NumberE(2); // 오류: 'NumberE'를 'int'에 할당할 수 없음
  
  num1.isValid(); // OK: 확장 멤버 호출
  num1.isNegative(); // 오류: 'NumberE'는 'int' 멤버 'isNegative'를 정의하지 않음
  
  var sum1 = num1 + num1; // OK: 'NumberE'는 '+'를 정의함
  var diff1 = num1 - num1; // 오류: 'NumberE'는 'int' 멤버 '-'를 정의하지 않음
  var diff2 = num1.value - 2; // OK: 기본 객체를 참조하여 접근 가능
  var sum2 = num1 + 2; // 오류: 'int'를 'NumberE' 매개변수 타입에 할당할 수 없음
  
  List<NumberE> numbers = [
    NumberE(1),
    num1.next, // OK: 'next' 게터가 'NumberE' 타입을 반환함
    1, // 오류: 'int' 요소를 'NumberE' 리스트 타입에 할당할 수 없음
  ];
}
```

**Type considerations**[#](https://dart.dev/language/extension-types#type-considerations)

Extension types are a compile-time wrapping construct. At run time, there is absolutely no trace of the extension type. Any type query or similar run-time operations work on the representation type.

This makes extension types an *unsafe* abstraction, because you can always find out the representation type at run time and access the underlying object.

Dynamic type tests (`e is T`), casts (`e as T`), and other run-time type queries (like `switch (e) ...` or `if (e case ...)`) all evaluate to the underlying representation object, and type check against that object's runtime type. That's true when the static type of `e` is an extension type, and when testing against an extension type (`case MyExtensionType(): ...`).

> **유형 고려 사항**
> 
> 
> 확장 유형은 컴파일 타임 래핑 구조입니다. 런타임에는 확장 유형에 대한 흔적이 전혀 없습니다. 모든 타입 쿼리 또는 이와 유사한 런타임 연산은 표현 타입에서 작동합니다.
> 
> 따라서 런타임에 항상 표현 유형을 찾아서 기본 객체에 액세스할 수 있기 때문에 확장 유형은 안전하지 않은 추상화입니다.
> 
> 동적 타입 테스트(e는 T), 형 변환(e는 T로) 및 기타 런타임 타입 쿼리(switch (e) ... 또는 if (e case ...) 등)는 모두 기본 표현 객체로 평가되고 해당 객체의 런타임 타입에 대해 타입 검사를 수행합니다. 이는 정적 유형인 e가 확장 유형이고 확장 유형에 대해 테스트할 때 해당됩니다(사례 MyExtensionType(): ...).
> 

```dart
// NumberE 확장 유형의 런타임 동작
void main() {
  var n = NumberE(1);

  // 'n'의 런타임 타입은 'int'입니다.
  if (n is int) print(n.value); // 1을 출력합니다.

  // 런타임에서 'n'에 대해 'int' 메서드를 사용할 수 있습니다.
  if (n case int x) print(x.toRadixString(10)); // 1을 출력합니다.
  switch (n) {
    case int(:var isEven): print("$n (${isEven ? "even" : "odd"})"); // 1 (odd)를 출력합니다.
  }
}
//  int 타입의 확장 유형 동작
void main() {
  int i = 2;
  if (i is NumberE) print("It is"); // 'It is'를 출력합니다.
  if (i case NumberE v) print("value: ${v.value}"); // 'value: 2'를 출력합니다.
  switch (i) {
    case NumberE(:var value): print("value: $value"); // 'value: 2'를 출력합니다.
  }
}
```

It's important to be aware of this quality when using extension types. Always keep in mind that an extension type exists and matters at compile time, but gets erased *during* compilation.

For example, consider an expression `e` whose static type is the extension type `E`, and the representation type of `E` is `R`. Then, the run-time type of the value of `e` is a subtype of `R`. Even the type itself is erased; `List<E>` is exactly the same thing as `List<R>` at run time.

In other words, a real wrapper class can encapsulate a wrapped object, whereas an extension type is just a compile-time view on the wrapped object. While a real wrapper is safer, the trade-off is extension types give you the option to avoid wrapper objects, which can greatly improve performance in some scenarios.

> 확장 유형을 사용할 때는 이 특성을 알아두는 것이 중요합니다. 확장 유형은 컴파일 시에는 존재하고 중요하지만 컴파일 중에 지워진다는 점을 항상 염두에 두어야 합니다.
> 
> 
> 예를 들어 정적 타입이 확장 타입 E이고 E의 표현 타입이 R인 표현식 e를 생각해 보세요. 그러면 e 값의 런타임 타입은 R의 하위 타입입니다. 타입 자체도 지워지므로 런타임에는 List<E>가 List<R>과 완전히 동일하게 됩니다.
> 
> 즉, 실제 래퍼 클래스는 래핑된 객체를 캡슐화할 수 있지만 확장 타입은 래핑된 객체에 대한 컴파일 타임 보기일 뿐입니다. 실제 래퍼가 더 안전하지만, 확장 유형은 래퍼 객체를 피할 수 있는 옵션을 제공하므로 일부 시나리오에서는 성능이 크게 향상될 수 있다는 단점이 있습니다.
> 

# **Callable objects**

To allow an instance of your Dart class to be called like a function, implement the `call()` method.

The `call()` method allows an instance of any class that defines it to emulate a function. This method supports the same functionality as normal [functions](https://dart.dev/language/functions) such as parameters and return types.

In the following example, the `WannabeFunction` class defines a `call()` function that takes three strings and concatenates them, separating each with a space, and appending an exclamation. Click **Run** to execute the code.

> Dart 클래스의 인스턴스를 함수처럼 호출할 수 있게 하려면 call() 메서드를 구현하세요.
> 
> 
> call() 메서드를 사용하면 이를 정의하는 모든 클래스의 인스턴스가 함수를 에뮬레이트할 수 있습니다. 이 메서드는 매개변수 및 반환 유형과 같은 일반 함수와 동일한 기능을 지원합니다.
> 
> 다음 예제에서 WannabeFunction 클래스는 세 개의 문자열을 받아 각각 공백으로 구분하고 느낌표를 추가하여 연결하는 call() 함수를 정의합니다. 실행을 클릭하여 코드를 실행합니다.
> 

```dart
// `WannabeFunction` 클래스는 `call()` 메서드를 구현하여 인스턴스를 함수처럼 호출할 수 있게 합니다.
class WannabeFunction {
  // `call` 메서드는 세 개의 문자열을 받아서 공백으로 구분하고 마지막에 느낌표를 추가합니다.
  String call(String a, String b, String c) => '$a $b $c!';
}

// `WannabeFunction` 클래스의 인스턴스를 생성합니다.
var wf = WannabeFunction();

// `wf` 인스턴스를 함수처럼 호출하여 세 개의 문자열을 전달하고 결과를 `out` 변수에 저장합니다.
var out = wf('Hi', 'there,', 'gang');

// `main` 함수는 프로그램의 진입점입니다.
void main() => print(out); // `out` 변수의 값을 출력합니다.

```
