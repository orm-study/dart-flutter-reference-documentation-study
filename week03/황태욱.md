# Error handling

## Exceptions


Your Dart code can throw and catch exceptions. Exceptions are errors indicating that something unexpected happened. If the exception isn't caught, the [isolate](https://dart.dev/language/concurrency#isolates) that raised the exception is suspended, and typically the isolate and its program are terminated.

In contrast to Java, all of Dart's exceptions are unchecked exceptions. Methods don't declare which exceptions they might throw, and you aren't required to catch any exceptions.

Dart provides [`Exception`](https://api.dart.dev/stable/dart-core/Exception-class.html) and [`Error`](https://api.dart.dev/stable/dart-core/Error-class.html) types, as well as numerous predefined subtypes. You can, of course, define your own exceptions. However, Dart programs can throw any non-null object—not just Exception and Error objects—as an exception.

## 예외

당신의 Dart 코드는 예외를 던지고 잡을 수 있습니다. 예외는 예상치 못한 일이 발생했음을 나타내는 오류입니다. 예외가 잡히지 않으면, 예외를 발생시킨 아이솔레이트(isolate)가 중단되고, 일반적으로 아이솔레이트와 그 프로그램이 종료됩니다.

Java와 대조적으로, Dart의 모든 예외는 체크되지 않은 예외입니다. 메서드가 어떤 예외를 던질지 선언하지 않으며, 어떤 예외도 잡아야 할 필요가 없습니다.

Dart는 `Exception`과 `Error` 타입뿐만 아니라, 수많은 미리 정의된 하위 타입들을 제공합니다. 물론, 자신의 예외를 정의할 수도 있습니다. 그러나 Dart 프로그램은 예외로 `Exception`과 `Error` 객체뿐만 아니라, 모든 null이 아닌 객체를 던질 수 있습니다.

### Throw

Here's an example of throwing, or _raising_, an exception:

### Throw

던지기 다음은 예외를 던지거나 발생시키는 예입니다:

```dart
throw FormatException('Expected at least 1 section');
```

You can also throw arbitrary objects:

임의의 객체를 던질 수도 있습니다:

```dart
throw 'Out of llamas!';
```

_Note_

Production-quality code usually throws types that implement [`Error`](https://api.dart.dev/stable/dart-core/Error-class.html) or [`Exception`](https://api.dart.dev/stable/dart-core/Exception-class.html).

_정보_

프로덕션 품질의 코드에서는 보통 `Error`나 `Exception`을 구현하는 타입을 던집니다.

Because throwing an exception is an expression, you can throw exceptions in => statements, as well as anywhere else that allows expressions:

예외를 던지는 것은 표현식이기 때문에, => 문에서는 물론, 표현식을 허용하는 모든 곳에서 예외를 던질 수 있습니다:


```dart
void distanceTo(Point other) => throw UnimplementedError();
```
### Catch

Catching, or capturing, an exception stops the exception from propagating (unless you rethrow the exception). Catching an exception gives you a chance to handle it:

### Catch

예외를 잡거나 포착하는 것은 예외가 전파되는 것을 멈추게 합니다(예외를 다시 던지지 않는 한). 예외를 잡는 것은 이를 처리할 기회를 줍니다:

```dart
try {
  breedMoreLlamas();
} on OutOfLlamasException {
  buyMoreLlamas();
}
```

To handle code that can throw more than one type of exception, you can specify multiple catch clauses. The first catch clause that matches the thrown object's type handles the exception. If the catch clause does not specify a type, that clause can handle any type of thrown object:

코드가 여러 종류의 예외를 던질 수 있는 경우, 여러 개의 `catch` 절을 지정할 수 있습니다. 던져진 객체의 타입과 일치하는 첫 번째 `catch` 절이 예외를 처리합니다. `catch` 절이 타입을 지정하지 않으면, 해당 절은 모든 타입의 던져진 객체를 처리할 수 있습니다:

```dart
try {
  breedMoreLlamas();
} on OutOfLlamasException {
  // A specific exception
  buyMoreLlamas();
} on Exception catch (e) {
  // Anything else that is an exception
  print('Unknown exception: $e');
} catch (e) {
  // No specified type, handles all
  print('Something really unknown: $e');
}
```

As the preceding code shows, you can use either `on` or `catch` or both. Use `on` when you need to specify the exception type. Use `catch` when your exception handler needs the exception object.

You can specify one or two parameters to `catch()`. The first is the exception that was thrown, and the second is the stack trace (a [`StackTrace`](https://api.dart.dev/stable/dart-core/StackTrace-class.html) object).

위의 코드에서 보듯이, on이나 catch 또는 둘 다 사용할 수 있습니다. 예외 타입을 명시해야 할 때는 on을 사용하고, 예외 핸들러에서 예외 객체가 필요할 때는 catch를 사용하세요.

catch()에는 하나 또는 두 개의 매개변수를 지정할 수 있습니다. 첫 번째 매개변수는 던져진 예외 객체이며, 두 번째 매개변수는 스택 추적 정보인 StackTrace 객체입니다.

```dart
try {
  // ···
} on Exception catch (e) {
  print('Exception details:\n $e');
} catch (e, s) {
  print('Exception details:\n $e');
  print('Stack trace:\n $s');
}
```

To partially handle an exception, while allowing it to propagate, use the `rethrow` keyword.

예외를 일부 처리하면서 예외를 전파하려면 `rethrow` 키워드를 사용합니다.

```dart
void misbehave() {
  try {
    dynamic foo = true;
    print(foo++); // Runtime error
  } catch (e) {
    print('misbehave() partially handled ${e.runtimeType}.');
    rethrow; // Allow callers to see the exception.
  }
}

void main() {
  try {
    misbehave();
  } catch (e) {
    print('main() finished handling ${e.runtimeType}.');
  }
}
```

### Finally

To ensure that some code runs whether or not an exception is thrown, use a `finally` clause. If no `catch` clause matches the exception, the exception is propagated after the `finally` clause runs:

### Finally 

예외가 발생하든 발생하지 않든 특정 코드가 항상 실행되도록 보장하려면 finally 절을 사용합니다. 만약 catch 절이 예외와 일치하지 않는다면, finally 절이 실행된 후에 예외가 전파됩니다:

```dart
try {
  breedMoreLlamas();
} finally {
  // Always clean up, even if an exception is thrown.
  cleanLlamaStalls();
}
```

The `finally` clause runs after any matching `catch` clauses:

`finally` 절은 어떤 `catch` 절과도 일치하는 후에 실행됩니다:

```dart
try {
  breedMoreLlamas();
} catch (e) {
  print('Error: $e'); // Handle the exception first.
} finally {
  cleanLlamaStalls(); // Then clean up.
}
```

To learn more, check out the [core library exception docs](https://dart.dev/libraries/dart-core#exceptions).

더 알아보려면, Dart의 핵심 라이브러리 예외 문서를 확인하세요.

## Assert

During development, use an assert statement— `assert(<condition>, <optionalMessage>);` —to disrupt normal execution if a boolean condition is false.

## Assert

개발 중에는 assert 문을 사용하여 특정 조건이 false일 경우 정상 실행을 중단합니다. assert(<조건>, <선택적인 메시지>);

```dart
// Make sure the variable has a non-null value.
assert(text != null);

// Make sure the value is less than 100.
assert(number < 100);

// Make sure this is an https URL.
assert(urlString.startsWith('https'));
```

To attach a message to an assertion, add a string as the second argument to `assert` (optionally with a [trailing comma](https://dart.dev/language/collections#trailing-comma)):

단언문(assert)에 메시지를 첨부하려면, 두 번째 인자로 문자열을 추가하면 됩니다(선택적으로 마지막에 쉼표를 붙일 수 있습니다):

```dart
assert(urlString.startsWith('https'),
    'URL ($urlString) should start with "https".');
```

The first argument to `assert` can be any expression that resolves to a boolean value. If the expression's value is true, the assertion succeeds and execution continues. If it's false, the assertion fails and an exception (an [`AssertionError`](https://api.dart.dev/stable/dart-core/AssertionError-class.html)) is thrown.

When exactly do assertions work? That depends on the tools and framework you're using:

- Flutter enables assertions in [debug mode.](https://docs.flutter.dev/testing/debugging#debug-mode-assertions)
- Development-only tools such as [`webdev serve`](https://dart.dev/tools/webdev#serve) typically enable assertions by default.
- Some tools, such as [`dart run`](https://dart.dev/tools/dart-run) and [`dart compile js`](https://dart.dev/tools/dart-compile#js) support assertions through a command-line flag: `--enable-asserts`.

In production code, assertions are ignored, and the arguments to `assert` aren't evaluated.

다트의 assert의 첫 번째 인자는 불리언 값을 평가하는 어떤 표현식이든 될 수 있습니다. 만약 표현식이 true로 평가되면, 단언문(assertion)은 성공하고 실행은 계속됩니다. 그러나 표현식이 false로 평가되면, 단언문은 실패하고 예외 (AssertionError)가 발생합니다.

단언문이 정확히 언제 작동하는지는 사용하는 도구와 프레임워크에 따라 달라집니다:

- **Flutter**에서는 디버그 모드에서 단언문이 활성화됩니다. 
- **웹 개발 도구**와 같은 개발 전용 도구들은 일반적으로 기본적으로 단언문을 활성화합니다. 
- `dart run` 및 `dart compile js`와 같은 도구들에서는 `--enable-asserts` 명령행 플래그를 사용하여 단언문을 활성화할 수 있습니다. 

생산 코드에서는 단언문(assertions)이 무시되며, assert의 인자들은 평가되지 않습니다.

# Classes

Dart is an object-oriented language with classes and mixin-based inheritance. Every object is an instance of a class, and all classes except `Null` descend from [`Object`](https://api.dart.dev/stable/dart-core/Object-class.html). _Mixin-based inheritance_ means that although every class (except for the [top class](https://dart.dev/null-safety/understanding-null-safety#top-and-bottom), `Object?`) has exactly one superclass, a class body can be reused in multiple class hierarchies. [Extension methods](https://dart.dev/language/extension-methods) are a way to add functionality to a class without changing the class or creating a subclass. [Class modifiers](https://dart.dev/language/class-modifiers) allow you to control how libraries can subtype a class.

Dart는 클래스와 mixin 기반 상속을 가진 객체 지향 언어입니다. 모든 객체는 클래스의 인스턴스이며, Null을 제외한 모든 클래스는 Object에서 상속됩니다. Mixin 기반 상속은 모든 클래스가 하나의 수퍼클래스를 가지지만 클래스 본문을 여러 클래스 계층구조에 재사용할 수 있다는 것을 의미합니다. 확장 메서드는 클래스의 변경 없이 해당 클래스에 기능을 추가하는 방법입니다. 클래스 수정자를 사용하면 라이브러리가 클래스를 서브타입화하는 방법을 제어할 수 있습니다.
## Using class members

Objects have _members_ consisting of functions and data (_methods_ and _instance variables_, respectively). When you call a method, you _invoke_ it on an object: the method has access to that object's functions and data.

Use a dot (`.`) to refer to an instance variable or method:

## 클래스 멤버 사용

객체는 메서드와 인스턴스 변수로 구성된 멤버를 가지고 있습니다. 메서드를 호출할 때, 그것을 객체에 대해 호출하게 되며, 메서드는 해당 객체의 함수와 데이터에 접근할 수 있습니다.

인스턴스 변수나 메서드를 참조할 때는 점(.)을 사용합니다:

```dart
var p = Point(2, 2);

// Get the value of y.
assert(p.y == 2);

// Invoke distanceTo() on p.
double distance = p.distanceTo(Point(4, 4));
```

Use `?.` instead of `.` to avoid an exception when the leftmost operand is null:

?. 연산자를 사용하여 왼쪽 피연산자가 null일 때 예외를 방지할 수 있습니다:

```dart
// If p is non-null, set a variable equal to its y value.
var a = p?.y;
```
## Using constructors

You can create an object using a _constructor_. Constructor names can be either `_ClassName_` or `_ClassName_._identifier_`. For example, the following code creates `Point` objects using the `Point()` and `Point.fromJson()` constructors:

## 생성자 사용하기

생성자를 사용하여 객체를 생성할 수 있습니다. 생성자 이름은 ClassName 또는 ClassName.identifier 형식일 수 있습니다. 예를 들어, 아래 코드는 Point() 생성자와 Point.fromJson() 생성자를 사용하여 Point 객체를 생성합니다:

```dart
var p1 = Point(2, 2);
var p2 = Point.fromJson({'x': 1, 'y': 2});
```

The following code has the same effect, but uses the optional `new` keyword before the constructor name:

다음 코드는 동일한 효과를 가지지만, 생성자 이름 앞에 선택적으로 `new` 키워드를 사용합니다:

```dart
var p1 = new Point(2, 2);
var p2 = new Point.fromJson({'x': 1, 'y': 2});
```

Some classes provide [constant constructors](https://dart.dev/language/constructors#constant-constructors). To create a compile-time constant using a constant constructor, put the `const` keyword before the constructor name:

일부 클래스는 상수 생성자를 제공합니다. 상수 생성자를 사용하여 컴파일 타임 상수를 생성하려면 생성자 이름 앞에 const 키워드를 넣으세요:

```dart
var p = const ImmutablePoint(2, 2);
```

Constructing two identical compile-time constants results in a single, canonical instance:

두 개의 동일한 컴파일 타임 상수를 생성하면 하나의 단일한 정규화된 인스턴스가 생성됩니다:

```dart
var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a, b)); // They are the same instance!
```

Within a _constant context_, you can omit the `const` before a constructor or literal. For example, look at this code, which creates a const map:

상수(context) 내에서는 생성자나 리터럴 앞의 const를 생략할 수 있습니다. 예를 들어, 다음은 const 맵을 생성하는 코드입니다:

```dart
// Lots of const keywords here.
const pointAndLine = const {
  'point': const [const ImmutablePoint(0, 0)],
  'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],
};
```

You can omit all but the first use of the `const` keyword:

첫 번째 사용 이외의 const 키워드는 모두 생략할 수 있습니다:

```dart
// Only one const, which establishes the constant context.
const pointAndLine = {
  'point': [ImmutablePoint(0, 0)],
  'line': [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],
};
```

If a constant constructor is outside of a constant context and is invoked without `const`, it creates a **non-constant object**:

상수 생성자가 상수(context) 외부에서 const 없이 호출되면, 비-상수 객체를 생성합니다.

```dart
var a = const ImmutablePoint(1, 1); // Creates a constant
var b = ImmutablePoint(1, 1); // Does NOT create a constant

assert(!identical(a, b)); // NOT the same instance!
```
## Getting an object's type

To get an object's type at runtime, you can use the `Object` property `runtimeType`, which returns a [`Type`](https://api.dart.dev/stable/dart-core/Type-class.html) object.

## 객체의 타입 얻기

객체의 런타임 타입을 얻으려면 Object의 속성인 runtimeType을 사용할 수 있습니다. 이는 Type 객체를 반환합니다.

```dart
print('The type of a is ${a.runtimeType}');
```

_Warning_

Use a [type test operator](https://dart.dev/language/operators#type-test-operators) rather than `runtimeType` to test an object's type. In production environments, the test `object is Type` is more stable than the test `object.runtimeType == Type`.

_경고_

객체의 타입을 테스트할 때는 runtimeType 대신 타입 테스트 연산자를 사용하세요. 생산 환경에서는 test object is Type이 test object.runtimeType == Type보다 안정적입니다.

Up to here, you've seen how to _use_ classes. The rest of this section shows how to _implement_ classes.

지금까지 클래스를 사용하는 방법을 살펴보았습니다. 이 섹션의 나머지 부분에서는 클래스를 구현하는 방법을 보여줍니다.
## Instance variables

Here's how you declare instance variables:

## 변수 선언

인스턴스 변수 선언 방법은 다음과 같습니다:

```dart
class Point {
  double? x; // Declare instance variable x, initially null.
  double? y; // Declare y, initially null.
  double z = 0; // Declare z, initially 0.
}
```

An uninitialized instance variable declared with a [nullable type](https://dart.dev/null-safety/understanding-null-safety#using-nullable-types) has the value `null`. Non-nullable instance variables [must be initialized](https://dart.dev/null-safety/understanding-null-safety#uninitialized-variables) at declaration.

All instance variables generate an implicit _getter_ method. Non-final instance variables and `late final` instance variables without initializers also generate an implicit _setter_ method. For details, check out [Getters and setters](https://dart.dev/language/methods#getters-and-setters).

초기화되지 않은 nullable 타입의 인스턴스 변수는 null 값을 가집니다. 초기화되지 않은 non-nullable 인스턴스 변수는 선언 시 초기화해야 합니다.

모든 인스턴스 변수는 암시적으로 getter 메서드를 생성합니다. 초기화되지 않은 non-final 인스턴스 변수와 초기화되지 않은 late final 인스턴스 변수는 암시적으로 setter 메서드도 생성합니다. 자세한 내용은 Getters and setters를 확인하세요.

```dart
class Point {
  double? x; // Declare instance variable x, initially null.
  double? y; // Declare y, initially null.
}

void main() {
  var point = Point();
  point.x = 4; // Use the setter method for x.
  assert(point.x == 4); // Use the getter method for x.
  assert(point.y == null); // Values default to null.
}
```

Initializing a non-`late` instance variable where it's declared sets the value when the instance is created, before the constructor and its initializer list execute. As a result, the initializing expression (after the `=`) of a non-`late` instance variable can't access `this`.

인스턴스 변수를 선언하는 위치에서 초기화할 경우, 해당 인스턴스가 생성되기 전에 생성자와 초기화 목록이 실행되어 값을 설정합니다. 따라서 non-late 인스턴스 변수의 초기화 표현식(= 뒤의 값)에서는 this를 사용할 수 없습니다.

```dart
double initialX = 1.5;

class Point {
  // OK, can access declarations that do not depend on `this`:
  double? x = initialX;

  // ERROR, can't access `this` in non-`late` initializer:
  double? y = this.x;

  // OK, can access `this` in `late` initializer:
  late double? z = this.x;

  // OK, `this.x` and `this.y` are parameter declarations, not expressions:
  Point(this.x, this.y);
}
```

Instance variables can be `final`, in which case they must be set exactly once. Initialize `final`, non-`late` instance variables at declaration, using a constructor parameter, or using a constructor's [initializer list](https://dart.dev/language/constructors#use-an-initializer-list):

인스턴스 변수는 final일 수 있으며, 이 경우 정확히 한 번 설정해야 합니다. final이면서 non-late 인스턴스 변수는 선언 시 초기화하거나 생성자 매개변수를 사용하거나 생성자의 초기화 목록을 이용하여 초기화할 수 있습니다:

```dart
class ProfileMark {
  final String name;
  final DateTime start = DateTime.now();

  ProfileMark(this.name);
  ProfileMark.unnamed() : name = '';
}
```

If you need to assign the value of a `final` instance variable after the constructor body starts, you can use one of the following:

- Use a [factory constructor](https://dart.dev/language/constructors#factory-constructors).
- Use `late final`, but [_be careful:_](https://dart.dev/effective-dart/design#avoid-public-late-final-fields-without-initializers) a `late final` without an initializer adds a setter to the API.

만약 생성자 본문이 시작된 후에 final 인스턴스 변수의 값을 할당해야 한다면, 다음 중 하나를 사용할 수 있습니다:

- 팩토리 생성자를 사용합니다.
- late final을 사용할 수 있지만, 주의해야 합니다: 초기화 없이 late final을 사용하면 API에 setter가 추가됩니다.

## Implicit interfaces

Every class implicitly defines an interface containing all the instance members of the class and of any interfaces it implements. If you want to create a class A that supports class B's API without inheriting B's implementation, class A should implement the B interface.

A class implements one or more interfaces by declaring them in an `implements` clause and then providing the APIs required by the interfaces. For example:

## 암시적 인터페이스

모든 클래스는 암시적으로 해당 클래스의 모든 인스턴스 멤버와 클래스가 구현하는 모든 인터페이스의 인스턴스 멤버를 포함하는 인터페이스를 정의합니다. 클래스 A가 클래스 B의 API를 지원하지만 B의 구현을 상속받지 않는 경우, 클래스 A는 B 인터페이스를 구현해야 합니다.

클래스는 implements 절에서 인터페이스를 선언하고, 인터페이스에서 요구하는 API를 제공함으로써 하나 이상의 인터페이스를 구현합니다. 예를 들어:

```dart
// A person. The implicit interface contains greet().
class Person {
  // In the interface, but visible only in this library.
  final String _name;

  // Not in the interface, since this is a constructor.
  Person(this._name);

  // In the interface.
  String greet(String who) => 'Hello, $who. I am $_name.';
}

// An implementation of the Person interface.
class Impostor implements Person {
  String get _name => '';

  String greet(String who) => 'Hi $who. Do you know who I am?';
}

String greetBob(Person person) => person.greet('Bob');

void main() {
  print(greetBob(Person('Kathy')));
  print(greetBob(Impostor()));
}
```

Here's an example of specifying that a class implements multiple interfaces:

다음은 클래스가 여러 인터페이스를 구현하는 예시입니다:

```dart
class Point implements Comparable, Location {...}
```
## Class variables and methods

Use the `static` keyword to implement class-wide variables and methods.

## 클래스 변수와 메서드

클래스 전역 변수와 메서드를 구현하기 위해 static 키워드를 사용하세요.

### Static variables

Static variables (class variables) are useful for class-wide state and constants:

### 정적 변수

정적 변수 (클래스 변수)는 클래스 전역 상태와 상수에 유용합니다:

```dart
class Queue {
  static const initialCapacity = 16;
  // ···
}

void main() {
  assert(Queue.initialCapacity == 16);
}
```

Static variables aren't initialized until they're used.

정적 변수는 사용될 때까지 초기화되지 않습니다.

_Note_

This page follows the [style guide recommendation](https://dart.dev/effective-dart/style#identifiers) of preferring `lowerCamelCase` for constant names.

_정보_

이 페이지는 상수 이름에 대해 lowerCamelCase를 권장하는 스타일 가이드를 따릅니다.
### Static methods

Static methods (class methods) don't operate on an instance, and thus don't have access to `this`. They do, however, have access to static variables. As the following example shows, you invoke static methods directly on a class:

### 정적 메서드

정적 메서드 (클래스 메서드)는 인스턴스에서 작동하지 않으며, 따라서 this에 접근할 수 없습니다. 그러나 정적 변수에는 접근할 수 있습니다. 다음 예제에서 보듯이 정적 메서드는 클래스에 직접 호출하여 사용할 수 있습니다:

```dart
import 'dart:math';

class Point {
  double x, y;
  Point(this.x, this.y);

  static double distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
  }
}

void main() {
  var a = Point(2, 2);
  var b = Point(4, 4);
  var distance = Point.distanceBetween(a, b);
  assert(2.8 < distance && distance < 2.9);
  print(distance);
}
```

_Note_

Consider using top-level functions, instead of static methods, for common or widely used utilities and functionality.

일반적이거나 널리 사용되는 유틸리티 및 기능에는 정적 메서드 대신 top-level 함수를 사용하는 것이 좋습니다.

_정보_

You can use static methods as compile-time constants. For example, you can pass a static method as a parameter to a constant constructor.

정적 메서드는 컴파일 타임 상수로 사용할 수 있습니다. 예를 들어, 정적 메서드를 상수 생성자의 매개변수로 전달할 수 있습니다.

# Constructors

Constructors are special functions that create instances of classes.

Dart implements many types of constructors. Except for default constructors, these functions use the same name as their class.

- [Generative constructors](https://dart.dev/language/constructors#generative-constructors): Creates new instances and initializes instance variables.
- [Default constructors](https://dart.dev/language/constructors#default-constructors): Used to create a new instance when a constructor hasn't been specified. It doesn't take arguments and isn't named.
- [Named constructors](https://dart.dev/language/constructors#named-constructors): Clarifies the purpose of a constructor or allows the creation of multiple constructors for the same class.
- [Constant constructors](https://dart.dev/language/constructors#constant-constructors): Creates instances as compile-type constants.
- [Factory constructors](https://dart.dev/language/constructors#factory-constructors): Either creates a new instance of a subtype or returns an existing instance from cache.
- [Redirecting constructor](https://dart.dev/language/constructors#redirecting-constructors): Forwards calls to another constructor in the same class.

생성자는 클래스의 인스턴스를 만드는 특별한 함수입니다.

Dart는 많은 유형의 생성자를 구현합니다. 기본 생성자를 제외한 이러한 함수들은 클래스와 동일한 이름을 사용합니다.

생성자(constructor)의 종류는 다음과 같습니다:

- **일반 생성자(Generative constructors)**: 새로운 인스턴스를 만들고 인스턴스 변수를 초기화합니다.
- **기본 생성자(Default constructors)**: 생성자가 지정되지 않았을 때 새로운 인스턴스를 만드는 데 사용됩니다. 인수를 받지 않으며 이름이 없습니다.
- **명명된 생성자(Named constructors)**: 생성자의 목적을 명확히 하거나 동일한 클래스에 대해 여러 생성자를 만들 수 있게 합니다.
- **상수 생성자(Constant constructors)**: 컴파일 타임 상수로 인스턴스를 생성합니다.
- **팩토리 생성자(Factory constructors)**: 하위 유형의 새 인스턴스를 만들거나 캐시에서 기존 인스턴스를 반환합니다.
- **리다이렉팅 생성자(Redirecting constructor)**: 같은 클래스의 다른 생성자로 호출을 전달합니다.

## Types of constructors

## 생성자의 유형
### Generative constructors

To instantiate a class, use a generative constructor.

### 일반 생성자(Generative constructors):

클래스를 인스턴스화하려면 일반 생성자를 사용하십시오.

```dart
class Point {
  // Initializer list of variables and values
  double x = 2.0;
  double y = 2.0;

  // Generative constructor with initializing formal parameters:
  Point(this.x, this.y);
}
```
### Default constructors

If you don't declare a constructor, Dart uses the default constructor. The default constructor is a generative constructor without arguments or name.

### 기본 생성자(Default constructors):

생성자를 선언하지 않으면 Dart는 기본 생성자를 사용합니다. 기본 생성자는 인수나 이름이 없는 일반 생성자입니다.

### Named constructors

Use a named constructor to implement multiple constructors for a class or to provide extra clarity:

### 명명된 생성자(Named constructors):

클래스에 여러 생성자를 구현하거나 추가적인 명확성을 제공하려면 명명된 생성자를 사용하십시오.

```dart
const double xOrigin = 0;
const double yOrigin = 0;

class Point {
  final double x;
  final double y;

  // Sets the x and y instance variables
  // before the constructor body runs.
  Point(this.x, this.y);

  // Named constructor
  Point.origin()
      : x = xOrigin,
        y = yOrigin;
}
```

A subclass doesn't inherit a superclass's named constructor. To create a subclass with a named constructor defined in the superclass, implement that constructor in the subclass.

정의된 명명된 생성자를 가진 서브클래스를 만들려면, 해당 생성자를 서브클래스에서 구현하십시오.
### Constant constructors

If your class produces unchanging objects, make these objects compile-time constants. To make objects compile-time constants, define a `const` constructor with all instance variables set as `final`.

### 상수 생성자

클래스가 변경되지 않는 객체를 생성하는 경우, 이러한 객체를 컴파일 타임 상수로 만드십시오. 객체를 컴파일 타임 상수로 만들려면 모든 인스턴스 변수를 final로 설정한 const 생성자를 정의하십시오.

```dart
class ImmutablePoint {
  static const ImmutablePoint origin = ImmutablePoint(0, 0);

  final double x, y;

  const ImmutablePoint(this.x, this.y);
}
```

Constant constructors don't always create constants. They might be invoked in a non-`const` context. To learn more, consult the section on [using constructors](https://dart.dev/language/classes#using-constructors).

상수 생성자(Constant constructors)는 항상 상수를 생성하지는 않습니다. 상수 생성자는 비상수 문맥에서 호출될 수 있습니다. 자세한 내용은 생성자 사용 섹션을 참조하십시오.

### Redirecting constructors

A constructor might redirect to another constructor in the same class. A redirecting constructor has an empty body. The constructor uses `this` instead of the class name after a colon (:).

### 리다이렉팅 생성자(Redirecting constructors):

생성자가 같은 클래스 내의 다른 생성자로 리다이렉트될 수 있습니다. 리다이렉팅 생성자는 본문이 비어 있습니다. 생성자는 콜론(:) 뒤에 클래스 이름 대신 this를 사용합니다.

```dart
class Point {
  double x, y;

  // The main constructor for this class.
  Point(this.x, this.y);

  // Delegates to the main constructor.
  Point.alongXAxis(double x) : this(x, 0);
}
```
### Factory constructors

When encountering one of following two cases of implementing a constructor, use the `factory` keyword:

- The constructor doesn't always create a new instance of its class. Although a factory constructor cannot return `null`, it might return:

	- an existing instance from a cache instead of creating a new one
    - a new instance of a subtype
- You need to perform non-trivial work prior to constructing an instance. This could include checking arguments or doing any other processing that cannot be handled in the initializer list.
- 
### 팩토리 생성자

팩토리 생성자(Factory constructors)는 다음 두 경우 중 하나에 해당할 때 factory 키워드를 사용하여 구현합니다:

- 생성자가 항상 클래스의 새 인스턴스를 생성하지 않습니다. 팩토리 생성자는 null을 반환할 수는 없지만, 다음과 같은 값을 반환할 수 있습니다:
    
    - 새 인스턴스를 생성하는 대신 캐시에서 기존 인스턴스를 반환할 수 있음
    - 서브타입의 새 인스턴스를 반환할 수 있음
- 인스턴스 생성 전에 복잡한 작업을 수행해야 할 필요가 있습니다. 이는 인수를 확인하거나 초기화 목록에서 처리할 수 없는 다른 처리를 포함할 수 있습니다.



_Tip_

You can also handle late initialization of a final variable with [`late final`](https://dart.dev/effective-dart/design#avoid-public-late-final-fields-without-initializers) (carefully!).

_팁_

최종 변수의 지연 초기화를 late final을 사용하여 처리할 수도 있습니다. (주의해서 사용하세요!)

The following example includes two factory constructors.

- `Logger` factory constructor returns objects from a cache.
- `Logger.fromJson` factory constructor initializes a final variable from a JSON object.
- 
다음 예제는 두 개의 팩토리 생성자를 포함하고 있습니다:

- Logger 팩토리 생성자는 캐시에서 객체를 반환합니다.
- Logger.fromJson 팩토리 생성자는 JSON 객체에서 최종 변수를 초기화합니다.

```dart
class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to
  // the _ in front of its name.
  static final Map<String, Logger> _cache = <String, Logger>{};

  factory Logger(String name) {
    return _cache.putIfAbsent(name, () => Logger._internal(name));
  }

  factory Logger.fromJson(Map<String, Object> json) {
    return Logger(json['name'].toString());
  }

  Logger._internal(this.name);

  void log(String msg) {
    if (!mute) print(msg);
  }
}
```

_Warning_

Factory constructors can't access `this`.

_경고_

팩토리 생성자는 `this`에 접근할 수 없습니다.

Use a factory constructor as any other constructor:

팩토리 생성자를 다른 생성자와 마찬가지로 사용하세요:

```dart
var logger = Logger('UI');
logger.log('Button clicked');

var logMap = {'name': 'UI'};
var loggerJson = Logger.fromJson(logMap);
```
### Redirecting factory constructors

A redirecting factory constructor specifies a call to a constructor of another class to use whenever someone makes a call to the redirecting constructor.

### 리다이렉팅 팩토리 생성자

리다이렉팅 팩토리 생성자는 다른 클래스의 생성자 호출을 지정하여, 리다이렉팅 생성자를 호출할 때마다 해당 생성자를 사용합니다.

```dart
factory Listenable.merge(List<Listenable> listenables) = _MergingListenable
```

It might appear that ordinary factory constructors could create and return instances of other classes. This would make redirecting factories unnecessary. Redirecting factories have several advantages:

- An abstract class might provide a constant constructor that uses the constant constructor of another class.
- A redirecting factory constructor avoids the need for forwarders to repeat the formal parameters and their default values.
- 
평범한 팩토리 생성자가 다른 클래스의 인스턴스를 생성하고 반환할 수 있다고 생각될 수 있습니다. 이로 인해 리다이렉팅 팩토리가 불필요해질 수 있습니다. 그러나 리다이렉팅 팩토리는 여러 가지 장점이 있습니다:

- 추상 클래스는 다른 클래스의 상수 생성자를 사용하는 상수 생성자를 제공할 수 있습니다.
- 리다이렉팅 팩토리 생성자는 포워더가 형식 매개변수와 그들의 기본값을 반복할 필요가 없도록 합니다.

### Constructor tear-offs

Dart allows you to supply a constructor as a parameter without calling it. Called a _tear-off_ (as you _tear off_ the parentheses) serves as a closure that invokes the constructor with the same parameters.

If the tear-off is a constructor with the same signature and return type as the method accepts, you can use the tear-off as a parameter or variable.

Tear-offs differ from lambdas or anonymous functions. Lambdas serve as a wrapper for the constructor whereas a tear-off is the constructor.

### 생성자 티어-오프 (Constructor Tear-offs)

Dart는 생성자를 호출하지 않고 매개변수로서 제공할 수 있는 기능을 제공합니다. 이를 티어-오프(tear-off)라고 하며, 괄호를 떼어내는 것처럼 사용됩니다. 이는 동일한 매개변수로 생성자를 호출하는 클로저 역할을 합니다.

티어-오프가 메서드가 받는 매개변수와 반환 유형과 동일한 시그니처의 생성자라면 티어-오프를 매개변수나 변수로 사용할 수 있습니다.

티어-오프는 람다 함수나 익명 함수와 다릅니다. 람다 함수는 생성자를 래핑하는 반면, 티어-오프는 생성자 자체입니다.

**Use Tear-Offs**

**티어-오프 사용하기**


```dart
//good
// Use a tear-off for a named constructor: 
var strings = charCodes.map(String.fromCharCode);  

// Use a tear-off for an unnamed constructor: 
var buffers = charCodes.map(StringBuffer.new);
```

**Not Lambdas**

**람다를 쓰지마**

```dart
//bad
// Instead of a lambda for a named constructor:
var strings = charCodes.map((code) => String.fromCharCode(code));

// Instead of a lambda for an unnamed constructor:
var buffers = charCodes.map((code) => StringBuffer(code));
```

## Instance Variable Initialization

Dart can initialize variables in three ways.

## 인스턴스 변수 초기화

Dart에서는 변수를 세 가지 방법으로 초기화할 수 있습니다.
### Initialize instance variables in the declaration

Initialize the instance variables when you declare the variables.

### 변수 선언 시 인스턴스 변수를 초기화하는 방법

변수를 선언할 때 인스턴스 변수를 초기화합니다.

```dart
class PointA {
  double x = 1.0;
  double y = 2.0;

  // The implicit default constructor sets these variables to (1.0,2.0)
  // PointA();

  @override
  String toString() {
    return 'PointA($x,$y)';
  }
}
```
### Use initializing formal parameters

To simplify the common pattern of assigning a constructor argument to an instance variable, Dart has _initializing formal parameters_.

In the constructor declaration, include `this.<propertyName>` and omit the body. The `this` keyword refers to the current instance.

When the name conflict exists, use `this`. Otherwise, Dart style omits the `this`. An exception exists for the generative constructor where you must prefix the initializing formal parameter name with `this`.

As noted earlier in this guide, certain constructors and certain parts of constructors can't access `this`. These include:

- Factory constructors
- The right-hand side of an initializer list
- Arguments to a superclass constructor

Initializing formal parameters also allow you to initialize non-nullable or `final` instance variables. Both of these types of variables require initialization or a default value.

### 초기화 형식 매개변수 사용

Dart에서는 생성자 인수를 인스턴스 변수에 할당하는 일반적인 패턴을 간소화하기 위해 초기화 형식 매개변수를 제공합니다.

생성자 선언에서 this.\<propertyName>을 포함하고 본문을 생략합니다. this 키워드는 현재 인스턴스를 참조합니다.

이름 충돌이 있는 경우 this를 사용하며, 그렇지 않으면 Dart 스타일에서는 this를 생략합니다. 초기화 형식 매개변수 이름은 반드시 this로 접두사를 붙여야 하는 생성자의 경우에 예외가 있습니다.

이 가이드의 앞부분에서 언급한 바와 같이 일부 생성자 및 생성자의 일부 부분에서는 this에 접근할 수 없습니다. 이에는 다음이 포함됩니다:

- 팩토리 생성자
- 초기화자 목록의 우측 항목
- 슈퍼클래스 생성자의 인수

초기화 형식 매개변수를 사용하면 초기화되지 않거나 final 인스턴스 변수를 초기화할 수 있습니다. 이러한 유형의 변수는 초기화나 기본값이 필요합니다.

``` dart 
class PointB {
  final double x;
  final double y;

  // Sets the x and y instance variables
  // before the constructor body runs.
  PointB(this.x, this.y);

  // Initializing formal parameters can also be optional.
  PointB.optional([this.x = 0.0, this.y = 0.0]);
}
```


Private fields can't be used as named initializing formals.

비공개 필드는 초기화 형식 매개변수로 사용할 수 없습니다.

```dart
class PointB {
// ...

  PointB.namedPrivate({required double x, required double y})
      : _x = x,
        _y = y;

// ...
}
```

This also works with named variables.

이것은 명명된 변수와도 작동합니다.

```dart
class PointC {
  double x; // must be set in constructor
  double y; // must be set in constructor

  // Generative constructor with initializing formal parameters
  // with default values
  PointC.named({this.x = 1.0, this.y = 1.0});

  @override
  String toString() {
    return 'PointC.named($x,$y)';
  }
}

// Constructor using named variables.
final pointC = PointC.named(x: 2.0, y: 2.0);
```

All variables introduced from initializing formal parameters are both final and only in scope of the initialized variables.

To perform logic that you can't express in the initializer list, create a [factory constructor](https://dart.dev/language/constructors#factory-constructors) or [static method](https://dart.dev/language/classes#static-methods) with that logic. You can then pass the computed values to a normal constructor.

The constructor parameters could be set as nullable and not be initialized.

모든 초기화 형식 매개변수에서 도입된 변수는 final이며, 초기화된 변수의 범위 내에서만 사용할 수 있습니다.

초기화 리스트에서 표현할 수 없는 로직을 수행하려면 해당 로직을 포함한 팩토리 생성자나 정적 메서드를 만들 수 있습니다. 그런 다음 계산된 값을 일반 생성자에 전달할 수 있습니다.

생성자 매개변수는 nullable로 설정될 수 있고 초기화되지 않을 수도 있습니다.

```dart
class PointD {
  double? x; // null if not set in constructor
  double? y; // null if not set in constructor

  // Generative constructor with initializing formal parameters
  PointD(this.x, this.y);

  @override
  String toString() {
    return 'PointD($x,$y)';
  }
}
```
### Use an initializer list

Before the constructor body runs, you can initialize instance variables. Separate initializers with commas.

### 초기화 리스트 사용하기

생성자 본문이 실행되기 전에 인스턴스 변수를 초기화할 수 있습니다. 초기화는 쉼표로 구분하여 설정합니다.

```dart
// Initializer list sets instance variables before
// the constructor body runs.
Point.fromJson(Map<String, double> json)
    : x = json['x']!,
      y = json['y']! {
  print('In Point.fromJson(): ($x, $y)');
}
```


_Warning_

The right-hand side of an initializer list can't access `this`.

_경고_

초기화 리스트의 우측 항목은 this를 사용할 수 없습니다.

To validate inputs during development, use `assert` in the initializer list.

개발 중에 입력값을 유효성 검사하려면 초기화 리스트에서 assert를 사용하세요.

```dart
Point.withAssert(this.x, this.y) : assert(x >= 0) {
  print('In Point.withAssert(): ($x, $y)');
}
```

Initializer lists help set up `final` fields.

The following example initializes three `final` fields in an initializer list.

Initializer 리스트는 final 필드를 설정하는 데 도움이 됩니다.

다음 예제에서는 초기화 리스트를 사용하여 세 개의 final 필드를 초기화합니다.

## Constructor inheritance

_Subclasses_, or child classes, don't inherit _constructors_ from their _superclass_, or immediate parent class. If a class doesn't declare a constructor, it can only use the [default constructor](https://dart.dev/language/constructors#default-constructors).

A class can inherit the _parameters_ of a superclass. These are called [super parameters](https://dart.dev/language/constructors#super-parameters)

Constructors work in a somewhat similar way to how you call a chain of static methods. Each subclass can call its superclass's constructor to initialize an instance, like a subclass can call a superclass's static method. This process doesn't "inherit" constructor bodies or signatures.

## 생성자 상속

서브클래스 또는 자식 클래스는 슈퍼클래스 또는 즉시 상위 클래스로부터 생성자를 상속받지 않습니다. 만약 클래스가 생성자를 선언하지 않으면 기본 생성자만 사용할 수 있습니다.

클래스는 슈퍼클래스의 매개변수를 상속받을 수 있습니다. 이러한 매개변수들을 슈퍼 파라미터라고 합니다.

생성자는 정적 메서드 체인 호출 방식과 비슷한 방식으로 작동합니다. 각 서브클래스는 인스턴스를 초기화하기 위해 자신의 슈퍼클래스의 생성자를 호출할 수 있습니다. 이 과정에서는 생성자 본문이나 시그니처는 상속되지 않습니다.
### Non-default superclass constructors

Dart executes constructors in the following order:

1. [initializer list](https://dart.dev/language/constructors#use-an-initializer-list)
2. superclass's unnamed, no-arg constructor
3. main class's no-arg constructor

If the superclass lacks an unnamed, no-argument constructor, call one of the constructors in the superclass. Before the constructor body (if any), specify the superclass constructor after a colon (`:`).

In the following example, the `Employee` class constructor calls the named constructor for its superclass, `Person`. To execute the following code, click **Run**.



### 기본 생성자가 아닌 슈퍼클래스의 생성자

Dart에서 생성자는 다음 순서대로 실행됩니다:

1. 초기화 리스트(initializer list)
2. 슈퍼클래스의 명명되지 않은 매개변수 없는 생성자(no-arg constructor)
3. 주 클래스의 매개변수 없는 생성자(no-arg constructor)

만약 슈퍼클래스에 명명되지 않은 매개변수 없는 생성자가 없다면, 슈퍼클래스의 다른 생성자 중 하나를 호출합니다. 생성자 본문 앞(있는 경우)에 콜론(:)으로 슈퍼클래스의 생성자를 명시합니다.

다음 예제에서 Employee 클래스 생성자는 슈퍼클래스인 Person의 명명된 생성자를 호출합니다. 이 코드를 실행하려면 아래의 예제를 참고하세요.

As Dart evaluates the arguments to the superclass constructor _before_ invoking the constructor, an argument can be an expression like a function call.

다트에서는 슈퍼클래스의 생성자에 전달되는 인수를 생성자를 호출하기 전에 평가합니다. 이는 함수 호출과 같은 표현식을 인수로 사용할 수 있음을 의미합니다.

```dart
class Employee extends Person {
  Employee() : super.fromJson(fetchDefaultData());
  // ···
}
```

_Warning_

Arguments to the superclass constructor can't access `this`. For example, arguments can call _static_ methods but not _instance_ methods.

_경고_

슈퍼클래스 생성자에 전달되는 인수는 `this`를 사용할 수 없습니다. 예를 들어, 인수는 정적 메서드를 호출할 수 있지만 인스턴스 메서드를 호출할 수는 없습니다.
### Super parameters

To avoid passing each parameter into the super invocation of a constructor, use super-initializer parameters to forward parameters to the specified or default superclass constructor. You can't use this feature with [redirecting constructors](https://dart.dev/language/constructors#redirecting-constructors). Super-initializer parameters have syntax and semantics like [initializing formal parameters](https://dart.dev/language/constructors#use-initializing-formal-parameters).

### 슈퍼 파라미터

슈퍼-이니셜라이저 파라미터는 지정된 또는 기본 슈퍼클래스 생성자로 파라미터를 전달하는 것을 피하기 위해 사용됩니다. 이 기능은 리다이렉팅 생성자와 함께 사용할 수 없습니다. 슈퍼-이니셜라이저 파라미터는 초기화 폼 파라미터와 동일한 구문과 의미를 가집니다.


_Version note_

Using super-initializer parameters requires a [language version](https://dart.dev/guides/language/evolution#language-versioning) of at least 2.17. If you're using an earlier language version, you must manually pass in all super constructor parameters.

_버전 노트_

슈퍼-이니셜라이저 파라미터를 사용하려면 최소 언어 버전이 2.17 이상이어야 합니다. 이전 언어 버전을 사용하는 경우 모든 슈퍼 생성자 파라미터를 수동으로 전달해야 합니다.

If the super-constructor invocation includes positional arguments, super-initializer parameters can't be positional.

슈퍼-생성자 호출에 위치 인수가 포함된 경우 슈퍼-이니셜라이저 파라미터는 위치 인수로 사용할 수 없습니다.

```dart
class Vector2d {
  final double x;
  final double y;

  Vector2d(this.x, this.y);
}

class Vector3d extends Vector2d {
  final double z;

  // Forward the x and y parameters to the default super constructor like:
  // Vector3d(final double x, final double y, this.z) : super(x, y);
  Vector3d(super.x, super.y, this.z);
}
```

To further illustrate, consider the following example.

더 명확히 설명하기 위해 다음 예시를 살펴보세요.

```dart
  // If you invoke the super constructor (`super(0)`) with any
  // positional arguments, using a super parameter (`super.x`)
  // results in an error.
  Vector3d.xAxisError(super.x): z = 0, super(0); // BAD
```

This named constructor tries to set the `x` value twice: once in the super constructor and once as a positional super parameter. As both address the `x` positional parameter, this results in an error.

When the super constructor has named arguments, you can split them between named super parameters (`super.y` in the next example) and named arguments to the super constructor invocation (`super.named(x: 0)`).

이 명명된 생성자는 x 값을 두 번 설정하려고 시도합니다: 하나는 슈퍼 생성자에서, 다른 하나는 위치 기반 슈퍼 매개변수로. 두 경우 모두 x 위치 매개변수를 다루기 때문에 이로 인해 오류가 발생합니다.

슈퍼 생성자가 명명된 매개변수를 가지고 있는 경우, 이들을 명명된 슈퍼 매개변수 (예: super.y)와 슈퍼 생성자 호출의 명명된 인수 (예: super.named(x: 0)) 사이에 나눌 수 있습니다.

```dart
class Vector2d {
  // ...
  Vector2d.named({required this.x, required this.y});
}

class Vector3d extends Vector2d {
  final double z;

  // Forward the y parameter to the named super constructor like:
  // Vector3d.yzPlane({required double y, required this.z})
  //       : super.named(x: 0, y: y);
  Vector3d.yzPlane({required super.y, required this.z}) : super.named(x: 0);
}
```

# Methods

Methods are functions that provide behavior for an object.

메서드는 객체의 동작을 제공하는 함수입니다.
## Instance methods

Instance methods on objects can access instance variables and `this`. The `distanceTo()` method in the following sample is an example of an instance method:

## 인스턴스 메서드

객체의 인스턴스 메서드는 인스턴스 변수와 this에 접근할 수 있습니다. 다음 예제의 distanceTo() 메서드는 인스턴스 메서드의 한 예입니다:

```dart
import 'dart:math';

class Point {
  final double x;
  final double y;

  // Sets the x and y instance variables
  // before the constructor body runs.
  Point(this.x, this.y);

  double distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}
```
## Operators

Most operators are instance methods with special names. Dart allows you to define operators with the following names:
## 연산자

대부분의 연산자는 특별한 이름을 가진 인스턴스 메서드입니다. Dart에서는 다음과 같은 이름으로 연산자를 정의할 수 있습니다:

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|`<`|`>`|`<=`|`>=`|`==`|`~`|
|`-`|`+`|`/`|`~/`|`*`|`%`|
|`\|`|`ˆ`|`&`|`<<`|`>>>`|`>>`|
|`[]=`|`[]`|||||

_Note_

You may have noticed that some [operators](https://dart.dev/language/operators), like `!=`, aren't in the list of names. These operators aren't instance methods. Their behavior is built in to Dart.

_참고_

일부 연산자들은 !=와 같이 위의 이름 목록에 없는 것을 주목할 수 있습니다. 이러한 연산자들은 인스턴스 메서드가 아닙니다. 이들의 동작은 Dart에 내장되어 있습니다.

To declare an operator, use the built-in identifier `operator` then the operator you are defining. The following example defines vector addition (`+`), subtraction (`-`), and equality (`==`):

연산자를 선언하려면, 내장된 식별자 `operator` 다음에 정의하려는 연산자를 사용합니다. 다음 예제는 벡터의 덧셈(+), 뺄셈(-) 및 동등성(\==) 연산자를 정의합니다:

```dart
class Vector {
  final int x, y;

  Vector(this.x, this.y);

  Vector operator +(Vector v) => Vector(x + v.x, y + v.y);
  Vector operator -(Vector v) => Vector(x - v.x, y - v.y);

  @override
  bool operator ==(Object other) =>
      other is Vector && x == other.x && y == other.y;

  @override
  int get hashCode => Object.hash(x, y);
}

void main() {
  final v = Vector(2, 3);
  final w = Vector(2, 2);

  assert(v + w == Vector(4, 5));
  assert(v - w == Vector(0, 1));
}
```
## Getters and setters

Getters and setters are special methods that provide read and write access to an object's properties. Recall that each instance variable has an implicit getter, plus a setter if appropriate. You can create additional properties by implementing getters and setters, using the `get` and `set` keywords:

## 게터와 세터

게터(Getters)와 세터(Setters)는 객체의 속성에 대한 읽기 및 쓰기 접근을 제공하는 특수한 메서드입니다. 각 인스턴스 변수는 필요에 따라 암시적인 게터와 세터를 가지고 있습니다. get 및 set 키워드를 사용하여 추가적인 속성을 구현하여 사용할 수 있습니다:

```dart
class Rectangle {
  double left, top, width, height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Define two calculated properties: right and bottom.
  double get right => left + width;
  set right(double value) => left = value - width;
  double get bottom => top + height;
  set bottom(double value) => top = value - height;
}

void main() {
  var rect = Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}
```

With getters and setters, you can start with instance variables, later wrapping them with methods, all without changing client code.

게터와 세터를 사용하면 인스턴스 변수로 시작하여 나중에 메서드로 래핑할 수 있습니다. 이 과정에서 클라이언트 코드를 변경하지 않고도 가능합니다.

_Note_

Operators such as increment (++) work in the expected way, whether or not a getter is explicitly defined. To avoid any unexpected side effects, the operator calls the getter exactly once, saving its value in a temporary variable.

_참고_

증가 연산자(++)와 같은 연산자는 명시적으로 게터가 정의되었든 안 되었든 예상대로 작동합니다. 예기치 않은 부작용을 피하기 위해 연산자는 게터를 정확히 한 번 호출하여 그 값을 임시 변수에 저장합니다.
## Abstract methods

Instance, getter, and setter methods can be abstract, defining an interface but leaving its implementation up to other classes. Abstract methods can only exist in [abstract classes](https://dart.dev/language/class-modifiers#abstract) or [mixins](https://dart.dev/language/mixins).

To make a method abstract, use a semicolon (`;`) instead of a method body:

## 추상 메서드

인스턴스 메서드, 게터 및 세터 메서드는 추상일 수 있으며, 인터페이스를 정의하지만 구현은 다른 클래스에 맡깁니다. 추상 메서드는 추상 클래스나 믹스인에서만 존재할 수 있습니다.

메서드를 추상화하려면 메서드 몸체 대신 세미콜론 (;)을 사용하세요:

```dart
abstract class Doer {
  // Define instance variables and methods...

  void doSomething(); // Define an abstract method.
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // Provide an implementation, so the method is not abstract here...
  }
}
```

# Extend a class

Use `extends` to create a subclass, and `super` to refer to the superclass:

클래스를 상속받기 위해 `extends`를 사용하고, 슈퍼 클래스를 참조하기 위해 `super`를 사용합니다:

```dart
class Television {
  void turnOn() {
    _illuminateDisplay();
    _activateIrSensor();
  }
  // ···
}

class SmartTelevision extends Television {
  void turnOn() {
    super.turnOn();
    _bootNetworkInterface();
    _initializeMemory();
    _upgradeApps();
  }
  // ···
}
```

For another usage of `extends`, see the discussion of [parameterized types](https://dart.dev/language/generics#restricting-the-parameterized-type) on the Generics page.

extends의 또 다른 사용 방법은 제네릭 페이지에서 매개변수화된 타입에 대한 논의를 참조하십시오.
## Overriding members

Subclasses can override instance methods (including [operators](https://dart.dev/language/methods#operators)), getters, and setters. You can use the `@override` annotation to indicate that you are intentionally overriding a member:

## 멤버 오버라이딩

서브클래스는 인스턴스 메서드(연산자 포함), 게터, 세터를 오버라이드할 수 있습니다. @override 주석을 사용하여 의도적으로 멤버를 오버라이드하고 있다는 것을 나타낼 수 있습니다.

```dart
class Television {
  // ···
  set contrast(int value) {...}
}

class SmartTelevision extends Television {
  @override
  set contrast(num value) {...}
  // ···
}
```

An overriding method declaration must match the method (or methods) that it overrides in several ways:

- The return type must be the same type as (or a subtype of) the overridden method's return type.
- Parameter types must be the same type as (or a supertype of) the overridden method's parameter types. In the preceding example, the `contrast` setter of `SmartTelevision` changes the parameter type from `int` to a supertype, `num`.
- If the overridden method accepts _n_ positional parameters, then the overriding method must also accept _n_ positional parameters.
- A [generic method](https://dart.dev/language/generics#using-generic-methods) can't override a non-generic one, and a non-generic method can't override a generic one.

Sometimes you might want to narrow the type of a method parameter or an instance variable. This violates the normal rules, and it's similar to a downcast in that it can cause a type error at runtime. Still, narrowing the type is possible if the code can guarantee that a type error won't occur. In this case, you can use the [`covariant` keyword](https://dart.dev/guides/language/sound-problems#the-covariant-keyword) in a parameter declaration. For details, see the [Dart language specification](https://dart.dev/guides/language/spec).

오버라이딩된 메서드 선언은 여러 가지 방법으로 오버라이드되는 메서드의 규칙과 일치해야 합니다:

- 반환 타입은 오버라이드된 메서드의 반환 타입과 동일하거나 해당 타입의 서브타입이어야 합니다.
- 매개변수 타입은 오버라이드된 메서드의 매개변수 타입과 동일하거나 해당 타입의 슈퍼타입이어야 합니다. 예를 들어, SmartTelevision의 contrast 세터는 매개변수 타입을 int에서 num의 슈퍼타입으로 변경합니다.
- 만약 오버라이드된 메서드가 n개의 위치 매개변수를 받는다면, 오버라이딩 메서드도 n개의 위치 매개변수를 받아야 합니다.
- 제네릭 메서드는 비-제네릭 메서드를 오버라이드할 수 없으며, 비-제네릭 메서드는 제네릭 메서드를 오버라이드할 수 없습니다.

때로는 메서드 매개변수나 인스턴스 변수의 타입을 좁히고 싶을 수 있습니다. 이는 일반적인 규칙을 위반하며, 런타임에서 타입 오류를 일으킬 수 있는 다운캐스트와 유사합니다. 그럼에도 불구하고 코드가 타입 오류가 발생하지 않음을 보장할 수 있다면, 매개변수 선언에서 covariant 키워드를 사용하여 타입을 좁힐 수 있습니다. 자세한 내용은 Dart 언어 사양을 참조하십시오.

_Warning_

If you override `==`, you should also override Object's `hashCode` getter. For an example of overriding `==` and `hashCode`, check out [Implementing map keys](https://dart.dev/libraries/dart-core#implementing-map-keys).

_경고_ 
만약 \==를 오버라이드한다면, Object의 hashCode 게터도 오버라이드해야 합니다. \==와 hashCode를 오버라이드하는 예제는 Map 키 구현을 확인해보세요.

## noSuchMethod()

To detect or react whenever code attempts to use a non-existent method or instance variable, you can override `noSuchMethod()`:

## noSuchMethod()

존재하지 않는 메서드나 인스턴스 변수를 사용하려고 할 때 감지하거나 반응하기 위해 noSuchMethod()을 오버라이드할 수 있습니다.

```dart
class A {
  // Unless you override noSuchMethod, using a
  // non-existent member results in a NoSuchMethodError.
  @override
  void noSuchMethod(Invocation invocation) {
    print('You tried to use a non-existent member: '
        '${invocation.memberName}');
  }
}
```

You **can't invoke** an unimplemented method unless **one** of the following is true:

- The receiver has the static type `dynamic`.
    
- The receiver has a static type that defines the unimplemented method (abstract is OK), and the dynamic type of the receiver has an implementation of `noSuchMethod()` that's different from the one in class `Object`.
    

For more information, see the informal [noSuchMethod forwarding specification.](https://github.com/dart-lang/language/blob/main/archive/feature-specifications/nosuchmethod-forwarding.md)

구현되지 않은 메서드를 호출할 수 없는 경우는 다음과 같습니다:

- 수신자(receiver)의 정적 타입(static type)이 dynamic인 경우.
- 수신자의 정적 타입이 구현되지 않은 메서드를 정의하는 경우(추상 메서드는 허용됨), 그리고 수신자의 동적 타입(dynamic type)이 Object 클래스의 noSuchMethod()과 다른 구현을 가지고 있는 경우.

더 많은 정보는 비공식 noSuchMethod forwarding specification을 참조하세요.
