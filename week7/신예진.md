# **Concurrency in Dart**

모든 다트 코드는 Isolate에서 실행되며, 기본 메인 Isolate에서 시작하여 명시적으로 생성하는 추가 격리로 확장됩니다. 새로운 Isolate를 생성하면 해당 Isolate는 자체 메모리와 이벤트 루프를 갖습니다. 이벤트 루프는 다트에서 비동기 및 동시성 프로그래밍을 가능하게 합니다.

### 이벤트 루프

**이벤트 루프란?**

- 다트의 런타임 모델은 이벤트 루프를 기반으로 합니다.
- 이벤트 루프는 **프로그램 코드 실행, 이벤트 수집 및 처리** 등을 담당합니다.
- 애플리케이션이 실행되면서 모든 이벤트는 이벤트 큐라는 큐에 추가됩니다. **이벤트는 UI 재페인트 요청, 사용자 탭 및 키 입력, 디스크 I/O 등** 다양한 형태일 수 있습니다.
- 이벤트 루프는 큐에 추가된 순서대로 이벤트를 하나씩 처리합니다.

**일반적인 이벤트 루프**

![Untitled](https://github.com/user-attachments/assets/8a97e2f0-f70b-4f07-a6e5-502b02d81533)

```dart
while (eventQueue.waitForEvent()) {
  eventQueue.processNextEvent();
}
```

이 예제 이벤트 루프는 동기적이며 단일 스레드에서 실행됩니다. 그러나 대부분의 다트 애플리케이션은 한 번에 여러 작업을 수행해야 합니다. 예를 들어, 클라이언트 애플리케이션은 HTTP 요청을 실행하면서도 사용자 버튼 탭을 듣고 있어야 할 수 있습니다.

**비동기를 처리할 때의 이벤트 루프**

이를 처리하기 위해 다트는 Future, Stream, async-await 같은 많은 비동기 API를 제공합니다.

```dart
http.get('https://example.com').then((response) {
  if (response.statusCode == 200) {
    print('Success!');
  }
});
```
![Untitled (1)](https://github.com/user-attachments/assets/c6da2a44-2b4f-4e4e-800e-36f051be5194)


HTTP request를 이벤트 큐에 등록 → Future를 반환 → 이후의 작업은 Flutter 프레임 워크가 처리 → HTTP response를 이벤트 큐에 등록 → 콜백 실행

### 비동기 언어 기능

### Stream

 **await-for and yield**

wait-for는 스트림에서 새로운 값이 제공될 때마다 각 반복을 실행하는 for 루프의 일종입니다.스트림 값을 반환하는 함수에서는 return 대신 yield 키워드를 사용합니다.

```dart
Stream<int> sumStream(Stream<int> stream) async* {
  var sum = 0;
  await for (final value in stream) {
    yield sum += value;
  }
}

```

### Isolate

Dart는 비동기 API뿐만 아니라 아이솔레이트를 통해서도 동시성을 지원합니다. 

⇒ 동시성이란? 병렬성이란?

대부분의 현대 장치는 다중 코어 CPU를 가지고 있습니다. 다중 코어를 활용하기 위해 개발자는 때때로 공유 메모리 스레드를 동시에 실행합니다.

- 왜 갑자기 CPU 얘기를? 스레드란?
    
    멀티코어란?
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a40c3c7-b29b-40d8-91be-8d52b2907519/13399e63-035e-49c8-b526-c218ae54e99d/Untitled.png)
    
    - 하나의 CPU/프로세서 내부에 2개 이상의 코어가 존재 하는 것(각 코어는 여러개의 스레드를 가지고 있지만 실행은 하나의 스레드를 실행)
    - 병렬 실행
    
    스레드란?
    
    - 프로세스의 하위 집합으로 코드,데이터,힙을 스레드끼리 서로 공유한다.(스택빼고 공유)
    - 프로세스의 메모리를 공유하기 때문에 동시성 문제 발생 가능

그러나 공유 상태 동시성은 오류가 발생하기 쉽고 복잡한 코드를 유발할 수 있습니다.

- 동시성 문제란?
    - 동시성 문제란 다수의 스레드나 프로세스가 동시에 자원에 접근할 때 발생할 수 있는 문제를 말한다.
    - 경쟁 상태 (Race Conditions),데드락 (Deadlock),기아 (Starvation)와 같은 문제들이 발생하수 있고 해결하기 위한 두가지 접근방식이 있다.비관적 락&낙관적 락.

스레드 대신, 모든 Dart 코드는 아이솔레이트 내에서 실행됩니다. 아이솔레이트를 사용하면 Dart 코드는 여러 독립적인 작업을 동시에 수행할 수 있습니다.

⇒ 어떻게? 아이솔레이트는 스레드나 프로세스와 비슷하지만, 각 아이솔레이트는 고유한 메모리와 단일 스레드 이벤트 루프를 가집니다.

각 아이솔레이트는 고유한 전역 필드를 가지며, 아이솔레이트 내 상태는 다른 아이솔레이트에서 접근할 수 없습니다. 아이솔레이트는 메시지 전달을 통해서만 서로 통신할 수 있습니다. 

⇒ 자원공유 x 동시성문제 방지

- 아이솔레이트 메세지 전달 찍먹
    
    ```dart
    import 'dart:isolate';
    
    // 아이솔레이트에게 작업을 지시하고 결과를 받는 함수
    Future<void> main() async {
      // 메인 아이솔레이트가 작업자 아이솔레이트와 통신하기 위한 ReceivePort 생성
      final receivePort = ReceivePort();
    
      // 작업자 아이솔레이트 생성 및 시작
      final isolate = await Isolate.spawn(worker, receivePort.sendPort);
    
      // 작업자 아이솔레이트로부터 메시지를 수신할 스트림
      final stream = receivePort.asBroadcastStream();
    
      // 작업자에게 메시지 보내기
      stream.listen((message) {
        if (message is SendPort) {
          // 작업자 아이솔레이트의 SendPort를 받으면 작업 요청
          message.send('안녕하세요, 작업자 아이솔레이트!');
        } else {
          // 작업자 아이솔레이트로부터 메시지 받기
          print('작업자로부터 메시지: $message');
          // 작업 완료 후 아이솔레이트 종료
          receivePort.close();
          isolate.kill(priority: Isolate.immediate);
        }
      });
    }
    
    // 작업자 아이솔레이트에서 실행될 함수
    void worker(SendPort sendPort) {
      // 메인 아이솔레이트와 통신하기 위한 ReceivePort 생성
      final receivePort = ReceivePort();
    
      // 메인 아이솔레이트에게 작업자 아이솔레이트의 SendPort 전달
      sendPort.send(receivePort.sendPort);
    
      // 메인 아이솔레이트로부터 메시지를 수신하고 처리
      receivePort.listen((message) {
        print('메인으로부터 메시지: $message');
        // 작업 결과를 메인 아이솔레이트에게 전송
        sendPort.send('작업 완료!');
      });
    }
    ```
    

아이솔레이트 간에 공유 상태가 없기 때문에, 뮤텍스나 락, 데이터 레이스와 같은 동시성 복잡성이 Dart에서는 발생하지 않습니다. 그렇다고 해서 아이솔레이트가 경쟁 상태를 완전히 방지하는 것은 아닙니다. 이 동시성 모델에 대한 자세한 내용은 액터 모델에 대해 읽어보세요.

- 왜 경쟁상태를 완전히 방지하는 것이 아닐까?
    1. **메시지 순서 보장 부족**:
    아이솔레이트 간의 통신은 메시지 전달을 통해 이루어지며, 특정 메시지의 순서가 항상 보장되지는 않습니다. 여러 아이솔레이트가 동시에 동일한 아이솔레이트에 메시지를 보낼 때, 메시지의 도착 순서가 예측되지 않을 수 있습니다. 이것은 논리적 오류와 경쟁 상태를 초래할 수 있습니다.
    2. **이벤트 처리 시간**:
    한 아이솔레이트 내에서 이벤트 루프가 작업을 처리하는 데 걸리는 시간이 다를 수 있습니다. 예를 들어, 특정 이벤트가 예상보다 오래 걸리면, 다른 이벤트가 지연될 수 있으며, 이는 타이밍 관련 문제를 발생시킬 수 있습니다. 특히, 사용자 인터페이스와 같은 실시간 시스템에서 이러한 타이밍 문제는 경쟁 상태로 이어질 수 있습니다.
    3. **메시지 전달 지연**:
    메시지가 한 아이솔레이트에서 다른 아이솔레이트로 전달되는 데 걸리는 시간은 일정하지 않을 수 있습니다. 네트워크 지연이나 시스템의 부하로 인해 메시지가 지연될 수 있으며, 이로 인해 예상하지 못한 상태 변화가 발생할 수 있습니다.
    4. **논리적 경쟁 상태**:
    비록 물리적 메모리를 공유하지 않더라도, 두 아이솔레이트가 동일한 자원에 대한 접근을 논리적으로 경쟁할 수 있습니다. 예를 들어, 두 아이솔레이트가 동일한 파일에 접근하려고 할 때, 파일 잠금 메커니즘이 없다면 데이터 손상이 발생할 수 있습니다.
    
    아이솔레이트 모델은 대부분의 전통적인 동시성 문제를 해결하지만, 완벽하지는 않습니다. 개발자는 여전히 아이솔레이트 간의 통신을 설계할 때 주의해야 하며, 논리적 경쟁 상태를 방지하기 위한 추가적인 조치를 취해야 할 수 있습니다.
    
- 액터 모델의 주요 개념
    - **독립적인 단위(Actor)**: 각각의 액터는 독립적으로 상태를 가지고 있고, 다른 액터와 상태를 공유하지 않습니다.
    - **메시지 기반 통신**: 액터는 서로 메시지를 보내며 통신합니다. 메시지는 비동기적으로 전달되며, 수신한 메시지를 처리하여 자신의 상태를 변경하거나 다른 액터에게 메시지를 보냅니다.
    - **상태 비공유**: 각 액터는 자신의 상태를 가지고 있으며, 다른 액터와 상태를 직접 공유하지 않습니다. 이를 통해 데이터 레이스와 같은 동시성 문제를 방지합니다.

아이솔레이트를 사용하면 Dart 코드는 여러 독립적인 작업을 동시에 수행할 수 있으며, 사용 가능한 경우 추가 프로세서 코어를 활용할 수 있습니다. 

⇒ 아이솔레이트를 추가로 만들 수 있다는 말.

아이솔레이트는 스레드나 프로세스와 비슷하지만, 각 아이솔레이트는 고유한 메모리와 단일 스레드 이벤트 루프를 가집니다.

⇒ 스레드는 자원을 공유해서 동시성 문제가 생기지만, 아이솔레이트 싱글 스레드로 동시성 문제가 생기지않는다. 다만, 이벤트루프를 사용하여 동시성처럼 보일 뿐이다.

**주 아이솔레이트 (The main isolate)**

대부분의 경우, 아이솔레이트에 대해 깊이 생각할 필요는 없습니다. Dart 프로그램은 기본적으로 주 아이솔레이트에서 실행됩니다. 주 아이솔레이트는 프로그램이 실행되기 시작하는 스레드입니다.

단일 아이솔레이트 프로그램도 원활하게 실행될 수 있습니다. 이러한 앱은 다음 코드 줄로 넘어가기 전에 비동기 작업이 완료될 때까지 `async-await`를 사용하여 대기합니다. 잘 설계된 앱은 가능한 빨리 시작되어 이벤트 루프에 도달합니다. 그런 다음, 앱은 필요한 비동기 작업을 사용하여 대기열에 있는 각 이벤트에 신속하게 응답합니다.

- **Isolate.run()**: 별도의 아이솔레이트에서 단일 연산을 실행하고 결과를 반환합니다.
- **Isolate.spawn()**: 여러 메시지를 처리할 수 있는 새로운 아이솔레이트를 생성합니다.
- **Isolate.spawnUri()**: 지정된 URI의 코드로부터 새로운 아이솔레이트를 생성하며, 속도가 느리고 같은 아이솔레이트 그룹에 포함되지 않습니다.
- **Isolate.exit()**: 현재 아이솔레이트를 종료하며, 선택적으로 마지막 메시지를 보냅니다.

동시성 vs 병렬성
동기 vs 비동기
블로킹 vs 논블로킹

Future.microtask 왜쓰는지 다른 방법은 없는지 어떻게 작동되는지를
