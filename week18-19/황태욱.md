## What is DevTools?

DevTools is a suite of performance and debugging tools for Dart and Flutter. _Flutter DevTools_ and _Dart DevTools_ refer to the same set of tools.

DevTools는 Dart와 Flutter를 위한 성능 및 디버깅 도구 모음입니다. Flutter DevTools와 Dart DevTools는 동일한 도구 세트를 가리킵니다.

![Dart DevTools Screens](https://docs.flutter.dev/assets/images/docs/tools/devtools/dart-devtools.gif)

For a video introduction to DevTools, check out the following deep dive and use-case walkthrough:

DevTools에 대한 비디오 소개를 보려면 다음의 심층 탐구 및 사용 사례 walkthrough를 확인하세요:

[Dive in to Flutter and Dart DevTools](https://www.youtube.com/watch/_EYk-E29edo "Open 'Dive in to Flutter and Dart DevTools' video in new tab")

## What can I do with DevTools?

Here are some of the things you can do with DevTools:

- Inspect the UI layout and state of a Flutter app.
- Diagnose UI jank performance issues in a Flutter app.
- CPU profiling for a Flutter or Dart app.
- Network profiling for a Flutter app.
- Source-level debugging of a Flutter or Dart app.
- Debug memory issues in a Flutter or Dart command-line app.
- View general log and diagnostics information about a running Flutter or Dart command-line app.
- Analyze code and app size.
- Validate deep links in your Android app.

- Flutter 앱의 UI 레이아웃 및 상태 검사
- Flutter 앱에서 UI 지연 성능 문제 진단
- Flutter 또는 Dart 앱에 대한 CPU 프로파일링
- Flutter 앱에 대한 네트워크 프로파일링
- Flutter 또는 Dart 앱의 소스 수준 디버깅
- Flutter 또는 Dart 명령줄 앱에서 메모리 문제 디버깅
- 실행 중인 Flutter 또는 Dart 명령줄 앱에 대한 일반 로그 및 진단 정보 보기
- 코드 및 앱 크기 분석
- Android 앱에서 딥 링크 유효성 검사

We expect you to use DevTools in conjunction with your existing IDE or command-line based development workflow.

우리는 여러분이 기존 IDE나 명령줄 기반 개발 워크플로와 함께 DevTools를 사용할 것으로 기대합니다.

## How to launch DevTools

See the [VS Code](https://docs.flutter.dev/tools/devtools/vscode), [Android Studio/IntelliJ](https://docs.flutter.dev/tools/devtools/android-studio), or [command line](https://docs.flutter.dev/tools/devtools/cli) pages for instructions on how to launch DevTools.

DevTools를 실행하는 방법에 대한 지침은 다음의 페이지를 참조하세요: VS Code, Android Studio/IntelliJ 또는 명령줄.

## Troubleshooting some standard issues


**Question**: My app looks janky or stutters. How do I fix it?

**Answer**: Performance issues can cause [UI frames](https://docs.flutter.dev/perf/ui-performance) to be janky and/or slow down some operations.

1. To detect which code impacts concrete late frames, start at [Performance > Timeline](https://docs.flutter.dev/tools/devtools/performance#timeline-events-tab).
2. To learn which code takes the most CPU time in the background, use the [CPU profiler](https://docs.flutter.dev/tools/devtools/cpu-profiler).

For more information, check out the [Performance](https://docs.flutter.dev/perf) page.

**질문: 내 앱이 지연되거나 끊기는 것처럼 보입니다. 어떻게 해결하나요?**

**답변:** 성능 문제로 인해 UI 프레임이 지연되거나 일부 작업이 느려질 수 있습니다.

1. 어떤 코드가 구체적인 지연 프레임에 영향을 미치는지 감지하려면 **Performance > Timeline**에서 시작하세요. 
2. 백그라운드에서 가장 많은 CPU 시간을 소모하는 코드를 알아보려면 CPU 프로파일러를 사용하세요. 

더 많은 정보는 **Performance** 페이지를 확인하세요.

**Question**: I see a lot of garbage collection (GC) events occurring. Is this a problem?

**Answer**: Frequent GC events might display on the DevTools > Memory > Memory chart. In most cases, it's not a problem.

If your app has frequent background activity with some idle time, Flutter might use that opportunity to collect the created objects without performance impact.

**질문: 많은 가비지 컬렉션(GC) 이벤트가 발생하는데, 이게 문제인가요?**

**답변:** 잦은 GC 이벤트는 DevTools > Memory > Memory 차트에서 표시될 수 있습니다. 대부분의 경우, 이는 문제되지 않습니다.

앱에 자주 백그라운드 활동이 있고 약간의 유휴 시간이 있을 경우, Flutter는 성능에 영향을 주지 않고 생성된 객체를 수집할 수 있는 기회를 활용할 수 있습니다.
## Providing feedback

Please give DevTools a try, provide feedback, and file issues in the [DevTools issue tracker](https://github.com/flutter/devtools/issues). Thanks!

DevTools를 사용해 보시고, 피드백을 제공하며, 문제를 DevTools 이슈 트래커에 신고해 주세요. 감사합니다!
## Other resources

For more information on debugging and profiling Flutter apps, see the [Debugging](https://docs.flutter.dev/testing/debugging) page and, in particular, its list of [other resources](https://docs.flutter.dev/testing/debugging#other-resources).

For more information on using DevTools with Dart command-line apps, see the [DevTools documentation on dart.dev](https://dart.dev/tools/dart-devtools).

Flutter 앱의 디버깅 및 프로파일링에 대한 자세한 정보는 디버깅 페이지와 특히 그 안의 다른 리소스 목록을 참조하세요.

Dart 명령줄 앱과 함께 DevTools를 사용하는 방법에 대한 자세한 정보는 dart.dev의 DevTools 문서를 참조하세요.
## What is it?

The Flutter widget inspector is a powerful tool for visualizing and exploring Flutter widget trees. The Flutter framework uses widgets as the core building block for anything from controls (such as text, buttons, and toggles), to layout (such as centering, padding, rows, and columns). The inspector helps you visualize and explore Flutter widget trees, and can be used for the following:

- understanding existing layouts
- diagnosing layout issues

Flutter 위젯 인스펙터는 Flutter 위젯 트리를 시각화하고 탐색하는 강력한 도구입니다. Flutter 프레임워크는 위젯을 텍스트, 버튼, 토글과 같은 컨트롤에서부터 중앙 정렬, 패딩, 행, 열과 같은 레이아웃에 이르기까지 모든 것의 기본 빌딩 블록으로 사용합니다. 인스펙터는 Flutter 위젯 트리를 시각화하고 탐색하는 데 도움을 주며, 다음과 같은 용도로 사용할 수 있습니다:

- 기존 레이아웃 이해하기
- 레이아웃 문제 진단하기

![Screenshot of the Flutter inspector window](https://docs.flutter.dev/assets/images/docs/tools/devtools/inspector_screenshot.png)

## Get started

To debug a layout issue, run the app in [debug mode](https://docs.flutter.dev/testing/build-modes#debug) and open the inspector by clicking the **Flutter Inspector** tab on the DevTools toolbar.

_Note_
You can still access the Flutter inspector directly from Android Studio/IntelliJ, but you might prefer the more spacious view when running it from DevTools in a browser.

레이아웃 문제를 디버깅하려면 앱을 디버그 모드로 실행하고 DevTools 도구 모음에서 Flutter Inspector 탭을 클릭하여 인스펙터를 엽니다.

_참고_ 
Android Studio/IntelliJ에서 Flutter 인스펙터에 직접 접근할 수 있지만, 브라우저에서 DevTools로 실행할 때 더 넓은 화면을 선호할 수도 있습니다.

### Debugging layout issues visually

The following is a guide to the features available in the inspector's toolbar. When space is limited, the icon is used as the visual version of the label.

다음은 인스펙터 도구 모음에서 사용할 수 있는 기능에 대한 가이드입니다. 공간이 제한된 경우 아이콘이 레이블의 시각적 버전으로 사용됩니다.

![Select widget mode icon](https://docs.flutter.dev/assets/images/docs/tools/devtools/select-widget-mode-icon.png) **Select widget mode**

Enable this button in order to select a widget on the device to inspect it. To learn more, check out [Inspecting a widget](https://docs.flutter.dev/tools/devtools/inspector#inspecting-a-widget).

**위젯 선택 모드 아이콘**: 위젯 선택 모드 활성화  
이 버튼을 활성화하여 디바이스에서 위젯을 선택하고 검사할 수 있습니다. 자세한 내용은 "위젯 검사"를 참조하세요.

![Refresh tree icon](https://docs.flutter.dev/assets/images/docs/tools/devtools/refresh-tree-icon.png) **Refresh tree**

Reload the current widget info.

**트리 새로 고침 아이콘**: 현재 위젯 정보를 새로 고침  
현재 위젯 정보를 다시 로드합니다.

![Slow animations icon](https://docs.flutter.dev/assets/images/docs/tools/devtools/slow-animations-icon.png) **[Slow animations](https://docs.flutter.dev/tools/devtools/inspector#slow-animations)**

Run animations 5 times slower to help fine-tune them.

**느린 애니메이션 아이콘**: 애니메이션을 느리게 실행  
애니메이션을 5배 느리게 실행하여 세밀하게 조정하는 데 도움을 줍니다.

![Show guidelines mode icon](https://docs.flutter.dev/assets/images/docs/tools/devtools/debug-paint-mode-icon.png) **[Show guidelines](https://docs.flutter.dev/tools/devtools/inspector#show-guidelines)**

Overlay guidelines to assist with fixing layout issues.

**가이드라인 표시 모드 아이콘**: 가이드라인 표시  
레이아웃 문제를 해결하는 데 도움이 되는 가이드라인을 오버레이합니다.

![Show baselines icon](https://docs.flutter.dev/assets/images/docs/tools/devtools/paint-baselines-icon.png) **[Show baselines](https://docs.flutter.dev/tools/devtools/inspector#show-baselines)**

Show baselines, which are used for aligning text. Can be useful for checking if text is aligned.

**기준선 표시 아이콘**: 기준선 표시  
텍스트 정렬에 사용되는 기준선을 표시합니다. 텍스트가 정렬되어 있는지 확인하는 데 유용할 수 있습니다.

![Highlight repaints icon](https://docs.flutter.dev/assets/images/docs/tools/devtools/repaint-rainbow-icon.png) **[Highlight repaints](https://docs.flutter.dev/tools/devtools/inspector#highlight-repaints)**

Show borders that change color when elements repaint. Useful for finding unnecessary repaints.

**다시 그리기 강조 아이콘**: 다시 그리기 강조  
요소가 다시 그려질 때 색상이 변경되는 테두리를 표시합니다. 불필요한 다시 그리기를 찾는 데 유용합니다.

![Highlight oversized images icon](https://docs.flutter.dev/assets/images/docs/tools/devtools/invert_oversized_images_icon.png) **[Highlight oversized images](https://docs.flutter.dev/tools/devtools/inspector#highlight-oversized-images)**

Highlights images that are using too much memory by inverting colors and flipping them.

**과도한 이미지 강조 아이콘**: 과도한 이미지 강조  
너무 많은 메모리를 사용하는 이미지를 색상을 반전시키고 뒤집어서 강조합니다.

## Inspecting a widget

You can browse the interactive widget tree to view nearby widgets and see their field values.

To locate individual UI elements in the widget tree, click the **Select Widget Mode** button in the toolbar. This puts the app on the device into a "widget select" mode. Click any widget in the app's UI; this selects the widget on the app's screen, and scrolls the widget tree to the corresponding node. Toggle the **Select Widget Mode** button again to exit widget select mode.

When debugging layout issues, the key fields to look at are the `size` and `constraints` fields. The constraints flow down the tree, and the sizes flow back up. For more information on how this works, see [Understanding constraints](https://docs.flutter.dev/ui/layout/constraints).

대화형 위젯 트리를 탐색하여 인근 위젯과 해당 필드 값을 확인할 수 있습니다.

개별 UI 요소를 위젯 트리에서 찾으려면 도구 모음에서 **위젯 선택 모드** 버튼을 클릭하세요. 그러면 디바이스에서 앱이 "위젯 선택" 모드로 전환됩니다. 앱 UI의 위젯을 클릭하면, 해당 위젯이 선택되고 위젯 트리가 해당 노드로 스크롤됩니다. 위젯 선택 모드에서 나가려면 **위젯 선택 모드** 버튼을 다시 클릭하세요.

레이아웃 문제를 디버깅할 때 주의 깊게 살펴봐야 할 주요 필드는 **크기**와 **제약 조건** 필드입니다. 제약 조건은 트리 아래로 흐르고, 크기는 다시 위로 흐릅니다. 이 작동 방식에 대한 자세한 정보는 **제약 조건 이해하기**를 참조하세요.

## Flutter Layout Explorer

The Flutter Layout Explorer helps you to better understand Flutter layouts.

For an overview of what you can do with this tool, see the Flutter Explorer video:

  Flutter Layout Explorer는 Flutter 레이아웃을 더 잘 이해하는 데 도움을 줍니다.

이 도구로 할 수 있는 것에 대한 개요는 Flutter Explorer 비디오를 참조하세요.

[DevTools Layout Explorer](https://www.youtube.com/watch/Jakrc3Tn_y4 "Open 'DevTools Layout Explorer' video in new tab")

You might also find the following step-by-step article useful:

- [How to debug layout issues with the Flutter Inspector](https://medium.com/flutter/how-to-debug-layout-issues-with-the-flutter-inspector-87460a7b9db)

다음의 단계별 기사가 유용할 수 있습니다:

- Flutter 인스펙터로 레이아웃 문제를 디버깅하는 방법

### Use the Layout Explorer

From the Flutter Inspector, select a widget. The Layout Explorer supports both [flex layouts](https://api.flutter.dev/flutter/widgets/Flex-class.html) and fixed size layouts, and has specific tooling for both kinds.

Flutter 인스펙터에서 위젯을 선택하세요. Layout Explorer는 유연한 레이아웃(flex layouts)과 고정 크기 레이아웃(fixed size layouts)을 모두 지원하며, 두 종류에 맞는 특정 도구를 제공합니다.

#### Flex layouts

When you select a flex widget (for example, [`Row`](https://api.flutter.dev/flutter/widgets/Row-class.html), [`Column`](https://api.flutter.dev/flutter/widgets/Column-class.html), [`Flex`](https://api.flutter.dev/flutter/widgets/Flex-class.html)) or a direct child of a flex widget, the flex layout tool will appear in the Layout Explorer.

플렉스 위젯(예: Row, Column, Flex)이나 플렉스 위젯의 직접 자식을 선택하면 Layout Explorer에 플렉스 레이아웃 도구가 나타납니다.

The Layout Explorer visualizes how [`Flex`](https://api.flutter.dev/flutter/widgets/Flex-class.html) widgets and their children are laid out. The explorer identifies the main axis and cross axis, as well as the current alignment for each (for example, start, end, and spaceBetween). It also shows details like flex factor, flex fit, and layout constraints.

Layout Explorer는 플렉스 위젯과 그 자식들이 어떻게 배치되는지를 시각화합니다. 탐색기는 주 축(main axis)과 교차 축(cross axis), 그리고 각 축의 현재 정렬(예: 시작, 끝, spaceBetween)을 식별합니다. 또한 플렉스 계수(flex factor), 플렉스 적합성(flex fit), 및 레이아웃 제약 조건(layout constraints)과 같은 세부 정보도 보여줍니다.

Additionally, the explorer shows layout constraint violations and render overflow errors. Violated layout constraints are colored red, and overflow errors are presented in the standard "yellow-tape" pattern, as you might see on a running device. These visualizations aim to improve understanding of why overflow errors occur as well as how to fix them.

추가로, 탐색기는 레이아웃 제약 조건 위반과 렌더 오버플로우 오류(render overflow errors)를 표시합니다. 위반된 레이아웃 제약 조건은 빨간색으로 표시되며, 오버플로우 오류는 실행 중인 디바이스에서 볼 수 있는 표준 "노란색 테이프" 패턴으로 나타납니다. 이러한 시각화는 오버플로우 오류가 발생하는 이유와 이를 해결하는 방법을 이해하는 데 도움을 주기 위한 것입니다.

![The Layout Explorer showing errors and device inspector](https://docs.flutter.dev/assets/images/docs/tools/devtools/layout_explorer_errors_and_device.gif)

Clicking a widget in the layout explorer mirrors the selection on the on-device inspector. **Select Widget Mode** needs to be enabled for this. To enable it, click on the **Select Widget Mode** button in the inspector.

레이아웃 탐색기에서 위젯을 클릭하면 디바이스 인스펙터에서의 선택이 미러링됩니다. 이를 위해서는 **위젯 선택 모드**가 활성화되어야 합니다. 활성화하려면 인스펙터에서 **위젯 선택 모드** 버튼을 클릭하세요.

![The Select Widget Mode button in the inspector](https://docs.flutter.dev/assets/images/docs/tools/devtools/select_widget_mode_button.png)

For some properties, like flex factor, flex fit, and alignment, you can modify the value via dropdown lists in the explorer. When modifying a widget property, you see the new value reflected not only in the Layout Explorer, but also on the device running your Flutter app. The explorer animates on property changes so that the effect of the change is clear. Widget property changes made from the layout explorer don't modify your source code and are reverted on hot reload.

일부 속성(예: 플렉스 계수, 플렉스 적합성, 정렬)은 탐색기에서 드롭다운 목록을 통해 값을 수정할 수 있습니다. 위젯 속성을 수정하면, 새로운 값이 Layout Explorer뿐만 아니라 Flutter 앱이 실행 중인 디바이스에서도 반영됩니다. 탐색기는 속성 변경 시 애니메이션을 적용하여 변경의 효과를 명확히 보여줍니다. Layout Explorer에서 수행된 위젯 속성 변경은 소스 코드를 수정하지 않으며, 핫 리로드 시 원래 상태로 되돌아갑니다.

##### Interactive Properties

Layout Explorer supports modifying [`mainAxisAlignment`](https://api.flutter.dev/flutter/widgets/Flex/mainAxisAlignment.html), [`crossAxisAlignment`](https://api.flutter.dev/flutter/widgets/Flex/crossAxisAlignment.html), and [`FlexParentData.flex`](https://api.flutter.dev/flutter/rendering/FlexParentData/flex.html). In the future, we may add support for additional properties such as [`mainAxisSize`](https://api.flutter.dev/flutter/widgets/Flex/mainAxisSize.html), [`textDirection`](https://api.flutter.dev/flutter/widgets/Flex/textDirection.html), and [`FlexParentData.fit`](https://api.flutter.dev/flutter/rendering/FlexParentData/fit.html).

##### 대화형 속성
Layout Explorer는 `mainAxisAlignment`, `crossAxisAlignment`, 및 `FlexParentData.flex`를 수정하는 것을 지원합니다. 앞으로는 `mainAxisSize`, `textDirection`, 및 `FlexParentData.fit`와 같은 추가 속성에 대한 지원도 추가할 예정입니다.

###### mainAxisAlignment
![The Layout Explorer changing main axis alignment](https://docs.flutter.dev/assets/images/docs/tools/devtools/layout_explorer_main_axis_alignment.gif)

Supported values:

- `MainAxisAlignment.start`
- `MainAxisAlignment.end`
- `MainAxisAlignment.center`
- `MainAxisAlignment.spaceBetween`
- `MainAxisAlignment.spaceAround`
- `MainAxisAlignment.spaceEvenly`

###### crossAxisAlignment


![The Layout Explorer changing cross axis alignment](https://docs.flutter.dev/assets/images/docs/tools/devtools/layout_explorer_cross_axis_alignment.gif)

Supported values:

- `CrossAxisAlignment.start`
- `CrossAxisAlignment.center`
- `CrossAxisAlignment.end`
- `CrossAxisAlignment.stretch`

###### FlexParentData.flex


![The Layout Explorer changing flex factor](https://docs.flutter.dev/assets/images/docs/tools/devtools/layout_explorer_flex.gif)

Layout Explorer supports 7 flex options in the UI (null, 0, 1, 2, 3, 4, 5), but technically the flex factor of a flex widget's child can be any int.

Layout Explorer는 UI에서 7개의 플렉스 옵션(null, 0, 1, 2, 3, 4, 5)을 지원하지만, 기술적으로 플렉스 위젯의 자식의 플렉스 계수는 어떤 정수(int)도 될 수 있습니다.
###### Flexible.fit


![The Layout Explorer changing fit](https://docs.flutter.dev/assets/images/docs/tools/devtools/layout_explorer_fit.gif)

Layout Explorer supports the two different types of [`FlexFit`](https://api.flutter.dev/flutter/rendering/FlexFit.html): `loose` and `tight`.

Layout Explorer는 두 가지 유형의 **FlexFit**을 지원합니다: **loose**와 **tight**.
#### Fixed size layouts

When you select a fixed size widget that is not a child of a flex widget, fixed size layout information will appear in the Layout Explorer. You can see size, constraint, and padding information for both the selected widget and its nearest upstream RenderObject.

#### 고정 크기 레이아웃

고정 크기 위젯을 선택하면, 해당 위젯이 플렉스 위젯의 자식이 아닐 경우 Layout Explorer에 고정 크기 레이아웃 정보가 나타납니다. 선택한 위젯과 가장 가까운 상위 **RenderObject**에 대한 크기, 제약 조건, 패딩 정보를 확인할 수 있습니다.

![The Layout Explorer fixed size tool](https://docs.flutter.dev/assets/images/docs/tools/devtools/layout_explorer_fixed_layout.png)

## Visual debugging

The Flutter Inspector provides several options for visually debugging your app.

Flutter 인스펙터는 앱을 시각적으로 디버깅할 수 있는 여러 가지 옵션을 제공합니다.

![Inspector visual debugging options](https://docs.flutter.dev/assets/images/docs/tools/devtools/visual_debugging_options.png)

### Slow animations

When enabled, this option runs animations 5 times slower for easier visual inspection. This can be useful if you want to carefully observe and tweak an animation that doesn't look quite right.

This can also be set in code:

활성화하면 이 옵션은 애니메이션을 5배 느리게 실행하여 시각적으로 쉽게 검사할 수 있게 해줍니다. 이는 애니메이션이 올바르지 않아 보일 때 주의 깊게 관찰하고 조정하는 데 유용할 수 있습니다.

이 설정은 코드에서도 할 수 있습니다:


```dart
import 'package:flutter/scheduler.dart';

void setSlowAnimations() {
  timeDilation = 5.0;
}
```

This slows the animations by 5x.

이것은 애니메이션을 5배 느리게 만듭니다.
#### See also

The following links provide more info.

- [Flutter documentation: timeDilation property](https://api.flutter.dev/flutter/scheduler/timeDilation.html)

The following screen recordings show before and after slowing an animation.


### 참조

다음 링크에서 추가 정보를 확인할 수 있습니다.

- Flutter 문서: **timeDilation** 속성

다음 화면 녹화에서는 애니메이션을 느리게 하기 전과 후의 모습을 보여줍니다.

![Screen recording showing normal animation speed](https://docs.flutter.dev/assets/images/docs/tools/devtools/debug-toggle-slow-animations-disabled.gif) ![Screen recording showing slowed animation speed](https://docs.flutter.dev/assets/images/docs/tools/devtools/debug-toggle-slow-animations-enabled.gif)

### Show guidelines

This feature draws guidelines over your app that display render boxes, alignments, paddings, scroll views, clippings and spacers.

This tool can be used for better understanding your layout. For instance, by finding unwanted padding or understanding widget alignment.

You can also enable this in code:

이 기능은 앱 위에 가이드라인을 그려서 렌더 박스, 정렬, 패딩, 스크롤 뷰, 클리핑 및 스페이서를 표시합니다.

이 도구는 레이아웃을 더 잘 이해하는 데 사용될 수 있습니다. 예를 들어, 원치 않는 패딩을 찾거나 위젯 정렬을 이해하는 데 유용합니다.

이 설정은 코드에서도 활성화할 수 있습니다:

```dart
import 'package:flutter/rendering.dart';

void showLayoutGuidelines() {
  debugPaintSizeEnabled = true;
}
```
#### Render boxes

Widgets that draw to the screen create a [render box](https://api.flutter.dev/flutter/rendering/RenderBox-class.html), the building blocks of Flutter layouts. They're shown with a bright blue border:

화면에 그려지는 위젯은 Flutter 레이아웃의 기본 구성 요소인 렌더 박스를 생성합니다. 이들은 밝은 파란색 테두리로 표시됩니다:

![Screenshot of render box guidelines](https://docs.flutter.dev/assets/images/docs/tools/devtools/debug-toggle-guideline-render-box.png)

#### Alignments

Alignments are shown with yellow arrows. These arrows show the vertical and horizontal offsets of a widget relative to its parent. For example, this button's icon is shown as being centered by the four arrows:

정렬은 노란색 화살표로 표시됩니다. 이 화살표는 위젯이 부모에 대해 수직 및 수평으로 얼마나 이동했는지를 나타냅니다. 예를 들어, 이 버튼의 아이콘은 네 개의 화살표로 중앙에 위치하고 있음을 보여줍니다:

![Screenshot of alignment guidelines](https://docs.flutter.dev/assets/images/docs/tools/devtools/debug-toggle-guidelines-alignment.png)

#### Padding

Padding is shown with a semi-transparent blue background:

패딩은 반투명 파란색 배경으로 표시됩니다:

![Screenshot of padding guidelines](https://docs.flutter.dev/assets/images/docs/tools/devtools/debug-toggle-guidelines-padding.png)

#### Scroll views

Widgets with scrolling contents (such as list views) are shown with green arrows:

스크롤 가능한 콘텐츠가 있는 위젯(예: 리스트 뷰)은 녹색 화살표로 표시됩니다:

![Screenshot of scroll view guidelines](https://docs.flutter.dev/assets/images/docs/tools/devtools/debug-toggle-guidelines-scroll.png)

#### Clipping

Clipping, for example when using the [ClipRect widget](https://api.flutter.dev/flutter/widgets/ClipRect-class.html), are shown with a dashed pink line with a scissors icon:

클리핑, 예를 들어 ClipRect 위젯을 사용할 때, 점선 분홍색 선과 가위 아이콘으로 표시됩니다:

![Screenshot of clip guidelines](https://docs.flutter.dev/assets/images/docs/tools/devtools/debug-toggle-guidelines-clip.png)

#### Spacers

Spacer widgets are shown with a grey background, such as this `SizedBox` without a child:

스페이서 위젯은 회색 배경으로 표시되며, 예를 들어 자식이 없는 이 **SizedBox**와 같이 나타납니다:

![Screenshot of spacer guidelines](https://docs.flutter.dev/assets/images/docs/tools/devtools/debug-toggle-guidelines-spacer.png)

### Show baselines

This option makes all baselines visible. Baselines are horizontal lines used to position text.

This can be useful for checking whether text is precisely aligned vertically. For example, the text baselines in the following screenshot are slightly misaligned:

이 옵션은 모든 기준선을 표시합니다. 기준선은 텍스트 위치 지정을 위해 사용되는 수평선입니다.

이 기능은 텍스트가 수직으로 정확하게 정렬되어 있는지 확인하는 데 유용합니다. 예를 들어, 다음 스크린샷의 텍스트 기준선이 약간 어긋나 있습니다:

![Screenshot with show baselines enabled](https://docs.flutter.dev/assets/images/docs/tools/devtools/debug-toggle-guidelines-baseline.png)

The [Baseline](https://api.flutter.dev/flutter/widgets/Baseline-class.html) widget can be used to adjust baselines.

A line is drawn on any [render box](https://api.flutter.dev/flutter/rendering/RenderBox-class.html) that has a baseline set; alphabetic baselines are shown as green and ideographic as yellow.

You can also enable this in code:

**Baseline** 위젯은 기준선을 조정하는 데 사용할 수 있습니다.

기준선이 설정된 렌더 박스에는 선이 그려지며, 알파벳 기준선은 녹색으로, 이데오그래픽 기준선은 노란색으로 표시됩니다.

이 설정은 코드에서도 활성화할 수 있습니다:

```dart
import 'package:flutter/rendering.dart';

void showBaselines() {
  debugPaintBaselinesEnabled = true;
}
```

### Highlight repaints

This option draws a border around all [render boxes](https://api.flutter.dev/flutter/rendering/RenderBox-class.html) that changes color every time that box repaints.

This rotating rainbow of colors is useful for finding parts of your app that are repainting too often and potentially harming performance.

For example, one small animation could be causing an entire page to repaint on every frame. Wrapping the animation in a [RepaintBoundary widget](https://api.flutter.dev/flutter/widgets/RepaintBoundary-class.html) limits the repainting to just the animation.

Here the progress indicator causes its container to repaint:

이 옵션은 모든 렌더 박스 주위에 테두리를 그리며, 해당 박스가 다시 그려질 때마다 색상이 변경됩니다.

이 회전하는 무지개 색상은 앱의 일부가 너무 자주 다시 그려지고 있어 성능에 영향을 줄 수 있는 부분을 찾는 데 유용합니다.

예를 들어, 하나의 작은 애니메이션이 매 프레임마다 전체 페이지를 다시 그리게 할 수 있습니다. 애니메이션을 **RepaintBoundary** 위젯으로 감싸면 다시 그려지는 범위를 애니메이션으로 제한할 수 있습니다.

여기에서 진행 표시기가 자신의 컨테이너를 다시 그리게 합니다:

```dart
class EverythingRepaintsPage extends StatelessWidget {
  const EverythingRepaintsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Repaint Example')),
      body: const Center(
        child: CircularProgressIndicator(),
      ),
    );
  }
}
```


![Screen recording of a whole screen repainting](https://docs.flutter.dev/assets/images/docs/tools/devtools/debug-toggle-guidelines-repaint-1.gif)

Wrapping the progress indicator in a `RepaintBoundary` causes only that section of the screen to repaint:

진행 표시기를 **RepaintBoundary**로 감싸면 화면의 해당 섹션만 다시 그려지게 됩니다:

```dart
class AreaRepaintsPage extends StatelessWidget {
  const AreaRepaintsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Repaint Example')),
      body: const Center(
        child: RepaintBoundary(
          child: CircularProgressIndicator(),
        ),
      ),
    );
  }
}
```


![Screen recording of a just a progress indicator repainting](https://docs.flutter.dev/assets/images/docs/tools/devtools/debug-toggle-guidelines-repaint-2.gif)

`RepaintBoundary` widgets have tradeoffs. They can help with performance, but they also have an overhead of creating a new canvas, which uses additional memory.

You can also enable this option in code:

**RepaintBoundary** 위젯은 장단점이 있습니다. 성능에 도움을 줄 수 있지만, 새로운 캔버스를 생성하는 오버헤드가 발생하여 추가 메모리를 사용합니다.

이 옵션은 코드에서도 활성화할 수 있습니다:


```dart
import 'package:flutter/rendering.dart';

void highlightRepaints() {
  debugRepaintRainbowEnabled = true;
}
```
### Highlight oversized images

This option highlights images that are too large by both inverting their colors and flipping them vertically:

이 옵션은 크기가 너무 큰 이미지를 색상을 반전시키고 수직으로 뒤집어서 강조합니다:

![A highlighted oversized image](https://docs.flutter.dev/assets/images/docs/tools/devtools/debug-toggle-guidelines-oversized.png)

The highlighted images use more memory than is required; for example, a large 5MB image displayed at 100 by 100 pixels.

Such images can cause poor performance, especially on lower-end devices and when you have many images, as in a list view, this performance hit can add up. Information about each image is printed in the debug console:

강조된 이미지는 필요 이상으로 많은 메모리를 사용합니다. 예를 들어, 100x100 픽셀로 표시되는 5MB의 큰 이미지가 있습니다.

이러한 이미지는 성능 저하를 일으킬 수 있으며, 특히 저사양 디바이스나 많은 이미지가 있는 리스트 뷰와 같은 경우에는 성능 저하가 누적될 수 있습니다. 각 이미지에 대한 정보는 디버그 콘솔에 출력됩니다:

```
dash.png has a display size of 213×392 but a decode size of 2130×392, which uses an additional 2542KB.
```

Images are deemed too large if they use at least 128KB more than required.

이미지는 필요 이상으로 128KB 이상의 메모리를 사용하는 경우 "너무 크다"고 간주됩니다.
#### Fixing images

Wherever possible, the best way to fix this problem is resizing the image asset file so it's smaller.

If this isn't possible, you can use the `cacheHeight` and `cacheWidth` parameters on the `Image` constructor:

가능한 경우, 이 문제를 해결하는 가장 좋은 방법은 이미지 자산 파일의 크기를 줄이는 것입니다.

이것이 불가능한 경우, **Image** 생성자의 `cacheHeight` 및 `cacheWidth` 매개변수를 사용할 수 있습니다:

```dart
class ResizedImage extends StatelessWidget {
  const ResizedImage({super.key});

  @override
  Widget build(BuildContext context) {
    return Image.asset(
      'dash.png',
      cacheHeight: 213,
      cacheWidth: 392,
    );
  }
}
```

This makes the engine decode this image at the specified size, and reduces memory usage (decoding and storage is still more expensive than if the image asset itself was shrunk). The image is rendered to the constraints of the layout or width and height regardless of these parameters.

This property can also be set in code:

이렇게 하면 엔진이 지정된 크기로 이미지를 디코딩하여 메모리 사용량을 줄입니다(디코딩 및 저장은 이미지 자산 자체의 크기를 줄이는 것보다 여전히 더 비용이 많이 듭니다). 이미지는 레이아웃의 제약 조건 또는 지정된 너비와 높이에 맞춰 렌더링됩니다.

이 속성은 코드에서도 설정할 수 있습니다:

```dart
void showOversizedImages() {
  debugInvertOversizedImages = true;
}
```

#### More information

You can learn more at the following link:

- [Flutter documentation: debugInvertOversizedImages](https://api.flutter.dev/flutter/painting/debugInvertOversizedImages.html)

### 추가 정보

다음 링크에서 더 많은 정보를 확인할 수 있습니다:

- Flutter 문서: **debugInvertOversizedImages**

## Details Tree

Select the **Widget Details Tree** tab to display the details tree for the selected widget. From here, you can gather useful information about a widget's properties, render object, and children.

## 세부 사항 트리

**Widget Details Tree** 탭을 선택하여 선택한 위젯의 세부 사항 트리를 표시합니다. 여기에서 위젯의 속성, 렌더 객체, 자식에 대한 유용한 정보를 수집할 수 있습니다.

![The Details Tree view](https://docs.flutter.dev/assets/images/docs/tools/devtools/inspector_details_tree.png)

## Track widget creation

Part of the functionality of the Flutter inspector is based on instrumenting the application code in order to better understand the source locations where widgets are created. The source instrumentation allows the Flutter inspector to present the widget tree in a manner similar to how the UI was defined in your source code. Without it, the tree of nodes in the widget tree are much deeper, and it can be more difficult to understand how the runtime widget hierarchy corresponds to your application's UI.

You can disable this feature by passing `--no-track-widget-creation` to the `flutter run` command.

Here are examples of what your widget tree might look like with and without track widget creation enabled.

Track widget creation enabled (default):

Flutter 인스펙터의 일부 기능은 위젯이 생성되는 소스 위치를 더 잘 이해하기 위해 애플리케이션 코드를 계측하는 데 기반하고 있습니다. 이 소스 계측을 통해 Flutter 인스펙터는 위젯 트리를 소스 코드에서 UI가 정의된 방식과 유사하게 표시할 수 있습니다. 이를 사용하지 않으면 위젯 트리의 노드가 훨씬 더 깊어져 런타임 위젯 계층 구조가 애플리케이션 UI와 어떻게 대응하는지를 이해하기 어려워질 수 있습니다.

이 기능은 `flutter run` 명령에 `--no-track-widget-creation`을 전달하여 비활성화할 수 있습니다.

다음은 트랙 위젯 생성이 활성화된 경우와 비활성화된 경우의 위젯 트리 예시입니다.

트랙 위젯 생성 활성화 (기본값):

![The widget tree with track widget creation enabled](https://docs.flutter.dev/assets/images/docs/tools/devtools/track_widget_creation_enabled.png)

Track widget creation disabled (not recommended):

트랙 위젯 생성 비활성화 (권장하지 않음):

![The widget tree with track widget creation disabled](https://docs.flutter.dev/assets/images/docs/tools/devtools/track_widget_creation_disabled.png)

This feature prevents otherwise-identical `const` Widgets from being considered equal in debug builds. For more details, see the discussion on [common problems when debugging](https://docs.flutter.dev/testing/debugging).

이 기능은 디버그 빌드에서 동일한 **const** 위젯이 동등하다고 간주되는 것을 방지합니다. 자세한 내용은 디버깅 시 일반적인 문제에 대한 논의를 참조하세요.
## Inspector settings

![The Flutter Inspector Settings dialog](https://docs.flutter.dev/assets/images/docs/tools/devtools/flutter_inspector_settings.png)

### Enable hover inspection

Hovering over any widget displays its properties and values.

Toggling this value enables or disables the hover inspection functionality.

위젯 위에 마우스를 올리면 해당 위젯의 속성과 값이 표시됩니다.

이 값을 전환하면 호버 검사 기능을 활성화하거나 비활성화할 수 있습니다.

### Package directories

By default, DevTools limits the widgets displayed in the widget tree to those from the project's root directory, and those from Flutter. This filtering only applies to the widgets in the Inspector Widget Tree (left side of the Inspector)—not the Widget Details Tree (right side of the Inspector in the same tab view as the Layout Explorer). In the Widget Details Tree, you can see all widgets in the tree from all packages.

In order to show other widgets, a parent directory of theirs must be added to the Package Directories.

For example, consider the following directory structure:

기본적으로 DevTools는 위젯 트리에 표시되는 위젯을 프로젝트의 루트 디렉토리와 Flutter에서 가져온 위젯으로 제한합니다. 이 필터링은 인스펙터 위젯 트리(인스펙터 왼쪽)에만 적용되며, 레이아웃 탐색기와 동일한 탭 보기의 위젯 세부 사항 트리(인스펙터 오른쪽)에는 적용되지 않습니다. 위젯 세부 사항 트리에서는 모든 패키지에서의 모든 위젯을 볼 수 있습니다.

다른 위젯을 표시하려면, 해당 위젯의 상위 디렉토리를 패키지 디렉토리에 추가해야 합니다.

예를 들어, 다음과 같은 디렉토리 구조를 고려해보세요:

```
project_foo
  pkgs
    project_foo_app
    widgets_A
    widgets_B
```

Running your app from `project_foo_app` displays only widgets from `project_foo/pkgs/project_foo_app` in the widget inspector tree.

To show widgets from `widgets_A` in the widget tree, add `project_foo/pkgs/widgets_A` to the package directories.

To display _all_ widgets from your project root in the widget tree, add `project_foo` to the package directories.

Changes to your package directories persist the next time the widget inspector is opened for the app.

`project_foo_app`에서 앱을 실행하면 위젯 인스펙터 트리에 `project_foo/pkgs/project_foo_app`의 위젯만 표시됩니다.

`widgets_A`의 위젯을 위젯 트리에 표시하려면 `project_foo/pkgs/widgets_A`를 패키지 디렉토리에 추가해야 합니다.

프로젝트 루트의 모든 위젯을 위젯 트리에 표시하려면 `project_foo`를 패키지 디렉토리에 추가하세요.

패키지 디렉토리에 대한 변경 사항은 앱의 위젯 인스펙터가 다음에 열릴 때 지속됩니다.

## Other resources

For a demonstration of what's generally possible with the inspector, see the [DartConf 2018 talk](https://www.youtube.com/watch?v=JIcmJNT9DNI) demonstrating the IntelliJ version of the Flutter inspector.

To learn how to visually debug layout issues using DevTools, check out a guided [Flutter Inspector tutorial](https://medium.com/@fluttergems/mastering-dart-flutter-devtools-flutter-inspector-part-2-of-8-bbff40692fc7).

인스펙터로 일반적으로 가능한 기능을 시연하려면 DartConf 2018에서 Flutter 인스펙터의 IntelliJ 버전을 시연한 발표를 참조하세요.

DevTools를 사용하여 레이아웃 문제를 시각적으로 디버깅하는 방법을 배우려면 가이드가 포함된 Flutter 인스펙터 튜토리얼을 확인하세요._Note_

The DevTools performance view works for Flutter mobile and desktop apps. For web apps, Flutter adds timeline events to the performance panel of Chrome DevTools instead. To learn about profiling web apps, check out [Debugging web performance](https://docs.flutter.dev/perf/web-performance).

_정보_

DevTools 성능 보기 기능은 Flutter 모바일 및 데스크톱 앱에서 작동합니다. 웹 앱의 경우, Flutter는 Chrome DevTools의 성능 패널에 타임라인 이벤트를 추가합니다. 웹 앱 프로파일링에 대해 알아보려면 "웹 성능 디버깅"을 확인하세요.

The performance page can help you diagnose performance problems and UI jank in your application. This page offers timing and performance information for activity in your application. It consists of several tools to help you identify the cause of poor performance in your app:

- Flutter frames chart (Flutter apps only)
- Frame analysis tab (Flutter apps only)
- Raster stats tab (Flutter apps only)
- Timeline events trace viewer (all native Dart applications)
- Advanced debugging tools (Flutter apps only)

성능 페이지는 애플리케이션의 성능 문제와 UI 지연 현상을 진단하는 데 도움을 줄 수 있습니다. 이 페이지는 애플리케이션 내 활동에 대한 타이밍 및 성능 정보를 제공합니다. 성능 저하의 원인을 파악하는 데 도움이 되는 여러 도구로 구성되어 있습니다:

- Flutter 프레임 차트 (Flutter 앱 전용)
- 프레임 분석 탭 (Flutter 앱 전용)
- 래스터 통계 탭 (Flutter 앱 전용)
- 타임라인 이벤트 추적 뷰어 (모든 네이티브 Dart 애플리케이션)
- 고급 디버깅 도구 (Flutter 앱 전용)

**Use a [profile build](https://docs.flutter.dev/testing/build-modes#profile) of your application to analyze performance.** Frame rendering times aren't indicative of release performance when running in debug mode. Run your app in profile mode, which still preserves useful debugging information.

애플리케이션의 성능을 분석하려면 프로파일 빌드를 사용하세요. 프레임 렌더링 시간은 디버그 모드에서 실행할 때 릴리스 성능을 나타내지 않습니다. 앱을 프로파일 모드에서 실행하세요. 이 모드는 여전히 유용한 디버깅 정보를 보존합니다.

The performance view also supports importing and exporting of data snapshots. For more information, check out the [Import and export](https://docs.flutter.dev/tools/devtools/performance#import-and-export) section.

성능 뷰는 데이터 스냅샷의 가져오기 및 내보내기를 지원합니다. 자세한 내용은 가져오기 및 내보내기 섹션을 확인하세요.

## What is a frame in Flutter?

Flutter is designed to render its UI at 60 frames per second (fps), or 120 fps on devices capable of 120Hz updates. Each render is called a _frame_. This means that, approximately every 16ms, the UI updates to reflect animations or other changes to the UI. A frame that takes longer than 16ms to render causes jank (jerky motion) on the display device.

Flutter는 UI를 초당 60프레임(fps) 또는 120Hz 업데이트가 가능한 장치에서는 초당 120프레임으로 렌더링하도록 설계되었습니다. 각 렌더링을 프레임이라고 부릅니다. 이는 약 16ms마다 UI가 애니메이션이나 다른 UI 변경 사항을 반영하도록 업데이트됨을 의미합니다. 렌더링이 16ms보다 오래 걸리는 프레임은 디스플레이 장치에서 지연(jank) 현상을 일으킵니다.
## Flutter frames chart

This chart contains Flutter frame information for your application. Each bar set in the chart represents a single Flutter frame. The bars are color-coded to highlight the different portions of work that occur when rendering a Flutter frame: work from the UI thread and work from the raster thread.

이 차트는 애플리케이션의 Flutter 프레임 정보를 포함하고 있습니다. 차트의 각 막대 세트는 하나의 Flutter 프레임을 나타냅니다. 막대는 Flutter 프레임을 렌더링할 때 발생하는 작업의 서로 다른 부분(UI 스레드의 작업과 래스터 스레드의 작업)을 강조 표시하기 위해 색상 코드로 구분되어 있습니다.

This chart contains Flutter frame timing information for your application. Each pair of bars in the chart represents a single Flutter frame. Selecting a frame from this chart updates the data that is displayed below in the [Frame analysis](https://docs.flutter.dev/tools/devtools/performance#frame-analysis-tab) tab or the [Timeline events](https://docs.flutter.dev/tools/devtools/performance#timeline-events-tab) tab. (As of [DevTools 2.23.1](https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.23.1), the [Raster stats](https://docs.flutter.dev/tools/devtools/performance#raster-stats-tab) is a standalone feature without data per frame).

이 차트에는 애플리케이션의 Flutter 프레임 타이밍 정보가 포함되어 있습니다. 차트의 각 막대 쌍은 하나의 Flutter 프레임을 나타냅니다. 이 차트에서 프레임을 선택하면 아래의 프레임 분석 탭 또는 타임라인 이벤트 탭에 표시되는 데이터가 업데이트됩니다. (DevTools 2.23.1 기준, 래스터 통계는 프레임별 데이터 없이 독립된 기능입니다.)

The flutter frames chart updates when new frames are drawn in your app. To pause updates to this chart, click the pause button to the right of the chart. This chart can be collapsed to provide more viewing space for data below by clicking the **Flutter frames** button above the chart.

Flutter 프레임 차트는 애플리케이션에서 새로운 프레임이 그려질 때 업데이트됩니다. 이 차트의 업데이트를 일시 중지하려면 차트 오른쪽의 일시 중지 버튼을 클릭하세요. 이 차트는 차트 위의 Flutter 프레임 버튼을 클릭하여 아래의 데이터에 대한 더 많은 보기 공간을 제공하기 위해 축소할 수 있습니다.

![Screenshot of a Flutter frames chart](https://docs.flutter.dev/assets/images/docs/tools/devtools/flutter-frames-chart.png)

The pair of bars representing each Flutter frame are color-coded to highlight the different portions of work that occur when rendering a Flutter frame: work from the UI thread and work from the raster thread.

각 Flutter 프레임을 나타내는 막대 쌍은 Flutter 프레임을 렌더링할 때 발생하는 작업의 서로 다른 부분(UI 스레드의 작업과 래스터 스레드의 작업)을 강조 표시하기 위해 색상 코드로 구분되어 있습니다.

### UI

The UI thread executes Dart code in the Dart VM. This includes code from your application as well as the Flutter framework. When your app creates and displays a scene, the UI thread creates a layer tree, a lightweight object containing device-agnostic painting commands, and sends the layer tree to the raster thread to be rendered on the device. Do **not** block this thread.

UI 스레드는 Dart VM에서 Dart 코드를 실행합니다. 여기에는 애플리케이션의 코드뿐만 아니라 Flutter 프레임워크의 코드도 포함됩니다. 앱이 장면을 생성하고 표시할 때, UI 스레드는 장치에 독립적인 페인팅 명령을 포함하는 경량 객체인 레이어 트리를 생성하고, 이 레이어 트리를 래스터 스레드에 전송하여 장치에서 렌더링합니다. 이 스레드를 차단해서는 안 됩니다.

### Raster

The raster thread executes graphics code from the Flutter Engine. This thread takes the layer tree and displays it by talking to the GPU (graphic processing unit). You can't directly access the raster thread or its data, but if this thread is slow, it's a result of something you've done in the Dart code. Skia, the graphics library, runs on this thread. [Impeller](https://docs.flutter.dev/perf/impeller) also uses this thread.

래스터 스레드는 Flutter 엔진의 그래픽 코드를 실행합니다. 이 스레드는 레이어 트리를 가져와 GPU(그래픽 처리 장치)와 통신하여 이를 표시합니다. 래스터 스레드나 그 데이터를 직접적으로 접근할 수는 없지만, 이 스레드가 느리면 Dart 코드에서 발생한 문제 때문입니다. 그래픽 라이브러리인 Skia는 이 스레드에서 실행되며, Impeller도 이 스레드를 사용합니다.

Sometimes a scene results in a layer tree that is easy to construct, but expensive to render on the raster thread. In this case, you need to figure out what your code is doing that is causing rendering code to be slow. Specific kinds of workloads are more difficult for the GPU. They might involve unnecessary calls to `saveLayer()`, intersecting opacities with multiple objects, and clips or shadows in specific situations.

가끔 장면이 쉽게 구성될 수 있는 레이어 트리를 생성하지만, 래스터 스레드에서 렌더링하는 데 비용이 많이 드는 경우가 있습니다. 이 경우, 렌더링 코드가 느리게 되는 원인을 파악해야 합니다. 특정 종류의 작업량은 GPU에 더 어려울 수 있으며, 여기에는 불필요한 `saveLayer()` 호출, 여러 객체와의 불투명도 교차, 특정 상황에서의 클립 또는 그림자 등이 포함됩니다.

For more information on profiling, check out [Identifying problems in the GPU graph](https://docs.flutter.dev/perf/ui-performance#identifying-problems-in-the-gpu-graph).

프로파일링에 대한 더 많은 정보는 GPU 그래프에서 문제 식별하기를 확인하세요.
### Jank (slow frame)

The frame rendering chart shows jank with a red overlay. A frame is considered to be janky if it takes more than ~16 ms to complete (for 60 FPS devices). To achieve a frame rendering rate of 60 FPS (frames per second), each frame must render in ~16 ms or less. When this target is missed, you may experience UI jank or dropped frames.

프레임 렌더링 차트는 지연(jank)을 빨간색 오버레이로 표시합니다. 프레임이 60 FPS 장치에서 완료하는 데 16ms 이상 걸리면 해당 프레임은 지연으로 간주됩니다. 초당 60프레임의 렌더링 속도를 달성하려면 각 프레임이 약 16ms 이내에 렌더링되어야 합니다. 이 목표를 놓치면 UI 지연이나 프레임 손실이 발생할 수 있습니다.

For more information on how to analyze your app's performance, check out [Flutter performance profiling](https://docs.flutter.dev/perf/ui-performance).

애플리케이션 성능을 분석하는 방법에 대한 더 많은 정보는 Flutter 성능 프로파일링을 확인하세요.

### Shader compilation

Shader compilation occurs when a shader is first used in your Flutter app. Frames that perform shader compilation are marked in dark red:

셰이더 컴파일은 Flutter 앱에서 셰이더가 처음 사용될 때 발생합니다. 셰이더 컴파일을 수행하는 프레임은 짙은 빨간색으로 표시됩니다.

![Screenshot of shader compilation for a frame](https://docs.flutter.dev/assets/images/docs/tools/devtools/shader-compilation-frames-chart.png)

For more information on how to reduce shader compilation jank, check out [Reduce shader compilation jank on mobile](https://docs.flutter.dev/perf/shader).

셰이더 컴파일 지연을 줄이는 방법에 대한 더 많은 정보는 "모바일에서 셰이더 컴파일 지연 줄이기"를 확인하세요.
## Frame analysis tab

Selecting a janky frame (slow, colored in red) from the Flutter frames chart above shows debugging hints in the Frame analysis tab. These hints help you diagnose jank in your app, and notify you of any expensive operations that we have detected that might have contributed to the slow frame time.

Flutter 프레임 차트에서 지연된 프레임(느리며 빨간색으로 표시된 프레임)을 선택하면 프레임 분석 탭에 디버깅 힌트가 표시됩니다. 이러한 힌트는 애플리케이션에서의 지연을 진단하는 데 도움을 주며, 느린 프레임 시간에 기여했을 수 있는 비용이 많이 드는 작업을 감지했음을 알려줍니다.

![Screenshot of the frame analysis tab](https://docs.flutter.dev/assets/images/docs/tools/devtools/frame-analysis-tab.png)

## Raster stats tab

_Note_

For best results, this tool should be used with the Impeller rendering engine. When using Skia, the raster stats reported might be inconsistent due to the timing of when shaders are compiled.

_정보_

최상의 결과를 얻으려면 이 도구를 Impeller 렌더링 엔진과 함께 사용해야 합니다. Skia를 사용할 경우, 셰이더가 컴파일되는 시점 때문에 보고되는 래스터 통계가 일관되지 않을 수 있습니다.

If you have Flutter frames that are janking with slow raster thread times, this tool might be able to help you diagnose the source of the slow performance. To generate raster stats:

1. Navigate to the screen in your app where you are seeing raster thread jank.
2. Click **Take Snapshot**.
3. View different layers and their respective rendering times.

래스터 스레드 시간이 느려서 지연이 발생하는 Flutter 프레임이 있는 경우, 이 도구가 느린 성능의 원인을 진단하는 데 도움을 줄 수 있습니다. 래스터 통계를 생성하려면:

- 애플리케이션에서 래스터 스레드 지연이 발생하는 화면으로 이동합니다.
- **스냅샷 찍기(Take Snapshot)를** 클릭합니다.
- 다양한 레이어와 해당 렌더링 시간을 확인합니다.

If you see an expensive layer, find the Dart code in your app that is producing this layer and investigate further. You can make changes to your code, hot reload, and take new snapshots to see if the performance of a layer was improved by your change.

비싼 레이어가 보이면, 이 레이어를 생성하는 Dart 코드를 찾아 더 자세히 조사하세요. 코드를 변경한 후 핫 리로드를 하고, 성능이 개선되었는지 확인하기 위해 새로운 스냅샷을 찍을 수 있습니다.

![Screenshot of the raster stats tab](https://docs.flutter.dev/assets/images/docs/tools/devtools/raster-stats-tab.png)

## Timeline events tab

The timeline events chart shows all event tracing from your application. The Flutter framework emits timeline events as it works to build frames, draw scenes, and track other activity such as HTTP request timings and garbage collection. These events show up here in the Timeline. You can also send your own Timeline events using the dart:developer [`Timeline`](https://api.flutter.dev/flutter/dart-developer/Timeline-class.html) and [`TimelineTask`](https://api.flutter.dev/flutter/dart-developer/TimelineTask-class.html) APIs.

타임라인 이벤트 차트는 애플리케이션의 모든 이벤트 추적을 보여줍니다. Flutter 프레임워크는 프레임을 빌드하고, 장면을 그리며, HTTP 요청 시간 및 가비지 컬렉션과 같은 다른 활동을 추적하는 동안 타임라인 이벤트를 발생시킵니다. 이러한 이벤트는 타임라인에서 나타납니다. 또한, `dart:developer`의 타임라인 및 타임라인 작업(TimelineTask) API를 사용하여 자신의 타임라인 이벤트를 보낼 수도 있습니다.

![Screenshot of a timeline events tab](https://docs.flutter.dev/assets/images/docs/tools/devtools/timeline-events-tab.png) 

For help with navigating and using the trace viewer, click the **?** button at the top right of the timeline events tab bar. To refresh the timeline with new events from your application, click the refresh button (also in the upper right corner of the tab controls).

타임라인 이벤트 탭 바의 오른쪽 상단에 있는 ? 버튼을 클릭하면 추적 뷰어를 탐색하고 사용하는 데 대한 도움을 받을 수 있습니다. 애플리케이션의 새로운 이벤트로 타임라인을 새로 고치려면, 탭 컨트롤의 오른쪽 상단에 있는 새로 고침 버튼을 클릭하세요.

## Advanced debugging tools

### Enhance tracing

To view more detailed tracing in the timeline events chart, use the options in the enhance tracing dropdown:

타임라인 이벤트 차트에서 더 자세한 추적 정보를 보려면 향상된 추적 드롭다운의 옵션을 사용하세요:

_Note_

Frame times might be negatively affected when these options are enabled.

_정보_

> 이러한 옵션이 활성화되면 프레임 시간에 부정적인 영향을 미칠 수 있습니다.

![Screenshot of enhanced tracing options](https://docs.flutter.dev/assets/images/docs/tools/devtools/enhanced-tracing.png)

To see the new timeline events, reproduce the activity in your app that you are interested in tracing, and then select a frame to inspect the timeline.

새로운 타임라인 이벤트를 보려면, 추적하려는 활동을 앱에서 재현한 다음, 프레임을 선택하여 타임라인을 검사하세요.

### Track widget builds

To see the `build()` method events in the timeline, enable the **Track Widget Builds** option. The name of the widget is shown in the timeline event.

타임라인에서 `build()` 메서드 이벤트를 보려면 "Track Widget Builds" 옵션을 활성화하세요. 그러면 타임라인 이벤트에 위젯의 이름이 표시됩니다.

![Screenshot of track widget builds](https://docs.flutter.dev/assets/images/docs/tools/devtools/track-widget-builds.png)

[Watch this video for an example of tracking widget builds](https://www.youtube.com/watch/_EYk-E29edo?t=623)

위젯 빌드를 추적하는 예제를 보려면 이 비디오를 시청하세요.
### Track layouts

To see render object layout events in the timeline, enable the **Track Layouts** option:

타임라인에서 렌더 객체 레이아웃 이벤트를 보려면 "Track Layouts" 옵션을 활성화하세요.

![Screenshot of track layouts](https://docs.flutter.dev/assets/images/docs/tools/devtools/track-layouts.png)

[Watch this video for an example of tracking layouts](https://www.youtube.com/watch/_EYk-E29edo?t=676)

레이아웃을 추적하는 예제를 보려면 이 비디오를 시청하세요.
### Track paints

To see render object paint events in the timeline, enable the **Track Paints** option:

타임라인에서 렌더 객체 페인트 이벤트를 보려면 "Track Paints" 옵션을 활성화하세요.

![Screenshot of track paints](https://docs.flutter.dev/assets/images/docs/tools/devtools/track-paints.png)

[Watch this video for an example of tracking paints](https://www.youtube.com/watch/_EYk-E29edo?t=748)

## More debugging options

To diagnose performance problems related to rendering layers, toggle off a rendering layer. These options are enabled by default.

렌더링 레이어와 관련된 성능 문제를 진단하려면 렌더링 레이어를 끄세요. 이러한 옵션은 기본적으로 활성화되어 있습니다.

To see the effects on your app's performance, reproduce the activity in your app. Then select the new frames in the frames chart to inspect the timeline events with the layers disabled. If Raster time has significantly decreased, excessive use of the effects you disabled might be contributing to the jank you saw in your app.

앱 성능에 미치는 영향을 보려면, 앱에서 활동을 재현한 다음, 프레임 차트에서 새로운 프레임을 선택하여 레이어가 비활성화된 상태의 타임라인 이벤트를 검사하세요. 만약 래스터 시간이 상당히 줄어들었다면, 비활성화한 효과의 과도한 사용이 앱에서 보였던 지연의 원인이 될 수 있습니다.

**Render Clip layers**

Disable this option to check whether excessive use of clipping is affecting performance. If performance improves with this option disabled, try to reduce the use of clipping effects in your app.

이 옵션을 비활성화하여 클리핑의 과도한 사용이 성능에 영향을 미치는지 확인하세요. 이 옵션이 비활성화되었을 때 성능이 개선된다면, 앱에서 클리핑 효과의 사용을 줄이는 것을 고려해 보세요.

**Render Opacity layers**

Disable this option to check whether excessive use of opacity effects are affecting performance. If performance improves with this option disabled, try to reduce the use of opacity effects in your app.

이 옵션을 비활성화하여 불투명 효과의 과도한 사용이 성능에 영향을 미치는지 확인하세요. 이 옵션이 비활성화되었을 때 성능이 개선된다면, 앱에서 불투명 효과의 사용을 줄이는 것을 고려해 보세요.

**Render Physical Shape layers**

Disable this option to check whether excessive use of physical modeling effects are affecting performance, such as shadows or elevation. If performance improves with this option disabled, try to reduce the use of physical modeling effects in your app.

이 옵션을 비활성화하여 그림자나 높이와 같은 물리적 모델링 효과의 과도한 사용이 성능에 영향을 미치는지 확인하세요. 이 옵션이 비활성화되었을 때 성능이 개선된다면, 앱에서 물리적 모델링 효과의 사용을 줄이는 것을 고려해 보세요.

![Screenshot of more debugging options](https://docs.flutter.dev/assets/images/docs/tools/devtools/more-debugging-options.png)

## Import and export

DevTools supports importing and exporting performance snapshots. Clicking the export button (upper-right corner above the frame rendering chart) downloads a snapshot of the current data on the performance page. To import a performance snapshot, you can drag and drop the snapshot into DevTools from any page. **Note that DevTools only supports importing files that were originally exported from DevTools.**

DevTools는 성능 스냅샷의 가져오기 및 내보내기를 지원합니다. 프레임 렌더링 차트 위의 오른쪽 상단에 있는 내보내기 버튼을 클릭하면 성능 페이지의 현재 데이터 스냅샷이 다운로드됩니다. 성능 스냅샷을 가져오려면, DevTools에 스냅샷을 드래그 앤 드롭하면 됩니다. 단, DevTools는 원래 DevTools에서 내보낸 파일만 가져오는 것을 지원합니다.

## Other resources

To learn how to monitor an app's performance and detect jank using DevTools, check out a guided [Performance View tutorial](https://medium.com/@fluttergems/mastering-dart-flutter-devtools-performance-view-part-8-of-8-4ae762f91230).

DevTools를 사용하여 앱의 성능을 모니터링하고 지연(jank)을 감지하는 방법을 배우려면, 가이드 성능 뷰 튜토리얼을 확인하세요._Note_

The CPU profiler view works with Dart CLI and mobile apps only. Use Chrome DevTools to [analyze performance](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/) of a web app.

_정보_

CPU 프로파일러 뷰는 Dart CLI 및 모바일 앱에서만 작동합니다. 웹 앱의 성능을 분석하려면 Chrome DevTools를 사용하세요.

The CPU profiler view allows you to record and profile a session from your Dart or Flutter application. The profiler can help you solve performance problems or generally understand your app's CPU activity. The Dart VM collects CPU samples (a snapshot of the CPU call stack at a single point in time) and sends the data to DevTools for visualization. By aggregating many CPU samples together, the profiler can help you understand where the CPU spends most of its time.

CPU 프로파일러 뷰는 Dart 또는 Flutter 애플리케이션의 세션을 기록하고 프로파일링할 수 있게 해줍니다. 프로파일러는 성능 문제를 해결하거나 애플리케이션의 CPU 활동을 일반적으로 이해하는 데 도움을 줄 수 있습니다. Dart VM은 CPU 샘플(특정 시점의 CPU 호출 스택 스냅샷)을 수집하고, 이 데이터를 DevTools로 전송하여 시각화합니다. 여러 CPU 샘플을 집계함으로써 프로파일러는 CPU가 대부분의 시간을 어디에 쓰고 있는지를 이해하는 데 도움을 줄 수 있습니다.

_Note_

**If you are running a Flutter application, use a profile build to analyze performance.** CPU profiles are not indicative of release performance unless your Flutter application is run in profile mode.

_정보_

Flutter 애플리케이션을 실행 중인 경우, 성능 분석을 위해 프로파일 빌드를 사용하세요. CPU 프로파일은 Flutter 애플리케이션이 프로파일 모드로 실행되지 않는 한 릴리스 성능을 나타내지 않습니다.

## CPU profiler

Start recording a CPU profile by clicking **Record**. When you are done recording, click **Stop**. At this point, CPU profiling data is pulled from the VM and displayed in the profiler views (Call tree, Bottom up, Method table, and Flame chart).

CPU 프로파일을 기록하려면 **Record** 버튼을 클릭하세요. 녹음이 완료되면 **Stop** 버튼을 클릭합니다. 이 시점에서 CPU 프로파일링 데이터가 VM에서 가져와져 프로파일러 뷰(호출 트리, 하향식, 메서드 테이블 및 플레임 차트)에 표시됩니다.

To load all available CPU samples without manually recording and stopping, you can click **Load all CPU samples**, which pulls all CPU samples that the VM has recorded and stored in its ring buffer, and then displays those CPU samples in the profiler views.

수동으로 기록하고 정지하지 않고 모든 사용 가능한 CPU 샘플을 로드하려면 **Load all CPU samples** 버튼을 클릭하세요. 이 버튼은 VM이 기록하고 링 버퍼에 저장한 모든 CPU 샘플을 가져와 프로파일러 뷰에 표시합니다.

### Bottom up

This table provides a bottom-up representation of a CPU profile. This means that each top-level method, or root, in the bottom up table is actually the top method in the call stack for one or more CPU samples. In other words, each top-level method in a bottom up table is a leaf node from the top down table (the call tree). In this table, a method can be expanded to show its _callers_.

이 표는 CPU 프로파일의 하향식(bottom-up) 표현을 제공합니다. 이는 하향식 표의 각 최상위 메서드 또는 루트가 하나 이상의 CPU 샘플에 대한 호출 스택의 최상위 메서드라는 것을 의미합니다. 즉, 하향식 표의 각 최상위 메서드는 상향식(top-down) 표(호출 트리)의 리프 노드입니다. 이 표에서는 메서드를 확장하여 호출자를 확인할 수 있습니다.

This view is useful for identifying expensive _methods_ in a CPU profile. When a root node in this table has a high _self_ time, that means that many CPU samples in this profile ended with that method on top of the call stack.

이 뷰는 CPU 프로파일에서 비싼 메서드를 식별하는 데 유용합니다. 이 표의 루트 노드가 높은 자기 시간(high self time)을 가지면, 이는 이 프로파일의 많은 CPU 샘플이 호출 스택의 최상위에서 해당 메서드로 끝났음을 의미합니다.

![Screenshot of the Bottom up view](https://docs.flutter.dev/assets/images/docs/tools/devtools/bottom-up-view.png) See the [Guidelines](https://docs.flutter.dev/tools/devtools/cpu-profiler#guidelines) section below to learn how to enable the blue and green vertical lines seen in this image.

아래의 가이드라인 섹션을 참조하여 이 이미지에서 볼 수 있는 파란색 및 녹색 수직선을 활성화하는 방법을 알아보세요.

Tooltips can help you understand the values in each column:

툴팁은 각 열의 값을 이해하는 데 도움을 줄 수 있습니다:

**Total time**

For top-level methods in the bottom-up tree (stack frames that were at the top of at least one CPU sample), this is the time the method spent executing its own code, as well as the code for any methods that it called.

하향식 트리의 최상위 메서드(최소 하나의 CPU 샘플에서 최상위에 있었던 스택 프레임)에 대해, 이는 메서드가 자신의 코드를 실행하는 데 소요된 시간과 호출한 모든 메서드의 코드 실행 시간입니다.

**Self time**

For top-level methods in the bottom-up tree (stack frames that were at the top of at least one CPU sample), this is the time the method spent executing only its own code.  

하향식 트리의 최상위 메서드에 대해(최소 하나의 CPU 샘플에서 최상위에 있었던 스택 프레임), 이는 메서드가 오직 자신의 코드를 실행하는 데 소요된 시간입니다.
  
For children methods in the bottom-up tree (the callers), this is the self time of the top-level method (the callee) when called through the child method (the caller).

하향식 트리의 자식 메서드(호출자)에 대해, 이는 자식 메서드(호출자)를 통해 호출된 최상위 메서드(피호출자)의 자기 시간입니다.

**Table element** (self time) ![Screenshot of a bottom up table](https://docs.flutter.dev/assets/images/docs/tools/devtools/table-element.png)

### Call tree

This table provides a top-down representation of a CPU profile. This means that each top-level method in the call tree is a root of one or more CPU samples. In this table, a method can be expanded to show its _callees_.

이 표는 CPU 프로파일의 상향식(top-down) 표현을 제공합니다. 이는 호출 트리의 각 최상위 메서드가 하나 이상의 CPU 샘플의 루트임을 의미합니다. 이 표에서는 메서드를 확장하여 호출된 메서드(피호출자)를 확인할 수 있습니다.

This view is useful for identifying expensive _paths_ in a CPU profile. When a root node in this table has a high _total_ time, that means that many CPU samples in this profile started with that method on the bottom of the call stack.

이 뷰는 CPU 프로파일에서 비싼 경로를 식별하는 데 유용합니다. 이 표의 루트 노드가 높은 총 시간을 가지면, 이는 이 프로파일의 많은 CPU 샘플이 호출 스택의 하단에서 해당 메서드로 시작되었음을 의미합니다.

![Screenshot of a call tree table](https://docs.flutter.dev/assets/images/docs/tools/devtools/call-tree.png) See the [Guidelines](https://docs.flutter.dev/tools/devtools/cpu-profiler#guidelines) section below to learn how to enable the blue and green vertical lines seen in this image.

아래의 가이드라인 섹션을 참조하여 이 이미지에서 볼 수 있는 파란색 및 녹색 수직선을 활성화하는 방법을 알아보세요.

Tooltips can help you understand the values in each column:

툴팁은 각 열의 값을 이해하는 데 도움을 줄 수 있습니다:

**Total time**

Time that a method spent executing its own code as well as the code for any methods it called.

메서드가 자신의 코드와 호출한 모든 메서드의 코드를 실행하는 데 소요된 시간입니다.

**Self time**

Time the method spent executing only its own code.

메서드가 오직 자신의 코드를 실행하는 데 소요된 시간입니다.
### Method table

The method table provides CPU statistics for each method contained in a CPU profile. In the table on the left, all available methods are listed with their **total** and **self** time.

메서드 테이블은 CPU 프로파일에 포함된 각 메서드에 대한 CPU 통계를 제공합니다. 왼쪽 테이블에는 모든 사용 가능한 메서드가 총 시간과 자기 시간과 함께 나열되어 있습니다.

**Total** time is the combined time that a method spent **anywhere** on the call stack, or in other words, the time a method spent executing its own code and any code for methods that it called.

메서드가 호출 스택의 어느 곳에서든 소요한 시간의 합으로, 즉 메서드가 자신의 코드와 호출한 모든 메서드의 코드를 실행하는 데 소요된 시간입니다.

**Self** time is the combined time that a method spent on top of the call stack, or in other words, the time a method spent executing only its own code.

메서드가 호출 스택의 최상위에서 소요한 시간의 합으로, 즉 메서드가 오직 자신의 코드를 실행하는 데 소요된 시간입니다.

![Screenshot of a call tree table](https://docs.flutter.dev/assets/images/docs/tools/devtools/method-table.png)

Selecting a method from the table on the left shows the call graph for that method. The call graph shows a method's callers and callees and their respective caller / callee percentages.

왼쪽 테이블에서 메서드를 선택하면 해당 메서드의 호출 그래프가 표시됩니다. 호출 그래프는 메서드의 호출자와 피호출자, 그리고 각 호출자/피호출자에 대한 비율을 보여줍니다.

### Flame chart

The flame chart view is a graphical representation of the [Call tree](https://docs.flutter.dev/tools/devtools/cpu-profiler#call-tree). This is a top-down view of a CPU profile, so in this chart, the top-most method calls the one below it. The width of each flame chart element represents the amount of time that a method spent on the call stack.

플레임 차트 뷰는 호출 트리의 그래픽 표현입니다. 이는 CPU 프로파일의 상향식(top-down) 뷰로, 이 차트에서 가장 위의 메서드는 그 아래에 있는 메서드를 호출합니다. 각 플레임 차트 요소의 너비는 메서드가 호출 스택에서 소요한 시간을 나타냅니다.

Like the Call tree, this view is useful for identifying expensive paths in a CPU profile.

호출 트리와 마찬가지로 이 뷰는 CPU 프로파일에서 비싼 경로를 식별하는 데 유용합니다.

![Screenshot of a flame chart](https://docs.flutter.dev/assets/images/docs/tools/devtools/cpu-flame-chart.png)

The help menu, which can be opened by clicking the `?` icon next to the search bar, provides information about how to navigate and zoom within the chart and a color-coded legend. 

검색 바 옆에 있는 ? 아이콘을 클릭하여 열 수 있는 도움말 메뉴는 차트 내에서 탐색하고 확대하는 방법에 대한 정보와 색상으로 구분된 범례를 제공합니다.

![Screenshot of flame chart help](https://docs.flutter.dev/assets/images/docs/tools/devtools/flame-chart-help.png)


### CPU sampling rate

DevTools sets a rate at which the VM collects CPU samples: 1 sample / 250 μs (microseconds). This is selected by default on the CPU profiler page as "Cpu sampling rate: medium". This rate can be modified using the selector at the top of the page.



DevTools는 VM이 CPU 샘플을 수집하는 비율을 설정합니다: 1 샘플/250 μs(마이크로초). 이는 CPU 프로파일러 페이지에서 기본적으로 "CPU 샘플링 비율: 중간"으로 선택되어 있습니다. 이 비율은 페이지 상단의 선택기를 사용하여 수정할 수 있습니다.

![Screenshot of cpu sampling rate menu](https://docs.flutter.dev/assets/images/docs/tools/devtools/cpu-sampling-rate-menu.png)

The **low**, **medium**, and **high** sampling rates are 1,000 Hz, 4,000 Hz, and 20,000 Hz, respectively. It's important to know the trade-offs of modifying this setting.

낮음, 중간, 높음 샘플링 비율은 각각 1,000 Hz, 4,000 Hz 및 20,000 Hz입니다. 이 설정을 수정할 때의 트레이드오프를 아는 것이 중요합니다.

A profile that was recorded with a **higher** sampling rate yields a more fine-grained CPU profile with more samples. This might affect performance of your app since the VM is being interrupted more often to collect samples. This also causes the VM's CPU sample buffer to overflow more quickly. The VM has limited space where it can store CPU sample information. At a higher sampling rate, the space fills up and begins to overflow sooner than it would have if a lower sampling rate was used. This means that you might not have access to CPU samples from the beginning of the recorded profile, depending on whether the buffer overflows during the time of recording.

**높은 샘플링 비율**로 기록된 프로파일은 더 많은 샘플을 포함하는 세밀한 CPU 프로파일을 생성합니다. 그러나 이로 인해 VM이 샘플을 수집하기 위해 더 자주 인터럽트되므로 앱의 성능에 영향을 미칠 수 있습니다. 또한, VM의 CPU 샘플 버퍼가 더 빨리 오버플로우하게 됩니다. VM은 CPU 샘플 정보를 저장할 수 있는 공간이 제한되어 있기 때문에, 높은 샘플링 비율에서는 공간이 더 빨리 차고 오버플로우가 시작됩니다. 이는 녹화된 프로파일의 시작 부분에 대한 CPU 샘플에 접근할 수 없게 될 수 있음을 의미합니다.

A profile that was recorded with a lower sampling rate yields a more coarse-grained CPU profile with fewer samples. This affects your app's performance less, but you might have access to less information about what the CPU was doing during the time of the profile. The VM's sample buffer also fills more slowly, so you can see CPU samples for a longer period of app run time. This means that you have a better chance of viewing CPU samples from the beginning of the recorded profile.

**낮은 샘플링 비율**로 기록된 프로파일은 샘플 수가 적은 더 거친 CPU 프로파일을 생성합니다. 이는 앱의 성능에 덜 영향을 미치지만, 프로파일 시간 동안 CPU가 무엇을 하고 있었는지에 대한 정보가 적을 수 있습니다. VM의 샘플 버퍼도 더 천천히 차기 때문에 앱 실행 시간 동안 더 오랜 기간 동안 CPU 샘플을 볼 수 있습니다. 이는 녹화된 프로파일의 시작 부분에 대한 CPU 샘플을 볼 확률이 높아짐을 의미합니다.

### Filtering

When viewing a CPU profile, you can filter the data by library, method name, or [`UserTag`](https://api.flutter.dev/flutter/dart-developer/UserTag-class.html).

CPU 프로파일을 볼 때, 라이브러리, 메서드 이름 또는 UserTag로 데이터를 필터링할 수 있습니다.

![Screenshot of filter by tag menu](https://docs.flutter.dev/assets/images/docs/tools/devtools/filter-by-tag.png)

## Guidelines

When looking at a call tree or bottom up view, sometimes the trees can be very deep. To help with viewing parent-child relationships in a deep tree, enable the **Display guidelines** option. This adds vertical guidelines between parent and child in the tree.

![Screenshot of display options](https://docs.flutter.dev/assets/images/docs/tools/devtools/display-options.png)

## Other resources

To learn how to use DevTools to analyze the CPU usage of a compute-intensive Mandelbrot app, check out a guided [CPU Profiler View tutorial](https://medium.com/@fluttergems/mastering-dart-flutter-devtools-cpu-profiler-view-part-6-of-8-31e24eae6bf8). Also, learn how to analyze CPU usage when the app uses isolates for parallel computing.

계산 집약적인 Mandelbrot 앱의 CPU 사용량을 분석하기 위해 DevTools를 사용하는 방법을 배우려면 **CPU 프로파일러 보기** 튜토리얼을 확인하세요. 또한 앱이 병렬 컴퓨팅을 위해 **isolates**를 사용할 때 CPU 사용량을 분석하는 방법도 배워보세요.

The memory view provides insights into details of the application's memory allocation and tools to detect and debug specific issues.

메모리 뷰는 애플리케이션의 메모리 할당에 대한 세부 정보를 제공하고 특정 문제를 탐지하고 디버깅할 수 있는 도구를 제공합니다.

_Note_

This page is up to date for DevTools 2.23.0.

For information on how to locate DevTools screens in different IDEs, check out the [DevTools overview](https://docs.flutter.dev/tools/devtools).

다양한 IDE에서 DevTools 화면을 찾는 방법에 대한 정보는 **DevTools 개요**를 확인하세요.

To better understand the insights found on this page, the first section explains how Dart manages memory. If you already understand Dart's memory management, you can skip to the [Memory view guide](https://docs.flutter.dev/tools/devtools/memory#memory-view-guide).

이 페이지에서 제공되는 통찰력을 더 잘 이해하기 위해, 첫 번째 섹션에서는 Dart의 메모리 관리 방법을 설명합니다. Dart의 메모리 관리에 대해 이미 이해하고 있다면, **메모리 뷰 가이드**로 바로 넘어가도 됩니다.

## Reasons to use the memory view

Use the memory view for preemptive memory optimization or when your application experiences one of the following conditions:

- Crashes when it runs out of memory
- Slows down
- Causes the device to slow down or become unresponsive
- Shuts down because it exceeded the memory limit, enforced by operating system
- Exceeds memory usage limit
    - This limit can vary depending on the type of devices your app targets.
- Suspect a memory leak

메모리 뷰는 다음과 같은 조건이 발생할 때 선제적인 메모리 최적화에 사용하거나 애플리케이션이 다음과 같은 문제를 겪을 때 사용할 수 있습니다:

- 메모리가 부족할 때 애플리케이션이 크래시됨
- 애플리케이션이 느려짐
- 장치가 느려지거나 반응하지 않음
- 운영 체제에서 설정한 메모리 한도를 초과하여 종료됨
- 메모리 사용 한도를 초과함 (이 한도는 앱이 타겟으로 하는 장치 유형에 따라 다를 수 있음)
- 메모리 누수가 의심됨

## Basic memory concepts

Dart objects created using a class constructor (for example, by using `MyClass()`) live in a portion of memory called the _heap_. The memory in the heap is managed by the Dart VM (virtual machine). The Dart VM allocates memory for the object at the moment of the object creation, and releases (or deallocates) the memory when the object is no longer used (see [Dart garbage collection](https://medium.com/flutter/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30)).

클래스 생성자를 사용하여 생성된 Dart 객체(예: MyClass()를 사용하여)는 힙이라고 하는 메모리 영역에 존재합니다. 힙의 메모리는 Dart VM(가상 머신)에 의해 관리됩니다. Dart VM은 객체가 생성되는 순간 객체를 위한 메모리를 할당하고, 객체가 더 이상 사용되지 않을 때 메모리를 해제(또는 비할당)합니다(자세한 내용은 Dart 가비지 컬렉션 참조).
### Object types

#### Disposable object

A disposable object is any Dart object that defines a `dispose()` method. To avoid memory leaks, invoke `dispose` when the object isn't needed anymore.

디스포저블 객체는 dispose() 메서드를 정의한 모든 Dart 객체를 말합니다. 메모리 누수를 피하기 위해, 객체가 더 이상 필요하지 않을 때 dispose를 호출해야 합니다.
#### Memory-risky object

A memory-risky object is an object that _might_ cause a memory leak, if it is not disposed properly or disposed but not GCed.

메모리 위험 객체는 적절히 디스포즈되지 않거나 디스포즈되었지만 가비지 컬렉션(GC)이 수행되지 않을 경우 메모리 누수를 초래할 수 있는 객체입니다.

### Root object, retaining path, and reachability

#### Root object

Every Dart application creates a _root object_ that references, directly or indirectly, all other objects the application allocates.

모든 Dart 애플리케이션은 애플리케이션이 할당하는 모든 객체를 직접적이거나 간접적으로 참조하는 루트 객체를 생성합니다.
#### Reachability

If, at some moment of the application run, the root object stops referencing an allocated object, the object becomes _unreachable_, which is a signal for the garbage collector (GC) to deallocate the object's memory.

애플리케이션 실행 중 어떤 순간에 루트 객체가 할당된 객체를 더 이상 참조하지 않게 되면, 그 객체는 도달할 수 없는 상태가 되어 쓰레기 수집기(GC)가 해당 객체의 메모리를 해제하라는 신호가 됩니다.

#### Retaining path

The sequence of references from root to an object is called the object's _retaining_ path, as it retains the object's memory from the garbage collection. One object can have many retaining paths. Objects with at least one retaining path are called _reachable_ objects.

루트에서 객체로의 참조 순서를 "객체의 유지 경로"라고 하며, 이는 쓰레기 수집으로부터 객체의 메모리를 유지합니다. 하나의 객체는 여러 개의 유지 경로를 가질 수 있습니다. 최소한 하나의 유지 경로를 가진 객체는 "도달 가능한 객체"라고 합니다.
#### Example

The following example illustrates the concepts:

다음 예제는 이러한 개념을 설명합니다:

```dart
class Child{}

class Parent {
  Child? child;
}

Parent parent1 = Parent();

void myFunction() {

  Child? child = Child();

  // The `child` object was allocated in memory.
  // It's now retained from garbage collection
  // by one retaining path (root …-> myFunction -> child).

  Parent? parent2 = Parent()..child = child;
  parent1.child = child;

  // At this point the `child` object has three retaining paths:
  // root …-> myFunction -> child
  // root …-> myFunction -> parent2 -> child
  // root -> parent1 -> child

  child = null;
  parent1.child = null;
  parent2 = null;

  // At this point, the `child` instance is unreachable
  // and will eventually be garbage collected.

  …
}
```

### Shallow size vs retained size

**Shallow size** includes only the size of the object and its references, while **retained size** also includes the size of the retained objects.

얕은 크기는 객체와 그 참조의 크기만 포함되는 반면, 유지 크기는 유지된 객체의 크기도 포함됩니다.

The **retained size** of the root object includes all reachable Dart objects.

루트 객체의 유지 크기는 모든 도달 가능한 Dart 객체를 포함합니다.

In the following example, the size of `myHugeInstance` isn't part of the parent's or child's shallow sizes, but is part of their retained sizes:

다음 예제에서, `myHugeInstance`의 크기는 부모 또는 자식의 얕은 크기의 일부가 아니지만, 그들의 유지 크기의 일부입니다:

```dart
class Child{
  /// The instance is part of both [parent] and [parent.child]
  /// retained sizes.
  final myHugeInstance = MyHugeInstance();
}

class Parent {
  Child? child;
}

Parent parent = Parent()..child = Child();
```

In DevTools calculations, if an object has more than one retaining path, its size is assigned as retained only to the members of the shortest retaining path.

DevTools 계산에서, 객체가 하나 이상의 유지 경로를 가지면, 해당 객체의 크기는 가장 짧은 유지 경로에 있는 구성원에게만 유지 크기로 할당됩니다.

In this example the object `x` has two retaining paths:

이 예제에서 객체 `x`는 두 개의 유지 경로를 가지고 있습니다:

```
root -> a -> b -> c -> x
root -> d -> e -> x (shortest retaining path to `x`)
```

Only members of the shortest path (`d` and `e`) will include `x` into their retaining size.

가장 짧은 경로의 구성원(d와 e)만이 x를 그들의 유지 크기에 포함하게 됩니다.
### Memory leaks happen in Dart?

Garbage collector cannot prevent all types of memory leaks, and developers still need to watch objects to have leak-free lifecycle.

가비지 수집기는 모든 유형의 메모리 누수를 방지할 수 없으며, 개발자는 여전히 누수가 없는 생애 주기를 유지하기 위해 객체를 주의 깊게 살펴봐야 합니다.
#### Why can't the garbage collector prevent all leaks?

While the garbage collector takes care of all unreachable objects, it's the responsibility of the application to ensure that unneeded objects are no longer reachable (referenced from the root).

가비지 수집기가 모든 도달할 수 없는 객체를 처리하는 동안, 불필요한 객체가 더 이상 도달할 수 없도록 (루트에서 참조되지 않도록) 보장하는 것은 애플리케이션의 책임입니다.

So, if non-needed objects are left referenced (in a global or static variable, or as a field of a long-living object), the garbage collector can't recognize them, the memory allocation grows progressively, and the app eventually crashes with an `out-of-memory` error.

따라서 필요 없는 객체가 전역 변수, 정적 변수 또는 장기 생명 객체의 필드로 남아 있으면 가비지 수집기는 이를 인식할 수 없게 되며, 메모리 할당이 점진적으로 증가하고 결국 앱이 메모리 부족 오류로 인해 충돌하게 됩니다.

#### Why closures require extra attention

One hard-to-catch leak pattern relates to using closures. In the following code, a reference to the designed-to-be short-living `myHugeObject` is implicitly stored in the closure context and passed to `setHandler`. As a result, `myHugeObject` won't be garbage collected as long as `handler` is reachable.

잡기 어려운 메모리 누수 패턴 중 하나는 클로저를 사용할 때 발생합니다. 다음 코드에서, 짧은 생명주기를 가지도록 설계된 `myHugeObject`에 대한 참조가 클로저 컨텍스트에 암시적으로 저장되고 `setHandler`에 전달됩니다. 그 결과, `handler`가 도달할 수 있는 한 `myHugeObject`는 가비지 수집되지 않습니다.

```dart
  final handler = () => print(myHugeObject.name);
  setHandler(handler);
```

#### Why `BuildContext` requires extra attention

An example of a large, short-living object that might squeeze into a long-living area and thus cause leaks, is the `context` parameter passed to Flutter's `build` method.

Flutter의 `build` 메서드에 전달되는 `context` 매개변수는 큰 짧은 생명주기를 가지는 객체의 예로, 장기 생명 주기 영역에 들어가서 누수를 일으킬 수 있습니다.

The following code is leak prone, as `useHandler` might store the handler in a long-living area:

다음 코드는 `useHandler`가 핸들러를 장기 생명 주기 영역에 저장할 수 있기 때문에 누수에 취약합니다.

```dart
// BAD: DO NOT DO THIS
// This code is leak prone:
@override
Widget build(BuildContext context) {
  final handler = () => apply(Theme.of(context));
  useHandler(handler);
…
```

#### How to fix leak prone code?

The following code is not leak prone, because:

1. The closure doesn't use the large and short-living `context` object.
2. The `theme` object (used instead) is long-living. It is created once and shared between `BuildContext` instances.

다음 코드는 누수 발생 가능성이 없습니다. 그 이유는:

1. 클로저가 크고 짧은 생명 주기의 `context` 객체를 사용하지 않습니다.
2. 대신 사용된 `theme` 객체는 장기 생명 주기입니다. 이 객체는 한 번 생성되어 `BuildContext` 인스턴스 간에 공유됩니다.

```dart
// GOOD
@override
Widget build(BuildContext context) {
  final theme = Theme.of(context);
  final handler = () => apply(theme);
  useHandler(handler);
…
```

#### General rule for `BuildContext`

In general, use the following rule for a `BuildContext`: if the closure doesn't outlive the widget, it's ok to pass the context to the closure.

일반적으로 `BuildContext`에 대한 다음 규칙을 사용하세요: 클로저가 위젯보다 오래 지속되지 않는다면, `context`를 클로저에 전달하는 것이 괜찮습니다.

Stateful widgets require extra attention. They consist of two classes: the [widget and the widget state](https://docs.flutter.dev/ui/interactivity#creating-a-stateful-widget), where the widget is short living, and the state is long living. The build context, owned by the widget, should never be referenced from the state's fields, as the state won't be garbage collected together with the widget, and can significantly outlive it.

상태가 있는 위젯(Stateful widgets)은 추가적인 주의가 필요합니다. 이들은 두 개의 클래스로 구성되어 있습니다: 위젯(Widget)과 위젯 상태(State)입니다. 여기서 위젯은 짧은 생명 주기를 가지며, 상태는 긴 생명 주기를 가집니다. 위젯이 소유한 `build context`는 상태의 필드에서 참조해서는 안 됩니다. 왜냐하면 상태는 위젯과 함께 가비지 컬렉션되지 않으며, 위젯보다 상당히 더 오래 지속될 수 있기 때문입니다.

### Memory leak vs memory bloat

In a memory leak, an application progressively uses memory, for example, by repeatedly creating a listener, but not disposing it.

메모리 누수(memory leak)에서는 애플리케이션이 메모리를 점진적으로 사용하게 됩니다. 예를 들어, 리스너를 반복적으로 생성하지만 이를 해제하지 않을 때 발생합니다.

Memory bloat uses more memory than is necessary for optimal performance, for example, by using overly large images or keeping streams open through their lifetime.

메모리 팽창(memory bloat)은 최적의 성능을 위해 필요한 것보다 더 많은 메모리를 사용합니다. 예를 들어, 과도하게 큰 이미지를 사용하거나 스트림을 생애 동안 열어두는 경우가 이에 해당합니다.

Both leaks and bloats, when large, cause an application to crash with an `out-of-memory` error. However, leaks are more likely to cause memory issues, because even a small leak, if repeated many times, leads to a crash.

누수와 팽창 모두 심각할 경우 애플리케이션이 메모리 부족 오류(out-of-memory error)로 크래시를 일으킬 수 있습니다. 그러나 누수는 작은 누수라도 반복적으로 발생할 수 있기 때문에 메모리 문제를 일으킬 가능성이 더 높습니다.

## Memory view guide

The DevTools memory view helps you investigate memory allocations (both in the heap and external), memory leaks, memory bloat, and more. The view has the following features:

[**Expandable chart**](https://docs.flutter.dev/tools/devtools/memory#expandable-chart)

Get a high-level trace of memory allocation, and view both standard events (like garbage collection) and custom events (like image allocation).

[**Profile Memory** tab](https://docs.flutter.dev/tools/devtools/memory#profile-memory-tab)

See current memory allocation listed by class and memory type.

[**Diff Snapshots** tab](https://docs.flutter.dev/tools/devtools/memory#diff-snapshots-tab)

Detect and investigate a feature's memory management issues.

[**Trace Instances** tab](https://docs.flutter.dev/tools/devtools/memory#trace-instances-tab)

Investigate a feature's memory management for a specified set of classes.

DevTools의 메모리 뷰는 메모리 할당(힙과 외부 모두), 메모리 누수, 메모리 팽창 등을 조사하는 데 도움을 줍니다. 이 뷰는 다음과 같은 기능을 제공합니다:

**확장 가능한 차트**: 메모리 할당의 고급 추적을 제공하며, 가비지 수집과 같은 표준 이벤트와 이미지 할당과 같은 사용자 정의 이벤트를 모두 볼 수 있습니다.

**메모리 프로파일 탭**: 클래스 및 메모리 유형별로 현재 메모리 할당을 나열합니다.

**스냅샷 차이 탭**: 기능의 메모리 관리 문제를 감지하고 조사합니다.

**인스턴스 추적 탭**: 지정된 클래스 집합에 대한 기능의 메모리 관리를 조사합니다.
### Expandable chart

The expandable chart provides the following features:

확장 가능한 차트는 다음과 같은 기능을 제공합니다:
#### Memory anatomy

A timeseries graph visualizes the state of Flutter memory at successive intervals of time. Each data point on the chart corresponds to the timestamp (x-axis) of measured quantities (y-axis) of the heap. For example, usage, capacity, external, garbage collection, and resident set size are captured.

시계열 그래프는 Flutter 메모리의 상태를 시간의 연속적인 간격에서 시각화합니다. 차트의 각 데이터 포인트는 측정된 양(예: 사용량, 용량, 외부 메모리, 가비지 수집, 상주 집합 크기)의 타임스탬프(x축)를 나타냅니다. 이러한 메모리 지표를 통해 앱의 메모리 사용 패턴과 성능 문제를 분석하고 진단하는 데 도움을 줍니다.

![Screenshot of a memory anatomy page](https://docs.flutter.dev/assets/images/docs/tools/devtools/memory_chart_anatomy.png)

#### Memory overview chart

The memory overview chart is a timeseries graph of collected memory statistics. It visually presents the state of the Dart or Flutter heap and Dart's or Flutter's native memory over time.

메모리 개요 차트는 수집된 메모리 통계의 시계열 그래프입니다. 이 차트는 Dart 또는 Flutter의 힙과 Dart 또는 Flutter의 네이티브 메모리 상태를 시간에 따라 시각적으로 표현합니다.

The chart's x-axis is a timeline of events (timeseries). The data plotted in the y-axis all has a timestamp of when the data was collected. In other words, it shows the polled state (capacity, used, external, RSS (resident set size), and GC (garbage collection)) of the memory every 500 ms. This helps provide a live appearance on the state of the memory as the application is running.

차트의 x축은 이벤트의 타임라인(시계열)이며, y축에 플로팅된 데이터는 모두 데이터가 수집된 시점의 타임스탬프를 가지고 있습니다. 즉, 메모리의 상태(용량, 사용량, 외부 메모리, RSS(상주 집합 크기), GC(가비지 수집))를 500ms마다 조사하여 보여줍니다. 이는 애플리케이션이 실행되는 동안 메모리 상태에 대한 실시간 정보를 제공합니다.

Clicking the **Legend** button displays the collected measurements, symbols, and colors used to display the data.

Legend 버튼을 클릭하면 수집된 측정값, 기호 및 데이터를 표시하는 데 사용되는 색상을 확인할 수 있습니다.

![Screenshot of a memory anatomy page](https://docs.flutter.dev/assets/images/docs/tools/devtools/memory_chart_anatomy.png)

The **Memory Size Scale** y-axis automatically adjusts to the range of data collected in the current visible chart range.

메모리 크기 척도 y축은 현재 표시된 차트 범위에 수집된 데이터의 범위에 맞게 자동으로 조정됩니다.

The quantities plotted on the y-axis are as follows:

**Dart/Flutter Heap**

Objects (Dart and Flutter objects) in the heap.

**Dart/Flutter Native**

Memory that isn't in the Dart/Flutter heap but is still part of the total memory footprint. Objects in this memory would be native objects (for example, from reading a file into memory, or a decoded image). The native objects are exposed to the Dart VM from the native OS (such as Android, Linux, Windows, iOS) using a Dart embedder. The embedder creates a Dart wrapper with a finalizer, allowing Dart code to communicate with these native resources. Flutter has an embedder for Android and iOS. For more information, see [Command-line and server apps](https://dart.dev/server), [Dart on the server with Dart Frog](https://dartfrog.vgv.dev/), [Custom Flutter Engine Embedders](https://github.com/flutter/engine/blob/main/docs/Custom-Flutter-Engine-Embedders.md), [Dart web server deployment with Heroku](https://www.youtube.com/watch?v=nkTUMVNelXA).

**Timeline**

The timestamps of all collected memory statistics and events at a particular point in time (timestamp).

**Raster Cache**

The size of the Flutter engine's raster cache layer(s) or picture(s), while performing the final rendering after compositing. For more information, see the [Flutter architectural overview](https://docs.flutter.dev/resources/architectural-overview) and [DevTools Performance view](https://docs.flutter.dev/tools/devtools/performance).

**Allocated**

The current capacity of the heap is typically slightly larger than the total size of all heap objects.

**RSS - Resident Set Size**

The resident set size displays the amount of memory for a process. It doesn't include memory that is swapped out. It includes memory from shared libraries that are loaded, as well as all stack and heap memory. For more information, see [Dart VM internals](https://mrale.ph/dartvm/).

y축에 플로팅된 수량은 다음과 같습니다:

 **Dart/Flutter Heap**
 
 힙에 있는 객체(Dart 및 Flutter 객체).
 
**Dart/Flutter Native**

Dart/Flutter 힙에 포함되지 않지만 여전히 총 메모리 사용량의 일부인 메모리. 이 메모리에 있는 객체는 파일을 메모리로 읽거나 디코딩된 이미지와 같은 네이티브 객체입니다. 네이티브 객체는 Dart embedder를 사용하여 네이티브 OS(예: Android, Linux, Windows, iOS)에서 Dart VM에 노출됩니다. Embedder는 최종화기를 갖춘 Dart 래퍼를 생성하여 Dart 코드가 이러한 네이티브 리소스와 통신할 수 있도록 합니다. Flutter는 Android 및 iOS용 embedder를 제공합니다. 자세한 내용은 명령줄 및 서버 앱, Dart Frog를 사용하는 서버의 Dart, 커스텀 Flutter 엔진 embedder, Heroku와 함께하는 Dart 웹 서버 배포를 참조하세요.
**Timeline**

특정 시점(타임스탬프)에서 수집된 모든 메모리 통계 및 이벤트의 타임스탬프.

**Raster Cache**

최종 렌더링을 수행하는 동안 Flutter 엔진의 래스터 캐시 레이어(또는 그림)의 크기. 자세한 내용은 Flutter 아키텍처 개요 및 DevTools 성능 보기 를 참조하세요.

**Allocated**

힙의 현재 용량은 일반적으로 모든 힙 객체의 총 크기보다 약간 더 큽니다.

**RSS - Resident Set Size**

레지던트 집합 크기는 프로세스의 메모리 양을 표시합니다. 스왑된 메모리는 포함되지 않습니다. 로드된 공유 라이브러리의 메모리뿐만 아니라 모든 스택 및 힙 메모리가 포함됩니다. 자세한 내용은 Dart VM 내부를 참조하세요.

### Profile Memory tab

Use the **Profile Memory** tab to see current memory allocation by class and memory type. For a deeper analysis in Google Sheets or other tools, download the data in CSV format. Toggle **Refresh on GC**, to see allocation in real time.

**Profile Memory 탭**을 사용하여 클래스 및 메모리 유형별로 현재 메모리 할당을 확인할 수 있습니다. Google Sheets 또는 다른 도구에서 더 깊이 있는 분석을 위해 CSV 형식으로 데이터를 다운로드할 수 있습니다. **Refresh on GC**를 켜면 실시간으로 할당을 확인할 수 있습니다.

![Screenshot of the profile tab page](https://docs.flutter.dev/assets/images/docs/tools/devtools/profile-tab-2.png)

### Diff Snapshots tab

Use the **Diff Snapshots** tab to investigate a feature's memory management. Follow the guidance on the tab to take snapshots before and after interaction with the application, and diff the snapshots:

**Diff Snapshots 탭**을 사용하여 기능의 메모리 관리를 조사할 수 있습니다. 탭의 지침에 따라 애플리케이션과 상호작용하기 전과 후에 스냅샷을 찍고, 스냅샷을 비교(diff)하세요. 이를 통해 메모리 사용량의 변화를 분석하고, 메모리 누수나 비효율적인 메모리 사용을 식별할 수 있습니다.

![Screenshot of the diff tab page](https://docs.flutter.dev/assets/images/docs/tools/devtools/diff-tab.png)

Tap the **Filter classes and packages** button, to narrow the data:

`Filter classes and packages` 버튼을 눌러 데이터를 좁힐 수 있습니다.

![Screenshot of the filter options ui](https://docs.flutter.dev/assets/images/docs/tools/devtools/filter-ui.png)

For a deeper analysis in Google Sheets or other tools, download the data in CSV format.

더 깊이 있는 분석을 위해 Google Sheets나 다른 도구에서 사용할 수 있도록 데이터를 CSV 형식으로 다운로드할 수 있습니다.

### Trace Instances tab

Use the **Trace Instances** tab to investigate what methods allocate memory for a set of classes during feature execution:

1. Select classes to trace
2. Interact with your app to trigger the code you are interested in
3. Tap **Refresh**
4. Select a traced class
5. Review the collected data

**Trace Instances 탭을 사용하여 특정 클래스의 메서드가 피처 실행 중에 메모리를 할당하는 방식을 조사하는 방법:**

1. **클래스 선택:** 추적하고 싶은 클래스를 선택합니다.
2. **앱과 상호작용:** 관심 있는 코드를 트리거하기 위해 앱을 조작합니다.
3. **새로 고침 클릭:** 메모리 할당을 새로 고치고 최신 데이터를 수집합니다.
4. **추적된 클래스 선택:** 수집된 데이터에서 추적할 클래스를 선택합니다.
5. **수집된 데이터 검토:** 수집된 데이터를 검토하여 메모리 할당과 관련된 정보를 분석합니다.

![Screenshot of a trace tab](https://docs.flutter.dev/assets/images/docs/tools/devtools/trace-instances-tab.png)

#### Bottom up vs call tree view

Switch between bottom-up and call tree views depending on specifics of your tasks.

작업의 세부 사항에 따라 하향식 및 호출 트리 보기 간에 전환하기.

![Screenshot of a trace allocations](https://docs.flutter.dev/assets/images/docs/tools/devtools/trace-view.png)

The call tree view shows the method allocations for each instance. The view is a top-down representation of the call stack, meaning that a method can be expanded to show its callees.

호출 트리 보기는 각 인스턴스의 메서드 할당을 보여줍니다. 이 보기는 호출 스택의 상향식 표현으로, 메서드를 확장하여 해당 메서드가 호출하는 하위 메서드를 표시할 수 있습니다.

The bottom-up view shows the list of different call stacks that have allocated the instances.

하향식 보기에서는 인스턴스를 할당한 다양한 호출 스택 목록이 표시됩니다.
## Other resources

For more information, check out the following resources:

- To learn how to monitor an app's memory usage and detect memory leaks using DevTools, check out a guided [Memory View tutorial](https://medium.com/@fluttergems/mastering-dart-flutter-devtools-memory-view-part-7-of-8-e7f5aaf07e15).
- To understand Android memory structure, check out [Android: Memory allocation among processes](https://developer.android.com/topic/performance/memory-management).

자세한 정보는 다음 리소스를 확인하세요:

- DevTools를 사용하여 앱의 메모리 사용량을 모니터링하고 메모리 누수를 감지하는 방법을 배우려면 가이드 메모리 보기 튜토리얼을 확인하세요.
- Android의 메모리 구조를 이해하려면 [Android: 프로세스 간 메모리 할당](https://developer.android.com/topic/performance/memory#memory-allocation) 을 확인하세요.

The DevTools Debug console allows you to watch an application's standard output (`stdout`), evaluate expressions for a paused or running app in debug mode, and analyze inbound and outbound references for objects.

DevTools 디버그 콘솔은 애플리케이션의 표준 출력(`stdout`)을 모니터링하고, 디버그 모드에서 일시 정지된 또는 실행 중인 앱에 대한 표현식을 평가하며, 객체에 대한 인바운드 및 아웃바운드 참조를 분석할 수 있게 해줍니다.

_Note_

This page is up to date for DevTools 2.23.0.

The Debug console is available from the [Inspector](https://docs.flutter.dev/tools/devtools/inspector), [Debugger](https://docs.flutter.dev/tools/devtools/debugger), and [Memory](https://docs.flutter.dev/tools/devtools/memory) views.

디버그 콘솔은 인스펙터, 디버거 및 메모리 뷰에서 사용할 수 있습니다.
## Watch application output

The console shows the application's standard output (`stdout`):

콘솔은 애플리케이션의 표준 출력(stdout)을 표시합니다:

![Screenshot of stdout in Console view](https://docs.flutter.dev/assets/images/docs/tools/devtools/console-stdout.png)

## Explore inspected widgets

If you click a widget on the **Inspector** screen, the variable for this widget displays in the **Console**:

Inspector 화면에서 위젯을 클릭하면, 이 위젯에 대한 변수가 콘솔에 표시됩니다:

![Screenshot of inspected widget in Console view](https://docs.flutter.dev/assets/images/docs/tools/devtools/console-inspect-widget.png)

## Evaluate expressions

In the console, you can evaluate expressions for a paused or running application, assuming that you are running your app in debug mode:

콘솔에서는 애플리케이션이 일시 정지되었거나 실행 중일 때, 앱이 디버그 모드에서 실행되고 있다고 가정하면 표현식을 평가할 수 있습니다:


![Screenshot showing evaluating an expression in the console](https://docs.flutter.dev/assets/images/docs/tools/devtools/console-evaluate-expressions.png)

To assign an evaluated object to a variable, use `$0`, `$1` (through `$5`) in the form of `var x = $0`:

평가된 객체를 변수에 할당하려면 var x = $0 형식에서 $0, $1(최대 $5)를 사용합니다:

![Screenshot showing how to evaluate variables](https://docs.flutter.dev/assets/images/docs/tools/devtools/console-evaluate-variables.png)

## Browse heap snapshot

To drop a variable to the console from a heap snapshot, do the following:

1. Navigate to **Devtools > Memory > Diff Snapshots**.
2. Record a memory heap snapshot.
3. Click on the context menu `[⋮]` to view the number of **Instances** for the desired **Class**.
4. Select whether you want to store a single instance as a console variable, or whether you want to store _all_ currently alive instances in the app.

힙 스냅샷에서 변수를 콘솔로 드롭하려면 다음 단계를 따르세요:

1. Devtools > Memory > Diff Snapshots로 이동합니다.
2. 메모리 힙 스냅샷을 기록합니다.
3. 원하는 클래스의 인스턴스 수를 보려면 컨텍스트 메뉴 [⋮]를 클릭합니다.
4. 콘솔 변수로 단일 인스턴스를 저장할지, 현재 앱에서 살아 있는 모든 인스턴스를 저장할지를 선택합니다.

![Screenshot showing how to browse the heap snapshots](https://docs.flutter.dev/assets/images/docs/tools/devtools/browse-heap-snapshot.png)

The Console screen displays both live and static inbound and outbound references, as well as field values:

콘솔 화면은 실시간 및 정적의 인바운드 및 아웃바운드 참조와 필드 값을 모두 표시합니다.

![Screenshot showing inbound and outbound references in Console](https://docs.flutter.dev/assets/images/docs/tools/devtools/console-references.png)

## What is it?

The network view allows you to inspect HTTP, HTTPS, and web socket traffic from your Dart or Flutter application.

네트워크 보기는 Dart 또는 Flutter 애플리케이션의 HTTP, HTTPS 및 웹 소켓 트래픽을 검사할 수 있도록 해줍니다.

![Screenshot of the network screen](https://docs.flutter.dev/assets/images/docs/tools/devtools/network_screenshot.png)

## How to use it

Network traffic should be recording by default when you open the Network page. If it is not, click the **Resume** button in the upper left to begin polling.

네트워크 페이지를 열면 기본적으로 네트워크 트래픽이 기록되어야 합니다. 기록되지 않는 경우, 왼쪽 상단의 Resume 버튼을 클릭하여 polling을 시작하세요.

Select a network request from the table (left) to view details (right). You can inspect general and timing information about the request, as well as the content of response and request headers and bodies.

테이블(왼쪽)에서 네트워크 요청을 선택하면 세부정보(오른쪽)를 볼 수 있습니다. 요청에 대한 일반 정보 및 타이밍 정보를 검사할 수 있으며, 응답 및 요청 헤더와 본문의 내용도 확인할 수 있습니다.

### Search and filtering

You can use the search and filter controls to find a specific request or filter requests out of the request table.

검색 및 필터 컨트롤을 사용하여 특정 요청을 찾거나 요청 테이블에서 요청을 필터링할 수 있습니다.

![Screenshot of the network screen](https://docs.flutter.dev/assets/images/docs/tools/devtools/network_search_and_filter.png)

To apply a filter, press the filter button (right of the search bar). You will see a filter dialog pop up:

필터를 적용하려면 검색 바 오른쪽에 있는 필터 버튼을 누르세요. 그러면 필터 대화 상자가 나타납니다.

![Screenshot of the network screen](https://docs.flutter.dev/assets/images/docs/tools/devtools/network_filter_dialog.png)

The filter query syntax is described in the dialog. You can filter network requests by the following keys:

- `method`, `m`: this filter corresponds to the value in the "Method" column
- `status`, `s`: this filter corresponds to the value in the "Status" column
- `type`, `t`: this filter corresponds to the value in the "Type" column

필터 쿼리 구문은 대화 상자에 설명되어 있습니다. 다음 키를 사용하여 네트워크 요청을 필터링할 수 있습니다:

- **method, m**: 이 필터는 "Method" 열의 값에 해당합니다.
- **status, s**: 이 필터는 "Status" 열의 값에 해당합니다.
- **type, t**: 이 필터는 "Type" 열의 값에 해당합니다.

Any text that is not paired with an available filter key will be queried against all categories (method, uri, status, type).

사용 가능한 필터 키와 쌍이 아닌 모든 텍스트는 모든 카테고리(메서드, URI, 상태, 유형)에 대해 쿼리됩니다.

Example filter queries:

예시 필터 쿼리:
```
my-endpoint m:get t:json s:200
```



```
https s:404
```



### Recording network requests on app startup

[#](https://docs.flutter.dev/tools/devtools/network#recording-network-requests-on-app-startup)

To record network traffic on app startup, you can start your app in a paused state, and then begin recording network traffic in DevTools before resuming your app.

1. Start your app in a paused state:
    - `flutter run --start-paused ...`
    - `dart run --pause-isolates-on-start --observe ...`
2. Open DevTools from the IDE where you started your app, or from the link that was printed to the command line if you started your app from the CLI.
3. Navigate to the Network screen and ensure that recording has started.
4. Resume your app. 

앱 시작 시 네트워크 트래픽을 기록하려면 앱을 일시 중지 상태에서 시작한 다음, 앱을 재개하기 전에 DevTools에서 네트워크 트래픽 기록을 시작하면 됩니다.

1. 앱을 일시 중지 상태에서 시작하는 방법:
	`flutter run --start-paused ...`
	`dart run --pause-isolates-on-start --observe ...`
2. 앱을 시작한 IDE에서 DevTools를 엽니다. CLI에서 앱을 시작한 경우, 명령줄에 인쇄된 링크를 통해 DevTools를 열 수 있습니다.
3. 네트워크 화면으로 이동하고 기록이 시작되었는지 확인합니다.
4. 앱을 재개합니다.

![Screenshot of the app resumption experience on the Network screen](https://docs.flutter.dev/assets/images/docs/tools/devtools/network_startup_resume.png)
5. The Network profiler will now record all network traffic from your app, including traffic from app startup.
5. 이제 네트워크 프로파일러가 앱의 모든 네트워크 트래픽을 기록합니다. 여기에는 앱 시작 시의 트래픽도 포함됩니다.
## Other resources

HTTP and HTTPs requests are also surfaced in the [Timeline](https://docs.flutter.dev/tools/devtools/performance#timeline-events-tab) as asynchronous timeline events. Viewing network activity in the timeline can be useful if you want to see how HTTP traffic aligns with other events happening in your app or in the Flutter framework.

HTTP 및 HTTPS 요청은 또한 타임라인에서 비동기 타임라인 이벤트로 나타납니다. 타임라인에서 네트워크 활동을 보는 것은 HTTP 트래픽이 앱이나 Flutter 프레임워크에서 발생하는 다른 이벤트와 어떻게 일치하는지를 확인하는 데 유용할 수 있습니다.

To learn how to monitor an app's network traffic and inspect different types of requests using the DevTools, check out a guided [Network View tutorial](https://medium.com/@fluttergems/mastering-dart-flutter-devtools-network-view-part-4-of-8-afce2463687c). The tutorial also uses the view to identify network activity that causes poor app performance.

앱의 네트워크 트래픽을 모니터링하고 DevTools를 사용하여 다양한 유형의 요청을 검사하는 방법을 배우려면, 안내된 네트워크 뷰 튜토리얼을 확인하세요. 이 튜토리얼에서는 앱 성능 저하를 유발하는 네트워크 활동을 식별하기 위해 이 뷰를 사용하는 방법도 다룹니다.

_Note_

DevTools hides the Debugger tab if the app was launched from VS Code because VS Code has a built-in debugger.

_정보_

DevTools는 VS Code에서 앱이 시작된 경우 Debugger 탭을 숨깁니다. 이는 VS Code에 내장된 디버거가 있기 때문입니다.
## Getting started

DevTools includes a full source-level debugger, supporting breakpoints, stepping, and variable inspection.

DevTools는 전체 소스 수준 디버거를 포함하고 있으며, 중단점 설정, 코드 실행 단계별 진행, 변수 검사 기능을 지원합니다.

_Note_

The debugger works with all Flutter and Dart applications. If you are looking for a way to use GDB to remotely debug the Flutter engine running within an Android app process, check out [`flutter_gdb`](https://github.com/flutter/engine/blob/main/sky/tools/flutter_gdb).

_정보_

디버거는 모든 Flutter 및 Dart 애플리케이션과 함께 작동합니다. Android 앱 프로세스 내에서 실행되는 Flutter 엔진을 원격으로 디버그하는 방법을 찾고 있다면, `flutter_gdb`를 확인해보세요.

When you open the debugger tab, you should see the source for the main entry-point for your app loaded in the debugger.

디버거 탭을 열면 애플리케이션의 메인 진입점 소스가 디버거에 로드되어 있는 것을 볼 수 있습니다.

In order to browse around more of your application sources, click **Libraries** (top right) or press Ctrl / Cmd + P. This opens the libraries window and allows you to search for other source files.

애플리케이션의 다른 소스 파일을 더 탐색하려면 상단 오른쪽의 **Libraries**를 클릭하거나 **Ctrl / Cmd + P**를 누릅니다. 이렇게 하면 라이브러리 창이 열리며 다른 소스 파일을 검색할 수 있습니다.

![Screenshot of the debugger tab](https://docs.flutter.dev/assets/images/docs/tools/devtools/debugger_screenshot.png)

## Setting breakpoints

To set a breakpoint, click the left margin (the line number ruler) in the source area. Clicking once sets a breakpoint, which should also show up in the **Breakpoints** area on the left. Clicking again removes the breakpoint.

중단점을 설정하려면 소스 영역의 왼쪽 여백(행 번호 눈금)을 클릭합니다. 한 번 클릭하면 중단점이 설정되며, 이는 왼쪽의 **Breakpoints** 영역에도 표시됩니다. 다시 클릭하면 중단점이 제거됩니다.
## The call stack and variable areas

When your application encounters a breakpoint, it pauses there, and the DevTools debugger shows the paused execution location in the source area. In addition, the `Call stack` and `Variables` areas populate with the current call stack for the paused isolate, and the local variables for the selected frame. Selecting other frames in the `Call stack` area changes the contents of the variables.

애플리케이션이 중단점에 도달하면 해당 위치에서 실행이 일시 중지되며, DevTools 디버거는 소스 영역에 일시 중지된 실행 위치를 표시합니다. 또한 **Call stack** 및 **Variables** 영역에는 일시 중지된 격리의 현재 호출 스택과 선택된 프레임의 지역 변수가 채워집니다. **Call stack** 영역에서 다른 프레임을 선택하면 변수의 내용이 변경됩니다.

Within the `Variables` area, you can inspect individual objects by toggling them open to see their fields. Hovering over an object in the `Variables` area calls `toString()` for that object and displays the result.

**Variables** 영역 내에서 개별 객체를 열어 그 필드를 검사할 수 있습니다. **Variables** 영역의 객체 위에 마우스를 올리면 해당 객체의 `toString()` 메서드가 호출되고 결과가 표시됩니다.

## Stepping through source code

When paused, the three stepping buttons become active.

- Use **Step in** to step into a method invocation, stopping at the first executable line in that invoked method.
- Use **Step over** to step over a method invocation; this steps through source lines in the current method.
- Use **Step out** to step out of the current method, without stopping at any intermediary lines.

In addition, the **Resume** button continues regular execution of the application.

일시 중지 상태에서는 세 가지 단계 버튼이 활성화됩니다.

- **Step in**: 메서드 호출로 들어가며, 호출된 메서드의 첫 번째 실행 가능한 줄에서 중단됩니다.
- **Step over**: 메서드 호출을 건너뛰며, 현재 메서드의 소스 줄을 순차적으로 실행합니다.
- **Step out**: 현재 메서드에서 나가며, 중간 줄에서 중단되지 않습니다.

또한, **Resume** 버튼을 사용하면 애플리케이션의 일반 실행이 계속됩니다.

## Console output

Console output for the running app (stdout and stderr) is displayed in the console, below the source code area. You can also see the output in the [Logging view](https://docs.flutter.dev/tools/devtools/logging).

실행 중인 애플리케이션의 콘솔 출력(`stdout` 및 `stderr`)은 소스 코드 영역 아래의 콘솔에 표시됩니다. 또한, 로깅 뷰에서도 출력을 확인할 수 있습니다.
## Breaking on exceptions

To adjust the stop-on-exceptions behavior, toggle the **Ignore** dropdown at the top of the debugger view.

예외 중단 동작을 조정하려면 디버거 뷰 상단에 있는 Ignore 드롭다운을 전환하세요.

Breaking on unhandled excepts only pauses execution if the breakpoint is considered uncaught by the application code. Breaking on all exceptions causes the debugger to pause whether or not the breakpoint was caught by application code.

처리되지 않은 예외에서 중단하는 것은 애플리케이션 코드에서 중단점이 처리되지 않은 경우에만 실행을 일시 중지합니다. 모든 예외에서 중단하는 경우, 애플리케이션 코드에서 중단점을 처리했는지 여부에 관계없이 디버거가 일시 중지됩니다.
## Known issues

When performing a hot restart for a Flutter application, user breakpoints are cleared.

Flutter 애플리케이션에서 핫 리스타트를 수행할 때 사용자 중단점이 제거됩니다.
## Other resources

For more information on debugging and profiling, see the [Debugging](https://docs.flutter.dev/testing/debugging) page.

디버깅 및 프로파일링에 대한 자세한 내용은 디버깅 페이지를 참조하세요.

_Note_

The logging view works with all Flutter and Dart applications.

## What is it?

The logging view displays events from the Dart runtime, application frameworks (like Flutter), and application-level logging events.

로깅 뷰는 Dart 런타임, 애플리케이션 프레임워크(예: Flutter) 및 애플리케이션 수준 로깅 이벤트의 이벤트를 표시합니다.
## Standard logging events

By default, the logging view shows:

- Garbage collection events from the Dart runtime
- Flutter framework events, like frame creation events
- `stdout` and `stderr` from applications
- Custom logging events from applications

기본적으로 로깅 뷰는 다음을 표시합니다:

- Dart 런타임의 가비지 수집 이벤트
- 프레임 생성 이벤트와 같은 Flutter 프레임워크 이벤트
- 애플리케이션의 stdout 및 stderr
- 애플리케이션의 사용자 정의 로깅 이벤트

![Screenshot of a logging view](https://docs.flutter.dev/assets/images/docs/tools/devtools/logging_log_entries.png)

## Logging from your application

To implement logging in your code, see the [Logging](https://docs.flutter.dev/testing/code-debugging#add-logging-to-your-application) section in the [Debugging Flutter apps programmatically](https://docs.flutter.dev/testing/code-debugging) page.

코드에서 로깅을 구현하려면 Debugging Flutter apps programmatically 페이지의 로깅 섹션을 참조하세요.

## Clearing logs

To clear the log entries in the logging view, click the **Clear logs** button.

To clear the log entries in the logging view, click the Clear logs button.
## Other resources

To learn about different methods of logging and how to effectively use DevTools to analyze and debug Flutter apps faster, check out a guided [Logging View tutorial](https://medium.com/@fluttergems/mastering-dart-flutter-devtools-logging-view-part-5-of-8-b634f3a3af26).

로깅의 다양한 방법과 DevTools를 사용하여 Flutter 앱을 더 빠르게 분석하고 디버그하는 방법에 대해 알아보려면 **Guided Logging View tutorial**를 확인하세요.

## What is it?

The app size tool allows you to analyze the total size of your app. You can view a single snapshot of "size information" using the [Analysis tab](https://docs.flutter.dev/tools/devtools/app-size#analysis-tab), or compare two different snapshots of "size information" using the [Diff tab](https://docs.flutter.dev/tools/devtools/app-size#diff-tab).

앱 크기 도구는 앱의 전체 크기를 분석할 수 있게 해줍니다. **분석** 탭을 사용하여 "크기 정보"의 단일 스냅샷을 볼 수 있으며, **차이** 탭을 사용하여 "크기 정보"의 두 가지 다른 스냅샷을 비교할 수 있습니다.

### What is "size information"?

"Size information" contains size data for Dart code, native code, and non-code elements of your app, like the application package, assets and fonts. A "size information" file contains data for the total picture of your application size.

"크기 정보"는 Dart 코드, 네이티브 코드, 애플리케이션 패키지, 자산 및 폰트와 같은 비코드 요소의 크기 데이터를 포함합니다. "크기 정보" 파일은 애플리케이션 크기의 전체적인 그림에 대한 데이터를 포함하고 있습니다.
### Dart size information

The Dart AOT compiler performs tree-shaking on your code when compiling your application (profile or release mode only—the AOT compiler is not used for debug builds, which are JIT compiled). This means that the compiler attempts to optimize your app's size by removing pieces of code that are unused or unreachable.

Dart AOT 컴파일러는 애플리케이션을 컴파일할 때(프로파일 모드 또는 릴리즈 모드에서만—디버그 빌드에서는 JIT 컴파일이 사용됨) 코드의 트리 쉐이킹을 수행합니다. 이는 컴파일러가 사용되지 않거나 도달할 수 없는 코드 조각을 제거하여 앱의 크기를 최적화하려고 시도함을 의미합니다.

After the compiler optimizes your code as much as it can, the end result can be summarized as the collection of packages, libraries, classes, and functions that exist in the binary output, along with their size in bytes. This is the Dart portion of "size information" we can analyze in the app size tool to further optimize Dart code and track down size issues.

컴파일러가 코드를 최대한 최적화한 후, 최종 결과는 바이너리 출력에 존재하는 패키지, 라이브러리, 클래스 및 함수의 모음과 그 크기를 바이트 단위로 요약할 수 있습니다. 이는 앱 크기 도구에서 분석하여 Dart 코드를 추가로 최적화하고 크기 문제를 추적할 수 있는 Dart 부분의 "크기 정보"입니다.
## How to use it

If DevTools is already connected to a running application, navigate to the "App Size" tab.

DevTools가 이미 실행 중인 애플리케이션에 연결되어 있는 경우, "앱 크기" 탭으로 이동합니다.

![Screenshot of app size tab](https://docs.flutter.dev/assets/images/docs/tools/devtools/app_size_tab.png)

If DevTools is not connected to a running application, you can access the tool from the landing page that appears once you have launched DevTools (see [launch instructions](https://docs.flutter.dev/tools/devtools#start)).

DevTools가 실행 중인 애플리케이션에 연결되어 있지 않은 경우, DevTools를 실행한 후 나타나는 랜딩 페이지에서 도구에 접근할 수 있습니다(시작 지침 참조).

![Screenshot of app size access on landing page](https://docs.flutter.dev/assets/images/docs/tools/devtools/app_size_access_landing_page.png)

## Analysis tab

The analysis tab allows you to inspect a single snapshot of size information. You can view the hierarchical structure of the size data using the treemap and table, and you can view code attribution data (for example, why a piece of code is included in your compiled application) using the dominator tree and call graph.

분석 탭에서는 크기 정보의 단일 스냅샷을 검사할 수 있습니다. 트리맵과 표를 사용하여 크기 데이터의 계층 구조를 볼 수 있으며, 도미네이터 트리와 호출 그래프를 사용하여 코드 속성 데이터(예: 특정 코드 조각이 컴파일된 애플리케이션에 포함된 이유)를 볼 수 있습니다.

![Screenshot of app size analysis](https://docs.flutter.dev/assets/images/docs/tools/devtools/app_size_analysis.png)

### Loading a size file

When you open the Analysis tab, you'll see instructions to load an app size file. Drag and drop an app size file into the dialog, and click "Analyze Size".

분석 탭을 열면 앱 크기 파일을 로드하는 방법에 대한 지침이 표시됩니다. 앱 크기 파일을 대화 상자로 드래그 앤 드롭한 후 "Analyze Size"를 클릭하세요.

![Screenshot of app size analysis loading screen](https://docs.flutter.dev/assets/images/docs/tools/devtools/app_size_load_analysis.png)

See [Generating size files](https://docs.flutter.dev/tools/devtools/app-size#generating-size-files) below for information on generating size files.

"크기 파일 생성"에 대한 정보는 아래에서 확인하세요.
### Treemap and table

The treemap and table show the hierarchical data for your app's size.

"트리맵과 표는 앱의 크기에 대한 계층적 데이터를 보여줍니다."
#### Use the treemap

A treemap is a visualization for hierarchical data. The space is broken up into rectangles, where each rectangle is sized and ordered by some quantitative variable (in this case, size in bytes). The area of each rectangle is proportional to the size the node occupies in the compiled application. Inside of each rectangle (call one A), there are additional rectangles that exist one level deeper in the data hierarchy (children of A).

"트리맵은 계층적 데이터를 시각화하는 방법입니다. 공간이 사각형으로 나뉘며, 각 사각형은 특정 수치 변수(이 경우 바이트 크기)에 따라 크기와 순서가 결정됩니다. 각 사각형의 면적은 해당 노드가 컴파일된 애플리케이션에서 차지하는 크기에 비례합니다. 각 사각형(하나를 A라고 합시다) 안에는 데이터 계층에서 한 단계 더 깊은 추가 사각형들이 존재합니다(A의 자식들).

To drill into a cell in the treemap, select the cell. This re-roots the tree so that the selected cell becomes the visual root of the treemap.

트리맵에서 셀을 드릴다운하려면 해당 셀을 선택하세요. 그러면 선택한 셀이 트리맵의 시각적 루트가 되도록 트리가 재구성됩니다.

To navigate back, or up a level, use the breadcrumb navigator at the top of the treemap.

되돌아가거나 한 단계 위로 이동하려면 트리맵 상단의 브레드크럼 내비게이터를 사용하세요."

![Screenshot of treemap breadcrumb navigator](https://docs.flutter.dev/assets/images/docs/tools/devtools/treemap_breadcrumbs.png)

### Dominator tree and call graph

This section of the page shows code size attribution data (for example, why a piece of code is included in your compiled application). This data is visible in the form of a dominator tree as well as a call graph.

"이 페이지의 이 섹션은 코드 크기 기여 데이터를 보여줍니다(예: 특정 코드 조각이 컴파일된 애플리케이션에 포함된 이유). 이 데이터는 지배자 트리 형태와 호출 그래프 형태로 표시됩니다."

#### Use the dominator tree

A [dominator tree](https://en.wikipedia.org/wiki/Dominator_(graph_theory)) is a tree where each node's children are those nodes it immediately dominates. A node `a` is said to "dominate" a node `b` if every path to `b` must go through `a`.

"지배자 트리는 각 노드의 자식이 그 노드가 즉시 지배하는 노드인 트리입니다. 노드 a는 노드 b를 '지배한다'고 할 수 있는데, 이는 b로 가는 모든 경로가 반드시 a를 거쳐야 한다는 의미입니다.

To put it in context of app size analysis, imagine `package:a` imports both `package:b` and `package:c`, and both `package:b` and `package:c` import `package:d`.

앱 크기 분석의 맥락에서 예를 들어, package가 package와 package를 모두 임포트하고, package와 package가 모두 package를 임포트한다고 상상해보세요."

```
package:a
|__ package:b
|   |__ package:d
|__ package:c
    |__ package:d
```

content_copy

In this example, `package:a` dominates `package:d`, so the dominator tree for this data would look like:

이 예에서 `package:a`는 `package:d`를 지배하므로, 이 데이터의 지배자 트리는 다음과 같이 보일 것입니다:

```
package:a
|__ package:b
|__ package:c
|__ package:d
```

This information is helpful for understanding why certain pieces of code are present in your compiled application. For example, if you are analyzing your app size and find an unexpected package included in your compiled app, you can use the dominator tree to trace the package to its root source.

이 정보는 컴파일된 애플리케이션에 특정 코드 조각이 포함된 이유를 이해하는 데 유용합니다. 예를 들어, 앱 크기를 분석할 때 예상치 못한 패키지가 포함되어 있는 것을 발견하면, 지배자 트리를 사용하여 해당 패키지를 원래 출처까지 추적할 수 있습니다.

![Screenshot of code size dominator tree](https://docs.flutter.dev/assets/images/docs/tools/devtools/app_size_dominator_tree.png)

#### Use the call graph

A call graph provides similar information to the dominator tree in regards to helping you understand why code exists in a compiled application. However, instead of showing the one-to-many dominant relationships between nodes of code size data like the dominator tree, the call graph shows the many-to-many relationships that existing between nodes of code size data.

호출 그래프는 지배자 트리와 유사한 정보를 제공하여 컴파일된 애플리케이션에 코드가 존재하는 이유를 이해하는 데 도움을 줍니다. 하지만 지배자 트리가 코드 크기 데이터의 노드 간의 일대다 지배 관계를 보여주는 반면, 호출 그래프는 코드 크기 데이터의 노드 간에 존재하는 다대다 관계를 보여줍니다.

Again, using the following example:

다시 말해, 다음 예를 사용하면:

```
package:a
|__ package:b
|   |__ package:d
|__ package:c
    |__ package:d
```


The call graph for this data would link `package:d` to its direct callers, `package:b` and `package:c`, instead of its "dominator", `package:a`.

이 데이터에 대한 호출 그래프는 패키지 `d`를 직접 호출하는 패키지 `b`와 패키지 `c`에 연결하고, "지배자"인 패키지 `a`와는 연결하지 않을 것입니다.

```
package:a --> package:b -->
                              package:d
package:a --> package:c -->
```


This information is useful for understanding the fine-grained dependencies of between pieces of your code (packages, libraries, classes, functions).

이 정보는 코드의 구성 요소(패키지, 라이브러리, 클래스, 함수) 간의 세부적인 의존성을 이해하는 데 유용합니다.

![Screenshot of code size call graph](https://docs.flutter.dev/assets/images/docs/tools/devtools/app_size_call_graph.png)

#### Should I use the dominator tree or the call graph?

Use the dominator tree if you want to understand the _root_ cause for why a piece of code is included in your application. Use the call graph if you want to understand all the call paths to and from a piece of code.

지배자 트리는 애플리케이션에 코드 조각이 포함된 근본적인 원인을 이해하려는 경우에 사용하고, 호출 그래프는 코드 조각 간의 모든 호출 경로를 이해하고자 할 때 사용합니다.

A dominator tree is an analysis or slice of call graph data, where nodes are connected by "dominance" instead of parent-child hierarchy. In the case where a parent node dominates a child, the relationship in the call graph and the dominator tree would be identical, but this is not always the case.

지배자 트리는 호출 그래프 데이터의 분석 또는 슬라이스로, 노드가 "지배" 관계에 의해 연결됩니다. 부모 노드가 자식 노드를 지배하는 경우, 호출 그래프와 지배자 트리의 관계는 동일하지만, 항상 그런 것은 아닙니다.

In the scenario where the call graph is complete (an edge exists between every pair of nodes), the dominator tree would show the that `root` is the dominator for every node in the graph. This is an example where the call graph would give you a better understanding around why a piece of code is included in your application.

호출 그래프가 완전한 경우(모든 노드 쌍 간에 엣지가 존재하는 경우), 지배자 트리는 루트가 그래프의 모든 노드에 대한 지배자임을 보여줍니다. 이 경우 호출 그래프가 코드 조각이 애플리케이션에 포함된 이유를 더 잘 이해하는 데 도움이 됩니다.
## Diff tab

The diff tab allows you to compare two snapshots of size information. The two size information files you are comparing should be generated from two different versions of the same app; for example, the size file generated before and after changes to your code. You can visualize the difference between the two data sets using the treemap and table.

diff 탭은 두 개의 크기 정보 스냅샷을 비교할 수 있게 해줍니다. 비교하는 두 개의 크기 정보 파일은 같은 앱의 두 가지 다른 버전에서 생성된 것이어야 하며, 예를 들어 코드 변경 전후에 생성된 크기 파일이 이에 해당합니다. 두 데이터 세트 간의 차이를 트리맵과 표를 사용하여 시각화할 수 있습니다.

![Screenshot of app size diff](https://docs.flutter.dev/assets/images/docs/tools/devtools/app_size_diff.png)

### Loading size files

When you open the **Diff** tab, you'll see instructions to load "old" and "new" size files. Again, these files need to be generated from the same application. Drag and drop these files into their respective dialogs, and click **Analyze Diff**.

Diff 탭을 열면 "old"와 "new" 크기 파일을 로드하는 방법에 대한 지침이 표시됩니다. 다시 말해, 이 파일들은 동일한 애플리케이션에서 생성되어야 합니다. 각 파일을 해당 다이얼로그에 드래그 앤 드롭한 후 "Analyze Diff" 버튼을 클릭하세요.

![Screenshot of app size diff loading screen](https://docs.flutter.dev/assets/images/docs/tools/devtools/app_size_load_diff.png)

See [Generating size files](https://docs.flutter.dev/tools/devtools/app-size#generating-size-files) below for information on generating these files.

아래 "크기 파일 생성" 섹션을 참조하여 이러한 파일을 생성하는 방법에 대한 정보를 확인하세요.

### Treemap and table

In the diff view, the treemap and tree table show only data that differs between the two imported size files.

diff 뷰에서는 트리맵과 트리 테이블이 두 개의 가져온 크기 파일 간에 차이가 있는 데이터만 표시합니다.

For questions about using the treemap, see [Use the treemap](https://docs.flutter.dev/tools/devtools/app-size#use-the-treemap) above.

트리맵 사용에 대한 질문은 위의 "트리맵 사용" 섹션을 참조하세요.
## Generating size files

To use the app size tool, you'll need to generate a Flutter size analysis file. This file contains size information for your entire application (native code, Dart code, assets, fonts, etc.), and you can generate it using the `--analyze-size` flag:

앱 크기 도구를 사용하려면 Flutter 크기 분석 파일을 생성해야 합니다. 이 파일은 전체 애플리케이션에 대한 크기 정보를 포함하며(네이티브 코드, Dart 코드, 자산, 폰트 등), `--analyze-size` 플래그를 사용하여 생성할 수 있습니다.

```
flutter build <your target platform> --analyze-size
```

This builds your application, prints a size summary to the command line, and prints a line telling you where to find the size analysis file.

이 명령은 애플리케이션을 빌드하고, 크기 요약을 커맨드 라인에 출력하며, 크기 분석 파일의 위치를 알려주는 메시지를 출력합니다.

```
flutter build apk --analyze-size --target-platform=android-arm64
...
▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
app-release.apk (total compressed)                               6 MB
...
▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
A summary of your APK analysis can be found at: build/apk-code-size-analysis_01.json
```

content_copy

In this example, import the `build/apk-code-size-analysis_01.json` file into the app size tool to analyze further. For more information, see [App Size Documentation](https://docs.flutter.dev/perf/app-size#breaking-down-the-size).

이 예에서는 `build/apk-code-size-analysis_01.json` 파일을 앱 크기 도구에 가져와서 더 분석합니다. 자세한 정보는 앱 크기 문서를 참조하세요.

## Other resources

To learn how to perform a step-by-step size analysis of the Wonderous App using DevTools, check out the [App Size Tool tutorial](https://medium.com/@fluttergems/mastering-dart-flutter-devtools-app-size-tool-part-3-of-8-9be6e9ec42a2). Various strategies to reduce an app's size are also discussed.

Wonderous App의 단계별 크기 분석을 DevTools를 사용하여 수행하는 방법을 배우려면 앱 크기 도구 튜토리얼을 확인하세요. 앱 크기를 줄이는 다양한 전략도 논의됩니다.

## What are DevTools extensions?

[DevTools extensions](https://pub.dev/packages/devtools_extensions) are developer tools provided by third-party packages that are tightly integrated into the DevTools tooling suite. Extensions are distributed as part of a pub package, and they are dynamically loaded into DevTools when a user is debugging their app.

DevTools 확장은 서드파티 패키지에서 제공하는 개발자 도구로, DevTools 툴링 스위트와 밀접하게 통합되어 있습니다. 확장은 pub 패키지의 일부로 배포되며, 사용자가 앱을 디버깅할 때 DevTools에 동적으로 로드됩니다.

## Use a DevTools extension

If your app depends on a package that provides a DevTools extension, the extension automatically shows up in a new tab when you open DevTools.

앱이 DevTools 확장을 제공하는 패키지에 의존하는 경우, DevTools를 열면 해당 확장이 자동으로 새로운 탭에 표시됩니다.

### Configure extension enablement states

You need to manually enable the extension before it loads for the first time. Make sure the extension is provided by a source you trust before enabling it.

확장이 처음 로드되기 전에 수동으로 활성화해야 합니다. 활성화하기 전에 해당 확장이 신뢰할 수 있는 출처에서 제공되는 것인지 확인하세요.

![Screenshot of extension enablement prompt](https://docs.flutter.dev/assets/images/docs/tools/devtools/extension_enable_prompt.png)

Extension enablement states are stored in a `devtools_options.yaml` file in the root of the user's project (similar to `analysis_options.yaml`). This file stores per-project (or optionally, per user) settings for DevTools.

확장 활성화 상태는 사용자의 프로젝트 루트에 있는 `devtools_options.yaml` 파일에 저장됩니다(이는 `analysis_options.yaml`과 유사합니다). 이 파일은 DevTools에 대한 프로젝트별(또는 선택적으로 사용자별) 설정을 저장합니다.

If this file is **checked into source control**, the specified options are configured for the project. This means that anyone who pulls a project's source code and works on the project uses the same settings.

이 파일이 소스 제어에 체크인되면, 지정된 옵션이 프로젝트에 대해 구성됩니다. 즉, 프로젝트의 소스 코드를 가져와 작업하는 모든 사람이 동일한 설정을 사용하게 됩니다.

If this file is **omitted from source control**, for example by adding `devtools_options.yaml` as an entry in the `.gitignore` file, then the specified options are configured separately for each user. Since each user or contributor to the project uses a local copy of the `devtools_options.yaml` file in this case, the specified options might differ between project contributors.

반면, 이 파일이 소스 제어에서 생략되면(예: `.gitignore` 파일에 `devtools_options.yaml` 항목을 추가하여), 지정된 옵션이 각 사용자별로 별도로 구성됩니다. 이 경우 각 사용자 또는 기여자는 로컬 복사본의 `devtools_options.yaml` 파일을 사용하므로, 설정이 프로젝트 기여자 간에 다를 수 있습니다.

## Build a DevTools extension

For an in-depth guide on how to build a DevTools extension, check out [Dart and Flutter DevTools extensions](https://medium.com/flutter/dart-flutter-devtools-extensions-c8bc1aaf8e5f), a free article on Medium.

DevTools 확장을 만드는 방법에 대한 자세한 가이드는 Medium에서 제공하는 무료 기사인 "Dart and Flutter DevTools extensions"를 확인하세요.

To learn more about writing and using DevTools extensions, check out the following video:

DevTools 확장을 작성하고 사용하는 방법에 대해 더 알고 싶다면, 다음 비디오를 확인하세요:

_Note_

The deep link validator was added to DevTools in Flutter SDK 3.19. It currently works only for Android, but will be expanded to cover iOS in a future release.

To see a demo of the deep link validator, check out the Google I/O 2024 video, [No more broken links: Deep linking success in Flutter](https://youtube.com/watch?v=d7sZL6h1Elw).

_정보_

딥 링크 검증기는 Flutter SDK 3.19에 DevTools에 추가되었습니다. 현재는 Android에서만 작동하지만, 향후 릴리스에서 iOS를 지원할 예정입니다.

딥 링크 검증기의 데모를 보려면 Google I/O 2024 비디오인 "No more broken links: Deep linking success in Flutter"를 확인하세요.

The deep link view validates any deep links that are defined in your app.

To use this feature, open DevTools, click into the **Deep Links** tab, and import a Flutter project that contains deep links.

딥 링크 뷰는 앱에 정의된 모든 딥 링크를 검증합니다.

이 기능을 사용하려면 DevTools를 열고, 딥 링크 탭으로 이동한 다음 딥 링크가 포함된 Flutter 프로젝트를 가져오세요.

![Screenshot of the Deep Link Validator](https://docs.flutter.dev/assets/images/docs/tools/devtools/deep-link-validator.png)

This tool helps you identify and troubleshoot any errors in your Android deep link setup, from website configuration to Android manifest files. DevTools provides instructions on how to fix any issues, making the implementation process easier.

이 도구는 웹사이트 구성에서 Android 매니페스트 파일까지 Android 딥 링크 설정의 오류를 식별하고 문제를 해결하는 데 도움을 줍니다. DevTools는 문제를 해결하는 방법에 대한 지침을 제공하여 구현 과정을 더 쉽게 만듭니다.


