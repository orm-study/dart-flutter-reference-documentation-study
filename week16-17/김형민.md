### 플랫폼 임베더

모든 플러터 콘텐츠를 호스팅하는 네이티브 OS 애플리케이션

- 플러터 앱 시작 시 진입점 제공
- 플러터 엔진 초기화
- UI와 래스터 작업을 위한 스레드 확보
- 플러터가 쓸 수 있는 텍스처 생성
- 입력, 창 크기 조정, 스레드 관리, 플랫폼 메시지 등 앱 생명 주기 관리
- OS별 플랫폼 임베더 존재
- 커스텀 플랫폼 임베더 생성 가능

### 다른 코드와 통합

- 다른 언어로 작성된 코드/API에 접근/호출 가능
- 플러터 앱에 네이티브 컨트롤 임베드 가능
- 기존 앱에 플러터 임베드 가능

#### 플랫폼 채널

플랫폼 채널을 통해 사용자 정의 코드 호출 가능

공통 채널 생성
- Dart와 네이티브 코드 간 메시지 통신 가능
- 데이터 - Dart 타입 -> 표준 형식으로 직렬화 -> 네이티브 코드 타입으로 역직렬화

#### 외부 함수 인터페이스

dart:ffi 라이브러리로 네이티브 코드에 바인딩

직렬화가 필요 없어서 플랫폼 채널보다 빠를 수 있음

웹은 불가능. package:web이 유사한 기능 수행

#### 플러터 앱에서 네이티브 컨트롤 렌더링

네이티브 요소를 플러터 앱에 포함시키는 방법

플랫폼 뷰 위젯을 도입

플러터와 네이티브 요소의 동기화로 인한 오버헤드 발생

플러터에서 재구현하는 것이 비용이 클 때 적합함(ex: google map)

#### 상위(다른 언어로 작성된) 앱에서 플러터 콘텐츠 호스팅

기존 Android/iOS 앱에 플러터 위젯을 임베드 하는 방법

플러터는

Android : Actirvity

iOS : UIViewController

에서 호스팅됨

플러터 콘텐츠는 위의 임베딩 API를 사용하여 임베드할 수 있음

Flutter 모듈 템플릿은 Android Archive / iOS Framework 이진 파일로 컴파일해 사용 가능

Flutter 엔진
- Flutter 공유 라이브러리 로드
- Dart 런타임 초기화
- Dart iolate 생성/실행
- UI에 렌더링 표면 연결

로 초기화에 짧은 시간 소요

플러터 콘텐츠 표시할 때 UI 지연을 최소화 하려면

- 전체 앱 초기화 중에 플러터 엔진을 초기화
- 최소한 첫 플러터 화면 전에 초기화

이는 사용자가 첫 플러터 코드 로드 동안 갑작스런 중단을 경험하지 않게 함

플러터 엔진 분리 시

- 여러 플러터 화면 간 재사용 가능
- 필요 라이브러리 로드에 드는 메모리 오버헤드 공유 가능

#### 플러터 웹 지원

웹만의 고유한 특성 몇 가지가 있음

플러터 엔진은 웹 브라우저가 아니라 OS와 인터페이스하도록 설계됨

표준 브라우저 API 위에 엔진을 재구현함

웹에서 플러터 콘텐츠 렌더링 하는 두 옵션

- HTML : 
	- 플러터가 HTML, CSS, 캔버스 / SVG 사용
	- 최고의 코드 크기 특성 제공
- WebGL : CanvasKit (WebAssembly로 컴파일된 Skia 버전) 사용 : 
	- 브라우저 그래픽 스택으로 가는 가장 빠른 경로 제공
	- 네이티브에 비해 높은 그래픽 제공

웹 버전에서는 Flutter가 Dart 런타임을 제공할 필요 없음

Flutter Framework는 JS로 컴파일 됨

플러터 웹은 dartdevc를 사용해 핫 리스타트 가능 (핫 리로드 불가)

프로덕션 버전 앱에서는 dart2js로 배포 가능한 소스 파일로 만듦

#### BuildContext

BuildContext Class

- 번역

위젯 트리에서 위젯의 위치를 참조하는 핸들.

이 클래스는 StatelessWidget의 build 메서드와 State 객체의 메서드에서 사용할 수 있는 여러 메서드를 제공합니다.

BuildContext 객체는 WidgetBuilder 함수(예: StatelessWidget.build)에 전달되며, State 객체에서는 State.context 멤버로 사용할 수 있습니다. 일부 정적 함수(예: showDialog, Theme.of 등)도 빌드 컨텍스트를 받아 호출하는 위젯을 대신해 작동하거나, 주어진 컨텍스트에 대한 데이터를 얻습니다.

각 위젯은 자체 BuildContext를 가지며, 이는 StatelessWidget.build 또는 State.build 함수에서 반환된 위젯의 부모가 됩니다. (그리고 마찬가지로 RenderObjectWidgets의 자식들의 부모가 됩니다.)

특히, 이 말은 위젯의 빌드 메서드 내에서 사용되는 빌드 컨텍스트가 해당 빌드 메서드에서 반환된 위젯의 빌드 컨텍스트와 동일하지 않음을 의미합니다. 이로 인해 몇 가지 까다로운 상황이 발생할 수 있습니다. 예를 들어, Theme.of(context)는 주어진 빌드 컨텍스트에서 가장 가까운 테마를 찾습니다. 만약 Q라는 위젯의 빌드 메서드가 반환하는 위젯 트리 내에 Theme이 포함되어 있고, 자신의 컨텍스트를 전달하여 Theme.of를 호출하면, Q 위젯의 빌드 메서드는 해당 Theme 객체를 찾지 못하고 Q 위젯의 상위에 있는 테마를 찾게 됩니다. 반환된 트리의 일부에 대한 빌드 컨텍스트가 필요한 경우 Builder 위젯을 사용할 수 있습니다. Builder.builder 콜백에 전달되는 빌드 컨텍스트는 Builder 자체의 빌드 컨텍스트가 됩니다.

예를 들어, 아래 코드 조각에서 ScaffoldState.showBottomSheet 메서드는 빌드 메서드가 생성한 Scaffold 위젯에서 호출됩니다. 만약 Builder가 사용되지 않고 빌드 메서드 자체의 컨텍스트 인수가 사용되었다면, Scaffold가 발견되지 않았을 것이며 Scaffold.of 함수는 null을 반환했을 것입니다.

특정 위젯의 BuildContext는 시간이 지나면서 해당 위젯이 트리 내에서 이동할 때 위치가 변경될 수 있습니다. 그렇기 때문에 이 클래스의 메서드에서 반환된 값들은 하나의 동기 함수 실행을 넘어서 캐시되지 않아야 합니다.

BuildContext 인스턴스는 해당 위젯이 위젯 트리에서 제거되면 유효하지 않게 될 수 있으므로 저장하는 것을 피해야 합니다. 비동기 작업 후에 BuildContext를 사용해야 하는 경우, 해당 컨텍스트가 여전히 유효한지 확인하려면 `mounted`를 사용하여 위젯이 여전히 트리에 남아 있는지 확인하는 것이 좋습니다.

BuildContext 객체는 실제로 Element 객체입니다. BuildContext 인터페이스는 Element 객체를 직접 조작하지 않도록 하기 위해 사용됩니다.

- 설명

BuildContext는 Flutter에서 위젯의 위치를 알려주는 역할을 합니다. 위젯 트리에서 각 위젯은 자신만의 BuildContext를 가지고 있으며, 이 컨텍스트를 사용해 부모나 형제 위젯의 정보에 접근할 수 있습니다.

문제는, 같은 위젯 안에서 호출된 BuildContext와 그 안에서 생성된 자식 위젯의 BuildContext가 다를 수 있다는 점입니다. 그래서 위젯 트리 내에서 특정 데이터를 찾을 때 헷갈릴 수 있습니다.

예를 들어, 어떤 위젯 안에서 Theme.of(context)를 사용해 테마를 가져오려고 할 때, 잘못된 컨텍스트를 사용하면 원하는 테마를 찾지 못할 수 있습니다. 이럴 때는 Builder 위젯을 사용하면 새로운 BuildContext를 만들어주기 때문에, 필요한 컨텍스트를 정확히 사용할 수 있습니다.

쉽게 말해, BuildContext는 "위젯이 어디에 있는지" 알려주는 지도 같은 역할을 하고, 이를 올바르게 사용해야 위젯 트리에서 필요한 데이터를 찾을 수 있다는 것입니다.

BuildContext는 위젯의 위치를 나타내지만, 시간이 지나면서 위젯이 트리에서 이동하면 BuildContext도 변할 수 있습니다. 그래서 BuildContext를 사용해서 얻은 값들은 잠깐 동안만 사용해야 하고, 오랫동안 저장해두면 안 됩니다.

BuildContext는 위젯이 트리에서 사라지면 더 이상 유효하지 않게 될 수 있기 때문에, 그 값을 저장해서 계속 쓰는 건 위험할 수 있습니다. 비동기 작업(예: 네트워크 요청) 후에 BuildContext를 사용해야 할 때는, 위젯이 아직 트리에 있는지 `mounted`를 사용해 확인한 후에 사용해야 안전합니다.

BuildContext는 사실 Element라는 객체인데, Flutter에서는 사람들이 Element를 직접 건드리지 않도록 BuildContext라는 인터페이스를 사용하게 만듭니다. 즉, Element를 안전하게 다루기 위해 BuildContext를 사용하는 것입니다.
#### Key

Key class

- 번역

Key는 위젯, 엘리먼트, 그리고 SemanticsNodes를 위한 식별자입니다.

새로운 위젯은 현재 엘리먼트와 연결된 위젯의 Key와 동일할 경우에만 기존 엘리먼트를 업데이트하는 데 사용됩니다. Key는 동일한 부모를 가진 엘리먼트들 사이에서 고유해야 합니다.

Key의 서브클래스는 LocalKey 또는 GlobalKey를 서브클래스화해야 합니다.

- 설명

Key는 Flutter에서 위젯을 구분하는 식별자 역할을 합니다. 같은 부모 아래 있는 여러 위젯이 있을 때, Key를 사용하면 특정 위젯을 구별할 수 있습니다.

Key가 같은 경우 Flutter는 기존 위젯을 새 위젯으로 업데이트하고, Key가 다르면 새 위젯을 만듭니다. Key는 LocalKey와 GlobalKey라는 두 가지 종류가 있는데, 각각 위젯의 범위나 역할에 따라 사용됩니다.

쉽게 말해, Key는 위젯을 식별하고 관리하는 데 중요한 도구입니다.
