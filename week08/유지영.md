# Isolates

**This page discusses some examples that use the `Isolate` API to implement isolates.**

이 페이지는 고립 API를 사용하여 고립을 구현하는 몇 가지 예를 다룬다.

**You should use isolates whenever your application is handling computations that are large enough to temporarily block other computations. The most common example is in [Flutter](https://flutter.dev/perf/isolates) applications, when you need to perform large computations that might otherwise cause the UI to become unresponsive.**

어플리케이션이 일시적으로 다른 작업을 차단할 만큼 큰 계산을 처리할 때는 언제든지 고립을 사용해야 한다. 가장 흔한 예는 Flutter 어플리케이션에서 큰 계산을 수행해야 할 때, 그렇지 않으면 UI가 응답하지 않게 될 수 있다.

**There aren't any rules about when you *must* use isolates, but here are some more situations where they can be useful:**

고립을 반드시 사용해야 할 규칙은 없지만, 다음과 같은 상황에서 유용할 수 있다:

- **Parsing and decoding exceptionally large JSON blobs.**
    
    매우 큰 JSON 블롭을 파싱하고 디코딩할 때
    
- **Processing and compressing photos, audio and video.**
    
    사진, 오디오 및 비디오를 처리하고 압축할 때
    
- **Converting audio and video files.**
    
    오디오 및 비디오 파일을 변환할 때
    
- **Performing complex searching and filtering on large lists or within file systems.**
    
    큰 목록이나 파일 시스템 내에서 복잡한 검색 및 필터링을 수행할 때
    
- **Performing I/O, such as communicating with a database.**
    
    데이터베이스와 통신하는 등 I/O 작업을 수행할 때
    
- **Handling a large volume of network requests.**
    
    대량의 네트워크 요청을 처리할 때
    

**Implementing a simple worker isolate[#](https://dart.dev/language/isolates#implementing-a-simple-worker-isolate)**

간단한 워커 고립 구현하기

**These examples implement a main isolate that spawns a simple worker isolate. [`Isolate.run()`](https://api.dart.dev/dev/dart-isolate/Isolate/run.html) simplifies the steps behind setting up and managing worker isolates:**

이 예제들은 간단한 워커 고립을 생성하는 메인 고립을 구현한다. Isolate.run()은 워커 고립을 설정하고 관리하는 단계를 단순화한다:

1. **Spawns (starts and creates) an isolate.**
    
    고립을 생성하고 시작한다.
    
2. **Runs a function on the spawned isolate.**
    
    생성된 고립에서 함수를 실행한다.
    
3. **Captures the result.**
    
    결과를 캡처한다.
    
4. **Returns the result to the main isolate.**
    
    결과를 메인 고립에 반환한다.
    
5. **Terminates the isolate once work is complete.**
    
    작업이 완료되면 고립을 종료한다.
    
6. **Checks, captures, and throws exceptions and errors back to the main isolate.**
    
    예외와 오류를 확인하고 캡처하여 메인 고립으로 다시 던진다.
    

<aside>
ℹ️ **Flutter note**

**If you're using Flutter, you can use [Flutter's `compute` function](https://api.flutter.dev/flutter/foundation/compute.html) instead of `Isolate.run()`.**

Flutter를 사용하고 있다면 Isolate.run() 대신 Flutter의 compute 함수를 사용할 수 있다.

</aside>

## **Running an existing method in a new isolate[#](https://dart.dev/language/isolates#running-an-existing-method-in-a-new-isolate)**
기존 메서드를 새로운 고립에서 실행하기

1. **Call `run()` to spawn a new isolate (a [background worker](https://dart.dev/language/concurrency#background-workers)), directly in the [main isolate](https://dart.dev/language/concurrency#the-main-isolate) while `main()` waits for the result:**
    
    메인 고립에서 직접 run()을 호출하여 새로운 고립(백그라운드 워커)을 생성하고, main()이 결과를 기다리게 한다:
    

```dart
const String filename = 'with_keys.json';

void main() async {
  // 데이터를 읽는다.
  final jsonData = await Isolate.run(_readAndParseJson);

  // 그 데이터를 사용한다.
  print('Number of JSON keys: ${jsonData.length}');
}
```

1. **Pass the worker isolate the function you want it to execute as its first argument. In this example, it's the existing function `_readAndParseJson()`:**
    
    워커 고립에 실행할 함수를 첫 번째 인수로 전달한다. 이 예제에서는 _readAndParseJson() 함수이다:
    

```dart
Future<Map<String, dynamic>> _readAndParseJson() async {
  final fileData = await File(filename).readAsString();
  final jsonData = jsonDecode(fileData) as Map<String, dynamic>;
  return jsonData;
}
```

1. **`Isolate.run()` takes the result `_readAndParseJson()` returns and sends the value back to the main isolate, shutting down the worker isolate.**
    
    Isolate.run()은 _readAndParseJson()이 반환하는 결과를 받아 메인 고립으로 값을 보내고, 워커 고립을 종료한다.
    
2. **The worker isolate *transfers* the memory holding the result to the main isolate. It *does not copy* the data. The worker isolate performs a verification pass to ensure the objects are allowed to be transferred.**
    
    워커 고립은 결과를 저장하는 메모리를 메인 고립으로 전송한다. 데이터를 복사하지 않는다. 워커 고립은 객체가 전송될 수 있는지 확인하기 위해 검증 단계를 수행한다.
    

**`_readAndParseJson()` is an existing, asynchronous function that could just as easily run directly in the main isolate. Using `Isolate.run()` to run it instead enables concurrency. The worker isolate completely abstracts the computations of `_readAndParseJson()`. It can complete without blocking the main isolate.**

_readAndParseJson()은 기존의 비동기 함수로, 메인 고립에서 직접 실행될 수도 있다. Isolate.run()을 사용하여 실행하면 병행 처리가 가능하다. 워커 고립은 _readAndParseJson()의 계산을 완전히 추상화하여, 메인 고립을 차단하지 않고 완료될 수 있다.

**The result of `Isolate.run()` is always a Future, because code in the main isolate continues to run. Whether the computation the worker isolate executes is synchronous or asynchronous doesn't impact the main isolate, because it's running concurrently either way.**

Isolate.run()의 결과는 항상 Future이다. 왜냐하면 메인 고립의 코드는 계속 실행되기 때문이다. 워커 고립이 실행하는 계산이 동기적이든 비동기적이든 메인 고립에는 영향을 미치지 않는다. 왜냐하면 병행하여 실행되기 때문이다.

**For the complete program, check out the [send_and_receive.dart](https://github.com/dart-lang/samples/blob/main/isolates/bin/send_and_receive.dart) sample.**

전체 프로그램은 send_and_receive.dart 샘플에서 확인할 수 있다.

## **Sending closures with isolates[#](https://dart.dev/language/isolates#sending-closures-with-isolates)**
고립과 함께 클로저 보내기

**You can also create a simple worker isolate with `run()` using a function literal, or closure, directly in the main isolate.**

함수 리터럴 또는 클로저를 사용하여 run()으로 간단한 워커 고립을 생성할 수도 있다.

```dart
const String filename = 'with_keys.json';

void main() async {
  // 데이터를 읽는다.
  final jsonData = await Isolate.run(() async {
    final fileData = await File(filename).readAsString();
    final jsonData = jsonDecode(fileData) as Map<String, dynamic>;
    return jsonData;
  });

  // 그 데이터를 사용한다.
  print('Number of JSON keys: ${jsonData.length}');
}
```

**This example accomplishes the same as the previous. A new isolate spawns, computes something, and sends back the result.**

이 예제는 이전과 동일한 작업을 수행한다. 새로운 고립이 생성되고, 일부 계산을 수행하며, 결과를 다시 보낸다.

**However, now the isolate sends a [closure](https://dart.dev/language/functions#anonymous-functions). Closures are less limited than typical named functions, both in how they function and how they're written into the code. In this example, `Isolate.run()` executes what looks like local code, concurrently. In that sense, you can imagine `run()` to work like a control flow operator for "run in parallel".**

그러나 이제 고립은 클로저를 보낸다. 클로저는 일반적인 명명된 함수보다 기능이 더 많고, 코드에 어떻게 작성되는지에 있어 더 유연하다. 이 예제에서 Isolate.run()은 마치 로컬 코드처럼 보이는 것을 동시에 실행한다. 그런 의미에서 run()은 “병렬로 실행”하는 제어 흐름 연산자처럼 작동한다고 상상할 수 있다.

## **Sending multiple messages between isolates with ports[#](https://dart.dev/language/isolates#sending-multiple-messages-between-isolates-with-ports)**
포트를 사용하여 고립 간에 여러 메시지 보내기

**Short-lived isolates are convenient to use, but require performance overhead to spawn new isolates and to copy objects from one isolate to another. If your code relies on repeatedly running the same computation using `Isolate.run`, you might improve performance by instead creating long-lived isolates that don’t exit immediately.**

단기 고립은 사용하기 편리하지만, 새로운 고립을 생성하고 객체를 한 고립에서 다른 고립으로 복사하는 데 성능 오버헤드가 발생한다. 만약 Isolate.run을 사용하여 동일한 계산을 반복적으로 실행해야 한다면, 즉시 종료하지 않는 장기 고립을 생성하여 성능을 향상시킬 수 있다.

**To do this, you can use some of the low-level isolate APIs that `Isolate.run` abstracts:**

이를 위해 Isolate.run이 추상화하는 몇 가지 저수준 고립 API를 사용할 수 있다:

- [**`Isolate.spawn()`](https://api.dart.dev/stable/dart-isolate/Isolate/spawn.html) and [`Isolate.exit()`](https://api.dart.dev/stable/dart-isolate/Isolate/exit.html)**
    
    Isolate.spawn() 및 Isolate.exit()
    
- [**`ReceivePort`](https://api.dart.dev/stable/dart-isolate/ReceivePort-class.html) and [`SendPort`](https://api.dart.dev/stable/dart-isolate/SendPort-class.html)**
    
    ReceivePort 및 SendPort
    
- [**`SendPort.send()` method**](https://api.dart.dev/stable/dart-isolate/SendPort/send.html)
    
    SendPort.send() 메서드
    

**This section goes over the steps required to establish 2-way communication between a newly spawned isolate and the [main isolate](https://dart.dev/language/concurrency#the-main-isolate). The first example, [Basic ports](https://dart.dev/language/isolates#basic-ports-example), introduces the process at a high-level. The second example, [Robust ports](https://dart.dev/language/isolates#robust-ports-example), gradually adds more practical, real-world functionality to the first.**

이 섹션에서는 새로 생성된 고립과 메인 고립 간의 양방향 통신을 설정하는 데 필요한 단계에 대해 설명한다. 첫 번째 예제인 기본 포트는 전체적인 프로세스를 소개한다. 두 번째 예제인 견고한 포트는 첫 번째 예제에 실용적이고 실제적인 기능을 점진적으로 추가한다.

## **`ReceivePort` and `SendPort`[#](https://dart.dev/language/isolates#receiveport-and-sendport)**
ReceivePort 및 SendPort

**Setting up long-lived communication between isolates requires two classes (in addition to `Isolate`): `ReceivePort` and `SendPort`. These ports are the only way isolates can communicate with each other.**

고립 간의 장기 통신을 설정하려면 두 클래스(고립 외에)가 필요하다: ReceivePort와 SendPort. 이 포트들은 고립 간에 통신할 수 있는 유일한 방법이다.

**A `ReceivePort` is an object that handles messages that are sent from other isolates. Those messages are sent via a `SendPort`.**

ReceivePort는 다른 고립에서 보내는 메시지를 처리하는 객체이다. 이 메시지들은 SendPort를 통해 보내진다.

<aside>
ℹ️ **Note**

**A `SendPort` object is associated with exactly one `ReceivePort`, but a single `ReceivePort` can have many `SendPorts`. When you create a `ReceivePort`, it creates a `SendPort` for itself. You can create additional `SendPorts` that can send messages to an existing `ReceivePort`.**

SendPort 객체는 정확히 하나의 ReceivePort와 연관되지만, 하나의 ReceivePort는 여러 SendPort를 가질 수 있다. ReceivePort를 생성하면 자동으로 SendPort를 생성한다. 기존 ReceivePort에 메시지를 보낼 수 있는 추가 SendPort를 생성할 수 있다.

</aside>

**Ports behave similarly to [`Stream`](https://api.dart.dev/stable/dart-async/Stream-class.html) objects (in fact, receive ports implement `Stream`!) You can think of a `SendPort` and `ReceivePort` like Stream's `StreamController` and listeners, respectively. A `SendPort` is like a `StreamController` because you "add" messages to them with the [`SendPort.send()` method](https://api.dart.dev/stable/dart-isolate/SendPort/send.html), and those messages are handled by a listener, in this case the `ReceivePort`. The `ReceivePort` then handles the messages it receives by passing them as arguments to a callback that you provide.**

포트는 Stream 객체와 유사하게 동작한다(실제로 receive ports는 Stream을 구현한다!) SendPort와 ReceivePort를 Stream의 StreamController와 리스너로 생각할 수 있다. SendPort는 SendPort.send() 메서드로 메시지를 “추가”하기 때문에 StreamController와 유사하며, 그 메시지는 리스너, 즉 ReceivePort에 의해 처리된다. ReceivePort는 수신된 메시지를 제공된 콜백의 인수로 전달하여 메시지를 처리한다.

**Setting up ports[#](https://dart.dev/language/isolates#setting-up-ports)** 
포트 설정

**A newly spawned isolate only has the information it receives through the `Isolate.spawn` call. If you need the main isolate to continue to communicate with a spawned isolate past its initial creation, you must set up a communication channel where the spawned isolate can send messages to the main isolate. Isolates can only communicate via message passing. They can’t “see” inside each others’ memory, which is where the name “isolate” comes from.**

새로 생성된 고립은 Isolate.spawn 호출을 통해 수신한 정보만 가지고 있다. 생성된 고립이 초기 생성 이후에도 메인 고립과 통신을 계속해야 한다면, 생성된 고립이 메인 고립으로 메시지를 보낼 수 있는 통신 채널을 설정해야 한다. 고립은 메시지 전달을 통해서만 통신할 수 있다. 서로의 메모리 내부를 “볼 수” 없다. 여기서 “고립”이라는 이름이 유래되었다.

**To set up this 2-way communication, first create a [`ReceivePort`](https://api.dart.dev/stable/dart-isolate/ReceivePort-class.html) in the main isolate, then pass its [`SendPort`](https://api.dart.dev/stable/dart-isolate/SendPort-class.html) as an argument to the new isolate when spawning it with `Isolate.spawn`. The new isolate then creates its own `ReceivePort`, and sends *its* `SendPort` back on the `SendPort` it was passed by the main isolate. The main isolate receives this `SendPort`, and now both sides have an open channel to send and receive messages.**

이 양방향 통신을 설정하려면 먼저 메인 고립에서 ReceivePort를 생성한 다음 Isolate.spawn으로 생성할 때 첫 번째 메시지로 SendPort를 전달한다. 새 고립은 자체 ReceivePort를 생성하고, 메인 고립에서 전달받은 SendPort로 다시 SendPort를 보낸다. 메인 고립은 이 SendPort를 수신하고, 이제 양쪽 모두 메시지를 보내고 받을 수 있는 열린 채널을 가지게 된다.

<aside>
ℹ️ **Note**

**The diagrams in this section are high-level and intended to convey the *concept* of using ports for isolates. Actual implementation requires a bit more code, which you will find [later on this page](https://dart.dev/language/isolates#basic-ports-example).**

이 섹션의 다이어그램은 고립을 위한 포트를 사용하는 개념을 전달하기 위한 높은 수준의 것이다. 실제 구현에는 이 페이지 뒷부분에 나오는 더 많은 코드가 필요하다.

</aside>

!https://dart.dev/assets/img/C3cZkN_RYw-708.png

1. **Create a `ReceivePort` in the main isolate. The `SendPort` is created automatically as a property on the `ReceivePort`.**
    
    메인 고립에서 ReceivePort를 생성한다. SendPort는 ReceivePort의 속성으로 자동 생성된다.
    
2. **Spawn the worker isolate with `Isolate.spawn()`**
    
    Isolate.spawn()으로 워커 고립을 생성한다.
    
3. **Pass a reference to `ReceivePort.sendPort` as the first message to the worker isolate.**
    
    ReceivePort.sendPort에 대한 참조를 첫 번째 메시지로 생성된 고립에 전달한다.
    
4. **Create another new `ReceivePort` in the worker isolate.**
    
    생성된 고립에서 또 다른 새로운 ReceivePort를 생성한다.
    
5. **Pass a reference to the worker isolate's `ReceivePort.sendPort` as the first message *back* to the main isolate.**
    
    생성된 고립의 ReceivePort.sendPort에 대한 참조를 첫 번째 메시지로 메인 고립에 다시 전달한다.
    

**Along with creating the ports and setting up communication, you’ll also need to tell the ports what to do when they receive messages. This is done using the `listen` method on each respective `ReceivePort`.**

포트를 생성하고 통신을 설정하는 것 외에도 포트가 메시지를 수신할 때 해야 할 일을 지시해야 한다. 이는 각 ReceivePort의 listen 메서드를 사용하여 수행된다.

!https://dart.dev/assets/img/SJOLJRMsnW-747.png

1. **Send a message via the main isolate’s reference to the worker isolate's `SendPort`.**
    
    메인 고립의 SendPort 참조를 통해 메시지를 보낸다.
    
2. **Receive and handle the message via a listener on the worker isolate's `ReceivePort`. This is where the computation you want to move off the main isolate is executed.**
    
    리스너에서 생성된 고립의 ReceivePort를 통해 메시지를 수신하고 처리한다. 여기서 메인 고립을 차단하지 않으면서 실행하고 싶은 계산을 수행한다.
    
3. **Send a return message via the worker isolate's reference to the main isolate's `SendPort`.**
    
    생성된 고립의 SendPort 참조를 통해 반환 메시지를 보낸다
    
4. **Receive the message via a listener on the main isolate's `ReceivePort`.**
    
    메인 고립의 ReceivePort에서 리스너를 통해 메시지를 수신한다.
    

## **Basic ports example[#](https://dart.dev/language/isolates#basic-ports-example)**
기본 포트 예제

**This example demonstrates how you can set up a long-lived worker isolate with 2-way communication between it and the main isolate. The code uses the example of sending JSON text to a new isolate, where the JSON will be parsed and decoded, before being sent back to the main isolate.**

이 예제는 메인 고립과 생성된 고립 간의 양방향 통신을 설정하는 장기 워커 고립을 설정하는 방법을 보여준다. 코드는 JSON 텍스트를 새로운 고립으로 보내고, JSON을 파싱 및 디코딩한 다음, 다시 메인 고립으로 보내는 예제를 사용한다.

<aside>
ℹ️ **Warning**

**This example is meant to teach the *bare minimum* needed to spawn a new isolate that can send and receive multiple messages over time.**

이 예제는 새로 생성된 고립을 스폰하여 시간이 지남에 따라 여러 메시지를 보내고 받을 수 있는 최소한의 기능을 가르치기 위한 것이다.

**It does not cover important pieces of functionality that are expected in production software, like error handling, shutting down ports, and message sequencing.**

이는 생산 소프트웨어에서 기대되는 중요한 기능(예: 오류 처리, 포트 종료 및 메시지 시퀀싱)을 다루지 않는다.

**The [Robust ports example](https://dart.dev/language/isolates#robust-ports-example) in the next section covers this functionality and discusses some of the issues that can arise without it.**

다음 섹션의 견고한 포트 예제는 이 기능을 다루고, 이를 포함하지 않았을 때 발생할 수 있는 문제를 논의한다.

</aside>

**Step 1: Define the worker class[#](https://dart.dev/language/isolates#step-1-define-the-worker-class)**
1단계: 워커 클래스 정의하기

**First, create a class for your background worker isolate. This class contains all the functionality you need to:**

먼저, 백그라운드 워커 고립을 위한 클래스를 생성한다. 이 클래스는 다음 기능을 모두 포함한다:

- **Spawn an isolate.**
    
    고립 생성
    
- **Send messages to that isolate.**
    
    그 고립에 메시지 보내기
    
- **Have the isolate decode some JSON.**
    
    고립에서 JSON 디코딩하기
    
- **Send the decoded JSON back to the main isolate.**
    
    디코딩된 JSON을 메인 고립으로 보내기
    

**The class exposes two public methods: one that spawns the worker isolate, and one that handles sending messages to that worker isolate.**

이 클래스는 두 개의 공개 메서드를 노출한다: 하나는 워커 고립을 생성하는 것이고, 하나는 워커 고립에 메시지를 보내는 것이다.

**The remaining sections in this example will show you how to fill in the class methods, one-by-one.**

나머지 섹션에서는 클래스 메서드를 하나씩 채우는 방법을 보여준다.

```dart
class Worker {
  Future<void> spawn() async {
    // TODO: 워커 고립을 생성하는 기능 추가하기.
  }

  void _handleResponsesFromIsolate(dynamic message) {
    // TODO: 워커 고립에서 보낸 메시지 처리하기.
  }

  static void _startRemoteIsolate(SendPort port) {
    // TODO: 워커 고립에서 실행할 코드 정의하기.
  }

  Future<void> parseJson(String message) async {
    // TODO: 워커 고립에 메시지를 보내는 데 사용할 수 있는 공개 메서드 정의하기.
  }
}
```

**Step 2: Spawn a worker isolate[#](https://dart.dev/language/isolates#step-2-spawn-a-worker-isolate)**

2단계: 워커 고립 생성하기

**The `Worker.spawn` method is where you will group the code for creating the worker isolate and ensuring it can receive and send messages.**

Worker.spawn 메서드는 워커 고립을 생성하고, 메시지를 수신 및 송신할 수 있도록 하는 코드를 그룹화하는 곳이다.

- **First, create a `ReceivePort`. This allows the main isolate to receive messages sent from the newly spawned worker isolate.**
    
    먼저, ReceivePort를 생성한다. 이는 메인 고립이 새로 생성된 워커 고립에서 보내는 메시지를 수신할 수 있게 한다.
    
- **Next, add a listener to the receive port to handle messages the worker isolate will send back. The callback passed to the listener, `_handleResponsesFromIsolate`, will be covered in [step 4](https://dart.dev/language/isolates#step-4-handle-messages-on-the-main-isolate).**
    
    다음으로, 워커 고립이 다시 보낼 메시지를 처리하기 위해 receive port에 리스너를 추가한다. listen 메서드에 전달된 콜백인 _handleResponsesFromIsolate는 4단계에서 다룬다.
    
- **Finally, spawn the worker isolate with `Isolate.spawn`. It expects two arguments: a function to be executed on the worker isolate (covered in [step 3](https://dart.dev/language/isolates#step-3-execute-code-on-the-worker-isolate)), and the `sendPort` property of the receive port.**
    
    마지막으로, Isolate.spawn으로 워커 고립을 생성한다. 두 개의 인수를 기대한다: 워커 고립에서 실행할 함수(3단계에서 다룸)와 receive port의 sendPort 속성.
    

```dart
Future<void> spawn() async {
  final receivePort = ReceivePort();
  receivePort.listen(_handleResponsesFromIsolate);
  await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort);
}
```

**The `receivePort.sendPort` argument will be passed to the callback (`_startRemoteIsolate`) as an argument when it’s called on the worker isolate. This is the first step in ensuring that the worker isolate has a way to send messages back to the main isolate.**

receivePort.sendPort 인수는 워커 고립에서 호출될 때 콜백(_startRemoteIsolate)에 인수로 전달된다. 이는 워커 고립이 메인 고립으로 메시지를 보낼 수 있도록 하는 첫 번째 단계이다.

**Step 3: Execute code on the worker isolate[#](https://dart.dev/language/isolates#step-3-execute-code-on-the-worker-isolate)**

3단계: 워커 고립에서 코드 실행하기

**In this step, you define the method `_startRemoteIsolate` that is sent to the worker isolate to be executed when it spawns. This method is like the “main” method for the worker isolate.**

이 단계에서는 고립이 생성될 때 실행되도록 워커 고립으로 보내는 메서드 _startRemoteIsolate를 정의한다. 이 메서드는 워커 고립의 “메인” 메서드와 같다.

- **First, create another new `ReceivePort`. This port receives future messages from the main isolate.**
    
    먼저, 또 다른 새로운 ReceivePort를 생성한다. 이 포트는 메인 고립에서 보낼 미래의 메시지를 수신한다.
    
- **Next, send that port’s `SendPort` back to the main isolate.**
    
    다음으로, 해당 포트의 SendPort를 메인 고립으로 다시 보낸다.
    
- **Finally, add a listener to the new `ReceivePort`. This listener handles messages the main isolate sends to the worker isolate.**
    
    마지막으로, 새로운 ReceivePort에 리스너를 추가한다. 이 리스너는 메인 고립에서 워커 고립으로 보낸 메시지를 처리한다.
    

```dart
static void _startRemoteIsolate(SendPort port) {
  final receivePort = ReceivePort();
  port.send(receivePort.sendPort);

  receivePort.listen((dynamic message) async {
    if (message is String) {
      final transformed = jsonDecode(message);
      port.send(transformed);
    }
  });
}
```

**The listener on the worker’s `ReceivePort` decodes the JSON passed from the main isolate, and then sends the decoded JSON back to the main isolate.**

워커의 ReceivePort 리스너는 메인 고립에서 전달된 JSON을 디코딩한 다음, 디코딩된 JSON을 다시 메인 고립으로 보낸다.

**This listener is the entry point for messages sent from the main isolate to the worker isolate. This is the only chance you have to tell the worker isolate what code to execute in the future.**

이 리스너는 메인 고립에서 워커 고립으로 보낸 메시지의 진입점이다. 이는 워커 고립이 미래에 실행할 코드를 지시할 유일한 기회이다.

**Step 4: Handle messages on the main isolate[#](https://dart.dev/language/isolates#step-4-handle-messages-on-the-main-isolate)**
4단계: 메인 고립에서 메시지 처리하기

**Finally, you need to tell the main isolate how to handle messages sent from the worker isolate back to the main isolate. To do so, you need to fill in the `_handleResponsesFromIsolate` method. Recall that this method is passed to the `receivePort.listen` method, as described in [step 2](https://dart.dev/language/isolates#step-2-spawn-a-worker-isolate):**

마지막으로, 메인 고립에서 워커 고립이 다시 보낸 메시지를 처리하는 방법을 지시해야 한다. 이를 위해 _handleResponsesFromIsolate 메서드를 채워야 한다. 이 메서드는 2단계에서 설명한 대로 receivePort.listen 메서드에 전달된다:

```dart
Future<void> spawn() async {
  final receivePort = ReceivePort();
  receivePort.listen(_handleResponsesFromIsolate);
  await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort);
}
```

**Also recall that you sent a `SendPort` back to the main isolate in [step 3](https://dart.dev/language/isolates#step-3-execute-code-on-the-worker-isolate). This method handles the receipt of that `SendPort`, as well as handling future messages (which will be decoded JSON).**

또한, 3단계에서 SendPort를 메인 고립으로 다시 보낸다고 언급했다. 이 메서드는 그 SendPort의 수신과 향후 메시지(디코딩된 JSON)를 처리하는 역할을 한다.

- **First, check if the message is a `SendPort`. If so, assign that port to the class's `_sendPort` property so it can be used to send messages later.**
    
    먼저, 메시지가 SendPort인지 확인한다. 그렇다면, 그 포트를 클래스의 _sendPort 속성에 할당하여 나중에 메시지를 보내는 데 사용할 수 있다.
    
- **Next, check if the message is of type `Map<String, dynamic>`, the expected type of decoded JSON. If so, handle that message with your application-specific logic. In this example, the message is printed.**
    
    다음으로, 메시지가 예상된 디코딩된 JSON 유형(Map<String, dynamic>)인지 확인한다. 그렇다면, 해당 메시지를 어플리케이션 특정 로직으로 처리한다. 이 예제에서는 메시지를 출력한다.
    

```dart
void _handleResponsesFromIsolate(dynamic message) {
  if (message is SendPort) {
    _sendPort = message;
    _isolateReady.complete();
  } else if (message is Map<String, dynamic>) {
    print(message);
  }
}
```

**Step 5: Add a completer to ensure your isolate is set-up[#](https://dart.dev/language/isolates#step-5-add-a-completer-to-ensure-your-isolate-is-set-up)**
5단계: 고립 설정을 보장하기 위한 completer 추가하기

**To complete the class, define a public method called `parseJson`, which is responsible for sending messages to the worker isolate. It also needs to ensure that messages can be sent before the isolate is fully set up. To handle this, use a [`Completer`](https://api.dart.dev/stable/dart-async/Completer-class.html).**

클래스를 완성하려면, 고립이 완전히 설정되기 전에 메시지를 보낼 수 있도록 하는 parseJson이라는 공개 메서드를 정의해야 한다. 이를 처리하기 위해 Completer를 사용한다.

- **First, add a class-level property called a `Completer` and name it `_isolateReady`.**
    
    먼저, 클래스 수준 속성으로 Completer를 추가하고, _isolateReady라고 이름 짓는다.
    
- **Next, add a call to `complete()` on the completer in the `_handleResponsesFromIsolate` method (created in [step 4](https://dart.dev/language/isolates#step-4-handle-messages-on-the-main-isolate)) if the message is a `SendPort`.**
    
    다음으로, _handleResponsesFromIsolate 메서드에서 메시지가 SendPort인 경우 completer를 완료한다.
    
- **Finally, in the `parseJson` method, add `await _isolateReady.future` before adding `_sendPort.send`. This ensures that no message can be sent to the worker isolate until it is spawned *and* has sent its `SendPort` back to the main isolate.**
    
    마지막으로, parseJson 메서드에서 _sendPort.send를 추가하기 전에 await _isolateReady.future를 추가한다. 이는 고립이 생성되고, 메인 고립으로 SendPort를 보낼 때까지 메시지를 보낼 수 없도록 보장한다.
    

```dart
Future<void> parseJson(String message) async {
  await _isolateReady.future;
  _sendPort.send(message);
}
```

**Complete example[#](https://dart.dev/language/isolates#complete-example)**
완전한 예제

- **Expand to see the complete example**
    
    ```dart
    import 'dart:async';
    import 'dart:convert';
    import 'dart:isolate';
    
    void main() async {
      final worker = Worker();
      await worker.spawn();
      await worker.parseJson('{"key":"value"}');
    }
    
    class Worker {
      late SendPort _sendPort;
      final Completer<void> _isolateReady = Completer.sync();
    
      Future<void> spawn() async {
        final receivePort = ReceivePort();
        receivePort.listen(_handleResponsesFromIsolate);
        await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort);
      }
    
      void _handleResponsesFromIsolate(dynamic message) {
        if (message is SendPort) {
          _sendPort = message;
          _isolateReady.complete();
        } else if (message is Map<String, dynamic>) {
          print(message);
        }
      }
    
      static void _startRemoteIsolate(SendPort port) {
        final receivePort = ReceivePort();
        port.send(receivePort.sendPort);
    
        receivePort.listen((dynamic message) async {
          if (message is String) {
            final transformed = jsonDecode(message);
            port.send(transformed);
          }
        });
      }
    
      Future<void> parseJson(String message) async {
        await _isolateReady.future;
        _sendPort.send(message);
      }
    }
    ```
    

## **Robust ports example[#](https://dart.dev/language/isolates#robust-ports-example)**
견고한 포트 예제

**The [previous example](https://dart.dev/language/isolates#basic-ports-example) explained the basic building blocks needed to set up a long-lived isolate with two-way communication. As mentioned, that example lacks some important features, such as error handling, the ability to close the ports when they’re no longer in use, and inconsistencies around message ordering in some situations.**

이전 예제는 양방향 통신이 가능한 장기 고립을 설정하는 데 필요한 기본 빌딩 블록을 설명했다. 언급했듯이, 이 예제는 오류 처리, 포트가 더 이상 사용되지 않을 때 닫는 기능, 일부 상황에서의 메시지 순서 문제와 같은 중요한 기능이 부족하다.

**This example expands on the information in the first example by creating a long-lived worker isolate that has these additional features and more, and follows better design patterns. Although this code has similarities to the first example, it is not an extension of that example.**

이 예제는 첫 번째 예제의 정보를 확장하여 추가 기능을 갖춘 장기 워커 고립을 생성하고, 더 나은 설계 패턴을 따른다. 이 코드는 첫 번째 예제와 유사점이 있지만, 첫 번째 예제의 확장은 아니다.

<aside>
ℹ️ **Note**

**This example assumes that you are already familiar with establishing communication between isolates with `Isolate.spawn` and ports, which was covered in the [previous example](https://dart.dev/language/isolates#basic-ports-example).**

이 예제는 Isolate.spawn 및 포트를 사용하여 고립 간 통신을 설정하는 것에 이미 익숙하다고 가정한다. 이는 이전 예제에서 다루었다.

</aside>

**Step 1: Define the worker class[#](https://dart.dev/language/isolates#step-1-define-the-worker-class-1)**
1단계: 워커 클래스 정의하기

**First, create a class for your background worker isolate. This class contains all the functionality you need to:**

먼저, 백그라운드 워커 고립을 위한 클래스를 생성한다. 이 클래스는 다음 기능을 모두 포함한다:

- **Spawn an isolate.**
    
    고립 생성
    
- **Send messages to that isolate.**
    
    그 고립에 메시지 보내기
    
- **Have the isolate decode some JSON.**
    
    고립에서 JSON 디코딩하기
    
- **Send the decoded JSON back to the main isolate.**
    
    디코딩된 JSON을 메인 고립으로 보내기
    

**The class exposes three public methods: one that creates the worker isolate, one that handles sending messages to that worker isolate, and one that can shut down the ports when they’re no longer in use.**

이 클래스는 세 개의 공개 메서드를 노출한다: 하나는 워커 고립을 생성하는 것이고, 하나는 그 워커 고립에 메시지를 보내는 것이며, 하나는 포트를 더 이상 사용하지 않을 때 닫는 것이다.

```dart
class Worker {
  final SendPort _commands;
  final ReceivePort _responses;

  Future<Object?> parseJson(String message) async {
    // TODO: 포트가 여전히 열려 있는지 확인하기.
    _commands.send(message);
  }

  static Future<Worker> spawn() async {
    // TODO: 생성된 고립과의 연결로 새 Worker 객체를 생성하는 기능 추가하기.
    throw UnimplementedError();
  }

  Worker._(this._responses, this._commands) {
		// TODO: 메인 고립 receive port 리스너 초기화하기.
	}

void _handleResponsesFromIsolate(dynamic message) {
		// TODO: 워커 고립에서 보낸 메시지 처리하기.
	}

static void _handleCommandsToIsolate(ReceivePort rp, SendPort sp) async {
		// TODO: 워커 고립에서 보낸 메시지 처리하기.
	}

static void _startRemoteIsolate(SendPort sp) {
		// TODO: 워커 고립의 포트 초기화하기.
	}
}
```

<aside>
ℹ️ **Note**

**In this example, `SendPort` and `ReceivePort` instances follow a best practice naming convention, in which they are named in relation to the main isolate. The messages sent through the `SendPort` from the main isolate to the worker isolate are called *commands*, and the messages sent back to the main isolate are called *responses*.**

이 예제에서는 SendPort 및 ReceivePort 인스턴스가 메인 고립과 관련하여 이름이 지정되는 모범 사례 명명 규칙을 따른다. 메인 고립에서 워커 고립으로 보내는 메시지는 명령(command)이라고 하고, 메인 고립으로 다시 보내는 메시지는 응답(response)이라고 한다.

</aside>

**Step 2: Create a `RawReceivePort` in the `Worker.spawn` method[#](https://dart.dev/language/isolates#step-2-create-a-rawreceiveport-in-the-worker-spawn-method)**

2단계: Worker.spawn 메서드에서 RawReceivePort 생성하기

**Before spawning an isolate, you need to create a [`RawReceivePort`](https://api.dart.dev/stable/dart-isolate/RawReceivePort-class.html), which is a lower-level `ReceivePort`. Using `RawReceivePort` is a preferred pattern because it allows you to separate your isolate startup logic from logic that handles message passing on the isolate.**

고립을 생성하기 전에 RawReceivePort를 생성해야 한다. 이는 저수준의 ReceivePort이다. RawReceivePort를 사용하는 것이 선호되는 패턴인 이유는 고립 시작 논리를 메시지 전달 논리에서 분리할 수 있기 때문이다.

**In the `Worker.spawn` method:**

Worker.spawn 메서드에서:

- **First, create the `RawReceivePort`. This `ReceivePort` is only responsible for receiving the initial message from the worker isolate, which will be a `SendPort`.**
    
    먼저, RawReceivePort를 생성한다. 이 ReceivePort는 워커 고립에서 보낼 초기 메시지를 수신하는 역할만 한다. 이는 SendPort가 된다.
    
- **Next, create a `Completer` that will indicate when the isolate is ready to receive messages. When this completes, it will return a record with a `ReceivePort` and a `SendPort`.**
    
    다음으로, 고립이 메시지를 받을 준비가 되었음을 나타내는 Completer를 생성한다. 완료되면 ReceivePort와 SendPort가 있는 레코드를 반환한다.
    
- **Next, define the `RawReceivePort.handler` property. This property is a `Function?` that behaves like `ReceivePort.listener`. The function is called when a message is received by this port.**
    
    다음으로, RawReceivePort.handler 속성을 정의한다. 이 속성은 ReceivePort.listener와 유사한 함수이다. 이 함수는 이 포트에서 메시지를 수신할 때 호출된다.
    
- **Within the handler function, call `connection.complete()`. This method expects a [record](https://dart.dev/language/records) with a `ReceivePort` and a `SendPort` as an argument. The `SendPort` is the initial message sent from the worker isolate, which will be assigned in the next step to the class level `SendPort` named `_commands`.**
    
    핸들러 함수 내에서 connection.complete()을 호출한다. 이 메서드는 ReceivePort와 SendPort가 포함된 레코드를 인수로 기대한다. SendPort는 다음 단계에서 클래스 수준의 SendPort인 _commands에 할당된다.
    
- **Then, create a new `ReceivePort` with the `ReceivePort.fromRawReceivePort` constructor, and pass in the `initPort`.**
    
    마지막으로, ReceivePort.fromRawReceivePort 생성자를 사용하여 새로운 ReceivePort를 생성하고, initPort를 전달한다.
    

```dart
class Worker {
  final SendPort _commands;
  final ReceivePort _responses;

  static Future<Worker> spawn() async {
    // ReceivePort를 생성하고 초기 메시지 핸들러를 추가한다.
    final initPort = RawReceivePort();
    final connection = Completer<(ReceivePort, SendPort)>.sync();
    initPort.handler = (initialMessage) {
      final commandPort = initialMessage as SendPort;
      connection.complete((
        ReceivePort.fromRawReceivePort(initPort),
        commandPort,
      ));
    };
  }
```

**By creating a `RawReceivePort` first, and then a `ReceivePort`, you’ll be able to add a new callback to `ReceivePort.listen` later on. Conversely, if you were to create a `ReceivePort` straight away, you’d only be able to add one `listener`, because `ReceivePort` implements [`Stream`](https://api.dart.dev/stable/dart-async/Stream-class.html), rather than [`BroadcastStream`](https://api.dart.dev/stable/dart-async/BroadcastStream-class.html).**

RawReceivePort를 먼저 생성한 다음 ReceivePort를 생성하면 나중에 ReceivePort.listen에 새로운 콜백을 추가할 수 있다. 반면, ReceivePort를 바로 생성하면 ReceivePort가 Stream을 구현하므로 하나의 리스너만 추가할 수 있다.

**Effectively, this allows you to separate your isolate start-up logic from the logic that handles receiving messages after setting up communication is complete. This benefit will become more obvious as the logic in the other methods grows.**

실제로 이는 고립 시작 논리를 통신 설정이 완료된 후 메시지 수신을 처리하는 논리와 분리할 수 있게 한다. 이는 다른 메서드의 논리가 증가함에 따라 더 명확해질 것이다.

**Step 3: Spawn a worker isolate with `Isolate.spawn`[#](https://dart.dev/language/isolates#step-3-spawn-a-worker-isolate-with-isolate-spawn)**

3단계: Isolate.spawn을 사용하여 워커 고립 생성하기

**This step continues to fill in the `Worker.spawn` method. You’ll add the code needed to spawn an isolate, and return an instance of `Worker` from this class. In this example, the call to `Isolate.spawn` is wrapped in a [`try`/`catch` block](https://dart.dev/language/error-handling#catch), which ensures that, if the isolate fails to start up, the `initPort` will be closed, and the `Worker` object won’t be created.**

이 단계는 Worker.spawn 메서드를 채우는 것을 계속한다. 고립을 생성하는 데 필요한 코드를 추가하고, 이 클래스에서 Worker 인스턴스를 반환한다. 이 예제에서는 Isolate.spawn 호출이 try/catch 블록에 래핑되어 있다. 고립 생성에 실패하면 initPort가 닫히고, Worker 객체가 생성되지 않도록 보장한다.

- **First, attempt to spawn a worker isolate in a `try`/`catch` block. If spawning a worker isolate fails, close the receive port that was created in the previous step. The method passed to `Isolate.spawn` will be covered in a later step.**
    
    먼저, try/catch 블록 내에서 워커 고립을 생성하려고 시도한다. 워커 고립 생성에 실패하면 이전 단계에서 생성된 receive port를 닫는다. Isolate.spawn에 전달된 메서드는 다음 단계에서 다룬다.
    
- **Next, await the `connection.future`, and destructure the send port and receive port from the record it returns.**
    
    다음으로, connection.future를 대기하고, 레코드에서 send port와 receive port를 구조 분해한다.
    
- **Finally, return an instance of `Worker` by calling its private constructor, and passing in the ports from that completer.**
    
    마지막으로, private 생성자를 호출하여 포트를 전달함으로써 Worker 인스턴스를 반환한다.
    

```dart
class Worker {
  final SendPort _commands;
  final ReceivePort _responses;

  static Future<Worker> spawn() async {
    // ReceivePort를 생성하고 초기 메시지 핸들러를 추가한다.
    final initPort = RawReceivePort();
    final connection = Completer<(ReceivePort, SendPort)>.sync();
    initPort.handler = (initialMessage) {
      final commandPort = initialMessage as SendPort;
      connection.complete((
        ReceivePort.fromRawReceivePort(initPort),
        commandPort,
      ));
    };
    // 고립을 생성한다.
    try {
      await Isolate.spawn(_startRemoteIsolate, (initPort.sendPort));
    } on Object {
      initPort.close();
      rethrow;
    }

    final (ReceivePort receivePort, SendPort sendPort) =
        await connection.future;

    return Worker._(receivePort, sendPort);
  }
```

**Note that in this example (compared to the [previous example](https://dart.dev/language/isolates#basic-ports-example)), `Worker.spawn` acts as an asynchronous static constructor for this class and is the only way to create an instance of `Worker`. This simplifies the API, making the code that creates an instance of `Worker` cleaner.**

이 예제에서 Worker.spawn은 이 클래스의 비동기 정적 생성자로 작동하며, Worker 인스턴스를 생성하는 유일한 방법이다. 이는 API를 단순화하여 Worker 인스턴스를 생성하는 코드를 더 깔끔하게 만든다.

**Step 4: Complete the isolate setup process[#](https://dart.dev/language/isolates#step-4-complete-the-isolate-setup-process)**

4단계: 고립 설정 프로세스 완료하기

**In this step, you will complete the basic isolate setup process. This correlates almost entirely to the [previous example](https://dart.dev/language/isolates#basic-ports-example), and there are no new concepts. There is a slight change in that the code is broken into more methods, which is a design practice that sets you up for adding more functionality through the remainder of this example. For an in-depth walkthrough of the basic process of setting up an isolate, see the [basic ports example](https://dart.dev/language/isolates#basic-ports-example).**

이 단계에서는 기본 고립 설정 프로세스를 완료한다. 이는 거의 이전 예제와 완전히 일치하며, 새로운 개념은 없다. 약간의 차이는 코드가 더 많은 메서드로 나누어져 있어 나머지 예제에서 기능을 더 추가할 수 있게 하는 설계 실습이다. 고립을 설정하는 기본 프로세스에 대한 심층적인 워크스루는 기본 포트 예제를 참조하라.

**First, create the private constructor that is returned from the `Worker.spawn` method. In the constructor body, add a listener to the receive port used by the main isolate, and pass an as-yet undefined method to that listener called `_handleResponsesFromIsolate`.**

먼저, Worker.spawn 메서드에서 반환되는 private 생성자를 생성한다. 생성자 본문에서 메인 고립이 사용하는 receive port에 리스너를 추가하고, _handleResponsesFromIsolate라는 아직 정의되지 않은 메서드를 해당 리스너에 전달한다.

```dart
class Worker {
  final SendPort _commands;
  final ReceivePort _responses;
// ···
  Worker._(this._responses, this._commands) {
    _responses.listen(_handleResponsesFromIsolate);
  }
```

**Next, add the code to `_startRemoteIsolate` that is responsible for initializing the ports on the worker isolate. [Recall](https://dart.dev/language/isolates#step-3-spawn-a-worker-isolate-with-isolate-spawn) that this method was passed to `Isolate.spawn` in the `Worker.spawn` method, and it will be passed the main isolate’s `SendPort` as an argument.**

다음으로, _startRemoteIsolate에 워커 고립에서 포트를 초기화하는 데 필요한 코드를 추가한다. 이 메서드는 Worker.spawn 메서드에서 Isolate.spawn에 전달되며, 메인 고립의 SendPort를 인수로 받는다.

- **Create a new `ReceivePort`.**
    
    새로운 ReceivePort를 생성한다.
    
- **Send that port’s `SendPort` back to the main isolate.**
    
    그 포트의 SendPort를 메인 고립으로 다시 보낸다.
    
- **Call a new method called `_handleCommandsToIsolate`, and pass both the new `ReceivePort` and `SendPort` from the main isolate as arguments.**
    
    새로운 ReceivePort와 메인 고립의 SendPort를 인수로 전달하는 _handleCommandsToIsolate라는 새로운 메서드를 호출한다.
    

```dart
static void _startRemoteIsolate(SendPort sendPort) {
  final receivePort = ReceivePort();
  sendPort.send(receivePort.sendPort);
  _handleCommandsToIsolate(receivePort, sendPort);
}
```

**Next, add the `_handleCommandsToIsolate` method, which is responsible for receiving messages from the main isolate, decoding json on the worker isolate, and sending the decoded json back as a response.**

다음으로, _handleCommandsToIsolate 메서드를 추가하여, 이는 메인 고립에서 보내는 메시지를 수신하고, 워커 고립에서 json을 디코딩한 다음, 디코딩된 json을 응답으로 다시 보내는 역할을 한다.

- **First, declare a listener on the worker isolate’s `ReceivePort`.**
    
    먼저, 워커 고립의 ReceivePort에 리스너를 선언한다.
    
- **Within the callback added to the listener, attempt to decode the JSON passed from the main isolate within a [`try`/`catch` block](https://dart.dev/language/error-handling#catch). If decoding is successful, send the decoded JSON back to the main isolate.**
    
    리스너에 추가된 콜백 내에서 try/catch 블록 내에서 메인 고립에서 전달된 JSON을 디코딩하려고 시도한다. 디코딩이 성공하면, 디코딩된 JSON을 다시 메인 고립으로 보낸다.
    
- **If there is an error, send back a [`RemoteError`](https://api.dart.dev/stable/dart-isolate/RemoteError-class.html).**
    
    오류가 발생하면 RemoteError를 다시 보낸다.
    

```dart
static void _handleCommandsToIsolate(
    ReceivePort receivePort, SendPort sendPort) {
  receivePort.listen((message) {
    try {
      final jsonData = jsonDecode(message as String);
      sendPort.send(jsonData);
    } catch (e) {
      sendPort.send(RemoteError(e.toString(), ''));
    }
  });
}
```

**Next, add the code for the `_handleResponsesFromIsolate` method.**

다음으로, _handleResponsesFromIsolate 메서드에 대한 코드를 추가한다.

- **First, check if the message is a `RemoteError`, in which case you should `throw` that error.**
    
    먼저, 메시지가 RemoteError인지 확인하고, 그렇다면 해당 오류를 throw한다.
    
- **Otherwise, print the message. In future steps, you will update this code to return messages rather than print them.**
    
    그렇지 않으면, 메시지를 출력한다. 다음 단계에서는 이 코드를 메시지를 반환하도록 업데이트한다.
    

```dart
void _handleResponsesFromIsolate(dynamic message) {
  if (message is RemoteError) {
    throw message;
  } else {
    print(message);
  }
}
```

**Finally, add the `parseJson` method, which is a public method that allows outside code to send JSON to the worker isolate to be decoded.**

마지막으로, parseJson 메서드를 추가하여, 이는 외부 코드가 JSON을 워커 고립으로 보내서 디코딩할 수 있게 하는 공개 메서드이다.

```dart
Future<Object?> parseJson(String message) async {
  _commands.send(message);
}
```

**You will update this method in the next step.**

다음 단계에서 이 메서드를 업데이트할 것이다.

**Step 5: Handle multiple messages at the same time[#](https://dart.dev/language/isolates#step-5-handle-multiple-messages-at-the-same-time)**

5단계: 동시에 여러 메시지 처리하기

**Currently, if you rapidly send messages to the worker isolate, the isolate will send the decoded json response in *the order that they complete*, rather than the order that they’re sent. You have no way to determine which response corresponds to which message.**

현재, 메시지를 워커 고립으로 빠르게 보내면, 고립이 디코딩된 json 응답을 완료된 순서대로 보내며, 전송된 순서대로 보내지 않는다. 어떤 응답이 어떤 메시지에 해당하는지 알 방법이 없다.

**In this step, you’ll fix this problem by giving each message an id, and using `Completer` objects to ensure that when outside code calls `parseJson` the response that is returned to that caller is the correct response.**

이 단계에서는 각 메시지에 id를 부여하고, Completer 객체를 사용하여 parseJson을 호출하는 코드에 올바른 응답을 반환하도록 수정한다.

**First, add two class-level properties to `Worker`:**

먼저, Worker에 두 개의 클래스 수준 속성을 추가한다:

- **`Map<int, Completer<Object?>> _activeRequests`**
    
    Map<int, Completer<Object?>> _activeRequests
    
- **`int _idCounter`**
    
    int _idCounter
    

```dart
class Worker {
  final SendPort _commands;
  final ReceivePort _responses;
  final Map<int, Completer<Object?>> _activeRequests = {};
  int _idCounter = 0;
```

**The `_activeRequests` map associates a message sent to the worker isolate with a `Completer`. The keys used in `_activeRequests` are taken from `_idCounter`, which will be increased as more messages are sent.**

_activeRequests 맵은 워커 고립으로 보낸 메시지를 Completer와 연관시킨다. _activeRequests에 사용되는 키는 더 많은 메시지가 전송됨에 따라 증가하는 _idCounter에서 가져온다.

**Next, update the `parseJson` method to create completers before it sends messages to the worker isolate.**

다음으로, 고립으로 메시지를 보내기 전에 parseJson 메서드를 업데이트하여 completer를 생성한다.

- **First create a `Completer`.**
    
    먼저, Completer를 생성한다.
    
- **Next, increment `_idCounter`, so that each `Completer` is associated with a unique number.**
    
    다음으로, _idCounter를 증가시켜 각 Completer가 고유한 번호와 연관되도록 한다.
    
- **Add an entry to the `_activeRequests` map in which the key is the current number of `_idCounter`, and the completer is the value.**
    
    _activeRequests 맵에 현재 _idCounter 번호를 키로 하고, completer를 값으로 하는 항목을 추가한다.
    
- **Send the message to the worker isolate, along with the id. Because you can only send one value through the `SendPort`, wrap the id and message in a [record](https://dart.dev/language/records).**
    
    고립으로 메시지를 보내고, id와 함께 보낸다. SendPort를 통해 하나의 값만 보낼 수 있기 때문에, id와 메시지를 레코드로 래핑한다.
    
- **Finally, return the completer’s future, which will eventually contain the response from the worker isolate.**
    
    마지막으로, completer의 future를 반환한다. 이는 결국 워커 고립에서의 응답을 포함하게 된다.
    

```dart
Future<Object?> parseJson(String message) async {
  final completer = Completer<Object?>.sync();
  final id = _idCounter++;
  _activeRequests[id] = completer;
  _commands.send((id, message));
  return await completer.future;
}
```

**You also need to update `_handleResponsesFromIsolate` and `_handleCommandsToIsolate` to handle this system.**

또한, _handleResponsesFromIsolate와 _handleCommandsToIsolate를 이 시스템을 처리하도록 업데이트해야 한다.

**In `_handleCommandsToIsolate`, you need to account for the `message` being a record with two values, rather than just the json text. Do so by destructuring the values from `message`.**

_handleCommandsToIsolate에서는 메시지가 json 텍스트가 아닌 두 값이 포함된 레코드로 처리된다는 점을 고려해야 한다. 메시지에서 값을 구조 분해한다.

**Then, after decoding the json, update the call to `sendPort.send` to pass both the id and the decoded json back to the main isolate, again using a record.**

그런 다음, json을 디코딩한 후, 메인 고립으로 다시 보낼 때 sendPort.send 호출을 업데이트하여 id와 디코딩된 json을 레코드로 전달한다.

```dart
static void _handleCommandsToIsolate(
    ReceivePort receivePort, SendPort sendPort) {
  receivePort.listen((message) {
    final (int id, String jsonText) = message as (int, String); // 새로운 부분
    try {
      final jsonData = jsonDecode(jsonText);
      sendPort.send((id, jsonData)); // 업데이트된 부분
    } catch (e) {
      sendPort.send((id, RemoteError(e.toString(), '')));
    }
  });
}
```

**Finally, update the `_handleResponsesFromIsolate`.**

마지막으로, _handleResponsesFromIsolate를 업데이트한다.

- **First, destructure the id and the response from the message argument again.**
    
    먼저, 메시지 인수에서 id와 응답을 다시 구조 분해한다.
    
- **Then, remove the completer that corresponds to this request from the `_activeRequests` map.**
    
    그런 다음, _activeRequests 맵에서 해당 요청에 해당하는 completer를 제거한다.
    
- **Lastly, rather than throwing an error or printing the decoded json, complete the completer, passing in the response. When this completes, the response will be returned to the code that called `parseJson` on the main isolate.**
    
    마지막으로, 오류를 throw하거나 디코딩된 json을 출력하는 대신, 응답을 전달하여 completer를 완료한다. 이것이 완료되면, 응답은 메인 고립에서 parseJson을 호출한 코드에 반환된다.
    

```dart
void _handleResponsesFromIsolate(dynamic message) {
  final (int id, Object? response) = message as (int, Object?); // 새로운 부분
  final completer = _activeRequests.remove(id)!; // 새로운 부분

  if (response is RemoteError) {
    completer.completeError(response); // 업데이트된 부분
  } else {
    completer.complete(response); // 업데이트된 부분
  }
}
```

**Step 6: Add functionality to close the ports[#](https://dart.dev/language/isolates#step-6-add-functionality-to-close-the-ports)**

6단계: 포트를 닫는 기능 추가하기

**When the isolate is no longer being used by your code, you should close the ports on the main isolate and the worker isolate.**

고립이 더 이상 코드에서 사용되지 않을 때, 메인 고립과 워커 고립에서 포트를 닫아야 한다.

- **First, add a class-level boolean that tracks if the ports are closed.**
    
    먼저, 포트가 닫혀 있는지 여부를 추적하는 클래스 수준 boolean을 추가한다.
    
- **Then, add the `Worker.close` method. Within this method:**
    
    그런 다음, Worker.close 메서드를 추가한다. 이 메서드 내에서:
    
    - **Update `_closed` to be true.**
        
        _closed를 true로 업데이트한다.
        
    - **Send a final message to the worker isolate. This message is a `String` that reads “shutdown”, but it could be any object you’d like. You will use it in the next code snippet.**
        
        워커 고립에 마지막 메시지를 보낸다. 이 메시지는 “shutdown”이라는 문자열이지만, 다른 객체가 될 수도 있다. 다음 코드 스니펫에서 사용한다.
        
- **Finally, check if `_activeRequests` is empty. If it is, close down the main isolate’s `ReceivePort` named `_responses`.**
    
    마지막으로, _activeRequests가 비어 있는지 확인한다. 그렇다면, 메인 고립의 ReceivePort인 _responses를 닫는다.
    

```dart
class Worker {
  bool _closed = false;
// ···
  void close() {
    if (!_closed) {
      _closed = true;
      _commands.send('shutdown');
      if (_activeRequests.isEmpty) _responses.close();
      print('--- port closed --- ');
    }
  }
```

- **Next, you need to handle the “shutdown” message in the worker isolate. Add the following code to the `_handleCommandsToIsolate` method. This code will check if the message is a `String` that reads “shutdown”. If it is, it will close the worker isolate’s `ReceivePort`, and return.**
    
    다음으로, 워커 고립에서 “shutdown” 메시지를 처리해야 한다. _handleCommandsToIsolate 메서드에 다음 코드를 추가한다. 이 코드는 메시지가 “shutdown” 문자열인지 확인한다. 그렇다면, 워커 고립의 ReceivePort를 닫고, 반환한다.
    

```dart
static void _handleCommandsToIsolate(
  ReceivePort receivePort,
  SendPort sendPort,
) {
  receivePort.listen((message) {
    // 새로운 if 블록.
    if (message == 'shutdown') {
      receivePort.close();
      return;
    }
    final (int id, String jsonText) = message as (int, String);
    try {
      final jsonData = jsonDecode(jsonText);
      sendPort.send((id, jsonData));
    } catch (e) {
      sendPort.send((id, RemoteError(e.toString(), '')));
    }
  });
}
```

- **Finally, you should add code to check if the ports are closed before trying to send messages. Add one line in the `Worker.parseJson` method.**
    
    마지막으로, 메시지를 보내기 전에 포트가 닫혀 있는지 확인하는 코드를 추가해야 한다. Worker.parseJson 메서드에 한 줄을 추가한다.
    

```dart
Future<Object?> parseJson(String message) async {
  if (_closed) throw StateError('Closed'); // 새로운 부분
  final completer = Completer<Object?>.sync();
  final id = _idCounter++;
  _activeRequests[id] = completer;
  _commands.send((id, message));
  return await completer.future;
}
```

# Concurrency and isolates
**동시성 및 고립**

**All Dart code runs in [isolates](https://dart.dev/language/concurrency), which are similar to threads, but differ in that isolates have their own isolated memory. They do not share state in any way, and can only communicate by messaging. By default, Flutter apps do all of their work on a single isolate – the main isolate. In most cases, this model allows for simpler programming and is fast enough that the application's UI doesn't become unresponsive.**

모든 Dart 코드는 고립에서 실행된다. 고립은 스레드와 유사하지만, 고립은 자신의 독립된 메모리를 가지고 있으며 상태를 공유하지 않는다. 고립은 메시지로만 통신할 수 있다. 기본적으로 Flutter 앱은 모든 작업을 단일 고립인 메인 고립에서 수행한다. 대부분의 경우 이 모델은 더 간단한 프로그래밍을 가능하게 하며, 어플리케이션의 UI가 응답하지 않게 될 정도로 느리지 않다.

**Sometimes though, applications need to perform exceptionally large computations that can cause "UI jank" (jerky motion). If your app is experiencing jank for this reason, you can move these computations to a helper isolate. This allows the underlying runtime environment to run the computation concurrently with the main UI isolate's work and takes advantage of multi-core devices.**

그러나 때로는 매우 큰 계산을 수행해야 하는 경우 UI가 끊기는 “UI 지연(jank)” 현상이 발생할 수 있다. 이 경우 이러한 계산을 보조 고립으로 이동할 수 있다. 이를 통해 기본 런타임 환경이 메인 UI 고립의 작업과 동시에 계산을 실행할 수 있으며, 멀티코어 장치의 이점을 활용할 수 있다.

**Each isolate has its own memory and its own event loop. The event loop processes events in the order that they're added to an event queue. On the main isolate, these events can be anything from handling a user tapping in the UI, to executing a function, to painting a frame on the screen. The following figure shows an example event queue with 3 events waiting to be processed.**

각 고립은 자신의 메모리와 이벤트 루프를 가진다. 이벤트 루프는 이벤트 큐에 추가된 순서대로 이벤트를 처리한다. 메인 고립에서는 이러한 이벤트가 UI에서 사용자가 탭하는 것부터 함수 실행, 화면에 프레임을 그리는 것까지 다양하다. 다음 그림은 처리 대기 중인 3개의 이벤트가 있는 예제 이벤트 큐를 보여준다.

![메인 고립 다이어그램](https://docs.flutter.dev/assets/images/docs/development/concurrency/basics-main-isolate.png)

메인 고립 다이어그램

**For smooth rendering, Flutter adds a "paint frame" event to the event queue 60 times per second(for a 60Hz device). If these events aren't processed on time, the application experiences UI jank, or worse, become unresponsive altogether.**

원활한 렌더링을 위해 Flutter는 60Hz 장치 기준으로 초당 60번 “페인트 프레임” 이벤트를 이벤트 큐에 추가한다. 이러한 이벤트가 제때 처리되지 않으면 어플리케이션은 UI 지연을 경험하거나 최악의 경우 응답하지 않게 된다.

![이벤트 지연 다이어그램](https://docs.flutter.dev/assets/images/docs/development/concurrency/event-jank.png)

이벤트 지연 다이어그램

**Whenever a process can't be completed in a frame gap, the time between two frames, it's a good idea to offload the work to another isolate to ensure that the main isolate can produce 60 frames per second. When you spawn an isolate in Dart, it can process the work concurrently with the main isolate, without blocking it.**

프로세스가 프레임 간격(두 프레임 사이의 시간) 내에 완료될 수 없는 경우, 메인 고립이 초당 60 프레임을 생성할 수 있도록 작업을 다른 고립으로 오프로드하는 것이 좋다. Dart에서 고립을 생성하면 메인 고립을 차단하지 않고 작업을 동시에 처리할 수 있다.

**You can read more about how isolates and the event loop work in Dart on the [concurrency page](https://dart.dev/language/concurrency) of the Dart documentation.**

고립과 이벤트 루프가 Dart에서 어떻게 작동하는지 더 알고 싶다면 Dart 문서의 동시성 페이지를 참조하라.

[**Isolates and the event loop | Flutter in Focus**](https://www.youtube.com/watch/vl_AaCgudcY)

**Common use cases for isolates[#](https://docs.flutter.dev/perf/isolates#common-use-cases-for-isolates)
고립의 일반적인 사용 사례**

**There is only one hard rule for when you should use isolates, and that's when large computations are causing your Flutter application to experience UI jank. This jank happens when there is any computation that takes longer than Flutter's frame gap.**

고립을 사용해야 하는 유일한 엄격한 규칙은 큰 계산이 Flutter 어플리케이션에서 UI 지연을 발생시키는 경우이다. 이 지연은 Flutter의 프레임 간격보다 오래 걸리는 모든 계산에서 발생한다.

![이벤트 지연 다이어그램](https://docs.flutter.dev/assets/images/docs/development/concurrency/event-jank.png)

이벤트 지연 다이어그램

**Any process *could* take longer to complete, depending on the implementation and the input data, making it impossible to create an exhaustive list of when you need to consider using isolates.**

프로세스는 구현 및 입력 데이터에 따라 완료하는 데 시간이 더 오래 걸릴 수 있으므로 고립을 고려해야 하는 상황을 포괄적으로 나열하는 것은 불가능하다.

**That said, isolates are commonly used for the following:**

그렇기는 해도, 고립은 다음과 같은 경우에 일반적으로 사용된다:

- **Reading data from a local database**
    
    로컬 데이터베이스에서 데이터 읽기
    
- **Sending push notifications**
    
    푸시 알림 보내기
    
- **Parsing and decoding large data files**
    
    대형 데이터 파일 파싱 및 디코딩
    
- **Processing or compressing photos, audio files, and video files**
    
    사진, 오디오 파일 및 비디오 파일 처리 또는 압축
    
- **Converting audio and video files**
    
    오디오 및 비디오 파일 변환
    
- **When you need asynchronous support while using FFI**
    
    FFI를 사용할 때 비동기 지원 필요
    
- **Applying filtering to complex lists or filesystems**
    
    복잡한 목록 또는 파일 시스템에 필터링 적용
    

**Message passing between isolates[#](https://docs.flutter.dev/perf/isolates#message-passing-between-isolates)
고립 간의 메시지 전달**

**Dart's isolates are an implementation of the [Actor model](https://en.wikipedia.org/wiki/Actor_model). They can only communicate with each other by message passing, which is done with [`Port` objects](https://api.dart.dev/stable/dart-isolate/ReceivePort-class.html). When messages are "passed" between each other, they are generally copied from the sending isolate to the receiving isolate. This means that any value passed to an isolate, even if mutated on that isolate, doesn't change the value on the original isolate.**

Dart의 고립은 Actor 모델의 구현이다. 고립은 Port 객체를 사용하여 메시지 전달로만 통신할 수 있다. 메시지가 전달될 때, 일반적으로 보내는 고립에서 받는 고립으로 복사된다. 이는 고립에 전달된 값이 변형되더라도 원래 고립의 값이 변경되지 않음을 의미한다.

**The only [objects that aren't copied when passed](https://api.dart.dev/stable/dart-isolate/SendPort/send.html) to an isolate are immutable objects that can't be changed anyway, such a String or an unmodifiable byte. When you pass an immutable object between isolates, a reference to that object is sent across the port, rather than the object being copied, for better performance. Because immutable objects can't be updated, this effectively retains the actor model behavior.**

고립에 전달될 때 복사되지 않는 유일한 객체는 어차피 변경할 수 없는 String 또는 수정 불가능한 바이트와 같은 불변 객체이다. 불변 객체를 고립 간에 전달할 때, 객체가 복사되지 않고 해당 객체에 대한 참조가 포트를 통해 전송되어 더 나은 성능을 제공한다. 불변 객체는 업데이트할 수 없기 때문에, 이는 효과적으로 Actor 모델 동작을 유지한다.

**An exception to this rule is when an isolate exits when it sends a message using the `Isolate.exit` method. Because the sending isolate won't exist after sending the message, it can pass ownership of the message from one isolate to the other, ensuring that only one isolate can access the message.**

이 규칙의 예외는 Isolate.exit 메서드를 사용하여 고립이 종료될 때 메시지를 전송하는 경우이다. 보내는 고립이 메시지를 보낸 후 존재하지 않기 때문에, 메시지의 소유권을 하나의 고립에서 다른 고립으로 전달하여 하나의 고립만 메시지에 접근할 수 있게 한다.

**The two lowest-level primitives that send messages are `SendPort.send`, which makes a copy of a mutable message as it sends, and `Isolate.exit`, which sends the reference to the message. Both `Isolate.run` and `compute` use `Isolate.exit` under the hood.**

메시지를 보내는 두 가지 가장 저수준 원시 함수는 SendPort.send로, 이 함수는 전송할 때 변경 가능한 메시지를 복사하며, Isolate.exit로, 이 함수는 메시지에 대한 참조를 보낸다. Isolate.run과 compute는 모두 내부적으로 Isolate.exit를 사용한다.

**Short-lived isolates[#](https://docs.flutter.dev/perf/isolates#short-lived-isolates)
단기 고립**

**The easiest way to move a process to an isolate in Flutter is with the `Isolate.run` method. This method spawns an isolate, passes a callback to the spawned isolate to start some computation, returns a value from the computation, and then shuts the isolate down when the computation is complete. This all happens concurrently with the main isolate, and doesn't block it.**

Flutter에서 프로세스를 고립으로 이동하는 가장 쉬운 방법은 Isolate.run 메서드를 사용하는 것이다. 이 메서드는 고립을 생성하고, 생성된 고립에 콜백을 전달하여 일부 계산을 시작하며, 계산이 완료되면 값을 반환하고 고립을 종료한다. 이 모든 과정이 메인 고립과 동시에 일어나며, 메인 고립을 차단하지 않는다.

![고립 다이어그램](https://docs.flutter.dev/assets/images/docs/development/concurrency/isolate-bg-worker.png)

고립 다이어그램

**The `Isolate.run` method requires a single argument, a callback function, that is run on the new isolate. This callback's function signature must have exactly one required, unnamed argument. When the computation completes, it returns the callback's value back to the main isolate, and exits the spawned isolate.**

Isolate.run 메서드는 콜백 함수라는 단일 인수가 필요하며, 이 콜백 함수는 새로운 고립에서 실행된다. 이 콜백의 함수 서명은 정확히 하나의 필수, 이름 없는 인수를 가져야 한다. 계산이 완료되면 콜백의 값을 메인 고립으로 반환하고, 생성된 고립을 종료한다.

**For example, consider this code that loads a large JSON blob from a file, and converts that JSON into custom Dart objects. If the json decoding process wasn't off loaded to a new isolate, this method would cause the UI to become unresponsive for several seconds.**

예를 들어, 파일에서 큰 JSON 블롭을 로드하고, 해당 JSON을 사용자 정의 Dart 객체로 변환하는 코드를 고려하라. json 디코딩 프로세스가 새로운 고립으로 오프로드되지 않으면, 이 메서드는 UI가 몇 초 동안 응답하지 않게 한다.

```dart
// 211,640개의 사진 객체 목록을 생성한다.
// (JSON 파일 크기는 약 20MB.)
Future<List<Photo>> getPhotos() async {
  final String jsonString = await rootBundle.loadString('assets/photos.json');
  final List<Photo> photos = await Isolate.run<List<Photo>>(() {
    final List<Object?> photoData = jsonDecode(jsonString) as List<Object?>;
    return photoData.cast<Map<String, Object?>>().map(Photo.fromJson).toList();
  });
  return photos;
}
```

**For a complete walkthrough of using Isolates to parse JSON in the background, see [this cookbook recipe](https://docs.flutter.dev/cookbook/networking/background-parsing).**

백그라운드에서 JSON을 파싱하기 위해 고립을 사용하는 완전한 워크스루는 이 [cookbook 레시피](https://flutter.dev/docs/cookbook/networking/background-parsing)를 참조하라.

**Stateful, longer-lived isolates[#](https://docs.flutter.dev/perf/isolates#stateful-longer-lived-isolates)
상태 유지, 장기 고립**

**Short-live isolates are convenient to use, but there is performance overhead required to spawn new isolates, and to copy objects from one isolate to another. If you're doing the same computation using `Isolate.run` repeatedly, you might have better performance by creating isolates that don't exit immediately.**

단기 고립은 사용하기 편리하지만, 새로운 고립을 생성하고 객체를 다른 고립으로 복사하는 데 성능 오버헤드가 필요하다. Isolate.run을 사용하여 동일한 계산을 반복적으로 실행하는 경우, 즉시 종료되지 않는 고립을 생성하여 더 나은 성능을 얻을 수 있다.

**To do this, you can use a handful of lower-level isolate-related APIs that `Isolate.run` abstracts:**

이를 위해 Isolate.run이 추상화한 몇 가지 저수준 고립 관련 API를 사용할 수 있다:

- [**`Isolate.spawn()`](https://api.dart.dev/stable/dart-isolate/Isolate/spawn.html) and [`Isolate.exit()`](https://api.dart.dev/stable/dart-isolate/Isolate/exit.html)**
    
    Isolate.spawn() 및 Isolate.exit()
    
- [**`ReceivePort`](https://api.dart.dev/stable/dart-isolate/ReceivePort-class.html) and [`SendPort`](https://api.dart.dev/stable/dart-isolate/SendPort-class.html)**
    
    ReceivePort 및 SendPort
    
- [**`send()`](https://api.dart.dev/stable/dart-isolate/SendPort/send.html) method**
    
    send() 메서드
    

**When you use the `Isolate.run` method, the new isolate immediately shuts down after it returns a single message to the main isolate. Sometimes, you'll need isolates that are long lived, and can pass multiple messages to each other over time. In Dart, you can accomplish this with the Isolate API and Ports. These long-lived isolates are colloquially known as *background workers*.**

Isolate.run 메서드를 사용할 때, 새 고립은 메인 고립에 단일 메시지를 반환한 후 즉시 종료된다. 때로는 장기적으로 지속되고 시간이 지남에 따라 여러 메시지를 서로 주고받을 수 있는 고립이 필요하다. Dart에서는 Isolate API와 포트를 사용하여 이를 달성할 수 있다. 이러한 장기 고립은 일반적으로 백그라운드 워커로 알려져 있다.

**Long-lived isolates are useful when you have a specific process that either needs to be run repeatedly throughout the lifetime of your application, or if you have a process that runs over a period of time and needs to yield multiple return values to the main isolate.**

장기 고립은 어플리케이션의 수명 동안 반복적으로 실행해야 하거나, 일정 기간 동안 실행되고 메인 고립에 여러 반환 값을 제공해야 하는 특정 프로세스에 유용하다.

**Or, you might use [worker_manager](https://pub.dev/packages/worker_manager) to manage long-lived isolates.**

또는 worker_manager를 사용하여 장기 고립을 관리할 수도 있다.

**ReceivePorts and SendPorts[#](https://docs.flutter.dev/perf/isolates#receiveports-and-sendports)
ReceivePorts 및 SendPorts**

**Set up long-lived communication between isolates with two classes (in addition to Isolate): [`ReceivePort`](https://api.dart.dev/stable/dart-isolate/ReceivePort-class.html) and [`SendPort`](https://api.dart.dev/stable/dart-isolate/SendPort-class.html). These ports are the only way isolates can communicate with each other.**

고립 간의 장기 통신을 설정하려면 두 클래스(고립 외에)를 사용해야 한다: ReceivePort와 SendPort. 이 포트들은 고립 간에 통신할 수 있는 유일한 방법이다.

**`Ports` behave similarly to `Streams`, in which the `StreamController` or `Sink` is created in one isolate, and the listener is set up in the other isolate. In this analogy, the `StreamConroller` is called a `SendPort`, and you can "add" messages with the `send()` method. `ReceivePort`s are the listeners, and when these listeners receive a new message, they call a provided callback with the message as an argument.**

포트는 Stream과 유사하게 동작하며, StreamController 또는 Sink는 하나의 고립에서 생성되고, 리스너는 다른 고립에서 설정된다. 이 비유에서 StreamController는 SendPort라고 하며, send() 메서드로 메시지를 “추가”할 수 있다. ReceivePort는 리스너로, 이 리스너가 새로운 메시지를 받을 때 제공된 콜백을 메시지 인수로 호출한다.

**For an in-depth explanation on setting up two-way communication between the main isolate and a worker isolate, follow the examples in the [Dart documentation](https://dart.dev/language/concurrency).**

메인 고립과 워커 고립 간의 양방향 통신 설정에 대한 자세한 설명은 Dart 문서의 예제를 따르라.

**Using platform plugins in isolates[#](https://docs.flutter.dev/perf/isolates#using-platform-plugins-in-isolates)
고립에서 플랫폼 플러그인 사용하기**

**As of Flutter 3.7, you can use platform plugins in background isolates. This opens many possibilities to offload heavy, platform-dependent computations to an isolate that won't block your UI. For example, imagine you're encrypting data using a native host API (such as an Android API on Android, an iOS API on iOS, and so on). Previously, [marshaling data](https://en.wikipedia.org/wiki/Marshalling_(computer_science)) to the host platform could waste UI thread time, and can now be done in a background isolate.**

Flutter 3.7부터 백그라운드 고립에서 플랫폼 플러그인을 사용할 수 있다. 이는 무거운 플랫폼 종속 계산을 UI를 차단하지 않는 고립으로 오프로드할 수 있는 많은 가능성을 열어준다. 예를 들어, 네이티브 호스트 API(안드로이드 API, iOS API 등)를 사용하여 데이터를 암호화하는 경우를 상상해보라. 이전에는 호스트 플랫폼으로 데이터를 마샬링하는 데 UI 스레드 시간이 낭비될 수 있었지만, 이제는 백그라운드 고립에서 수행할 수 있다.

**Platform channel isolates use the [`BackgroundIsolateBinaryMessenger`](https://api.flutter.dev/flutter/services/BackgroundIsolateBinaryMessenger-class.html) API. The following snippet shows an example of using the `shared_preferences` package in a background isolate.**

플랫폼 채널 고립은 BackgroundIsolateBinaryMessenger API를 사용한다. 다음 스니펫은 백그라운드 고립에서 shared_preferences 패키지를 사용하는 예제를 보여준다.

```dart
import 'dart:isolate';

import 'package:flutter/services.dart';
import 'package:shared_preferences/shared_preferences.dart';

void main() {
  // 백그라운드 고립에 전달할 루트 고립 식별.
  RootIsolateToken rootIsolateToken = RootIsolateToken.instance!;
  Isolate.spawn(_isolateMain, rootIsolateToken);
}

Future<void> _isolateMain(RootIsolateToken rootIsolateToken) async {
  // 루트 고립에 백그라운드 고립 등록.
  BackgroundIsolateBinaryMessenger.ensureInitialized(rootIsolateToken);

  // 이제 shared_preferences 플러그인을 사용할 수 있다.
  SharedPreferences sharedPreferences = await SharedPreferences.getInstance();

  print(sharedPreferences.getBool('isDebug'));
}
```

**Limitations of Isolates[#](https://docs.flutter.dev/perf/isolates#limitations-of-isolates)
고립의 한계**

**If you're coming to Dart from a language with multithreading, it's reasonable to expect isolates to behave like threads, but that isn't the case. Isolates have their own global fields, and can only communicate with message passing, ensuring that mutable objects in an isolate are only ever accessible in a single isolate. Therefore, isolates are limited by their access to their own memory. For example, if you have an application with a global mutable variable called `configuration`, it is copied as a new global field in a spawned isolate. If you mutate that variable in the spawned isolate, it remains untouched in the main isolate. This is true even if you pass the `configuration` object as a message to the new isolate. This is how isolates are meant to function, and it's important to keep in mind when you consider using isolates.**

다중 스레드를 사용하는 언어에서 Dart로 전환하는 경우 고립이 스레드처럼 작동할 것으로 예상할 수 있지만, 그렇지 않다. 고립은 자체 전역 필드를 가지고 있으며, 메시지 전달로만 통신할 수 있어 고립의 변경 가능한 객체는 하나의 고립에서만 접근할 수 있도록 보장된다. 따라서 고립은 자신의 메모리에만 접근할 수 있다는 제한이 있다. 예를 들어, 전역 변경 가능한 변수인 configuration이 있는 어플리케이션이 있는 경우, 이는 생성된 고립에서 새로운 전역 필드로 복사된다. 생성된 고립에서 해당 변수를 변경하면, 메인 고립에서는 변경되지 않는다. 이는 해당 객체를 새로운 고립에 메시지로 전달하더라도 마찬가지이다. 고립은 이렇게 동작하도록 설계되어 있으며, 고립을 사용할 때 이를 염두에 두는 것이 중요하다.

**Web platforms and compute[#](https://docs.flutter.dev/perf/isolates#web-platforms-and-compute)
웹 플랫폼과 compute**

**Dart web platforms, including Flutter web, don't support isolates. If you're targeting the web with your Flutter app, you can use the `compute` method to ensure your code compiles. The [`compute()`](https://api.flutter.dev/flutter/foundation/compute.html) method runs the computation on the main thread on the web, but spawns a new thread on mobile devices. On mobile and desktop platforms `await compute(fun, message)` is equivalent to `await Isolate.run(() => fun(message))`.**

Dart 웹 플랫폼(Flutter 웹 포함)은 고립을 지원하지 않는다. Flutter 앱을 웹 대상으로 하고 있는 경우, compute 메서드를 사용하여 코드가 컴파일되도록 할 수 있다. compute() 메서드는 웹에서 메인 스레드에서 계산을 실행하지만, 모바일 장치에서는 새로운 스레드를 생성한다. 모바일 및 데스크톱 플랫폼에서는 await compute(fun, message)가 await Isolate.run(() => fun(message))와 동일하다.

**For more information on concurrency on the web, check out the [concurrency documentation](https://dart.dev/language/concurrency) on dart.dev.**

웹에서의 동시성에 대한 자세한 내용은 dart.dev의 동시성 문서를 참조하라.

**No rootBundle access or dart:ui methods[#](https://docs.flutter.dev/perf/isolates#no-rootbundle-access-or-dart-ui-methods)
rootBundle 접근 불가 및 dart:ui 메서드 제한**

**All UI tasks and Flutter itself are coupled to the main isolate. Therefore, you can't access assets using `rootBundle` in spawned isolates, nor can you perform any widget or UI work in spawned isolates.**

모든 UI 작업과 Flutter 자체는 메인 고립에 연결되어 있다. 따라서 생성된 고립에서는 rootBundle을 사용하여 자산에 접근할 수 없으며, 위젯 또는 UI 작업을 수행할 수 없다.

**Limited plugin messages from host platform to Flutter[#](https://docs.flutter.dev/perf/isolates#limited-plugin-messages-from-host-platform-to-flutter)
호스트 플랫폼에서 Flutter로의 제한된 플러그인 메시지**

**With background isolate platform channels, you can use platform channels in isolates to send messages to the host platform (for example Android or iOS), and receive responses to those messages. However, you can't receive unsolicited messages from the host platform.**

백그라운드 고립 플랫폼 채널을 사용하면 고립에서 플랫폼 채널을 사용하여 호스트 플랫폼(예: 안드로이드 또는 iOS)으로 메시지를 보내고, 해당 메시지에 대한 응답을 받을 수 있다. 그러나 호스트 플랫폼에서 온 요청하지 않은 메시지는 받을 수 없다.

**As an example, you can't set up a long-lived Firestore listener in a background isolate, because Firestore uses platform channels to push updates to Flutter, which are unsolicited. You can, however, query Firestore for a response in the background.**

예를 들어, 백그라운드 고립에서 장기 Firestore 리스너를 설정할 수 없다. Firestore는 Flutter로 업데이트를 푸시하기 위해 플랫폼 채널을 사용하며, 이는 요청하지 않은 메시지이다. 그러나 백그라운드에서 Firestore를 쿼리하여 응답을 받을 수는 있다.

**More information[#](https://docs.flutter.dev/perf/isolates#more-information)
추가 정보**

**For more information on isolates, check out the following resources:**

고립에 대한 자세한 내용은 다음 리소스를 참조하라:

- **If you're using many isolates, consider the [IsolateNameServer](https://api.flutter.dev/flutter/dart-ui/IsolateNameServer-class.html) class in Flutter, or the pub package that clones the functionality for Dart applications not using Flutter.**
    
    많은 고립을 사용하고 있다면, Flutter에서 IsolateNameServer 클래스를 고려하거나, Flutter를 사용하지 않는 Dart 어플리케이션을 위한 기능을 클론한 pub 패키지를 고려하라.
    
- **Dart's Isolates are an implementation of the [Actor model](https://en.wikipedia.org/wiki/Actor_model).**
    
    Dart의 고립은 Actor 모델의 구현이다.
    
- [**isolate_agents](https://medium.com/@gaaclarke/isolate-agents-easy-isolates-for-flutter-6d75bf69a2e7) is a package that abstracts Ports and make it easier to create long-lived isolates.**
    
    isolate_agents는 포트를 추상화하고 장기 고립을 쉽게 생성할 수 있게 하는 패키지이다.
    
- **Read more about the `BackgroundIsolateBinaryMessenger` API [announcement](https://medium.com/flutter/introducing-background-isolate-channels-7a299609cad8).**
    
    BackgroundIsolateBinaryMessenger API 발표에 대한 자세한 내용을 읽어보라.


  # **Parse JSON in the background
백그라운드에서 JSON 파싱하기**

**By default, Dart apps do all of their work on a single thread. In many cases, this model simplifies coding and is fast enough that it does not result in poor app performance or stuttering animations, often called "jank."**

기본적으로, Dart 앱은 모든 작업을 단일 스레드에서 실행한다. 많은 경우에 이 모델은 코딩을 단순화하고, 앱 성능이 저하되거나 애니메이션이 끊기는 “jank” 현상을 일으키지 않을 만큼 충분히 빠르다.

**However, you might need to perform an expensive computation, such as parsing a very large JSON document. If this work takes more than 16 milliseconds, your users experience jank.**

그러나 매우 큰 JSON 문서를 파싱하는 것과 같은 고가의 계산을 수행해야 할 경우가 있다. 이 작업이 16밀리초 이상 걸리면 사용자는 jank를 경험하게 된다.

**To avoid jank, you need to perform expensive computations like this in the background. On Android, this means scheduling work on a different thread. In Flutter, you can use a separate [Isolate](https://api.flutter.dev/flutter/dart-isolate/Isolate-class.html). This recipe uses the following steps:**

이러한 jank를 피하려면 백그라운드에서 고가의 계산을 수행해야 한다. 안드로이드에서는 이를 다른 스레드에서 작업을 예약하는 것으로 해결한다. Flutter에서는 별도의 고립을 사용할 수 있다. 이 레시피에서는 다음 단계를 사용한다:

1. **Add the `http` package.**
    
    http 패키지 추가
    
2. **Make a network request using the `http` package.**
    
    http 패키지를 사용하여 네트워크 요청 수행
    
3. **Convert the response into a list of photos.**
    
    응답을 사진 목록으로 변환
    
4. **Move this work to a separate isolate.**
    
    이 작업을 별도의 고립으로 이동
    

**1. Add the http package[#](https://docs.flutter.dev/cookbook/networking/background-parsing#1-add-the-http-package)
http 패키지 추가**

**First, add the [`http`](https://pub.dev/packages/http) package to your project. The `http` package makes it easier to perform network requests, such as fetching data from a JSON endpoint.**

먼저, 프로젝트에 http 패키지를 추가한다. http 패키지는 JSON 엔드포인트에서 데이터를 가져오는 등의 네트워크 요청을 더 쉽게 수행할 수 있게 한다.

**To add the `http` package as a dependency, run `flutter pub add`:**

http 패키지를 종속성으로 추가하려면, 다음 명령어를 실행한다:

```dart
flutter pub add http
```

**2. Make a network request[#](https://docs.flutter.dev/cookbook/networking/background-parsing#2-make-a-network-request)
네트워크 요청 수행**

**This example covers how to fetch a large JSON document that contains a list of 5000 photo objects from the [JSONPlaceholder REST API](https://jsonplaceholder.typicode.com/), using the [`http.get()`](https://pub.dev/documentation/http/latest/http/get.html) method.**

이 예제에서는 http.get() 메서드를 사용하여 JSONPlaceholder REST API에서 5000개의 사진 객체 목록이 포함된 큰 JSON 문서를 가져오는 방법을 다룬다.

```dart
Future<http.Response> fetchPhotos(http.Client client) async {
  return client.get(Uri.parse('https://jsonplaceholder.typicode.com/photos'));
}
```

<aside>
ℹ️ **Note**

**You're providing an `http.Client` to the function in this example. This makes the function easier to test and use in different environments.**

참고: 이 예제에서는 함수에 http.Client를 제공한다. 이는 함수를 더 쉽게 테스트하고 다양한 환경에서 사용할 수 있도록 한다.

</aside>

**3. Parse and convert the JSON into a list of photos[#](https://docs.flutter.dev/cookbook/networking/background-parsing#3-parse-and-convert-the-json-into-a-list-of-photos)
JSON을 파싱하고 사진 목록으로 변환**

**Next, following the guidance from the [Fetch data from the internet](https://docs.flutter.dev/cookbook/networking/fetch-data) recipe, convert the `http.Response` into a list of Dart objects. This makes the data easier to work with.**

다음으로, 인터넷에서 데이터를 가져오는 레시피의 지침을 따라 http.Response를 Dart 객체 목록으로 변환한다. 이렇게 하면 데이터를 더 쉽게 다룰 수 있다.

**Create a Photo class[#](https://docs.flutter.dev/cookbook/networking/background-parsing#create-a-photo-class)
Photo 클래스 생성**

**First, create a `Photo` class that contains data about a photo. Include a `fromJson()` factory method to make it easy to create a `Photo` starting with a JSON object.**

먼저, 사진에 대한 데이터를 포함하는 Photo 클래스를 생성한다. JSON 객체를 사용하여 Photo를 쉽게 생성할 수 있도록 fromJson() 팩토리 메서드를 포함한다.

```dart
class Photo {
  final int albumId;
  final int id;
  final String title;
  final String url;
  final String thumbnailUrl;

  const Photo({
    required this.albumId,
    required this.id,
    required this.title,
    required this.url,
    required this.thumbnailUrl,
  });

  factory Photo.fromJson(Map<String, dynamic> json) {
    return Photo(
      albumId: json['albumId'] as int,
      id: json['id'] as int,
      title: json['title'] as String,
      url: json['url'] as String,
      thumbnailUrl: json['thumbnailUrl'] as String,
    );
  }
}
```

**Convert the response into a list of photos[#](https://docs.flutter.dev/cookbook/networking/background-parsing#convert-the-response-into-a-list-of-photos)
응답을 사진 목록으로 변환**

**Now, use the following instructions to update the `fetchPhotos()` function so that it returns a `Future<List<Photo>>`:**

이제 fetchPhotos() 함수를 업데이트하여 Future<List<Photo>>를 반환하도록 한다:

1. **Create a `parsePhotos()` function that converts the response body into a `List<Photo>`.**
    
    응답 본문을 List<Photo>로 변환하는 parsePhotos() 함수를 생성한다.
    
2. **Use the `parsePhotos()` function in the `fetchPhotos()` function.**
    
    fetchPhotos() 함수에서 parsePhotos() 함수를 사용한다.
    

```dart
// 응답 본문을 List<Photo>로 변환하는 함수
List<Photo> parsePhotos(String responseBody) {
  final parsed =
      (jsonDecode(responseBody) as List).cast<Map<String, dynamic>>();

  return parsed.map<Photo>((json) => Photo.fromJson(json)).toList();
}

Future<List<Photo>> fetchPhotos(http.Client client) async {
  final response = await client
      .get(Uri.parse('https://jsonplaceholder.typicode.com/photos'));

  // 메인 고립에서 동기적으로 parsePhotos 실행
  return parsePhotos(response.body);
}
```

**4. Move this work to a separate isolate[#](https://docs.flutter.dev/cookbook/networking/background-parsing#4-move-this-work-to-a-separate-isolate)
이 작업을 별도의 고립으로 이동**

**If you run the `fetchPhotos()` function on a slower device, you might notice the app freezes for a brief moment as it parses and converts the JSON. This is jank, and you want to get rid of it.**

느린 장치에서 fetchPhotos() 함수를 실행하면 JSON을 파싱하고 변환할 때 앱이 잠시 멈추는 것을 발견할 수 있다. 이는 jank 현상이며, 이를 제거해야 한다.

**You can remove the jank by moving the parsing and conversion to a background isolate using the [`compute()`](https://api.flutter.dev/flutter/foundation/compute.html) function provided by Flutter. The `compute()` function runs expensive functions in a background isolate and returns the result. In this case, run the `parsePhotos()` function in the background.**

Flutter에서 제공하는 compute() 함수를 사용하여 백그라운드 고립에서 파싱 및 변환을 실행함으로써 jank를 제거할 수 있다. compute() 함수는 백그라운드 고립에서 고가의 함수를 실행하고 결과를 반환한다. 이 경우, parsePhotos() 함수를 백그라운드에서 실행한다.

```dart
Future<List<Photo>> fetchPhotos(http.Client client) async {
  final response = await client
      .get(Uri.parse('https://jsonplaceholder.typicode.com/photos'));

  // compute 함수를 사용하여 별도의 고립에서 parsePhotos 실행
  return compute(parsePhotos, response.body);
}
```

**Notes on working with isolates[#](https://docs.flutter.dev/cookbook/networking/background-parsing#notes-on-working-with-isolates)
고립 작업 관련 참고 사항**

**Isolates communicate by passing messages back and forth. These messages can be primitive values, such as `null`, `num`, `bool`, `double`, or `String`, or simple objects such as the `List<Photo>` in this example.**

고립은 메시지를 주고받으며 통신한다. 이러한 메시지는 null, num, bool, double, String과 같은 원시 값이나 이 예제에서의 List<Photo>와 같은 단순한 객체일 수 있다.

**You might experience errors if you try to pass more complex objects, such as a `Future` or `http.Response` between isolates.**

더 복잡한 객체(Future 또는 http.Response 등)를 고립 간에 전달하려고 하면 오류가 발생할 수 있다.

**As an alternate solution, check out the [`worker_manager`](https://pub.dev/packages/worker_manager) or [`workmanager`](https://pub.dev/packages/workmanager) packages for background processing.**

대체 솔루션으로 백그라운드 처리를 위해 worker_manager 또는 workmanager 패키지를 확인하라.

**Complete example[#](https://docs.flutter.dev/cookbook/networking/background-parsing#complete-example)
전체 예제**

```dart
import 'dart:async';
import 'dart:convert';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;

Future<List<Photo>> fetchPhotos(http.Client client) async {
  final response = await client
      .get(Uri.parse('https://jsonplaceholder.typicode.com/photos'));

  // compute 함수를 사용하여 별도의 고립에서 parsePhotos 실행
  return compute(parsePhotos, response.body);
}

// 응답 본문을 List<Photo>로 변환하는 함수
List<Photo> parsePhotos(String responseBody) {
  final parsed =
      (jsonDecode(responseBody) as List).cast<Map<String, dynamic>>();

  return parsed.map<Photo>((json) => Photo.fromJson(json)).toList();
}

class Photo {
  final int albumId;
  final int id;
  final String title;
  final String url;
  final String thumbnailUrl;

  const Photo({
    required this.albumId,
    required this.id,
    required this.title,
    required this.url,
    required this.thumbnailUrl,
  });

  factory Photo.fromJson(Map<String, dynamic> json) {
    return Photo(
      albumId: json['albumId'] as int,
      id: json['id'] as int,
      title: json['title'] as String,
      url: json['url'] as String,
      thumbnailUrl: json['thumbnailUrl'] as String,
    );
  }
}

void main() => runApp(const MyApp());

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    const appTitle = 'Isolate Demo';

    return const MaterialApp(
      title: appTitle,
      home: MyHomePage(title: appTitle),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});

  final String title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  late Future<List<Photo>> futurePhotos;

  @override
  void initState() {
    super.initState();
    futurePhotos = fetchPhotos(http.Client());
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: FutureBuilder<List<Photo>>(
        future: futurePhotos,
        builder: (context, snapshot) {
          if (snapshot.hasError) {
            return const Center(
              child: Text('An error has occurred!'),
            );
          } else if (snapshot.hasData) {
            return PhotosList(photos: snapshot.data!);
          } else {
            return const Center(
              child: CircularProgressIndicator(),
            );
          }
        },
      ),
    );
  }
}

class PhotosList extends StatelessWidget {
  const PhotosList({super.key, required this.photos});

  final List<Photo> photos;

  @override
  Widget build(BuildContext context) {
    return GridView.builder(
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 2,
      ),
      itemCount: photos.length,
      itemBuilder: (context, index) {
        return Image.network(photos[index].thumbnailUrl);
      },
    );
  }
}
```
