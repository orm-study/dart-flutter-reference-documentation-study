Dart(isolates)

공식문서 : 
https://dart.dev/language/isolates
https://docs.flutter.dev/perf/isolates
https://docs.flutter.dev/cookbook/networking/background-parsing

# Isolates

This page discusses some examples that use the `Isolate` API to implement isolates.

You should use isolates whenever your application is handling computations that are large enough to temporarily block other computations. The most common example is in [Flutter](https://docs.flutter.dev/perf/isolates) applications, when you need to perform large computations that might otherwise cause the UI to become unresponsive.

> **Isolates란?**
> 
> 
> **Isolate**는 Dart 애플리케이션에서 독립적으로 실행되는 작업 단위입니다. 특히, 큰 계산 작업을 처리할 때 다른 작업을 일시적으로 차단하지 않도록 하기 위해 사용됩니다. Flutter 애플리케이션에서 대규모 계산이 UI를 멈추지 않게 할 때 주로 활용됩니다.
> 

There aren't any rules about when you *must* use isolates, but here are some more situations where they can be useful:

- Parsing and decoding exceptionally large JSON blobs.
- Processing and compressing photos, audio and video.
- Converting audio and video files.
- Performing complex searching and filtering on large lists or within file systems.
- Performing I/O, such as communicating with a database.
- Handling a large volume of network requests.

> **Isolates가 유용한 상황**
> 
> - 매우 큰 JSON 데이터를 파싱하고 디코딩할 때
> - 사진, 오디오, 비디오 파일을 처리하고 압축할 때
> - 오디오 및 비디오 파일을 변환할 때
> - 대형 리스트에서 복잡한 검색 및 필터링을 수행할 때
> - 데이터베이스와의 통신 등 I/O 작업을 처리할 때
> - 대규모 네트워크 요청을 처리할 때

**Implementing a simple worker isolate**[#](https://dart.dev/language/isolates#implementing-a-simple-worker-isolate)

These examples implement a main isolate that spawns a simple worker isolate. [`Isolate.run()`](https://api.dart.dev/stable/dart-isolate/Isolate/run.html) simplifies the steps behind setting up and managing worker isolates:

1. Spawns (starts and creates) an isolate.
2. Runs a function on the spawned isolate.
3. Captures the result.
4. Returns the result to the main isolate.
5. Terminates the isolate once work is complete.
6. Checks, captures, and throws exceptions and errors back to the main isolate.

> **간단한 워커 Isolate 구현**
> 
> 
> **Isolate.run()** 메서드를 사용하여 간단한 워커 isolate를 구현할 수 있습니다. 이 메서드는 다음 작업을 자동으로 처리합니다:
> 
> 1. Isolate를 생성하고 시작함.
> 2. 생성된 isolate에서 함수를 실행함.
> 3. 결과를 캡처하여 메인 isolate로 반환함.
> 4. 작업이 완료되면 isolate를 종료함.
> 5. 예외 및 오류를 메인 isolate로 전달함.

**Running an existing method in a new isolate**[#](https://dart.dev/language/isolates#running-an-existing-method-in-a-new-isolate)

1. Call `run()` to spawn a new isolate (a [background worker](https://dart.dev/language/concurrency#background-workers)), directly in the [main isolate](https://dart.dev/language/concurrency#the-main-isolate) while `main()` waits for the result:

```dart
const String filename = 'with_keys.json';

void main() async {
  // 새로운 isolate에서 JSON 읽기 및 파싱
  final jsonData = await Isolate.run(_readAndParseJson);

  // 데이터 사용하기
  print('Number of JSON keys: ${jsonData.length}');
}
```

1. Pass the worker isolate the function you want it to execute as its first argument. In this example, it's the existing function `_readAndParseJson()`:

```dart
Future<Map<String, dynamic>> _readAndParseJson() async {
  final fileData = await File(filename).readAsString();
  final jsonData = jsonDecode(fileData) as Map<String, dynamic>;
  return jsonData;
}
```

1. `Isolate.run()` takes the result `_readAndParseJson()` returns and sends the value back to the main isolate, shutting down the worker isolate.
2. The worker isolate *transfers* the memory holding the result to the main isolate. It *does not copy* the data. The worker isolate performs a verification pass to ensure the objects are allowed to be transferred.

`_readAndParseJson()` is an existing, asynchronous function that could just as easily run directly in the main isolate. Using `Isolate.run()` to run it instead enables concurrency. The worker isolate completely abstracts the computations of `_readAndParseJson()`. It can complete without blocking the main isolate.

The result of `Isolate.run()` is always a Future, because code in the main isolate continues to run. Whether the computation the worker isolate executes is synchronous or asynchronous doesn't impact the main isolate, because it's running concurrently either way.

For the complete program, check out the [send_and_receive.dart](https://github.com/dart-lang/samples/blob/main/isolates/bin/send_and_receive.dart) sample.

**Sending closures with isolates**[#](https://dart.dev/language/isolates#sending-closures-with-isolates)

You can also create a simple worker isolate with `run()` using a function literal, or closure, directly in the main isolate.

```dart
const String filename = 'with_keys.json';

void main() async {
  // 새로운 isolate에서 JSON 읽기 및 파싱
  final jsonData = await Isolate.run(() async {
    final fileData = await File(filename).readAsString();
    final jsonData = jsonDecode(fileData) as Map<String, dynamic>;
    return jsonData;
  });

  // 데이터 사용하기
  print('Number of JSON keys: ${jsonData.length}');
}
```

This example accomplishes the same as the previous. A new isolate spawns, computes something, and sends back the result.

However, now the isolate sends a [closure](https://dart.dev/language/functions#anonymous-functions). Closures are less limited than typical named functions, both in how they function and how they're written into the code. In this example, `Isolate.run()` executes what looks like local code, concurrently. In that sense, you can imagine `run()` to work like a control flow operator for "run in parallel".

> 
> 
> 
> ### 1. 기존 메서드를 새로운 Isolate에서 실행하기
> 
> 1. **Isolate.run() 호출**:
> `main()` 함수에서 `Isolate.run()`을 호출하여 새로운 isolate를 생성합니다. 이 isolate는 `_readAndParseJson()` 메서드를 실행합니다.
>     
>     ```dart
>     const String filename = 'with_keys.json';
>     
>     void main() async {
>       // 데이터 읽기
>       final jsonData = await Isolate.run(_readAndParseJson);
>     
>       // 데이터 사용하기
>       print('Number of JSON keys: ${jsonData.length}');
>     }
>     
>     ```
>     
> 2. **메서드 정의**:
> `_readAndParseJson()` 함수는 파일을 읽고 JSON을 파싱하여 반환합니다.
>     
>     ```dart
>     Future<Map<String, dynamic>> _readAndParseJson() async {
>       final fileData = await File(filename).readAsString();
>       final jsonData = jsonDecode(fileData) as Map<String, dynamic>;
>       return jsonData;
>     }
>     
>     ```
>     
> 3. **결과 전달 및 종료**:
> `Isolate.run()`은 `_readAndParseJson()`의 결과를 메인 isolate로 전송하고, worker isolate를 종료합니다. 이 과정에서 데이터는 메모리에서 전송되며, 복사되지 않습니다.
> 4. **동시성 활용**:
> `_readAndParseJson()`은 비동기 함수로, 메인 isolate에서 직접 실행할 수도 있지만, `Isolate.run()`을 사용하면 동시성을 활용하여 메인 isolate가 차단되지 않도록 합니다.
> 5. **Future 반환**:
> `Isolate.run()`의 결과는 항상 `Future`입니다. 이는 메인 isolate가 계속 실행되도록 하며, worker isolate의 작업이 동기적이든 비동기적이든 상관없이 동시 실행됩니다.
> 
> ### 2. 클로저와 함께 Isolate 사용하기
> 
> 1. **Isolate.run() 호출**:
> `main()` 함수에서 `Isolate.run()`을 호출하여 새로운 isolate를 생성합니다. 이 isolate는 함수 리터럴(클로저)을 사용하여 작업을 수행합니다.
>     
>     ```dart
>     const String filename = 'with_keys.json';
>     
>     void main() async {
>       // 데이터 읽기
>       final jsonData = await Isolate.run(() async {
>         final fileData = await File(filename).readAsString();
>         final jsonData = jsonDecode(fileData) as Map<String, dynamic>;
>         return jsonData;
>       });
>     
>       // 데이터 사용하기
>       print('Number of JSON keys: ${jsonData.length}');
>     }
>     
>     ```
>     
> 2. **클로저 사용**:
> 클로저를 사용하여 worker isolate에서 실행할 코드를 정의합니다. 클로저는 코드가 더 유연해지며, 로컬 코드처럼 동작합니다.
> 3. **동시성 활용**:
> 이 방법도 동시성을 활용하여 메인 isolate가 차단되지 않도록 하며, `Isolate.run()`은 클로저를 병렬로 실행합니다.
> 
> 이렇게 두 가지 방법으로 `Isolate`를 활용하여 동시성을 구현할 수 있으며, 각각의 방법은 비슷한 방식으로 동작하지만, 클로저를 사용하는 방법은 더 유연하게 코드를 작성할 수 있습니다.
> 

**Sending multiple messages between isolates with ports**[#](https://dart.dev/language/isolates#sending-multiple-messages-between-isolates-with-ports)

Short-lived isolates are convenient to use, but require performance overhead to spawn new isolates and to copy objects from one isolate to another. If your code relies on repeatedly running the same computation using `Isolate.run`, you might improve performance by instead creating long-lived isolates that don’t exit immediately.

To do this, you can use some of the low-level isolate APIs that `Isolate.run` abstracts:

- [`Isolate.spawn()`](https://api.dart.dev/stable/dart-isolate/Isolate/spawn.html) and [`Isolate.exit()`](https://api.dart.dev/stable/dart-isolate/Isolate/exit.html)
- [`ReceivePort`](https://api.dart.dev/stable/dart-isolate/ReceivePort-class.html) and [`SendPort`](https://api.dart.dev/stable/dart-isolate/SendPort-class.html)
- [`SendPort.send()` method](https://api.dart.dev/stable/dart-isolate/SendPort/send.html)

This section goes over the steps required to establish 2-way communication between a newly spawned isolate and the [main isolate](https://dart.dev/language/concurrency#the-main-isolate). The first example, [Basic ports](https://dart.dev/language/isolates#basic-ports-example), introduces the process at a high-level. The second example, [Robust ports](https://dart.dev/language/isolates#robust-ports-example), gradually adds more practical, real-world functionality to the first.

**`ReceivePort` and `SendPort`**[#](https://dart.dev/language/isolates#receiveport-and-sendport)

Setting up long-lived communication between isolates requires two classes (in addition to `Isolate`): `ReceivePort` and `SendPort`. These ports are the only way isolates can communicate with each other.

A `ReceivePort` is an object that handles messages that are sent from other isolates. Those messages are sent via a `SendPort`.

***info*Note**
A `SendPort` object is associated with exactly one `ReceivePort`, but a single `ReceivePort` can have many `SendPorts`. When you create a `ReceivePort`, it creates a `SendPort` for itself. You can create additional `SendPorts` that can send messages to an existing `ReceivePort`.

Ports behave similarly to [`Stream`](https://api.dart.dev/stable/dart-async/Stream-class.html) objects (in fact, receive ports implement `Stream`!) You can think of a `SendPort` and `ReceivePort` like Stream's `StreamController` and listeners, respectively. A `SendPort` is like a `StreamController` because you "add" messages to them with the [`SendPort.send()` method](https://api.dart.dev/stable/dart-isolate/SendPort/send.html), and those messages are handled by a listener, in this case the `ReceivePort`. The `ReceivePort` then handles the messages it receives by passing them as arguments to a callback that you provide.

> 다음은 Dart의 `Isolate`를 사용하여 여러 메시지를 주고받는 방법에 대한 정리입니다.
> 
> 
> ### Isolate 간 메시지 전송
> 
> 짧은 생명의 `isolate`를 사용하는 것은 간편하지만, 성능에 영향을 줄 수 있습니다. 자주 동일한 계산을 수행해야 하는 경우, `Isolate.run` 대신 긴 생명의 `isolate`를 사용하여 성능을 개선할 수 있습니다. 이를 위해서는 다음과 같은 낮은 수준의 `isolate` API를 사용합니다:
> 
> - `Isolate.spawn()`과 `Isolate.exit()`
> - `ReceivePort`와 `SendPort`
> - `SendPort.send()` 메서드
> 
> ### ReceivePort와 SendPort
> 
> `ReceivePort`와 `SendPort`는 `isolate` 간의 메시지 전송을 설정하는 데 사용되는 두 가지 클래스입니다.
> 
> 1. **ReceivePort**:
>     - 메시지를 처리하는 객체입니다.
>     - 다른 `isolate`에서 보낸 메시지를 수신합니다.
>     - `ReceivePort`는 메시지를 수신할 때 이를 처리할 수 있는 콜백을 제공합니다.
> 2. **SendPort**:
>     - 메시지를 전송하는 객체입니다.
>     - 특정 `ReceivePort`에 연결되어 있으며, 그 `ReceivePort`로 메시지를 보냅니다.
>     - 하나의 `ReceivePort`는 여러 개의 `SendPort`를 가질 수 있습니다.
>     - `ReceivePort`를 생성하면 자동으로 `SendPort`도 생성됩니다.
> 
> ### 예제
> 
> **기본 포트 사용하기**
> 
> 1. **Isolate 생성**:
>     - `Isolate.spawn()`을 사용하여 새로운 `isolate`를 생성합니다.
>     - `ReceivePort`와 `SendPort`를 설정하여 메시지를 주고받습니다.
> 2. **ReceivePort와 SendPort 설정**:
>     - `ReceivePort`를 생성하고 이를 통해 메시지를 수신합니다.
>     - `SendPort`를 사용하여 `ReceivePort`에 메시지를 전송합니다.
> 3. **메시지 처리**:
>     - `SendPort.send()` 메서드를 사용하여 메시지를 전송합니다.
>     - `ReceivePort`는 메시지를 수신하고 제공된 콜백 함수로 처리합니다.
> 
> **ReceivePort와 SendPort의 유사성**
> 
> - `SendPort`는 Stream의 `StreamController`와 유사합니다. 메시지를 추가(`send()`)하여 `ReceivePort`로 전송합니다.
> - `ReceivePort`는 Stream의 리스너와 유사합니다. 메시지를 수신하고 콜백 함수를 통해 처리합니다.
> 
> 이렇게 `ReceivePort`와 `SendPort`를 사용하면 `isolate` 간의 2-way 통신을 설정하고 긴 생명의 `isolate`를 효율적으로 사용할 수 있습니다.
> 

**Setting up ports**[#](https://dart.dev/language/isolates#setting-up-ports)

A newly spawned isolate only has the information it receives through the `Isolate.spawn` call. If you need the main isolate to continue to communicate with a spawned isolate past its initial creation, you must set up a communication channel where the spawned isolate can send messages to the main isolate. Isolates can only communicate via message passing. They can’t “see” inside each others’ memory, which is where the name “isolate” comes from.

To set up this 2-way communication, first create a [`ReceivePort`](https://api.dart.dev/stable/dart-isolate/ReceivePort-class.html) in the main isolate, then pass its [`SendPort`](https://api.dart.dev/stable/dart-isolate/SendPort-class.html) as an argument to the new isolate when spawning it with `Isolate.spawn`. The new isolate then creates its own `ReceivePort`, and sends *its* `SendPort` back on the `SendPort` it was passed by the main isolate. The main isolate receives this `SendPort`, and now both sides have an open channel to send and receive messages.

***info*Note**
The diagrams in this section are high-level and intended to convey the *concept* of using ports for isolates. Actual implementation requires a bit more code, which you will find [later on this page](https://dart.dev/language/isolates#basic-ports-example).

!https://dart.dev/assets/img/language/concurrency/ports-setup.png

1. Create a `ReceivePort` in the main isolate. The `SendPort` is created automatically as a property on the `ReceivePort`.
2. Spawn the worker isolate with `Isolate.spawn()`
3. Pass a reference to `ReceivePort.sendPort` as the first message to the worker isolate.
4. Create another new `ReceivePort` in the worker isolate.
5. Pass a reference to the worker isolate's `ReceivePort.sendPort` as the first message *back* to the main isolate.

Along with creating the ports and setting up communication, you’ll also need to tell the ports what to do when they receive messages. This is done using the `listen` method on each respective `ReceivePort`.

!https://dart.dev/assets/img/language/concurrency/ports-passing-messages.png

1. Send a message via the main isolate’s reference to the worker isolate's `SendPort`.
2. Receive and handle the message via a listener on the worker isolate's `ReceivePort`. This is where the computation you want to move off the main isolate is executed.
3. Send a return message via the worker isolate's reference to the main isolate's `SendPort`.
4. Receive the message via a listener on the main isolate's `ReceivePort`.

**Basic ports example**[#](https://dart.dev/language/isolates#basic-ports-example)

This example demonstrates how you can set up a long-lived worker isolate with 2-way communication between it and the main isolate. The code uses the example of sending JSON text to a new isolate, where the JSON will be parsed and decoded, before being sent back to the main isolate.

***warning*Warning**
This example is meant to teach the *bare minimum* needed to spawn a new isolate that can send and receive multiple messages over time.
It does not cover important pieces of functionality that are expected in production software, like error handling, shutting down ports, and message sequencing.
The [Robust ports example](https://dart.dev/language/isolates#robust-ports-example) in the next section covers this functionality and discusses some of the issues that can arise without it.

> **포트 설정하기**
> 
> 1. **ReceivePort와 SendPort 생성하기**:
>     - `ReceivePort`를 메인 아이솔레이트에서 생성합니다. `ReceivePort`는 메시지를 받을 때 사용하는 포트입니다. 생성하면 자동으로 `SendPort`가 함께 생성됩니다.
>     - 새로운 아이솔레이트를 `Isolate.spawn()`으로 생성할 때, `ReceivePort.sendPort`를 인수로 전달합니다.
> 2. **아이솔레이트에서 포트 설정하기**:
>     - 새로 생성된 아이솔레이트에서는 또 다른 `ReceivePort`를 생성하고, 이 포트의 `SendPort`를 메인 아이솔레이트로 다시 보냅니다.
>     - 메인 아이솔레이트는 이 `SendPort`를 받아 두 포트 간의 통신이 가능해집니다.
> 3. **메시지 송수신**:
>     - 메인 아이솔레이트에서 작업을 보내기 위해 `SendPort`를 통해 메시지를 보냅니다.
>     - 아이솔레이트는 `ReceivePort`의 리스너를 통해 메시지를 받고 처리합니다.
>     - 처리된 결과를 다시 메인 아이솔레이트의 `SendPort`로 전송합니다.
>     - 메인 아이솔레이트는 `ReceivePort`의 리스너를 통해 결과를 수신합니다.
> 
> **기본 포트 예제**:
> 
> - 새로운 아이솔레이트를 생성하고, JSON 텍스트를 전송하여 파싱하고 디코딩한 후, 결과를 메인 아이솔레이트로 다시 보내는 예제입니다.
> - 이 예제는 기본적인 2-way 통신을 설명하며, 실제 프로덕션에서는 오류 처리, 포트 종료, 메시지 순서 보장 등의 추가 기능이 필요합니다.
> 
> 이 예제는 기본적인 아이솔레이트 통신을 이해하는 데 유용하며, 실제 애플리케이션에서는 보다 복잡한 기능이 필요할 수 있습니다.
> 

아래는 기본 포트 예제를 설정하고 사용하는 단계별 설명입니다:

### 기본 포트 예제

이 예제에서는 주 아이솔레이트 작업 아이솔레이트 간에 2-way 통신을 설정하는 방법을 보여줍니다. 이 코드는 JSON 텍스트를 새 아이솔레이트 보내고, 그곳에서 JSON을 파싱하고 디코딩한 후 다시 주 이소레이트로 보내는 예제입니다.

### 1단계: 워커 클래스 정의

먼저, 백그라운드 워커 아이솔레이트 위한 클래스를 만듭니다. 이 클래스는 다음 기능을 포함합니다:

- 아이솔레이트 생성하고
- 메시지를 아이솔레이트 보내며
- JSON을 디코딩하고
- 디코딩된 JSON을 주 아이솔레이트 보내는 작업을 수행합니다.

```dart
class Worker {
  Future<void> spawn() async {
    // TODO: 워커 이소레이트를 생성하는 기능을 추가합니다.
  }

  void _handleResponsesFromIsolate(dynamic message) {
    // TODO: 워커 이소레이트에서 보낸 메시지를 처리합니다.
  }

  static void _startRemoteIsolate(SendPort port) {
    // TODO: 워커 이소레이트에서 실행할 코드를 정의합니다.
  }

  Future<void> parseJson(String message) async {
    // TODO: 워커 이소레이트로 메시지를 보내는 공개 메서드를 정의합니다.
  }
}

```

### 2단계: 워커 아이솔레이트 생성

`Worker.spawn` 메서드에서 워커 아이솔레이트 생성하고 메시지를 받을 수 있도록 합니다:

- `ReceivePort`를 생성하여 주 이소레이트가 워커 이소레이트에서 보내는 메시지를 받을 수 있게 합니다.
- 메시지를 처리할 리스너를 `ReceivePort`에 추가합니다.
- `Isolate.spawn`을 사용하여 이소레이트를 생성합니다. 이때, 두 번째 인수로 `ReceivePort.sendPort`를 전달합니다.

```dart
Future<void> spawn() async {
  final receivePort = ReceivePort();
  receivePort.listen(_handleResponsesFromIsolate);
  await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort);
}

```

### 3단계: 워커 아이솔레이트에서 코드 실행

`_startRemoteIsolate` 메서드에서 워커 아이솔레이트에서 실행될 코드를 정의합니다:

- 또 다른 `ReceivePort`를 생성하여 주 아이솔레이트에서 보내는 메시지를 받습니다.
- 이 `ReceivePort`의 `SendPort`를 주 아이솔레이트로 보냅니다.
- `ReceivePort`에 리스너를 추가하여 주 아이솔레이트가 보낸 메시지를 처리합니다.

```dart
static void _startRemoteIsolate(SendPort port) {
  final receivePort = ReceivePort();
  port.send(receivePort.sendPort);

  receivePort.listen((dynamic message) async {
    if (message is String) {
      final transformed = jsonDecode(message);
      port.send(transformed);
    }
  });
}

```

### 4단계: 주 아이솔레이트에서 메시지 처리

주 아이솔레이트가 워커 아이솔레이트에서 보낸 메시지를 처리하도록 `_handleResponsesFromIsolate` 메서드를 구현합니다:

- 메시지가 `SendPort`인 경우, 이 포트를 클래스의 `_sendPort` 속성에 할당하여 나중에 사용할 수 있게 합니다.
- 메시지가 `Map<String, dynamic>` 타입인 경우, 이를 처리합니다 (예: 콘솔에 출력).

```dart
void _handleResponsesFromIsolate(dynamic message) {
  if (message is SendPort) {
    _sendPort = message;
    _isolateReady.complete();
  } else if (message is Map<String, dynamic>) {
    print(message);
  }
}

```

### 5단계: 아이솔레이트 설정 완료 보장

`parseJson` 메서드를 정의하여 메시지를 워커 아이솔레이트로 보내고 아이솔레이트가 완전히 설정될 때까지 기다립니다:

- `_isolateReady`라는 `Completer`를 클래스 수준 속성으로 추가합니다.
- `_handleResponsesFromIsolate` 메서드에서 메시지가 `SendPort`인 경우, `Completer`를 완료합니다.
- `parseJson` 메서드에서 `_isolateReady.future`를 기다린 후 메시지를 전송합니다.

```dart
Future<void> parseJson(String message) async {
  await _isolateReady.future;
  _sendPort.send(message);
}

```

이 단계들을 통해 워커 아이솔레이트와 주 아이솔레이트 간의 2-way 통신을 설정하고 관리할 수 있습니다.

아래는 강력한 포트 사용 예제를 단계별로 설명한 것입니다. 이 예제는 작업 이소레이트와 두 가지 통신을 설정하며, 오류 처리, 포트 관리, 메시지 순서 보장 등 추가적인 기능을 포함합니다.

### 강력한 포트 사용 예제

이 예제는 워커 이소레이트를 생성하고, JSON을 디코딩하며, 메인 이소레이트로 응답을 보내는 방법을 개선한 것입니다. 주요 기능으로는 오류 처리, 포트 관리, 메시지 순서 보장이 포함됩니다.

### 1단계: 워커 클래스 정의

워커 이소레이트를 위한 클래스를 정의합니다. 이 클래스는 이소레이트를 생성하고, 메시지를 보내며, JSON을 디코딩하고, 결과를 주 이소레이트로 반환하는 기능을 포함합니다.

```dart
class Worker {
  final SendPort _commands;
  final ReceivePort _responses;
  bool _closed = false; // 포트가 닫혔는지 추적하는 변수
  final Map<int, Completer<Object?>> _activeRequests = {}; // 요청과 Completer를 매핑
  int _idCounter = 0; // 메시지 ID 카운터

  // JSON 메시지를 워커 이소레이트로 보내는 메서드
  Future<Object?> parseJson(String message) async {
    if (_closed) throw StateError('Closed');
    final completer = Completer<Object?>.sync();
    final id = _idCounter++;
    _activeRequests[id] = completer;
    _commands.send((id, message));
    return await completer.future;
  }

  // 워커 이소레이트를 생성하는 메서드
  static Future<Worker> spawn() async {
    final initPort = RawReceivePort();
    final connection = Completer<(ReceivePort, SendPort)>.sync();
    initPort.handler = (initialMessage) {
      final commandPort = initialMessage as SendPort;
      connection.complete((
        ReceivePort.fromRawReceivePort(initPort),
        commandPort,
      ));
    };

    try {
      await Isolate.spawn(_startRemoteIsolate, initPort.sendPort);
    } on Object {
      initPort.close();
      rethrow;
    }

    final (ReceivePort receivePort, SendPort sendPort) =
        await connection.future;

    return Worker._(receivePort, sendPort);
  }

  // 워커 이소레이트의 포트와 통신 설정
  Worker._(this._responses, this._commands) {
    _responses.listen(_handleResponsesFromIsolate);
  }

  // 워커 이소레이트에서 JSON을 디코딩하고 응답을 보내는 메서드
  static void _handleCommandsToIsolate(
    ReceivePort receivePort,
    SendPort sendPort,
  ) {
    receivePort.listen((message) {
      if (message == 'shutdown') {
        receivePort.close();
        return;
      }
      final (int id, String jsonText) = message as (int, String);
      try {
        final jsonData = jsonDecode(jsonText);
        sendPort.send((id, jsonData));
      } catch (e) {
        sendPort.send((id, RemoteError(e.toString(), '')));
      }
    });
  }

  // 워커 이소레이트의 시작 메서드
  static void _startRemoteIsolate(SendPort sendPort) {
    final receivePort = ReceivePort();
    sendPort.send(receivePort.sendPort);
    _handleCommandsToIsolate(receivePort, sendPort);
  }

  // 워커 이소레이트에서 응답을 처리하는 메서드
  void _handleResponsesFromIsolate(dynamic message) {
    final (int id, Object? response) = message as (int, Object?);
    final completer = _activeRequests.remove(id)!;

    if (response is RemoteError) {
      completer.completeError(response);
    } else {
      completer.complete(response);
    }
  }

  // 워커 이소레이트와 메인 이소레이트의 포트를 닫는 메서드
  void close() {
    if (!_closed) {
      _closed = true;
      _commands.send('shutdown');
      if (_activeRequests.isEmpty) _responses.close();
      print('--- port closed --- ');
    }
  }
}

```

### 설명

1. **워크 클래스 정의**:
    - `parseJson`: 메시지를 이소레이트로 보내고 응답을 기다립니다.
    - `spawn`: 워커 이소레이트를 생성하고, 포트와 연결합니다.
    - `Worker._`: 생성된 포트를 초기화합니다.
    - `_startRemoteIsolate`: 워커 이소레이트에서 실행할 코드입니다.
    - `_handleCommandsToIsolate`: 워커 이소레이트에서 명령을 처리합니다.
    - `_handleResponsesFromIsolate`: 메인 이소레이트에서 응답을 처리합니다.
    - `close`: 포트를 닫습니다.
2. **포트 관리**:
    - `RawReceivePort`를 사용하여 초기 메시지를 받고, 이후 `ReceivePort`를 설정하여 메시지 수신을 처리합니다.
    - `Completer`를 사용하여 요청과 응답을 관리하고, 각 요청에 대한 응답을 올바르게 매칭합니다.
3. **오류 처리**:
    - JSON 디코딩 오류 발생 시 `RemoteError`를 메인 이소레이트로 보냅니다.
4. **포트 닫기**:
    - `close` 메서드로 포트를 안전하게 닫고, `shutdown` 메시지를 보내 이소레이트가 종료되도록 합니다.

이 예제는 이소레이트와의 통신을 안정적이고 효과적으로 관리할 수 있도록 도와줍니다.

---

### Concurrency and isolates[Performance](https://docs.flutter.dev/perf)chevron_right[Concurrency and isolates](https://docs.flutter.dev/perf/isolates)

All Dart code runs in [isolates](https://dart.dev/language/concurrency), which are similar to threads, but differ in that isolates have their own isolated memory. They do not share state in any way, and can only communicate by messaging. By default, Flutter apps do all of their work on a single isolate – the main isolate. In most cases, this model allows for simpler programming and is fast enough that the application's UI doesn't become unresponsive.

Sometimes though, applications need to perform exceptionally large computations that can cause "UI jank" (jerky motion). If your app is experiencing jank for this reason, you can move these computations to a helper isolate. This allows the underlying runtime environment to run the computation concurrently with the main UI isolate's work and takes advantage of multi-core devices.

Each isolate has its own memory and its own event loop. The event loop processes events in the order that they're added to an event queue. On the main isolate, these events can be anything from handling a user tapping in the UI, to executing a function, to painting a frame on the screen. The following figure shows an example event queue with 3 events waiting to be processed.

!https://docs.flutter.dev/assets/images/docs/development/concurrency/basics-main-isolate.png

For smooth rendering, Flutter adds a "paint frame" event to the event queue 60 times per second(for a 60Hz device). If these events aren't processed on time, the application experiences UI jank, or worse, become unresponsive altogether.

!https://docs.flutter.dev/assets/images/docs/development/concurrency/event-jank.png

Whenever a process can't be completed in a frame gap, the time between two frames, it's a good idea to offload the work to another isolate to ensure that the main isolate can produce 60 frames per second. When you spawn an isolate in Dart, it can process the work concurrently with the main isolate, without blocking it.

You can read more about how isolates and the event loop work in Dart on the [concurrency page](https://dart.dev/language/concurrency) of the Dart documentation.

> **Dart의 동시성 및 아이솔레이트**
> 
> 
> ### **아이솔레이트?**
> 
> - **정의**: Dart에서 모든 코드는 아이솔레이트를 실행됩니다. 아이솔레이트는 스레드와 유사하지만, 독립적인 메모리를 가지고 상태를 공유하지 않습니다. 이소레이트 간의 통신은 메시지를 통해 이루어집니다.
> - **기본 동작**: Flutter 앱은 기본적으로 하나의 이소레이트(메인 이소레이트)에서 모든 작업을 수행합니다. 이 모델은 프로그래밍을 간단하게 하고, 일반적으로 앱의 UI가 반응하지 않게 되는 문제를 방지할 수 있습니다.
> 
> ### **성능 및 UI 응답성**
> 
> - **문제 발생**: 때때로 애플리케이션이 매우 큰 계산을 수행할 필요가 있을 때, 이로 인해 "UI 잔크" (화면의 끊김 현상)가 발생할 수 있습니다.
> - **해결 방법**: 이러한 계산을 도와주는 아이솔레이트로 옮김으로써, 기본 UI 아이솔레이트의 작업과 동시에 수행할 수 있습니다. 이는 멀티코어 장치의 성능을 활용하여 문제를 해결합니다.
> 
> ### 아이솔레이트의 **동작**
> 
> - 아이솔레이트는의 **메모리**: 각 아이솔레이트는 독립적인 메모리와 이벤트 루프를 가지고 있습니다.
> - **이벤트 루프**: 아이솔레이트의 이벤트 루프는 이벤트 큐에 추가된 이벤트를 순서대로 처리합니다. 메인 아이솔레이트의 경우, 이 이벤트는 사용자 입력 처리, 함수 실행, 화면에 프레임을 그리는 작업 등을 포함할 수 있습니다.
>     - 예: Flutter는 60Hz 디바이스에서 초당 60번 "paint frame" 이벤트를 추가합니다. 이 이벤트가 제때 처리되지 않으면 UI 잔크가 발생할 수 있습니다.
> 
> ### 아이솔레이트 **사용 권장**
> 
> - **성능 최적화**: 계산 작업이 프레임 간의 시간 간격(프레임 갭)에서 완료되지 않는 경우, 메인 이소레이트가 초당 60프레임을 유지할 수 있도록 작업을 다른 이소레이트로 오프로드하는 것이 좋습니다. 아이솔레이트를 사용하면 메인 아이솔레이트를 차단하지 않고 작업을 동시에 처리할 수 있습니다.
> 
> ### **추가 정보**
> 
> - **문서 링크**: Dart의 동시성과 아이솔레이트에 대한 자세한 내용은 Dart 문서의 동시성 페이지에서 확인할 수 있습니다.
> 
> 이렇게 정리된 내용을 바탕으로, Dart의 아이솔레이트와 성능 최적화 방법을 이해하고 활용할 수 있습니다.
> 

**Common use cases for isolates**[#](https://docs.flutter.dev/perf/isolates#common-use-cases-for-isolates)

There is only one hard rule for when you should use isolates, and that's when large computations are causing your Flutter application to experience UI jank. This jank happens when there is any computation that takes longer than Flutter's frame gap.

!https://docs.flutter.dev/assets/images/docs/development/concurrency/event-jank.png

Any process *could* take longer to complete, depending on the implementation and the input data, making it impossible to create an exhaustive list of when you need to consider using isolates.

That said, isolates are commonly used for the following:

- Reading data from a local database
- Sending push notifications
- Parsing and decoding large data files
- Processing or compressing photos, audio files, and video files
- Converting audio and video files
- When you need asynchronous support while using FFI
- Applying filtering to complex lists or filesystems

> 아이솔레이트의 일반적인 사용 사례는 다음과 같습니다:
> 
> 
> ### 아이솔레이트 사용 필요
> 
> 아이솔레이트를 사용해야 하는 주된 이유는 큰 계산 작업으로 인해 Flutter 애플리케이션에서 UI가 깜빡이거나 멈추는 현상(유저 인터페이스 잔크)이 발생할 때입니다. 이러한 잔크는 Flutter의 프레임 간격보다 오래 걸리는 계산 작업이 있을 때 발생합니다.
> 
> ### 일반적인 사용 사례
> 
> 1. **로컬 데이터베이스 읽기**
>     
>     대규모 데이터베이스에서 데이터를 읽는 작업을 아이솔레이트로 처리하여 메인 스레드의 성능을 유지합니다.
>     
> 2. **푸시 알림 전송**
>     
>     서버에서 푸시 알림을 전송하는 작업을 아이솔레이트로 처리하여 앱의 메인 스레드가 차단되지 않도록 합니다.
>     
> 3. **대형 데이터 파일의 파싱 및 디코딩**
>     
>     큰 JSON, XML 등의 파일을 파싱하고 디코딩하는 작업을 아이솔레이트에서 수행하여 UI가 응답성을 유지하게 합니다.
>     
> 4. **사진, 오디오 파일, 비디오 파일의 처리 또는 압축**
>     
>     이미지, 오디오, 비디오 파일을 처리하거나 압축하는 작업을 아이솔레이트로 분리하여 메인 스레드의 부하를 줄입니다.
>     
> 5. **오디오 및 비디오 파일 변환**
>     
>     다양한 포맷의 오디오 및 비디오 파일을 변환하는 작업을 아이솔레이트에서 처리하여 UI의 성능을 보호합니다.
>     
> 6. **FFI를 사용할 때 비동기 지원**
>     
>     외부 C 라이브러리와 상호작용할 때 비동기 작업을 아이솔레이트에서 수행하여 메인 스레드가 차단되지 않도록 합니다.
>     
> 7. **복잡한 목록 또는 파일 시스템 필터링**
>     
>     복잡한 데이터 목록이나 파일 시스템의 필터링 작업을 아이솔레이트로 처리하여 성능을 최적화합니다.
>     
> 
> 아이솔레이트를 사용하여 위와 같은 작업들을 메인 스레드와 분리하여 UI의 성능을 보호하고, 사용자에게 원활한 경험을 제공할 수 있습니다.
> 

**Message passing between isolates**[#](https://docs.flutter.dev/perf/isolates#message-passing-between-isolates)

Dart's isolates are an implementation of the [Actor model](https://en.wikipedia.org/wiki/Actor_model). They can only communicate with each other by message passing, which is done with [`Port` objects](https://api.dart.dev/stable/dart-isolate/ReceivePort-class.html). When messages are "passed" between each other, they are generally copied from the sending isolate to the receiving isolate. This means that any value passed to an isolate, even if mutated on that isolate, doesn't change the value on the original isolate.

The only [objects that aren't copied when passed](https://api.dart.dev/stable/dart-isolate/SendPort/send.html) to an isolate are immutable objects that can't be changed anyway, such a String or an unmodifiable byte. When you pass an immutable object between isolates, a reference to that object is sent across the port, rather than the object being copied, for better performance. Because immutable objects can't be updated, this effectively retains the actor model behavior.

An exception to this rule is when an isolate exits when it sends a message using the `Isolate.exit` method. Because the sending isolate won't exist after sending the message, it can pass ownership of the message from one isolate to the other, ensuring that only one isolate can access the message.

The two lowest-level primitives that send messages are `SendPort.send`, which makes a copy of a mutable message as it sends, and `Isolate.exit`, which sends the reference to the message. Both `Isolate.run` and `compute` use `Isolate.exit` under the hood.

> Dart의 아이솔레이트는 액터 모델(Actor model)의 구현체입니다. 아이솔레이트 간의 통신은 메시지 전달(message passing)을 통해 이루어지며, 이를 위해 `Port` 객체를 사용합니다. 메시지가 아이솔레이트 간에 전달될 때, 메시지는 일반적으로 복사되어 전송됩니다. 따라서, 한 아이솔레이트에서 전달된 값을 수정해도 원래 아이솔레이트의 값에는 영향을 미치지 않습니다.
> 
> 
> ### 메시지 전달의 세부 사항
> 
> 1. **복사와 참조**
>     - **가변 객체(Mutable Objects)**: 기본적으로, 메시지로 전달되는 값은 복사되어 전송됩니다. 이 때문에 한 아이솔레이트에서 객체를 수정해도 다른 아이솔레이트의 객체에는 영향을 미치지 않습니다.
>     - **불변 객체(Immutable Objects)**: `String` 또는 변경 불가능한 바이트 배열 등 불변 객체는 복사되지 않고 참조만 전송됩니다. 불변 객체는 변경될 수 없으므로, 이 방식이 성능을 향상시키며 액터 모델의 동작을 효과적으로 유지합니다.
> 2. **예외 사항**
>     - **아이솔레이트 종료**: 아이솔레이트가 `Isolate.exit` 메서드를 사용하여 메시지를 전송할 때는, 전송하는 아이솔레이트가 종료되기 때문에 메시지의 소유권이 전달됩니다. 이 경우, 메시지는 참조를 통해 전달되며, 이를 통해 메시지에 대한 접근이 단일 아이솔레이트로 제한됩니다.
> 3. **저수준 메시지 전달 메서드**
>     - **`SendPort.send`**: 가변 메시지를 복사하여 전송합니다.
>     - **`Isolate.exit`**: 메시지의 참조를 전송합니다.
>     - **`Isolate.run` 및 `compute`**: 이들 메서드는 내부적으로 `Isolate.exit`를 사용하여 메시지를 전송합니다.

**Short-lived isolates**[#](https://docs.flutter.dev/perf/isolates#short-lived-isolates)

The easiest way to move a process to an isolate in Flutter is with the `Isolate.run` method. This method spawns an isolate, passes a callback to the spawned isolate to start some computation, returns a value from the computation, and then shuts the isolate down when the computation is complete. This all happens concurrently with the main isolate, and doesn't block it.

!https://docs.flutter.dev/assets/images/docs/development/concurrency/isolate-bg-worker.png

The `Isolate.run` method requires a single argument, a callback function, that is run on the new isolate. This callback's function signature must have exactly one required, unnamed argument. When the computation completes, it returns the callback's value back to the main isolate, and exits the spawned isolate.

For example, consider this code that loads a large JSON blob from a file, and converts that JSON into custom Dart objects. If the json decoding process wasn't off loaded to a new isolate, this method would cause the UI to become unresponsive for several seconds.

```dart
// 211,640개의 사진 객체 목록을 생성합니다.
// (JSON 파일의 크기는 약 20MB입니다.)
Future<List<Photo>> getPhotos() async {
  final String jsonString = await rootBundle.loadString('assets/photos.json');
  final List<Photo> photos = await Isolate.run<List<Photo>>(() {
    final List<Object?> photoData = jsonDecode(jsonString) as List<Object?>;
    return photoData.cast<Map<String, Object?>>().map(Photo.fromJson).toList();
  });
  return photos;
}
```

For a complete walkthrough of using Isolates to parse JSON in the background, see [this cookbook recipe](https://docs.flutter.dev/cookbook/networking/background-parsing).

> 
> 
> 
> ### 짧은 수명의 아이솔레이트 (Short-lived Isolates)
> 
> Flutter에서 간단하게 아이솔레이트를 사용하는 방법 중 하나는 `Isolate.run` 메서드를 사용하는 것입니다. 이 메서드는 다음과 같은 작업을 수행합니다:
> 
> 1. **아이솔레이트 생성**: 새로운 아이솔레이트를 생성합니다.
> 2. **콜백 전달**: 생성된 아이솔레이트에 콜백 함수를 전달하여 계산을 시작합니다.
> 3. **계산 결과 반환**: 계산이 완료되면, 콜백의 결과를 메인 아이솔레이트로 반환합니다.
> 4. **아이솔레이트 종료**: 계산이 끝난 후, 아이솔레이트를 종료합니다.
> 
> 이 과정은 메인 아이솔레이트와 동시에 실행되며, 메인 아이솔레이트를 차단하지 않습니다.
> 
> ### 사용 예제
> 
> 예를 들어, 큰 JSON 파일을 로드하고 이를 Dart 객체로 변환하는 작업이 필요할 때, 이 작업을 새 아이솔레이트로 오프로드할 수 있습니다. 이렇게 하면 UI가 몇 초 동안 응답하지 않는 문제를 방지할 수 있습니다.
> 
> 이 예제는 `Isolate.run`을 사용하여 JSON 데이터를 파싱하는 작업을 새 아이솔레이트에서 처리하고, 결과를 메인 아이솔레이트로 반환합니다. 이를 통해 메인 스레드가 UI를 계속해서 응답성 있게 유지할 수 있습니다.
> 
> 더 자세한 내용을 알고 싶다면 JSON을 배경에서 파싱하는 방법에 대한 요리법을 참고하세요.
> 

**Stateful, longer-lived isolates**[#](https://docs.flutter.dev/perf/isolates#stateful-longer-lived-isolates)

Short-live isolates are convenient to use, but there is performance overhead required to spawn new isolates, and to copy objects from one isolate to another. If you're doing the same computation using `Isolate.run` repeatedly, you might have better performance by creating isolates that don't exit immediately.

To do this, you can use a handful of lower-level isolate-related APIs that `Isolate.run` abstracts:

- [`Isolate.spawn()`](https://api.dart.dev/stable/dart-isolate/Isolate/spawn.html) and [`Isolate.exit()`](https://api.dart.dev/stable/dart-isolate/Isolate/exit.html)
- [`ReceivePort`](https://api.dart.dev/stable/dart-isolate/ReceivePort-class.html) and [`SendPort`](https://api.dart.dev/stable/dart-isolate/SendPort-class.html)
- [`send()`](https://api.dart.dev/stable/dart-isolate/SendPort/send.html) method

When you use the `Isolate.run` method, the new isolate immediately shuts down after it returns a single message to the main isolate. Sometimes, you'll need isolates that are long lived, and can pass multiple messages to each other over time. In Dart, you can accomplish this with the Isolate API and Ports. These long-lived isolates are colloquially known as *background workers*.

Long-lived isolates are useful when you have a specific process that either needs to be run repeatedly throughout the lifetime of your application, or if you have a process that runs over a period of time and needs to yield multiple return values to the main isolate.

Or, you might use [worker_manager](https://pub.dev/packages/worker_manager) to manage long-lived isolates.

> 
> 
> 
> ### 상태를 가진 장기 실행 아이솔레이트 (Stateful, Longer-Lived Isolates)
> 
> 짧은 수명의 아이솔레이트는 사용하기 편리하지만, 새로운 아이솔레이트를 생성하고 객체를 복사하는 데 성능 오버헤드가 발생합니다. 같은 계산을 반복해서 수행할 때, 매번 새로운 아이솔레이트를 생성하는 대신 장기 실행 아이솔레이트를 사용하는 것이 성능을 개선할 수 있습니다.
> 
> ### 장기 실행 아이솔레이트의 구성 요소
> 
> 장기 실행 아이솔레이트를 설정하려면 다음과 같은 낮은 수준의 API를 사용할 수 있습니다:
> 
> - **`Isolate.spawn()`** 및 **`Isolate.exit()`**: 아이솔레이트를 생성하고 종료합니다.
> - **`ReceivePort` 및 `SendPort`**: 아이솔레이트 간의 메시지 전송을 담당합니다.
> - **`send()` 메서드**: 메시지를 아이솔레이트로 전송합니다.
> 
> ### 장기 실행 아이솔레이트 사용 예
> 
> `Isolate.run` 메서드를 사용하면 새로운 아이솔레이트가 즉시 종료되며, 단일 메시지를 반환한 후 종료됩니다. 그러나 때로는 여러 메시지를 주고받아야 하는 장기 실행 아이솔레이트가 필요합니다. 이러한 아이솔레이트는 "백그라운드 작업자"로 알려져 있습니다.
> 
> **장기 실행 아이솔레이트의 사용 사례:**
> 
> - 애플리케이션의 전체 수명 동안 반복적으로 실행해야 하는 특정 프로세스.
> - 시간이 걸리는 프로세스가 있으며, 여러 반환 값을 메인 아이솔레이트로 전달해야 하는 경우.
> 
> 또한, `worker_manager`와 같은 라이브러리를 사용하여 장기 실행 아이솔레이트를 관리할 수도 있습니다.
> 

**ReceivePorts and SendPorts**[#](https://docs.flutter.dev/perf/isolates#receiveports-and-sendports)

Set up long-lived communication between isolates with two classes (in addition to Isolate): [`ReceivePort`](https://api.dart.dev/stable/dart-isolate/ReceivePort-class.html) and [`SendPort`](https://api.dart.dev/stable/dart-isolate/SendPort-class.html). These ports are the only way isolates can communicate with each other.

`Ports` behave similarly to `Streams`, in which the `StreamController` or `Sink` is created in one isolate, and the listener is set up in the other isolate. In this analogy, the `StreamConroller` is called a `SendPort`, and you can "add" messages with the `send()` method. `ReceivePort`s are the listeners, and when these listeners receive a new message, they call a provided callback with the message as an argument.

For an in-depth explanation on setting up two-way communication between the main isolate and a worker isolate, follow the examples in the [Dart documentation](https://dart.dev/language/concurrency).

> 
> 
> 
> ### ReceivePorts 및 SendPorts
> 
> 아이솔레이트 간의 장기적인 통신을 설정할 때 **ReceivePort**와 **SendPort**를 사용합니다. 이 두 클래스는 아이솔레이트 간의 유일한 통신 방법입니다.
> 
> ### Ports의 동작 방식
> 
> - **SendPort**: 메시지를 보내는 역할을 하며, **StreamController** 또는 **Sink**와 유사합니다. `send()` 메서드를 사용하여 메시지를 추가할 수 있습니다.
> - **ReceivePort**: 메시지를 수신하는 역할을 하며, **Stream**의 리스너와 유사합니다. 이 포트는 메시지를 수신할 때마다 제공된 콜백을 호출합니다.
> 
> **ReceivePort**와 **SendPort**는 서로 다른 아이솔레이트 간의 메시지 전달을 가능하게 합니다. **SendPort**는 메시지를 보내는 포트로, **ReceivePort**는 메시지를 수신하고 처리하는 포트입니다. 이들은 서로 연결되어 있어, 하나의 포트에서 다른 포트로 메시지를 전달할 수 있습니다.
> 
> ### 예제
> 
> Dart 문서에서 두 아이솔레이트 간의 양방향 통신을 설정하는 방법에 대한 자세한 예제를 확인할 수 있습니다. 이 예제들은 메인 아이솔레이트와 작업 아이솔레이트 간의 통신을 설정하는 데 유용합니다.
> 

**Using platform plugins in isolates**[#](https://docs.flutter.dev/perf/isolates#using-platform-plugins-in-isolates)

As of Flutter 3.7, you can use platform plugins in background isolates. This opens many possibilities to offload heavy, platform-dependent computations to an isolate that won't block your UI. For example, imagine you're encrypting data using a native host API (such as an Android API on Android, an iOS API on iOS, and so on). Previously, [marshaling data](https://en.wikipedia.org/wiki/Marshalling_(computer_science)) to the host platform could waste UI thread time, and can now be done in a background isolate.

Platform channel isolates use the [`BackgroundIsolateBinaryMessenger`](https://api.flutter.dev/flutter/services/BackgroundIsolateBinaryMessenger-class.html) API. The following snippet shows an example of using the `shared_preferences` package in a background isolate.

```dart
import 'dart:isolate';
import 'package:flutter/services.dart';
import 'package:shared_preferences/shared_preferences.dart';

void main() {
  // 백그라운드 아이솔레이트에 전달할 루트 아이솔레이트 식별.
  RootIsolateToken rootIsolateToken = RootIsolateToken.instance!;
  Isolate.spawn(_isolateMain, rootIsolateToken);
}

Future<void> _isolateMain(RootIsolateToken rootIsolateToken) async {
  // 루트 아이솔레이트와 백그라운드 아이솔레이트 등록.
  BackgroundIsolateBinaryMessenger.ensureInitialized(rootIsolateToken);

  // 이제 shared_preferences 플러그인을 사용할 수 있습니다.
  SharedPreferences sharedPreferences = await SharedPreferences.getInstance();

  print(sharedPreferences.getBool('isDebug'));
}

```

**Limitations of Isolates**[#](https://docs.flutter.dev/perf/isolates#limitations-of-isolates)

If you're coming to Dart from a language with multithreading, it's reasonable to expect isolates to behave like threads, but that isn't the case. Isolates have their own global fields, and can only communicate with message passing, ensuring that mutable objects in an isolate are only ever accessible in a single isolate. Therefore, isolates are limited by their access to their own memory. For example, if you have an application with a global mutable variable called `configuration`, it is copied as a new global field in a spawned isolate. If you mutate that variable in the spawned isolate, it remains untouched in the main isolate. This is true even if you pass the `configuration` object as a message to the new isolate. This is how isolates are meant to function, and it's important to keep in mind when you consider using isolates.

**Web platforms and compute**[#](https://docs.flutter.dev/perf/isolates#web-platforms-and-compute)

Dart web platforms, including Flutter web, don't support isolates. If you're targeting the web with your Flutter app, you can use the `compute` method to ensure your code compiles. The [`compute()`](https://api.flutter.dev/flutter/foundation/compute.html) method runs the computation on the main thread on the web, but spawns a new thread on mobile devices. On mobile and desktop platforms `await compute(fun, message)` is equivalent to `await Isolate.run(() => fun(message))`.

For more information on concurrency on the web, check out the [concurrency documentation](https://dart.dev/language/concurrency) on dart.dev.

**No rootBundle access or 
dart:ui methods**[#](https://docs.flutter.dev/perf/isolates#no-rootbundle-access-or-dart-ui-methods)

All UI tasks and Flutter itself are coupled to the main isolate. Therefore, you can't access assets using `rootBundle` in spawned isolates, nor can you perform any widget or UI work in spawned isolates.

**Limited plugin messages from host platform to Flutter**[#](https://docs.flutter.dev/perf/isolates#limited-plugin-messages-from-host-platform-to-flutter)

With background isolate platform channels, you can use platform channels in isolates to send messages to the host platform (for example Android or iOS), and receive responses to those messages. However, you can't receive unsolicited messages from the host platform.

As an example, you can't set up a long-lived Firestore listener in a background isolate, because Firestore uses platform channels to push updates to Flutter, which are unsolicited. You can, however, query Firestore for a response in the background.

> 
> 
> 
> ### 아이솔레이트에서 플랫폼 플러그인 사용하기
> 
> Flutter 3.7부터는 백그라운드 아이솔레이트에서도 플랫폼 플러그인을 사용할 수 있게 되었습니다. 이는 UI를 차단하지 않고 무거운 플랫폼 의존적 작업을 아이솔레이트에서 처리할 수 있는 많은 가능성을 열어줍니다. 예를 들어, 네이티브 호스트 API를 사용하여 데이터를 암호화하는 경우(UI 스레드의 시간 낭비를 줄이기 위해) 이제는 백그라운드 아이솔레이트에서 처리할 수 있습니다.
> 
> **플랫폼 채널 아이솔레이트**는 `BackgroundIsolateBinaryMessenger` API를 사용합니다. 아래는 백그라운드 아이솔레이트에서 `shared_preferences` 패키지를 사용하는 예제입니다:
> 
> ```dart
> import 'dart:isolate';
> import 'package:flutter/services.dart';
> import 'package:shared_preferences/shared_preferences.dart';
> 
> void main() {
>   // 백그라운드 아이솔레이트에 전달할 루트 아이솔레이트 식별.
>   RootIsolateToken rootIsolateToken = RootIsolateToken.instance!;
>   Isolate.spawn(_isolateMain, rootIsolateToken);
> }
> 
> Future<void> _isolateMain(RootIsolateToken rootIsolateToken) async {
>   // 루트 아이솔레이트와 백그라운드 아이솔레이트 등록.
>   BackgroundIsolateBinaryMessenger.ensureInitialized(rootIsolateToken);
> 
>   // 이제 shared_preferences 플러그인을 사용할 수 있습니다.
>   SharedPreferences sharedPreferences = await SharedPreferences.getInstance();
> 
>   print(sharedPreferences.getBool('isDebug'));
> }
> 
> ```
> 
> ### 아이솔레이트의 제한 사항
> 
> - **아이솔레이트는 스레드와 다릅니다**: 아이솔레이트는 자신의 글로벌 필드를 가지며 메시지 전달을 통해서만 통신합니다. 이로 인해 아이솔레이트에서 변경된 가변 객체는 원래 아이솔레이트에서는 영향을 미치지 않습니다.
> - **웹 플랫폼과 compute**: Dart 웹 플랫폼(Flutter 웹 포함)은 아이솔레이트를 지원하지 않습니다. 웹에서 Flutter 앱을 대상으로 하는 경우 `compute` 메서드를 사용하여 코드를 컴파일할 수 있습니다. `compute()` 메서드는 웹에서는 메인 스레드에서 실행되며, 모바일 기기에서는 새로운 스레드를 생성합니다. 모바일 및 데스크톱 플랫폼에서는 `await compute(fun, message)`가 `await Isolate.run(() => fun(message))`와 동등합니다.
> - **rootBundle 접근 불가**: 모든 UI 작업과 Flutter 자체는 메인 아이솔레이트에 결합되어 있습니다. 따라서 생성된 아이솔레이트에서 `rootBundle`을 사용하여 자산에 접근하거나 위젯 또는 UI 작업을 수행할 수 없습니다.
> - **플러그인 메시지 제한**: 백그라운드 아이솔레이트 플랫폼 채널을 사용하여 호스트 플랫폼(예: Android 또는 iOS)에 메시지를 보내고 응답을 받을 수 있습니다. 그러나 호스트 플랫폼에서 오는 자발적인 메시지를 받을 수는 없습니다. 예를 들어, Firestore의 장기 실행 리스너를 백그라운드 아이솔레이트에서 설정할 수 없습니다. Firestore는 Flutter에 업데이트를 푸시하기 위해 플랫폼 채널을 사용하며, 이는 자발적입니다. 그러나 Firestore에 대한 쿼리는 백그라운드에서 수행할 수 있습니다.

**More information**[#](https://docs.flutter.dev/perf/isolates#more-information)

For more information on isolates, check out the following resources:

- If you're using many isolates, consider the [IsolateNameServer](https://api.flutter.dev/flutter/dart-ui/IsolateNameServer-class.html) class in Flutter, or the pub package that clones the functionality for Dart applications not using Flutter.
- Dart's Isolates are an implementation of the [Actor model](https://en.wikipedia.org/wiki/Actor_model).
- [isolate_agents](https://medium.com/@gaaclarke/isolate-agents-easy-isolates-for-flutter-6d75bf69a2e7) is a package that abstracts Ports and make it easier to create long-lived isolates.
- Read more about the `BackgroundIsolateBinaryMessenger` API [announcement](https://medium.com/flutter/introducing-background-isolate-channels-7a299609cad8).

---

### JSON을 백그라운드에서 파싱하기

기본적으로 Dart 앱은 모든 작업을 단일 스레드에서 수행합니다. 대부분의 경우 이 모델은 코딩을 단순화하고 앱 성능에 큰 문제를 일으키지 않지만, 매우 큰 JSON 문서 같은 비용이 많이 드는 계산을 수행할 때는 UI가 멈추는 "jank"가 발생할 수 있습니다.

이러한 jank를 피하려면 계산을 백그라운드에서 수행해야 합니다. Flutter에서는 이를 별도의 아이솔레이트를 사용하여 수행할 수 있습니다. 다음은 이 과정을 설명하는 단계입니다:

1. **http 패키지 추가하기**
    
    프로젝트에 `http` 패키지를 추가합니다. 이 패키지는 네트워크 요청을 쉽게 처리할 수 있게 해줍니다.
    
    ```bash
    flutter pub add http
    
    ```
    
2. **네트워크 요청하기**
    
    JSONPlaceholder REST API에서 5000개의 사진 객체가 포함된 큰 JSON 문서를 가져오는 예제입니다:
    
    ```dart
    Future<http.Response> fetchPhotos(http.Client client) async {
      return client.get(Uri.parse('<https://jsonplaceholder.typicode.com/photos>'));
    }
    
    ```
    
    이 함수는 `http.Client`를 인자로 받아 네트워크 요청을 수행합니다.
    
3. **JSON을 Dart 객체 리스트로 변환하기**
    
    `http.Response`를 Dart 객체의 리스트로 변환합니다. `Photo` 클래스를 만들고, JSON 객체를 기반으로 `Photo` 인스턴스를 생성하는 `fromJson` 팩토리 메서드를 포함합니다:
    
    ```dart
    class Photo {
      final int albumId;
      final int id;
      final String title;
      final String url;
      final String thumbnailUrl;
    
      const Photo({
        required this.albumId,
        required this.id,
        required this.title,
        required this.url,
        required this.thumbnailUrl,
      });
    
      factory Photo.fromJson(Map<String, dynamic> json) {
        return Photo(
          albumId: json['albumId'] as int,
          id: json['id'] as int,
          title: json['title'] as String,
          url: json['url'] as String,
          thumbnailUrl: json['thumbnailUrl'] as String,
        );
      }
    }
    
    List<Photo> parsePhotos(String responseBody) {
      final parsed = (jsonDecode(responseBody) as List).cast<Map<String, dynamic>>();
      return parsed.map<Photo>((json) => Photo.fromJson(json)).toList();
    }
    
    ```
    
    `fetchPhotos` 함수는 `parsePhotos` 함수를 호출하여 JSON 응답을 `List<Photo>`로 변환합니다:
    
    ```dart
    Future<List<Photo>> fetchPhotos(http.Client client) async {
      final response = await client.get(Uri.parse('<https://jsonplaceholder.typicode.com/photos>'));
      return parsePhotos(response.body);
    }
    
    ```
    
4. **작업을 별도의 아이솔레이트로 이동하기**
    
    `fetchPhotos` 함수에서 JSON 파싱과 변환 작업을 백그라운드 아이솔레이트에서 수행하여 UI의 멈춤 현상을 방지할 수 있습니다. Flutter의 `compute` 함수를 사용하여 이를 수행합니다:
    
    ```dart
    Future<List<Photo>> fetchPhotos(http.Client client) async {
      final response = await client.get(Uri.parse('<https://jsonplaceholder.typicode.com/photos>'));
      return compute(parsePhotos, response.body);
    }
    
    ```
    

### 아이솔레이트에서 작업할 때 주의사항

- 아이솔레이트는 메시지를 통해 통신하며, 메시지는 원시 값(예: null, num, bool, double, String) 또는 간단한 객체(List<Photo> 등)일 수 있습니다.
- Future나 http.Response와 같은 복잡한 객체를 아이솔레이트 간에 전달하면 오류가 발생할 수 있습니다.
- 복잡한 백그라운드 작업을 관리하려면 `worker_manager` 또는 `workmanager` 패키지를 사용할 수도 있습니다.
