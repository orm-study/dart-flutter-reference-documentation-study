# Isolates
Contents

- [Implementing a simple worker isolate](https://dart.dev/language/isolates#implementing-a-simple-worker-isolate)
    - [Running an existing method in a new isolate](https://dart.dev/language/isolates#running-an-existing-method-in-a-new-isolate)
    - [Sending closures with isolates](https://dart.dev/language/isolates#sending-closures-with-isolates)
- [Sending multiple messages between isolates with ports](https://dart.dev/language/isolates#sending-multiple-messages-between-isolates-with-ports)
    - [ReceivePort and SendPort](https://dart.dev/language/isolates#receiveport-and-sendport)
    - [Basic ports example](https://dart.dev/language/isolates#basic-ports-example)
    - [Robust ports example](https://dart.dev/language/isolates#robust-ports-example)

- 간단한 워커 아이솔레이트 구현하기
	- 기존 메소드를 새로운 아이솔레이트에서 실행하기
	- 아이솔레이트와 함께 클로저 전송하기
- 포트를 사용하여 아이솔레이트 간에 여러 메시지 전송하기
	- ReceivePort와 SendPort
	- 기본 포트 예제
	- 강력한 포트 예제

This page discusses some examples that use the `Isolate` API to implement isolates.

You should use isolates whenever your application is handling computations that are large enough to temporarily block other computations. The most common example is in [Flutter](https://flutter.dev/perf/isolates) applications, when you need to perform large computations that might otherwise cause the UI to become unresponsive.

There aren't any rules about when you _must_ use isolates, but here are some more situations where they can be useful:

- Parsing and decoding exceptionally large JSON blobs.
- Processing and compressing photos, audio and video.
- Converting audio and video files.
- Performing complex searching and filtering on large lists or within file systems.
- Performing I/O, such as communicating with a database.
- Handling a large volume of network requests.

이 페이지는 Isolate API를 사용하여 아이솔레이트를 구현하는 몇 가지 예제를 다룹니다.

애플리케이션이 다른 계산을 일시적으로 차단할 만큼 큰 계산을 처리할 때는 아이솔레이트를 사용해야 합니다. 가장 흔한 예는 Flutter 애플리케이션에서 대규모 계산을 수행해야 할 때, 그렇지 않으면 UI가 응답하지 않게 될 수 있습니다.

아이솔레이트를 반드시 사용해야 하는 규칙은 없지만, 다음과 같은 상황에서도 유용할 수 있습니다:
- 매우 큰 JSON 블랍을 파싱하고 디코딩할 때
- 사진, 오디오, 비디오를 처리하고 압축할 때
- 오디오 및 비디오 파일을 변환할 때
- 큰 리스트나 파일 시스템 내에서 복잡한 검색 및 필터링을 수행할 때
- 데이터베이스와 통신하는 등 I/O 작업을 수행할 때
- 대량의 네트워크 요청을 처리할 때

자세한 내용을 원하시면 [여기](https://gptonline.ai/ko/)를 방문해 주세요.

## Implementing a simple worker isolate

These examples implement a main isolate that spawns a simple worker isolate. [`Isolate.run()`](https://api.dart.dev/dev/dart-isolate/Isolate/run.html) simplifies the steps behind setting up and managing worker isolates:

1. Spawns (starts and creates) an isolate.
2. Runs a function on the spawned isolate.
3. Captures the result.
4. Returns the result to the main isolate.
5. Terminates the isolate once work is complete.
6. Checks, captures, and throws exceptions and errors back to the main isolate.

_Flutter note_

If you're using Flutter, you can use [Flutter's `compute` function](https://api.flutter.dev/flutter/foundation/compute.html) instead of `Isolate.run()`.


**간단한 워커 아이솔레이트 구현하기**

이 예제들은 간단한 워커 아이솔레이트를 생성하는 메인 아이솔레이트를 구현합니다. `Isolate.run()`은 워커 아이솔레이트 설정 및 관리의 단계를 단순화합니다:

1. 아이솔레이트를 생성하고 시작합니다.
2. 생성된 아이솔레이트에서 함수를 실행합니다.
3. 결과를 캡처합니다.
4. 결과를 메인 아이솔레이트로 반환합니다.
5. 작업이 완료되면 아이솔레이트를 종료합니다.
6. 예외 및 오류를 확인하고 캡처하여 메인 아이솔레이트로 다시 던집니다.

_Flutter 참고사항_

만약 Flutter를 사용하고 있다면, `Isolate.run()` 대신 Flutter의 `compute` 함수를 사용할 수 있습니다.
### Running an existing method in a new isolate

1. Call `run()` to spawn a new isolate (a [background worker](https://dart.dev/language/concurrency#background-workers)), directly in the [main isolate](https://dart.dev/language/concurrency#the-main-isolate) while `main()` waits for the result:

```dart
const String filename = 'with_keys.json';

void main() async {
  // Read some data.
  final jsonData = await Isolate.run(_readAndParseJson);

  // Use that data.
  print('Number of JSON keys: ${jsonData.length}');
}
```

2. Pass the worker isolate the function you want it to execute as its first argument. In this example, it's the existing function `_readAndParseJson()`:

```dart
Future<Map<String, dynamic>> _readAndParseJson() async {
  final fileData = await File(filename).readAsString();
  final jsonData = jsonDecode(fileData) as Map<String, dynamic>;
  return jsonData;
}
```

3. `Isolate.run()` takes the result `_readAndParseJson()` returns and sends the value back to the main isolate, shutting down the worker isolate.
    
4. The worker isolate _transfers_ the memory holding the result to the main isolate. It _does not copy_ the data. The worker isolate performs a verification pass to ensure the objects are allowed to be transferred.
    

`_readAndParseJson()` is an existing, asynchronous function that could just as easily run directly in the main isolate. Using `Isolate.run()` to run it instead enables concurrency. The worker isolate completely abstracts the computations of `_readAndParseJson()`. It can complete without blocking the main isolate.

The result of `Isolate.run()` is always a Future, because code in the main isolate continues to run. Whether the computation the worker isolate executes is synchronous or asynchronous doesn't impact the main isolate, because it's running concurrently either way.

For the complete program, check out the [send_and_receive.dart](https://github.com/dart-lang/samples/blob/main/isolates/bin/send_and_receive.dart) sample.

### 기존 메소드를 새로운 아이솔레이트에서 실행하기

1. 메인 아이솔레이트에서 `run()`을 호출하여 새로운 아이솔레이트(백그라운드 워커)를 생성하고, `main()`이 결과를 기다리는 동안 직접 실행합니다:

```dart
const String filename = 'with_keys.json';

void main() async {
  // Read some data.
  final jsonData = await Isolate.run(_readAndParseJson);

  // Use that data.
  print('Number of JSON keys: ${jsonData.length}');
}
```

2. 새로운 아이솔레이트에게 실행하고자 하는 함수를 첫 번째 인수로 전달합니다. 이 예제에서는 기존 함수 `_readAndParseJson()`을 전달합니다:

```dart
Future<Map<String, dynamic>> _readAndParseJson() async {
  final fileData = await File(filename).readAsString();
  final jsonData = jsonDecode(fileData) as Map<String, dynamic>;
  return jsonData;
}
```

3. `Isolate.run()`은 `_readAndParseJson()`이 반환한 결과를 받아 그 값을 메인 아이솔레이트로 보내고, 워커 아이솔레이트를 종료합니다.

4. 워커 아이솔레이트는 결과를 담고 있는 메모리를 메인 아이솔레이트로 전달합니다. 데이터를 복사하지 않습니다. 워커 아이솔레이트는 객체가 전송될 수 있는지 확인하는 검증 과정을 수행합니다.

`_readAndParseJson()`은 기존의 비동기 함수로, 메인 아이솔레이트에서 직접 실행될 수도 있습니다. 대신 `Isolate.run()`을 사용하여 이를 실행하면 동시성 처리가 가능합니다. 워커 아이솔레이트는 `_readAndParseJson()`의 계산을 완전히 추상화합니다. 이는 메인 아이솔레이트를 차단하지 않고 완료될 수 있습니다.

`Isolate.run()`의 결과는 항상 `Future`입니다. 메인 아이솔레이트의 코드는 계속 실행되기 때문입니다. 워커 아이솔레이트가 실행하는 계산이 동기적이든 비동기적이든 메인 아이솔레이트에는 영향을 미치지 않습니다. 둘 다 동시에 실행되기 때문입니다.

전체 프로그램은 `send_and_receive.dart` 샘플을 참고하세요.
### Sending closures with isolates

You can also create a simple worker isolate with `run()` using a function literal, or closure, directly in the main isolate.

```dart
const String filename = 'with_keys.json';

void main() async {
  // Read some data.
  final jsonData = await Isolate.run(() async {
    final fileData = await File(filename).readAsString();
    final jsonData = jsonDecode(fileData) as Map<String, dynamic>;
    return jsonData;
  });

  // Use that data.
  print('Number of JSON keys: ${jsonData.length}');
}
```

This example accomplishes the same as the previous. A new isolate spawns, computes something, and sends back the result.

However, now the isolate sends a [closure](https://dart.dev/language/functions#anonymous-functions). Closures are less limited than typical named functions, both in how they function and how they're written into the code. In this example, `Isolate.run()` executes what looks like local code, concurrently. In that sense, you can imagine `run()` to work like a control flow operator for "run in parallel".

### 아이솔레이트와 함께 클로저 전송하기

`run()`을 사용하여 메인 아이솔레이트에서 직접 함수 리터럴 또는 클로저를 사용하여 간단한 워커 아이솔레이트를 생성할 수도 있습니다.

```dart
const String filename = 'with_keys.json';

void main() async {
  // Read some data.
  final jsonData = await Isolate.run(() async {
    final fileData = await File(filename).readAsString();
    final jsonData = jsonDecode(fileData) as Map<String, dynamic>;
    return jsonData;
  });

  // Use that data.
  print('Number of JSON keys: ${jsonData.length}');
}
```

이 예제는 이전 예제와 동일한 작업을 수행합니다. 새로운 아이솔레이트가 생성되어 계산을 수행하고 결과를 반환합니다.

그러나 이번에는 아이솔레이트가 클로저를 전송합니다. 클로저는 일반적인 명명된 함수보다 기능적으로나 코드 작성 측면에서 덜 제한적입니다. 이 예제에서 `Isolate.run()`은 로컬 코드처럼 보이는 것을 동시에 실행합니다. 그런 의미에서 `run()`은 "병렬로 실행"하기 위한 제어 흐름 연산자처럼 작동한다고 상상할 수 있습니다.
## Sending multiple messages between isolates with ports

Short-lived isolates are convenient to use, but require performance overhead to spawn new isolates and to copy objects from one isolate to another. If your code relies on repeatedly running the same computation using `Isolate.run`, you might improve performance by instead creating long-lived isolates that don’t exit immediately.

To do this, you can use some of the low-level isolate APIs that `Isolate.run` abstracts:

- [`Isolate.spawn()`](https://api.dart.dev/stable/dart-isolate/Isolate/spawn.html) and [`Isolate.exit()`](https://api.dart.dev/stable/dart-isolate/Isolate/exit.html)
- [`ReceivePort`](https://api.dart.dev/stable/dart-isolate/ReceivePort-class.html) and [`SendPort`](https://api.dart.dev/stable/dart-isolate/SendPort-class.html)
- [`SendPort.send()` method](https://api.dart.dev/stable/dart-isolate/SendPort/send.html)

This section goes over the steps required to establish 2-way communication between a newly spawned isolate and the [main isolate](https://dart.dev/language/concurrency#the-main-isolate). The first example, [Basic ports](https://dart.dev/language/isolates#basic-ports-example), introduces the process at a high-level. The second example, [Robust ports](https://dart.dev/language/isolates#robust-ports-example), gradually adds more practical, real-world functionality to the first.

### 포트를 사용하여 아이솔레이트 간에 여러 메시지 전송하기

단기 아이솔레이트는 사용하기 편리하지만, 새로운 아이솔레이트를 생성하고 객체를 복사하는 데 성능 오버헤드가 발생합니다. 만약 코드가 `Isolate.run`을 사용하여 반복적으로 동일한 계산을 실행해야 한다면, 즉시 종료되지 않는 장기 아이솔레이트를 생성하여 성능을 향상시킬 수 있습니다.

이를 위해 `Isolate.run`이 추상화하는 저수준의 아이솔레이트 API를 사용할 수 있습니다:

- `Isolate.spawn()` 및 `Isolate.exit()`
- `ReceivePort`와 `SendPort`
- `SendPort.send()` 메서드

이 섹션에서는 새로 생성된 아이솔레이트와 메인 아이솔레이트 간의 양방향 통신을 설정하는 데 필요한 단계들을 설명합니다. 첫 번째 예제인 기본 포트(Basic ports)에서는 고수준에서 과정을 소개합니다. 두 번째 예제인 강력한 포트(Robust ports)에서는 첫 번째 예제에 더 실제적이고 실용적인 기능을 점진적으로 추가합니다.

### `ReceivePort` and `SendPort`

Setting up long-lived communication between isolates requires two classes (in addition to `Isolate`): `ReceivePort` and `SendPort`. These ports are the only way isolates can communicate with each other.

A `ReceivePort` is an object that handles messages that are sent from other isolates. Those messages are sent via a `SendPort`.

_info_Note

A `SendPort` object is associated with exactly one `ReceivePort`, but a single `ReceivePort` can have many `SendPorts`. When you create a `ReceivePort`, it creates a `SendPort` for itself. You can create additional `SendPorts` that can send messages to an existing `ReceivePort`.

Ports behave similarly to [`Stream`](https://api.dart.dev/stable/dart-async/Stream-class.html) objects (in fact, receive ports implement `Stream`!) You can think of a `SendPort` and `ReceivePort` like Stream's `StreamController` and listeners, respectively. A `SendPort` is like a `StreamController` because you "add" messages to them with the [`SendPort.send()` method](https://api.dart.dev/stable/dart-isolate/SendPort/send.html), and those messages are handled by a listener, in this case the `ReceivePort`. The `ReceivePort` then handles the messages it receives by passing them as arguments to a callback that you provide.

### ReceivePort와 SendPort

아이솔레이트 간의 장기적인 통신을 설정하려면 두 가지 클래스(아이솔레이트 외에)를 사용해야 합니다: `ReceivePort`와 `SendPort`. 이 포트들은 아이솔레이트가 서로 통신할 수 있는 유일한 방법입니다.

`ReceivePort`는 다른 아이솔레이트에서 보내는 메시지를 처리하는 객체입니다. 이러한 메시지는 `SendPort`를 통해 전송됩니다.

_참고사항_

`SendPort` 객체는 정확히 하나의 `ReceivePort`와 연관되어 있지만, 하나의 `ReceivePort`는 여러 개의 `SendPort`를 가질 수 있습니다. `ReceivePort`를 생성하면 자체적으로 `SendPort`를 생성합니다. 기존의 `ReceivePort`로 메시지를 보낼 수 있는 추가적인 `SendPort`를 생성할 수 있습니다.

포트는 `Stream` 객체와 유사하게 작동합니다(사실, `ReceivePort`는 `Stream`을 구현합니다!). `SendPort`와 `ReceivePort`를 각각 `Stream`의 `StreamController`와 리스너로 생각할 수 있습니다. `SendPort`는 `StreamController`와 비슷하게 `SendPort.send()` 메서드로 메시지를 "추가"할 수 있으며, 이러한 메시지는 리스너(이 경우 `ReceivePort`)에 의해 처리됩니다. `ReceivePort`는 수신한 메시지를 제공된 콜백의 인수로 전달하여 처리합니다.

#### Setting up ports

A newly spawned isolate only has the information it receives through the `Isolate.spawn` call. If you need the main isolate to continue to communicate with a spawned isolate past its initial creation, you must set up a communication channel where the spawned isolate can send messages to the main isolate. Isolates can only communicate via message passing. They can’t “see” inside each others’ memory, which is where the name “isolate” comes from.

To set up this 2-way communication, first create a [`ReceivePort`](https://api.dart.dev/stable/dart-isolate/ReceivePort-class.html) in the main isolate, then pass its [`SendPort`](https://api.dart.dev/stable/dart-isolate/SendPort-class.html) as an argument to the new isolate when spawning it with `Isolate.spawn`. The new isolate then creates its own `ReceivePort`, and sends _its_ `SendPort` back on the `SendPort` it was passed by the main isolate. The main isolate receives this `SendPort`, and now both sides have an open channel to send and receive messages.

_info_Note

The diagrams in this section are high-level and intended to convey the _concept_ of using ports for isolates. Actual implementation requires a bit more code, which you will find [later on this page](https://dart.dev/language/isolates#basic-ports-example).

![A figure showing events being fed, one by one, into the event loop](https://dart.dev/assets/img/C3cZkN_RYw-708.png)

1. Create a `ReceivePort` in the main isolate. The `SendPort` is created automatically as a property on the `ReceivePort`.
2. Spawn the worker isolate with `Isolate.spawn()`
3. Pass a reference to `ReceivePort.sendPort` as the first message to the worker isolate.
4. Create another new `ReceivePort` in the worker isolate.
5. Pass a reference to the worker isolate's `ReceivePort.sendPort` as the first message _back_ to the main isolate.

Along with creating the ports and setting up communication, you’ll also need to tell the ports what to do when they receive messages. This is done using the `listen` method on each respective `ReceivePort`.

![A figure showing events being fed, one by one, into the event loop](https://dart.dev/assets/img/SJOLJRMsnW-747.png)

1. Send a message via the main isolate’s reference to the worker isolate's `SendPort`.
2. Receive and handle the message via a listener on the worker isolate's `ReceivePort`. This is where the computation you want to move off the main isolate is executed.
3. Send a return message via the worker isolate's reference to the main isolate's `SendPort`.
4. Receive the message via a listener on the main isolate's `ReceivePort`.

#### 포트 설정하기 

새로 생성된 isolate는 Isolate.spawn 호출을 통해 받은 정보만을 가지고 있습니다. 메인 isolate가 생성된 isolate와 초기 생성 이후에도 계속 소통하려면, 생성된 isolate가 메인 isolate로 메시지를 보낼 수 있는 통신 채널을 설정해야 합니다. Isolate는 메시지 전달을 통해서만 소통할 수 있으며, 서로의 메모리를 "볼" 수는 없습니다. 이것이 "isolate"라는 이름의 유래입니다.

이 2-way 통신을 설정하려면, 먼저 메인 isolate에서 ReceivePort를 생성하고, 그 SendPort를 Isolate.spawn을 사용하여 새 isolate를 생성할 때 인자로 전달합니다. 그러면 새 isolate는 자신의 ReceivePort를 생성하고, 메인 isolate로부터 받은 SendPort를 통해 자신의 SendPort를 다시 보냅니다. 메인 isolate는 이 SendPort를 수신하게 되며, 이제 양쪽 모두 메시지를 주고받을 수 있는 열린 채널이 형성됩니다.

_참고사항_

이 섹션의 다이어그램은 ports를 isolates에 사용하는 개념을 전달하기 위한 고수준의 것입니다. 실제 구현은 약간 더 많은 코드가 필요하며, 이 페이지 후반부에서 확인할 수 있습니다.

![다트1](https://dart.dev/assets/img/C3cZkN_RYw-708.webp)

1. 메인 isolate에서 ReceivePort를 생성합니다. SendPort는 ReceivePort의 속성으로 자동으로 생성됩니다.
2. Isolate.spawn()을 사용하여 worker isolate를 생성합니다.
3. worker isolate에 첫 번째 메시지로 ReceivePort.sendPort의 참조를 전달합니다.
4. worker isolate에서 새로운 ReceivePort를 생성합니다.
5. worker isolate의 ReceivePort.sendPort의 참조를 메인 isolate에 첫 번째 메시지로 다시 보냅니다.

포트를 생성하고 통신을 설정하는 것 외에도, 각 포트가 메시지를 수신했을 때 무엇을 할지 지정해야 합니다. 이는 각 ReceivePort에서 listen 메서드를 사용하여 수행합니다.

![다트2](https://dart.dev/assets/img/SJOLJRMsnW-747.webp)

1. 메인 isolate의 참조를 사용하여 worker isolate의 SendPort를 통해 메시지를 보냅니다.
2. worker isolate의 ReceivePort에서 listener를 통해 메시지를 수신하고 처리합니다. 여기서 메인 isolate에서 이동시키려는 계산이 실행됩니다.
3. worker isolate의 참조를 사용하여 메인 isolate의 SendPort를 통해 반환 메시지를 보냅니다.
4. 메인 isolate의 ReceivePort에서 listener를 통해 메시지를 수신합니다.
### Basic ports example

This example demonstrates how you can set up a long-lived worker isolate with 2-way communication between it and the main isolate. The code uses the example of sending JSON text to a new isolate, where the JSON will be parsed and decoded, before being sent back to the main isolate.

_warning_

This example is meant to teach the _bare minimum_ needed to spawn a new isolate that can send and receive multiple messages over time.

It does not cover important pieces of functionality that are expected in production software, like error handling, shutting down ports, and message sequencing.

The [Robust ports example](https://dart.dev/language/isolates#robust-ports-example) in the next section covers this functionality and discusses some of the issues that can arise without it.

### 기본 포트 예제

이 예제는 메인 이솔레이트와 워커 이솔레이트 간의 양방향 통신을 설정하는 방법을 보여줍니다. 이 코드는 JSON 텍스트를 새로운 이솔레이트로 보내면, 그 이솔레이트에서 JSON을 파싱하고 디코드한 후, 메인 이솔레이트로 다시 보내는 예제를 사용합니다.

_경고_

이 예제는 시간이 지나면서 여러 메시지를 송수신할 수 있는 새로운 이솔레이트를 생성하기 위해 필요한 **최소한의** 내용을 가르치기 위한 것입니다.

이 예제는 에러 처리, 포트 종료, 메시지 시퀀싱과 같은 프로덕션 소프트웨어에서 기대되는 중요한 기능을 다루지 않습니다.

다음 섹션의 [견고한 포트 예제](https://dart.dev/language/isolates#robust-ports-example)에서는 이러한 기능을 다루고, 이를 적용하지 않았을 때 발생할 수 있는 문제들에 대해 논의합니다.

#### Step 1: Define the worker class

First, create a class for your background worker isolate. This class contains all the functionality you need to:

- Spawn an isolate.
- Send messages to that isolate.
- Have the isolate decode some JSON.
- Send the decoded JSON back to the main isolate.

The class exposes two public methods: one that spawns the worker isolate, and one that handles sending messages to that worker isolate.

The remaining sections in this example will show you how to fill in the class methods, one-by-one.



```dart
class Worker {
  Future<void> spawn() async {
    // TODO: Add functionality to spawn a worker isolate.
  }

  void _handleResponsesFromIsolate(dynamic message) {
    // TODO: Handle messages sent back from the worker isolate.
  }

  static void _startRemoteIsolate(SendPort port) {
    // TODO: Define code that should be executed on the worker isolate.
  }

  Future<void> parseJson(String message) async {
    // TODO: Define a public method that can
    // be used to send messages to the worker isolate.
  }
}
```

#### Step 1: Define the Worker Class

먼저, 백그라운드 워커 이솔레이트를 위한 클래스를 생성합니다. 이 클래스는 다음과 같은 기능을 포함합니다:

- 이솔레이트 생성
- 이솔레이트로 메시지 전송
- 이솔레이트에서 JSON 디코드
- 디코드된 JSON을 메인 이솔레이트로 전송

이 클래스는 두 개의 공개 메서드를 제공합니다. 하나는 워커 이솔레이트를 생성하는 메서드이고, 다른 하나는 워커 이솔레이트로 메시지를 전송하는 메서드입니다.

이 예제의 나머지 부분에서는 클래스 메서드를 하나씩 채우는 방법을 설명합니다.

```dart
class Worker {
  Future<void> spawn() async {
    // TODO: Add functionality to spawn a worker isolate.
  }

  void _handleResponsesFromIsolate(dynamic message) {
    // TODO: Handle messages sent back from the worker isolate.
  }

  static void _startRemoteIsolate(SendPort port) {
    // TODO: Define code that should be executed on the worker isolate.
  }

  Future<void> parseJson(String message) async {
    // TODO: Define a public method that can
    // be used to send messages to the worker isolate.
  }
}
```
#### Step 2: Spawn a worker isolate

The `Worker.spawn` method is where you will group the code for creating the worker isolate and ensuring it can receive and send messages.

- First, create a `ReceivePort`. This allows the main isolate to receive messages sent from the newly spawned worker isolate.
- Next, add a listener to the receive port to handle messages the worker isolate will send back. The callback passed to the listener, `_handleResponsesFromIsolate`, will be covered in [step 4](https://dart.dev/language/isolates#step-4-handle-messages-on-the-main-isolate).
- Finally, spawn the worker isolate with `Isolate.spawn`. It expects two arguments: a function to be executed on the worker isolate (covered in [step 3](https://dart.dev/language/isolates#step-3-execute-code-on-the-worker-isolate)), and the `sendPort` property of the receive port.

```dart
Future<void> spawn() async {
  final receivePort = ReceivePort();
  receivePort.listen(_handleResponsesFromIsolate);
  await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort);
}
```

The `receivePort.sendPort` argument will be passed to the callback (`_startRemoteIsolate`) as an argument when it’s called on the worker isolate. This is the first step in ensuring that the worker isolate has a way to send messages back to the main isolate.

### Step 2: Spawn a Worker Isolate

`Worker.spawn` 메서드에서는 워커 이솔레이트를 생성하고 메시지를 주고받을 수 있도록 코드를 그룹화합니다.

- `ReceivePort`를 생성합니다. 이를 통해 메인 이솔레이트는 새로 생성된 워커 이솔레이트로부터 메시지를 받을 수 있습니다.
- `ReceivePort`에 리스너를 추가하여 워커 이솔레이트가 다시 보낼 메시지를 처리합니다. 리스너에 전달된 콜백 `_handleResponsesFromIsolate`는 4단계에서 다룹니다.
- `Isolate.spawn`을 사용하여 워커 이솔레이트를 생성합니다. 이 메서드는 두 개의 인수를 필요로 합니다: 워커 이솔레이트에서 실행할 함수(3단계에서 다룸)와 `ReceivePort`의 `sendPort` 속성.

```dart
Future<void> spawn() async {
  final receivePort = ReceivePort();
  receivePort.listen(_handleResponsesFromIsolate);
  await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort);
}
```

`receivePort.sendPort` 인수는 워커 이솔레이트에서 호출될 때 콜백(`_startRemoteIsolate`)에 인수로 전달됩니다. 이것은 워커 이솔레이트가 메인 이솔레이트로 메시지를 보낼 수 있는 방법을 보장하는 첫 번째 단계입니다.
#### Step 3: Execute code on the worker isolate

In this step, you define the method `_startRemoteIsolate` that is sent to the worker isolate to be executed when it spawns. This method is like the “main” method for the worker isolate.

- First, create another new `ReceivePort`. This port receives future messages from the main isolate.
- Next, send that port’s `SendPort` back to the main isolate.
- Finally, add a listener to the new `ReceivePort`. This listener handles messages the main isolate sends to the worker isolate.

```dart
static void _startRemoteIsolate(SendPort port) {
  final receivePort = ReceivePort();
  port.send(receivePort.sendPort);

  receivePort.listen((dynamic message) async {
    if (message is String) {
      final transformed = jsonDecode(message);
      port.send(transformed);
    }
  });
}
```

The listener on the worker’s `ReceivePort` decodes the JSON passed from the main isolate, and then sends the decoded JSON back to the main isolate.

This listener is the entry point for messages sent from the main isolate to the worker isolate. **This is the only chance you have to tell the worker isolate what code to execute in the future.**

#### Step 3: 워커 이솔레이트에서 코드 실행

이 단계에서는 워커 이솔레이트가 생성될 때 실행될 메서드 `_startRemoteIsolate`를 정의합니다. 이 메서드는 워커 이솔레이트의 "main" 메서드와 같습니다.

- 또 다른 새로운 `ReceivePort`를 만듭니다. 이 포트는 메인 이솔레이트로부터 향후 메시지를 받습니다. 
- 그 포트의 `SendPort`를 메인 이솔레이트로 다시 보냅니다.
- 새로운 `ReceivePort`에 리스너를 추가합니다. 이 리스너는 메인 이솔레이트가 워커 이솔레이트로 보내는 메시지를 처리합니다.

```dart
static void _startRemoteIsolate(SendPort port) {
  final receivePort = ReceivePort();
  port.send(receivePort.sendPort);

  receivePort.listen((dynamic message) async {
    if (message is String) {
      final transformed = jsonDecode(message);
      port.send(transformed);
    }
  });
}
```

워커의 ReceivePort에 있는 리스너는 메인 이솔레이트로부터 전달된 JSON을 디코드한 다음, 디코드된 JSON을 메인 이솔레이트로 다시 보냅니다.

이 리스너는 메인 이솔레이트에서 워커 이솔레이트로 보낸 메시지의 진입점입니다. 이는 워커 이솔레이트에게 앞으로 어떤 코드를 실행할지 알려줄 수 있는 유일한 기회입니다.
#### Step 4: Handle messages on the main isolate

Finally, you need to tell the main isolate how to handle messages sent from the worker isolate back to the main isolate. To do so, you need to fill in the `_handleResponsesFromIsolate` method. Recall that this method is passed to the `receivePort.listen` method, as described in [step 2](https://dart.dev/language/isolates#step-2-spawn-a-worker-isolate):

```dart
Future<void> spawn() async {
  final receivePort = ReceivePort();
  receivePort.listen(_handleResponsesFromIsolate);
  await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort);
}
```

Also recall that you sent a `SendPort` back to the main isolate in [step 3](https://dart.dev/language/isolates#step-3-execute-code-on-the-worker-isolate). This method handles the receipt of that `SendPort`, as well as handling future messages (which will be decoded JSON).

- First, check if the message is a `SendPort`. If so, assign that port to the class's `_sendPort` property so it can be used to send messages later.
- Next, check if the message is of type `Map<String, dynamic>`, the expected type of decoded JSON. If so, handle that message with your application-specific logic. In this example, the message is printed.

```dart
void _handleResponsesFromIsolate(dynamic message) {
  if (message is SendPort) {
    _sendPort = message;
    _isolateReady.complete();
  } else if (message is Map<String, dynamic>) {
    print(message);
  }
}
```
#### Step 4: 메인 이솔레이트에서 메시지 처리

마지막으로, 메인 이솔레이트가 워커 이솔레이트로부터 메인 이솔레이트로 다시 보내진 메시지를 처리하는 방법을 알려야 합니다. 이를 위해 `_handleResponsesFromIsolate` 메서드를 작성해야 합니다. 이 메서드는 2단계에서 설명한 대로 `receivePort.listen` 메서드에 전달됩니다.

```dart
Future<void> spawn() async {
  final receivePort = ReceivePort();
  receivePort.listen(_handleResponsesFromIsolate);
  await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort);
}
Completer```

또한 3단계에서 Main isolate로 SendPort를 반환한 것을 기억하십시오. 이 메서드는 SendPort의 수신 처리와 미래의 메시지 처리 (이 메시지는 JSON으로 디코딩됩니다)를 담당합니다.

- 메시지가 SendPort인지 확인합니다. 그렇다면 이 포트를 클래스의 _sendPort 속성에 할당하여 나중에 메시지를 보낼 때 사용할 수 있도록 합니다. 
- 메시지가 Map<String, dynamic> 유형인지 확인합니다. 이 유형은 디코딩된 JSON의 예상 유형입니다. 그렇다면 이 메시지를 애플리케이션의 특정 논리에 따라 처리합니다. 이 예제에서는 메시지를 출력합니다.

```dart
void _handleResponsesFromIsolate(dynamic message) {
  if (message is SendPort) {
    _sendPort = message;
    _isolateReady.complete();
  } else if (message is Map<String, dynamic>) {
    print(message);
  }
}
```
#### Step 5: Add a completer to ensure your isolate is set-up

To complete the class, define a public method called `parseJson`, which is responsible for sending messages to the worker isolate. It also needs to ensure that messages can be sent before the isolate is fully set up. To handle this, use a [`Completer`](https://api.dart.dev/stable/dart-async/Completer-class.html).

- First, add a class-level property called a `Completer` and name it `_isolateReady`.
- Next, add a call to `complete()` on the completer in the `_handleResponsesFromIsolate` method (created in [step 4](https://dart.dev/language/isolates#step-4-handle-messages-on-the-main-isolate)) if the message is a `SendPort`.
- Finally, in the `parseJson` method, add `await _isolateReady.future` before adding `_sendPort.send`. This ensures that no message can be sent to the worker isolate until it is spawned _and_ has sent its `SendPort` back to the main isolate.

#### 5단계: Isolate가 설정되었는지 확인하기 위해 Completer 추가

클래스를 완성하기 위해, `parseJson`이라는 공개 메서드를 정의합니다. 이 메서드는 워커 isolate에 메시지를 보내는 책임을 지며, isolate가 완전히 설정되기 전에 메시지를 보낼 수 있도록 해야 합니다. 이를 처리하기 위해 Completer를 사용합니다.

- 먼저, 클래스 수준의 속성으로 Completer를 추가하고 이를 `_isolateReady`라고 이름 붙입니다.
- 다음으로, 메시지가 SendPort일 경우 `_handleResponsesFromIsolate` 메서드 (4단계에서 생성됨)에서 completer의 `complete()`를 호출합니다.
- 마지막으로, `parseJson` 메서드에서 `_sendPort.send`를 추가하기 전에 `await _isolateReady.future`를 추가합니다. 이렇게 하면, 워커 isolate가 생성되어 SendPort를 메인 isolate에 반환할 때까지 메시지를 보낼 수 없도록 보장합니다.

```dart
Future<void> parseJson(String message) async {
  await _isolateReady.future;
  _sendPort.send(message);
}
```
#### Complete example

```dart
import 'dart:async';
import 'dart:convert';
import 'dart:isolate';

void main() async {
  final worker = Worker();
  await worker.spawn();
  await worker.parseJson('{"key":"value"}');
}

class Worker {
  late SendPort _sendPort;
  final Completer<void> _isolateReady = Completer.sync();

  Future<void> spawn() async {
    final receivePort = ReceivePort();
    receivePort.listen(_handleResponsesFromIsolate);
    await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort);
  }

  void _handleResponsesFromIsolate(dynamic message) {
    if (message is SendPort) {
      _sendPort = message;
      _isolateReady.complete();
    } else if (message is Map<String, dynamic>) {
      print(message);
    }
  }

  static void _startRemoteIsolate(SendPort port) {
    final receivePort = ReceivePort();
    port.send(receivePort.sendPort);

    receivePort.listen((dynamic message) async {
      if (message is String) {
        final transformed = jsonDecode(message);
        port.send(transformed);
      }
    });
  }

  Future<void> parseJson(String message) async {
    await _isolateReady.future;
    _sendPort.send(message);
  }
}
```
### Robust ports example

The [previous example](https://dart.dev/language/isolates#basic-ports-example) explained the basic building blocks needed to set up a long-lived isolate with two-way communication. As mentioned, that example lacks some important features, such as error handling, the ability to close the ports when they’re no longer in use, and inconsistencies around message ordering in some situations.

This example expands on the information in the first example by creating a long-lived worker isolate that has these additional features and more, and follows better design patterns. Although this code has similarities to the first example, it is not an extension of that example.
### 견고한 포트 예제

이전 예제에서는 양방향 통신이 가능한 장기적인 isolate를 설정하는 데 필요한 기본 구성 요소를 설명했습니다. 앞서 언급한 바와 같이, 그 예제는 오류 처리, 포트가 더 이상 사용되지 않을 때 포트를 닫는 기능, 그리고 일부 상황에서 메시지 순서의 불일치와 같은 중요한 기능이 부족합니다.

이 예제는 첫 번째 예제의 정보를 확장하여 이러한 추가 기능과 더 많은 기능을 갖춘 장기적인 워커 isolate를 생성하고, 더 나은 디자인 패턴을 따릅니다. 이 코드가 첫 번째 예제와 유사한 점이 있지만, 첫 번째 예제의 확장이 아닙니다.

_Note_

This example assumes that you are already familiar with establishing communication between isolates with `Isolate.spawn` and ports, which was covered in the [previous example](https://dart.dev/language/isolates#basic-ports-example).

_정보_

이 예제는 `Isolate.spawn`과 포트를 사용하여 isolate 간의 통신을 설정하는 방법에 대해 이미 알고 있다고 가정합니다. 이 내용은 이전 예제에서 다루었습니다.

#### Step 1: Define the worker class

First, create a class for your background worker isolate. This class contains all the functionality you need to:

- Spawn an isolate.
- Send messages to that isolate.
- Have the isolate decode some JSON.
- Send the decoded JSON back to the main isolate.

The class exposes three public methods: one that creates the worker isolate, one that handles sending messages to that worker isolate, and one that can shut down the ports when they’re no longer in use.
#### 1단계: 워커 클래스 정의하기

먼저, 백그라운드 워커 isolate를 위한 클래스를 생성합니다. 이 클래스는 다음과 같은 모든 기능을 포함해야 합니다:

- isolate를 생성합니다.
- 해당 isolate로 메시지를 보냅니다.
- isolate가 JSON을 디코딩하도록 합니다.
- 디코딩된 JSON을 메인 isolate로 다시 보냅니다.

이 클래스는 세 가지 공개 메서드를 제공합니다: 하나는 워커 isolate를 생성하는 메서드, 하나는 그 워커 isolate에 메시지를 보내는 메서드, 그리고 하나는 더 이상 사용되지 않는 포트를 종료할 수 있는 메서드입니다.

```dart
class Worker {
  final SendPort _commands;
  final ReceivePort _responses;

  Future<Object?> parseJson(String message) async {
    // TODO: Ensure the port is still open.
    _commands.send(message);
  }

  static Future<Worker> spawn() async {
    // TODO: Add functionality to create a new Worker object with a
    //  connection to a spawned isolate.
    throw UnimplementedError();
  }

  Worker._(this._responses, this._commands) {
    // TODO: Initialize main isolate receive port listener.
  }

  void _handleResponsesFromIsolate(dynamic message) {
    // TODO: Handle messages sent back from the worker isolate.
  }

  static void _handleCommandsToIsolate(ReceivePort rp, SendPort sp) async {
    // TODO: Handle messages sent back from the worker isolate.
  }

  static void _startRemoteIsolate(SendPort sp) {
    // TODO: Initialize worker isolate's ports.
  }
}
```

_info_Note

In this example, `SendPort` and `ReceivePort` instances follow a best practice naming convention, in which they are named in relation to the main isolate. The messages sent through the `SendPort` from the main isolate to the worker isolate are called _commands_, and the messages sent back to the main isolate are called _responses_.

_정보_

이 예제에서는 `SendPort`와 `ReceivePort` 인스턴스가 모범 사례 명명 규칙을 따릅니다. 이 규칙에서는 포트의 이름을 메인 isolate와의 관계에 따라 명명합니다. 메인 isolate에서 워커 isolate로 `SendPort`를 통해 전송되는 메시지는 "명령(command)"이라고 불리며, 메인 isolate로 다시 전송되는 메시지는 "응답(response)"이라고 불립니다.

#### Step 2: Create a `RawReceivePort` in the `Worker.spawn` method

Before spawning an isolate, you need to create a [`RawReceivePort`](https://api.dart.dev/stable/dart-isolate/RawReceivePort-class.html), which is a lower-level `ReceivePort`. Using `RawReceivePort` is a preferred pattern because it allows you to separate your isolate startup logic from logic that handles message passing on the isolate.

In the `Worker.spawn` method:

- First, create the `RawReceivePort`. This `ReceivePort` is only responsible for receiving the initial message from the worker isolate, which will be a `SendPort`.
- Next, create a `Completer` that will indicate when the isolate is ready to receive messages. When this completes, it will return a record with a `ReceivePort` and a `SendPort`.
- Next, define the `RawReceivePort.handler` property. This property is a `Function?` that behaves like `ReceivePort.listener`. The function is called when a message is received by this port.
- Within the handler function, call `connection.complete()`. This method expects a [record](https://dart.dev/language/records) with a `ReceivePort` and a `SendPort` as an argument. The `SendPort` is the initial message sent from the worker isolate, which will be assigned in the next step to the class level `SendPort` named `_commands`.
- Then, create a new `ReceivePort` with the `ReceivePort.fromRawReceivePort` constructor, and pass in the `initPort`.

#### 2단계: Worker.spawn 메서드에서 RawReceivePort 생성하기

isolate를 생성하기 전에, RawReceivePort를 생성해야 합니다. RawReceivePort는 더 낮은 수준의 ReceivePort입니다. RawReceivePort를 사용하는 것이 선호되는 패턴인데, 이는 isolate 시작 논리를 메시지 전달 논리와 분리할 수 있기 때문입니다.

`Worker.spawn` 메서드에서:

1. **RawReceivePort를 생성합니다.** 이 ReceivePort는 워커 isolate로부터 초기 메시지인 SendPort만을 수신하는 역할을 합니다.
2. **Completer를 생성합니다.** 이 Completer는 isolate가 메시지를 받을 준비가 되었음을 나타냅니다. 이 Completer가 완료되면, ReceivePort와 SendPort를 포함하는 레코드를 반환합니다.
3. **RawReceivePort.handler 속성을 정의합니다.** 이 속성은 ReceivePort.listener처럼 동작하는 `Function?`입니다. 이 함수는 이 포트에서 메시지를 수신할 때 호출됩니다.
4. **핸들러 함수 내에서 `connection.complete()`을 호출합니다.** 이 메서드는 ReceivePort와 SendPort를 포함하는 레코드를 인수로 받습니다. SendPort는 워커 isolate에서 전송된 초기 메시지로, 다음 단계에서 클래스 수준의 SendPort인 `_commands`에 할당됩니다.
5. **`ReceivePort.fromRawReceivePort` 생성자를 사용하여 새로운 ReceivePort를 생성하고, initPort를 전달합니다.**

```dart
class Worker {
  final SendPort _commands;
  final ReceivePort _responses;

  static Future<Worker> spawn() async {
    // Create a receive port and add its initial message handler.
    final initPort = RawReceivePort();
    final connection = Completer<(ReceivePort, SendPort)>.sync();
    initPort.handler = (initialMessage) {
      final commandPort = initialMessage as SendPort;
      connection.complete((
        ReceivePort.fromRawReceivePort(initPort),
        commandPort,
      ));
    };
// ···
  }
```

By creating a `RawReceivePort` first, and then a `ReceivePort`, you’ll be able to add a new callback to `ReceivePort.listen` later on. Conversely, if you were to create a `ReceivePort` straight away, you’d only be able to add one `listener`, because `ReceivePort` implements [`Stream`](https://api.dart.dev/stable/dart-async/Stream-class.html), rather than [`BroadcastStream`](https://api.dart.dev/stable/dart-async/BroadcastStream-class.html).

Effectively, this allows you to separate your isolate start-up logic from the logic that handles receiving messages after setting up communication is complete. This benefit will become more obvious as the logic in the other methods grows.

먼저 RawReceivePort를 생성하고, 그 다음에 ReceivePort를 생성하면 나중에 ReceivePort.listen에 새로운 콜백을 추가할 수 있습니다. 반대로, ReceivePort를 바로 생성하면 단일 리스너만 추가할 수 있습니다. 이는 ReceivePort가 `Stream`을 구현하고 있기 때문이며, `BroadcastStream`이 아닙니다.

결국, 이는 isolate 시작 논리와 통신 설정이 완료된 후 메시지를 수신하는 논리를 분리할 수 있게 해줍니다. 이 이점은 다른 메서드의 논리가 확장됨에 따라 더 명확해질 것입니다.

#### Step 3: Spawn a worker isolate with `Isolate.spawn`

This step continues to fill in the `Worker.spawn` method. You’ll add the code needed to spawn an isolate, and return an instance of `Worker` from this class. In this example, the call to `Isolate.spawn` is wrapped in a [`try`/`catch` block](https://dart.dev/language/error-handling#catch), which ensures that, if the isolate fails to start up, the `initPort` will be closed, and the `Worker` object won’t be created.

- First, attempt to spawn a worker isolate in a `try`/`catch` block. If spawning a worker isolate fails, close the receive port that was created in the previous step. The method passed to `Isolate.spawn` will be covered in a later step.
- Next, await the `connection.future`, and destructure the send port and receive port from the record it returns.
- Finally, return an instance of `Worker` by calling its private constructor, and passing in the ports from that completer.
#### 3단계: Isolate.spawn으로 워커 isolate 생성하기

이 단계에서는 `Worker.spawn` 메서드를 계속 작성합니다. 이 메서드에는 isolate를 생성하고, 이 클래스에서 `Worker`의 인스턴스를 반환하는 데 필요한 코드가 포함됩니다. 이 예제에서는 `Isolate.spawn` 호출이 `try/catch` 블록으로 감싸져 있습니다. 이로 인해 isolate 시작에 실패할 경우 `initPort`가 닫히고 `Worker` 객체가 생성되지 않도록 보장합니다.

1. **`try/catch` 블록 안에서 워커 isolate를 생성하려고 시도합니다.** 워커 isolate 생성이 실패하면, 이전 단계에서 생성한 수신 포트를 닫습니다. `Isolate.spawn`에 전달되는 메서드는 후속 단계에서 다루어질 것입니다.
2. **`connection.future`를 대기하고, 반환된 레코드에서 전송 포트와 수신 포트를 구조 분해하여 추출합니다.**
3. **그런 다음, `Worker`의 비공식 생성자를 호출하여 인스턴스를 반환합니다.** 이 생성자에는 Completer에서 얻은 포트들을 전달합니다.

```dart
class Worker {
  final SendPort _commands;
  final ReceivePort _responses;

  static Future<Worker> spawn() async {
    // Create a receive port and add its initial message handler
    final initPort = RawReceivePort();
    final connection = Completer<(ReceivePort, SendPort)>.sync();
    initPort.handler = (initialMessage) {
      final commandPort = initialMessage as SendPort;
      connection.complete((
        ReceivePort.fromRawReceivePort(initPort),
        commandPort,
      ));
    };
    // Spawn the isolate.
    try {
      await Isolate.spawn(_startRemoteIsolate, (initPort.sendPort));
    } on Object {
      initPort.close();
      rethrow;
    }

    final (ReceivePort receivePort, SendPort sendPort) =
        await connection.future;

    return Worker._(receivePort, sendPort);
  }
```

Note that in this example (compared to the [previous example](https://dart.dev/language/isolates#basic-ports-example)), `Worker.spawn` acts as an asynchronous static constructor for this class and is the only way to create an instance of `Worker`. This simplifies the API, making the code that creates an instance of `Worker` cleaner.

이 예제에서는 (이전 예제와 비교할 때) `Worker.spawn`이 이 클래스의 비동기 정적 생성자로 작동하며, `Worker`의 인스턴스를 생성하는 유일한 방법입니다. 이는 API를 단순화시켜, `Worker`의 인스턴스를 생성하는 코드가 더 깔끔해집니다.

#### Step 4: Complete the isolate setup process

In this step, you will complete the basic isolate setup process. This correlates almost entirely to the [previous example](https://dart.dev/language/isolates#basic-ports-example), and there are no new concepts. There is a slight change in that the code is broken into more methods, which is a design practice that sets you up for adding more functionality through the remainder of this example. For an in-depth walkthrough of the basic process of setting up an isolate, see the [basic ports example](https://dart.dev/language/isolates#basic-ports-example).

First, create the private constructor that is returned from the `Worker.spawn` method. In the constructor body, add a listener to the receive port used by the main isolate, and pass an as-yet undefined method to that listener called `_handleResponsesFromIsolate`.

#### 4단계: Isolate 설정 프로세스 완료하기

이 단계에서는 기본 isolate 설정 프로세스를 완료합니다. 이 과정은 거의 완전히 이전 예제와 일치하며, 새로운 개념은 없습니다. 다만, 코드를 더 많은 메서드로 나누어 디자인을 개선하고, 이 예제의 나머지 부분에서 추가 기능을 쉽게 추가할 수 있도록 준비합니다. 기본적인 isolate 설정 과정에 대한 자세한 설명은 기본 포트 예제를 참조하십시오.

1. **`Worker.spawn` 메서드에서 반환된 비공식 생성자를 생성합니다.** 생성자 본문에서 메인 isolate가 사용하는 수신 포트에 리스너를 추가하고, 이 리스너에 아직 정의되지 않은 `_handleResponsesFromIsolate`라는 메서드를 전달합니다.

```dart
class Worker {
  final SendPort _commands;
  final ReceivePort _responses;
// ···
  Worker._(this._responses, this._commands) {
    _responses.listen(_handleResponsesFromIsolate);
  }
```

Next, add the code to `_startRemoteIsolate` that is responsible for initializing the ports on the worker isolate. [Recall](https://dart.dev/language/isolates#step-3-spawn-a-worker-isolate-with-isolate-spawn) that this method was passed to `Isolate.spawn` in the `Worker.spawn` method, and it will be passed the main isolate’s `SendPort` as an argument.

- Create a new `ReceivePort`.
- Send that port’s `SendPort` back to the main isolate.
- Call a new method called `_handleCommandsToIsolate`, and pass both the new `ReceivePort` and `SendPort` from the main isolate as arguments.

다음으로, `Worker.spawn` 메서드에서 `Isolate.spawn`에 전달된 `Worker` 클래스의 `_startRemoteIsolate` 메서드에 대한 코드를 추가합니다. 이 메서드는 워커 isolate에서 포트를 초기화하는 책임을 집니다. 이 메서드는 메인 isolate의 `SendPort`를 인수로 받게 됩니다.

-  새로운 ReceivePort를 생성합니다.
- 그 포트의 SendPort를 메인 isolate로 다시 보냅니다.
- `_handleCommandsToIsolate`라는 새 메서드를 호출하고, 새로 생성한 ReceivePort와 메인 isolate의 SendPort를 인수로 전달합니다.

```dart
static void _startRemoteIsolate(SendPort sendPort) {
  final receivePort = ReceivePort();
  sendPort.send(receivePort.sendPort);
  _handleCommandsToIsolate(receivePort, sendPort);
}
```

Next, add the `_handleCommandsToIsolate` method, which is responsible for receiving messages from the main isolate, decoding json on the worker isolate, and sending the decoded json back as a response.

- First, declare a listener on the worker isolate’s `ReceivePort`.
- Within the callback added to the listener, attempt to decode the JSON passed from the main isolate within a [`try`/`catch` block](https://dart.dev/language/error-handling#catch). If decoding is successful, send the decoded JSON back to the main isolate.
- If there is an error, send back a [`RemoteError`](https://api.dart.dev/stable/dart-isolate/RemoteError-class.html).

다음으로, `_handleCommandsToIsolate` 메서드를 추가합니다. 이 메서드는 메인 isolate로부터 메시지를 수신하고, 워커 isolate에서 JSON을 디코딩한 다음, 디코딩된 JSON을 응답으로 다시 보내는 책임을 집니다.

- 워커 isolate의 ReceivePort에 리스너를 선언합니다.
- 리스너에 추가된 콜백 내에서, 메인 isolate로부터 전달된 JSON을 `try/catch` 블록 안에서 디코딩하려고 시도합니다. 디코딩이 성공하면, 디코딩된 JSON을 메인 isolate로 다시 보냅니다.
- 오류가 발생하면, `RemoteError`를 반환합니다.

```dart
static void _handleCommandsToIsolate(
    ReceivePort receivePort, SendPort sendPort) {
  receivePort.listen((message) {
    try {
      final jsonData = jsonDecode(message as String);
      sendPort.send(jsonData);
    } catch (e) {
      sendPort.send(RemoteError(e.toString(), ''));
    }
  });
}
```

Next, add the code for the `_handleResponsesFromIsolate` method.

- First, check if the message is a `RemoteError`, in which case you should `throw` that error.
- Otherwise, print the message. In future steps, you will update this code to return messages rather than print them.

다음으로, `_handleResponsesFromIsolate` 메서드에 대한 코드를 추가합니다.

- 먼저, 메시지가 `RemoteError`인지 확인합니다. 만약 그렇다면, 해당 오류를 발생시킵니다.
-  그렇지 않다면, 메시지를 출력합니다. 이후 단계에서는 이 코드를 수정하여 메시지를 출력하는 대신 반환하도록 할 예정입니다.

```dart
void _handleResponsesFromIsolate(dynamic message) {
  if (message is RemoteError) {
    throw message;
  } else {
    print(message);
  }
}
```

Finally, add the `parseJson` method, which is a public method that allows outside code to send JSON to the worker isolate to be decoded.

마지막으로, 외부 코드가 JSON을 워커 isolate로 보내어 디코딩할 수 있도록 하는 공개 메서드인 `parseJson` 메서드를 추가합니다.

```dart
Future<Object?> parseJson(String message) async {
  _commands.send(message);
}
```

You will update this method in the next step.

다음 단계에서 이 메서드를 업데이트할 것입니다.
#### Step 5: Handle multiple messages at the same time

Currently, if you rapidly send messages to the worker isolate, the isolate will send the decoded json response in _the order that they complete_, rather than the order that they’re sent. You have no way to determine which response corresponds to which message.

In this step, you’ll fix this problem by giving each message an id, and using `Completer` objects to ensure that when outside code calls `parseJson` the response that is returned to that caller is the correct response.

First, add two class-level properties to `Worker`:

- `Map<int, Completer<Object?>> _activeRequests`
- `int _idCounter`

#### 5단계: 동시에 여러 메시지 처리하기

현재, 메시지를 워커 isolate로 빠르게 보내면, isolate는 메시지가 전송된 순서가 아니라 완료된 순서에 따라 디코딩된 JSON 응답을 보냅니다. 따라서 어떤 응답이 어떤 메시지에 해당하는지 확인할 방법이 없습니다.

이 단계에서는 각 메시지에 ID를 부여하고, Completer 객체를 사용하여 외부 코드가 `parseJson`을 호출할 때 해당 호출자에게 반환되는 응답이 올바른 응답이 되도록 하여 이 문제를 해결합니다.

 **`Worker`에 두 개의 클래스 수준 속성을 추가합니다:**
- `Map<int, Completer<Object?>> _activeRequests`
- `int _idCounter`

```dart
class Worker {
  final SendPort _commands;
  final ReceivePort _responses;
  final Map<int, Completer<Object?>> _activeRequests = {};
  int _idCounter = 0;
```

The `_activeRequests` map associates a message sent to the worker isolate with a `Completer`. The keys used in `_activeRequests` are taken from `_idCounter`, which will be increased as more messages are sent.

Next, update the `parseJson` method to create completers before it sends messages to the worker isolate.

- First create a `Completer`.
- Next, increment `_idCounter`, so that each `Completer` is associated with a unique number.
- Add an entry to the `_activeRequests` map in which the key is the current number of `_idCounter`, and the completer is the value.
- Send the message to the worker isolate, along with the id. Because you can only send one value through the `SendPort`, wrap the id and message in a [record](https://dart.dev/language/records).
- Finally, return the completer’s future, which will eventually contain the response from the worker isolate.

`_activeRequests` 맵은 워커 isolate에 전송된 메시지와 `Completer`를 연결합니다. `_activeRequests`에서 사용되는 키는 `_idCounter`에서 가져오며, 이는 더 많은 메시지가 전송됨에 따라 증가합니다.

다음으로, `parseJson` 메서드를 업데이트하여 메시지를 워커 isolate로 전송하기 전에 `Completer`를 생성하도록 합니다.

-  **먼저, `Completer`를 생성합니다.**
- **다음으로, `_idCounter`를 증가시킵니다.** 이렇게 하면 각 `Completer`가 고유한 숫자와 연결됩니다.
- **현재 `_idCounter` 숫자를 키로, `Completer`를 값으로 하는 `_activeRequests` 맵에 항목을 추가합니다.**
- **ID와 메시지를 레코드로 묶어 워커 isolate로 메시지를 전송합니다.** `SendPort`를 통해 하나의 값만 보낼 수 있기 때문에, ID와 메시지를 레코드로 감싸서 전송합니다.
- **마지막으로, `Completer`의 `future`를 반환합니다.** 이 `future`는 결국 워커 isolate로부터의 응답을 포함하게 됩니다.

```dart
Future<Object?> parseJson(String message) async {
  final completer = Completer<Object?>.sync();
  final id = _idCounter++;
  _activeRequests[id] = completer;
  _commands.send((id, message));
  return await completer.future;
}
```

You also need to update `_handleResponsesFromIsolate` and `_handleCommandsToIsolate` to handle this system.

In `_handleCommandsToIsolate`, you need to account for the `message` being a record with two values, rather than just the json text. Do so by destructuring the values from `message`.

Then, after decoding the json, update the call to `sendPort.send` to pass both the id and the decoded json back to the main isolate, again using a record.

이 시스템을 처리하기 위해 `_handleResponsesFromIsolate`와 `_handleCommandsToIsolate`를 업데이트해야 합니다.

1. **`_handleCommandsToIsolate`에서** 메시지가 JSON 텍스트만이 아니라 두 개의 값을 가진 레코드임을 고려해야 합니다. 따라서 메시지에서 값을 구조 분해합니다.
    
    - JSON을 디코딩한 후, `sendPort.send` 호출을 업데이트하여 ID와 디코딩된 JSON을 모두 메인 isolate로 다시 전송합니다. 이 역시 레코드를 사용하여 전송합니다.
2. **`_handleResponsesFromIsolate`에서** 응답 메시지를 처리하는 로직을 업데이트해야 합니다. 여기서도 레코드를 구조 분해하여 응답의 ID와 JSON을 추출합니다.
    
    - 메시지가 `RemoteError`인지 확인한 후, 응답을 출력하거나 적절한 방식으로 처리합니다.

이러한 업데이트를 통해, 각 메시지와 응답을 올바르게 매칭하고, 여러 메시지를 동시에 처리할 수 있습니다.

```dart
static void _handleCommandsToIsolate(
    ReceivePort receivePort, SendPort sendPort) {
  receivePort.listen((message) {
    final (int id, String jsonText) = message as (int, String); // New
    try {
      final jsonData = jsonDecode(jsonText);
      sendPort.send((id, jsonData)); // Updated
    } catch (e) {
      sendPort.send((id, RemoteError(e.toString(), '')));
    }
  });
}
```

Finally, update the `_handleResponsesFromIsolate`.

- First, destructure the id and the response from the message argument again.
- Then, remove the completer that corresponds to this request from the `_activeRequests` map.
- Lastly, rather than throwing an error or printing the decoded json, complete the completer, passing in the response. When this completes, the response will be returned to the code that called `parseJson` on the main isolate.
- 
마지막으로, `_handleResponsesFromIsolate`를 업데이트합니다.

1. **다시 메시지 인수에서 ID와 응답을 구조 분해합니다.**
2. **이 요청에 해당하는 `Completer`를 `_activeRequests` 맵에서 제거합니다.**
3. **오류를 발생시키거나 디코딩된 JSON을 출력하는 대신, `Completer`를 완료하고 응답을 전달합니다.** 이 `Completer`가 완료되면, 응답은 메인 isolate에서 `parseJson`을 호출한 코드로 반환됩니다.

```dart
void _handleResponsesFromIsolate(dynamic message) {
  final (int id, Object? response) = message as (int, Object?); // New
  final completer = _activeRequests.remove(id)!; // New

  if (response is RemoteError) {
    completer.completeError(response); // Updated
  } else {
    completer.complete(response); // Updated
  }
}
```
#### Step 6: Add functionality to close the ports

When the isolate is no longer being used by your code, you should close the ports on the main isolate and the worker isolate.

- First, add a class-level boolean that tracks if the ports are closed.
- Then, add the `Worker.close` method. Within this method:
    - Update `_closed` to be true.
    - Send a final message to the worker isolate. This message is a `String` that reads “shutdown”, but it could be any object you’d like. You will use it in the next code snippet.
- Finally, check if `_activeRequests` is empty. If it is, close down the main isolate’s `ReceivePort` named `_responses`.

#### 6단계: 포트를 닫는 기능 추가하기

이제 코드에서 isolate를 더 이상 사용하지 않을 때, 메인 isolate와 워커 isolate의 포트를 닫아야 합니다.

- **먼저, 포트가 닫혔는지를 추적하는 클래스 수준의 불리언을 추가합니다.** 이 변수는 포트가 이미 닫혔는지를 확인하는 데 사용됩니다.
- **그 다음, `Worker.close` 메서드를 추가합니다.** 이 메서드 내에서:
    - `_closed`를 `true`로 업데이트합니다.
    - 워커 isolate에 최종 메시지를 전송합니다. 이 메시지는 “shutdown”이라는 문자열이지만, 원하는 다른 객체를 사용할 수도 있습니다. 이 메시지는 다음 코드 스니펫에서 사용됩니다.
- 마지막으로, `_activeRequests`가 비어 있는지 확인합니다. 만약 비어 있다면, 메인 isolate의 `ReceivePort`인 `_responses`를 닫습니다.

```dart
class Worker {
  bool _closed = false;
// ···
  void close() {
    if (!_closed) {
      _closed = true;
      _commands.send('shutdown');
      if (_activeRequests.isEmpty) _responses.close();
      print('--- port closed --- ');
    }
  }
```

- Next, you need to handle the “shutdown” message in the worker isolate. Add the following code to the `_handleCommandsToIsolate` method. This code will check if the message is a `String` that reads “shutdown”. If it is, it will close the worker isolate’s `ReceivePort`, and return.

- 다음으로, 워커 isolate에서 “shutdown” 메시지를 처리해야 합니다. `_handleCommandsToIsolate` 메서드에 다음 코드를 추가합니다. 이 코드는 메시지가 “shutdown”이라는 문자열인지 확인하고, 만약 그렇다면 워커 isolate의 `ReceivePort`를 닫고 메서드를 종료합니다.

```dart
static void _handleCommandsToIsolate(
  ReceivePort receivePort,
  SendPort sendPort,
) {
  receivePort.listen((message) {
    // New if-block.
    if (message == 'shutdown') {
      receivePort.close();
      return;
    }
    final (int id, String jsonText) = message as (int, String);
    try {
      final jsonData = jsonDecode(jsonText);
      sendPort.send((id, jsonData));
    } catch (e) {
      sendPort.send((id, RemoteError(e.toString(), '')));
    }
  });
}
```

- Finally, you should add code to check if the ports are closed before trying to send messages. Add one line in the `Worker.parseJson` method.

- 마지막으로, 메시지를 보내기 전에 포트가 닫혔는지 확인하는 코드를 추가해야 합니다. `Worker.parseJson` 메서드에 다음 줄을 추가합니다:

```dart
Future<Object?> parseJson(String message) async {
  if (_closed) throw StateError('Closed'); // New
  final completer = Completer<Object?>.sync();
  final id = _idCounter++;
  _activeRequests[id] = completer;
  _commands.send((id, message));
  return await completer.future;
}
```
#### Complete example

```dart
import 'dart:async';
import 'dart:convert';
import 'dart:isolate';

void main() async {
  final worker = await Worker.spawn();
  print(await worker.parseJson('{"key":"value"}'));
  print(await worker.parseJson('"banana"'));
  print(await worker.parseJson('[true, false, null, 1, "string"]'));
  print(
      await Future.wait([worker.parseJson('"yes"'), worker.parseJson('"no"')]));
  worker.close();
}

class Worker {
  final SendPort _commands;
  final ReceivePort _responses;
  final Map<int, Completer<Object?>> _activeRequests = {};
  int _idCounter = 0;
  bool _closed = false;

  Future<Object?> parseJson(String message) async {
    if (_closed) throw StateError('Closed');
    final completer = Completer<Object?>.sync();
    final id = _idCounter++;
    _activeRequests[id] = completer;
    _commands.send((id, message));
    return await completer.future;
  }

  static Future<Worker> spawn() async {
    // Create a receive port and add its initial message handler
    final initPort = RawReceivePort();
    final connection = Completer<(ReceivePort, SendPort)>.sync();
    initPort.handler = (initialMessage) {
      final commandPort = initialMessage as SendPort;
      connection.complete((
        ReceivePort.fromRawReceivePort(initPort),
        commandPort,
      ));
    };

    // Spawn the isolate.
    try {
      await Isolate.spawn(_startRemoteIsolate, (initPort.sendPort));
    } on Object {
      initPort.close();
      rethrow;
    }

    final (ReceivePort receivePort, SendPort sendPort) =
        await connection.future;

    return Worker._(receivePort, sendPort);
  }

  Worker._(this._responses, this._commands) {
    _responses.listen(_handleResponsesFromIsolate);
  }

  void _handleResponsesFromIsolate(dynamic message) {
    final (int id, Object? response) = message as (int, Object?);
    final completer = _activeRequests.remove(id)!;

    if (response is RemoteError) {
      completer.completeError(response);
    } else {
      completer.complete(response);
    }

    if (_closed && _activeRequests.isEmpty) _responses.close();
  }

  static void _handleCommandsToIsolate(
    ReceivePort receivePort,
    SendPort sendPort,
  ) {
    receivePort.listen((message) {
      if (message == 'shutdown') {
        receivePort.close();
        return;
      }
      final (int id, String jsonText) = message as (int, String);
      try {
        final jsonData = jsonDecode(jsonText);
        sendPort.send((id, jsonData));
      } catch (e) {
        sendPort.send((id, RemoteError(e.toString(), '')));
      }
    });
  }

  static void _startRemoteIsolate(SendPort sendPort) {
    final receivePort = ReceivePort();
    sendPort.send(receivePort.sendPort);
    _handleCommandsToIsolate(receivePort, sendPort);
  }

  void close() {
    if (!_closed) {
      _closed = true;
      _commands.send('shutdown');
      if (_activeRequests.isEmpty) _responses.close();
      print('--- port closed --- ');
    }
  }
}
```

# Concurrency and isolates

All Dart code runs in [isolates](https://dart.dev/language/concurrency), which are similar to threads, but differ in that isolates have their own isolated memory. They do not share state in any way, and can only communicate by messaging. By default, Flutter apps do all of their work on a single isolate – the main isolate. In most cases, this model allows for simpler programming and is fast enough that the application's UI doesn't become unresponsive.

Sometimes though, applications need to perform exceptionally large computations that can cause "UI jank" (jerky motion). If your app is experiencing jank for this reason, you can move these computations to a helper isolate. This allows the underlying runtime environment to run the computation concurrently with the main UI isolate's work and takes advantage of multi-core devices.

Each isolate has its own memory and its own event loop. The event loop processes events in the order that they're added to an event queue. On the main isolate, these events can be anything from handling a user tapping in the UI, to executing a function, to painting a frame on the screen. The following figure shows an example event queue with 3 events waiting to be processed.

모든 Dart 코드는 isolate에서 실행됩니다. 이는 스레드와 유사하지만, isolate는 독립적인 메모리를 가지고 있다는 점에서 다릅니다. 상태를 공유하지 않으며, 오직 메시지를 통해서만 통신할 수 있습니다. 기본적으로 Flutter 앱은 모든 작업을 단일 isolate인 메인 isolate에서 수행합니다. 대부분의 경우, 이 모델은 프로그래밍을 더 간단하게 만들며, 애플리케이션의 UI가 응답하지 않는 문제를 일으키지 않을 만큼 충분히 빠릅니다.

하지만 때때로, 애플리케이션이 매우 큰 계산 작업을 수행해야 할 경우, "UI 지연" (끊기는 동작)을 초래할 수 있습니다. 애플리케이션이 이러한 이유로 지연이 발생하는 경우, 이러한 계산 작업을 보조 isolate로 이동시킬 수 있습니다. 이렇게 하면 기본 런타임 환경이 메인 UI isolate의 작업과 동시에 계산을 수행할 수 있으며, 멀티코어 장치를 활용할 수 있습니다.

각 isolate는 자체 메모리와 자체 이벤트 루프를 가지고 있습니다. 이벤트 루프는 이벤트 큐에 추가된 순서대로 이벤트를 처리합니다. 메인 isolate에서는 이러한 이벤트가 사용자 UI에서의 탭 처리, 함수 실행, 화면에 프레임 그리기 등일 수 있습니다. 다음 그림은 처리 대기 중인 3개의 이벤트가 있는 이벤트 큐의 예를 보여줍니다.

![The main isolate diagram](https://docs.flutter.dev/assets/images/docs/development/concurrency/basics-main-isolate.png)

For smooth rendering, Flutter adds a "paint frame" event to the event queue 60 times per second(for a 60Hz device). If these events aren't processed on time, the application experiences UI jank, or worse, become unresponsive altogether.

부드러운 렌더링을 위해 Flutter는 60Hz 장치에서는 초당 60번 "프레임 그리기" 이벤트를 이벤트 큐에 추가합니다. 이러한 이벤트가 제때 처리되지 않으면, 애플리케이션이 UI 지연을 경험하거나 심지어 완전히 응답하지 않을 수도 있습니다.

![Event jank diagram](https://docs.flutter.dev/assets/images/docs/development/concurrency/event-jank.png)

Whenever a process can't be completed in a frame gap, the time between two frames, it's a good idea to offload the work to another isolate to ensure that the main isolate can produce 60 frames per second. When you spawn an isolate in Dart, it can process the work concurrently with the main isolate, without blocking it.

You can read more about how isolates and the event loop work in Dart on the [concurrency page](https://dart.dev/language/concurrency) of the Dart documentation.

프레임 간격, 즉 두 프레임 사이의 시간 내에 작업을 완료할 수 없을 때는, 메인 isolate가 초당 60프레임을 생산할 수 있도록 작업을 다른 isolate로 오프로드하는 것이 좋습니다. Dart에서 isolate를 생성하면, 해당 isolate는 메인 isolate와 동시에 작업을 처리할 수 있으며, 메인 isolate를 차단하지 않습니다.

Dart에서 isolate와 이벤트 루프가 어떻게 작동하는지에 대한 자세한 내용은 Dart 문서의 동시성 페이지에서 읽을 수 있습니다.
## Common use cases for isolates

There is only one hard rule for when you should use isolates, and that's when large computations are causing your Flutter application to experience UI jank. This jank happens when there is any computation that takes longer than Flutter's frame gap.

## isolate의 일반적인 사용 사례

isolate를 사용해야 하는 경우는 오직 하나의 확실한 규칙이 있습니다. 그것은 대규모 계산 작업이 Flutter 애플리케이션에서 UI 지연을 초래할 때입니다. 이 지연은 Flutter의 프레임 간격보다 더 오래 걸리는 계산이 있을 때 발생합니다.

![Event jank diagram](https://docs.flutter.dev/assets/images/docs/development/concurrency/event-jank.png)

Any process _could_ take longer to complete, depending on the implementation and the input data, making it impossible to create an exhaustive list of when you need to consider using isolates.

That said, isolates are commonly used for the following:

- Reading data from a local database
- Sending push notifications
- Parsing and decoding large data files
- Processing or compressing photos, audio files, and video files
- Converting audio and video files
- When you need asynchronous support while using FFI
- Applying filtering to complex lists or filesystems

어떤 프로세스는 구현 방식과 입력 데이터에 따라 완료되는 데 시간이 더 걸릴 수 있으며, 이로 인해 언제 isolate를 사용하는 것이 필요한지에 대한 포괄적인 목록을 만드는 것은 불가능합니다.

그럼에도 불구하고, isolate는 일반적으로 다음과 같은 용도로 사용됩니다:

- 로컬 데이터베이스에서 데이터 읽기
- 푸시 알림 전송
- 대용량 데이터 파일 파싱 및 디코딩
- 사진, 오디오 파일, 비디오 파일 처리 또는 압축
- 오디오 및 비디오 파일 변환
- FFI를 사용할 때 비동기 지원 필요
- 복잡한 목록 또는 파일 시스템에 필터링 적용

## Message passing between isolates

Dart's isolates are an implementation of the [Actor model](https://en.wikipedia.org/wiki/Actor_model). They can only communicate with each other by message passing, which is done with [`Port` objects](https://api.dart.dev/stable/dart-isolate/ReceivePort-class.html). When messages are "passed" between each other, they are generally copied from the sending isolate to the receiving isolate. This means that any value passed to an isolate, even if mutated on that isolate, doesn't change the value on the original isolate.

The only [objects that aren't copied when passed](https://api.dart.dev/stable/dart-isolate/SendPort/send.html) to an isolate are immutable objects that can't be changed anyway, such a String or an unmodifiable byte. When you pass an immutable object between isolates, a reference to that object is sent across the port, rather than the object being copied, for better performance. Because immutable objects can't be updated, this effectively retains the actor model behavior.

An exception to this rule is when an isolate exits when it sends a message using the `Isolate.exit` method. Because the sending isolate won't exist after sending the message, it can pass ownership of the message from one isolate to the other, ensuring that only one isolate can access the message.

The two lowest-level primitives that send messages are `SendPort.send`, which makes a copy of a mutable message as it sends, and `Isolate.exit`, which sends the reference to the message. Both `Isolate.run` and `compute` use `Isolate.exit` under the hood.
## **isolate 간 메시지 전달**

Dart의 isolate는 액터 모델(Actor model)의 구현체입니다. 서로 메시지를 통해서만 통신할 수 있으며, 이는 `Port` 객체를 사용하여 이루어집니다. 메시지가 서로 "전달"될 때, 일반적으로 메시지는 보내는 isolate에서 받는 isolate로 복사됩니다. 이는 isolate에 전달된 값이, 그 isolate에서 수정되더라도 원래 isolate의 값은 변경되지 않는다는 의미입니다.

전달될 때 복사되지 않는 유일한 객체는 변경할 수 없는 불변 객체(immutable objects)입니다. 예를 들어, `String`이나 수정할 수 없는 바이트(unmodifiable byte)와 같은 객체입니다. 불변 객체를 isolate 간에 전달할 때, 객체가 복사되는 대신 객체에 대한 참조가 포트를 통해 전달됩니다. 이렇게 하면 성능이 향상됩니다. 불변 객체는 업데이트할 수 없으므로, 이는 효과적으로 액터 모델의 동작을 유지합니다.

이 규칙의 예외는 `Isolate.exit` 메서드를 사용하여 메시지를 보낼 때 발생합니다. 메시지를 보낸 후, 보낸 isolate는 존재하지 않으므로 메시지의 소유권을 다른 isolate로 넘길 수 있습니다. 이를 통해 오직 하나의 isolate만 메시지에 접근할 수 있도록 보장합니다.

메시지를 보내는 두 가지 가장 낮은 수준의 원시 방법은 `SendPort.send`로, 이는 메시지를 보내면서 가변 메시지의 복사본을 만듭니다. 그리고 `Isolate.exit`는 메시지의 참조를 보냅니다. `Isolate.run`과 `compute`는 내부적으로 `Isolate.exit`를 사용합니다.

## Short-lived isolates

The easiest way to move a process to an isolate in Flutter is with the `Isolate.run` method. This method spawns an isolate, passes a callback to the spawned isolate to start some computation, returns a value from the computation, and then shuts the isolate down when the computation is complete. This all happens concurrently with the main isolate, and doesn't block it.

## 단기 생애의 isolate

Flutter에서 프로세스를 isolate로 이동시키는 가장 쉬운 방법은 `Isolate.run` 메서드를 사용하는 것입니다. 이 메서드는 isolate를 생성하고, 생성된 isolate에 콜백을 전달하여 일부 계산을 시작합니다. 계산이 완료되면 결과 값을 반환하고, isolate를 종료합니다. 이 모든 과정은 메인 isolate와 동시에 진행되며, 메인 isolate를 차단하지 않습니다.

![Isolate diagram](https://docs.flutter.dev/assets/images/docs/development/concurrency/isolate-bg-worker.png)

The `Isolate.run` method requires a single argument, a callback function, that is run on the new isolate. This callback's function signature must have exactly one required, unnamed argument. When the computation completes, it returns the callback's value back to the main isolate, and exits the spawned isolate.

For example, consider this code that loads a large JSON blob from a file, and converts that JSON into custom Dart objects. If the json decoding process wasn't off loaded to a new isolate, this method would cause the UI to become unresponsive for several seconds.

`Isolate.run` 메서드는 새로운 isolate에서 실행될 콜백 함수 하나만을 인수로 요구합니다. 이 콜백 함수의 함수 시그니처는 정확히 하나의 필수 인자(이름이 없는)만을 가져야 합니다. 계산이 완료되면 콜백의 값을 메인 isolate로 반환하고, 생성된 isolate를 종료합니다.

예를 들어, 다음 코드는 큰 JSON 블롭을 파일에서 로드하고, 그 JSON을 사용자 정의 Dart 객체로 변환하는 과정입니다. 만약 JSON 디코딩 과정이 새로운 isolate로 오프로드되지 않았다면, 이 메서드는 UI가 몇 초 동안 응답하지 않게 만들 수 있습니다.

```dart
// Produces a list of 211,640 photo objects.
// (The JSON file is ~20MB.)
Future<List<Photo>> getPhotos() async {
  final String jsonString = await rootBundle.loadString('assets/photos.json');
  final List<Photo> photos = await Isolate.run<List<Photo>>(() {
    final List<Object?> photoData = jsonDecode(jsonString) as List<Object?>;
    return photoData.cast<Map<String, Object?>>().map(Photo.fromJson).toList();
  });
  return photos;
}
```

For a complete walkthrough of using Isolates to parse JSON in the background, see [this cookbook recipe](https://docs.flutter.dev/cookbook/networking/background-parsing).

백그라운드에서 JSON을 파싱하기 위해 Isolate를 사용하는 전체 절차에 대한 자세한 설명은 이 요리책 레시피를 참조하세요.
## Stateful, longer-lived isolates

Short-live isolates are convenient to use, but there is performance overhead required to spawn new isolates, and to copy objects from one isolate to another. If you're doing the same computation using `Isolate.run` repeatedly, you might have better performance by creating isolates that don't exit immediately.

To do this, you can use a handful of lower-level isolate-related APIs that `Isolate.run` abstracts:

- [`Isolate.spawn()`](https://api.dart.dev/stable/dart-isolate/Isolate/spawn.html) and [`Isolate.exit()`](https://api.dart.dev/stable/dart-isolate/Isolate/exit.html)
- [`ReceivePort`](https://api.dart.dev/stable/dart-isolate/ReceivePort-class.html) and [`SendPort`](https://api.dart.dev/stable/dart-isolate/SendPort-class.html)
- [`send()`](https://api.dart.dev/stable/dart-isolate/SendPort/send.html) method

When you use the `Isolate.run` method, the new isolate immediately shuts down after it returns a single message to the main isolate. Sometimes, you'll need isolates that are long lived, and can pass multiple messages to each other over time. In Dart, you can accomplish this with the Isolate API and Ports. These long-lived isolates are colloquially known as _background workers_.

Long-lived isolates are useful when you have a specific process that either needs to be run repeatedly throughout the lifetime of your application, or if you have a process that runs over a period of time and needs to yield multiple return values to the main isolate.

Or, you might use [worker_manager](https://pub.dev/packages/worker_manager) to manage long-lived isolates.

## 상태를 가지며 긴 생애를 가진 isolate

짧은 생애의 isolate는 사용하기 편리하지만, 새로운 isolate를 생성하고 객체를 한 isolate에서 다른 isolate로 복사하는 데에는 성능 오버헤드가 발생합니다. 만약 `Isolate.run`을 반복적으로 사용하여 동일한 계산을 수행하고 있다면, 즉시 종료되지 않는 isolate를 생성하는 것이 성능 면에서 더 나을 수 있습니다.

이를 위해 `Isolate.run`이 추상화한 낮은 수준의 isolate 관련 API를 사용할 수 있습니다:

- `Isolate.spawn()` 및 `Isolate.exit()`
- `ReceivePort` 및 `SendPort`
- `send()` 메서드

`Isolate.run` 메서드를 사용할 때, 새로운 isolate는 메인 isolate에 단일 메시지를 반환한 후 즉시 종료됩니다. 때때로, 여러 메시지를 서로 주고받으며 오랜 시간 동안 실행되는 isolate가 필요할 수 있습니다. Dart에서는 `Isolate` API와 Ports를 사용하여 이러한 긴 생애의 isolate를 구현할 수 있습니다. 이러한 긴 생애의 isolate는 일반적으로 백그라운드 워커(background workers)라고 불립니다.

긴 생애의 isolate는 애플리케이션의 전체 생애 동안 반복적으로 실행해야 하는 특정 프로세스가 있거나, 일정 기간 동안 실행되며 메인 isolate에 여러 반환 값을 제공해야 하는 프로세스가 있을 때 유용합니다.

또한, `worker_manager`를 사용하여 긴 생애의 isolate를 관리할 수도 있습니다.

### ReceivePorts and SendPorts

Set up long-lived communication between isolates with two classes (in addition to Isolate): [`ReceivePort`](https://api.dart.dev/stable/dart-isolate/ReceivePort-class.html) and [`SendPort`](https://api.dart.dev/stable/dart-isolate/SendPort-class.html). These ports are the only way isolates can communicate with each other.

`Ports` behave similarly to `Streams`, in which the `StreamController` or `Sink` is created in one isolate, and the listener is set up in the other isolate. In this analogy, the `StreamConroller` is called a `SendPort`, and you can "add" messages with the `send()` method. `ReceivePort`s are the listeners, and when these listeners receive a new message, they call a provided callback with the message as an argument.

For an in-depth explanation on setting up two-way communication between the main isolate and a worker isolate, follow the examples in the [Dart documentation](https://dart.dev/language/concurrency).
### ReceivePort와 SendPort

긴 생애의 통신을 위해서는 `ReceivePort`와 `SendPort` 두 가지 클래스를 설정해야 합니다 (이 외에도 `Isolate`가 필요합니다). 이 포트들은 isolates 간에 통신할 수 있는 유일한 방법입니다.

포트는 스트림(Streams)과 유사하게 동작합니다. 스트림 컨트롤러(StreamController) 또는 싱크(Sink)가 하나의 isolate에서 생성되고, 리스너(listener)가 다른 isolate에서 설정됩니다. 이 비유에서, 스트림 컨트롤러는 `SendPort`라고 하며, `send()` 메서드를 사용하여 메시지를 "추가"할 수 있습니다. `ReceivePort`는 리스너 역할을 하며, 이 리스너가 새로운 메시지를 수신하면 제공된 콜백 함수를 메시지를 인수로 호출합니다.

메인 isolate와 워커 isolate 간의 양방향 통신을 설정하는 방법에 대한 자세한 설명은 Dart 문서의 예제를 참조하세요.

## Using platform plugins in isolates

As of Flutter 3.7, you can use platform plugins in background isolates. This opens many possibilities to offload heavy, platform-dependent computations to an isolate that won't block your UI. For example, imagine you're encrypting data using a native host API (such as an Android API on Android, an iOS API on iOS, and so on). Previously, [marshaling data](https://en.wikipedia.org/wiki/Marshalling_(computer_science)) to the host platform could waste UI thread time, and can now be done in a background isolate.

Platform channel isolates use the [`BackgroundIsolateBinaryMessenger`](https://api.flutter.dev/flutter/services/BackgroundIsolateBinaryMessenger-class.html) API. The following snippet shows an example of using the `shared_preferences` package in a background isolate.
### isolate에서 플랫폼 플러그인 사용하기

Flutter 3.7부터는 백그라운드 isolate에서도 플랫폼 플러그인을 사용할 수 있습니다. 이는 UI를 차단하지 않는 isolate에서 무거운 플랫폼 의존적인 계산을 오프로드할 수 있는 많은 가능성을 열어줍니다. 예를 들어, 네이티브 호스트 API를 사용하여 데이터를 암호화한다고 가정해 보겠습니다 (예: Android에서는 Android API, iOS에서는 iOS API 등). 이전에는 호스트 플랫폼으로 데이터를 마샬링하는 데 UI 스레드 시간이 낭비될 수 있었으나, 이제는 백그라운드 isolate에서 처리할 수 있습니다.

플랫폼 채널 isolate는 `BackgroundIsolateBinaryMessenger` API를 사용합니다. 다음 코드 스니펫은 백그라운드 isolate에서 `shared_preferences` 패키지를 사용하는 예를 보여줍니다.

```dart
import 'dart:isolate';

import 'package:flutter/services.dart';
import 'package:shared_preferences/shared_preferences.dart';

void main() {
  // Identify the root isolate to pass to the background isolate.
  RootIsolateToken rootIsolateToken = RootIsolateToken.instance!;
  Isolate.spawn(_isolateMain, rootIsolateToken);
}

Future<void> _isolateMain(RootIsolateToken rootIsolateToken) async {
  // Register the background isolate with the root isolate.
  BackgroundIsolateBinaryMessenger.ensureInitialized(rootIsolateToken);

  // You can now use the shared_preferences plugin.
  SharedPreferences sharedPreferences = await SharedPreferences.getInstance();

  print(sharedPreferences.getBool('isDebug'));
}
```
## Limitations of Isolates

If you're coming to Dart from a language with multithreading, it's reasonable to expect isolates to behave like threads, but that isn't the case. Isolates have their own global fields, and can only communicate with message passing, ensuring that mutable objects in an isolate are only ever accessible in a single isolate. Therefore, isolates are limited by their access to their own memory. For example, if you have an application with a global mutable variable called `configuration`, it is copied as a new global field in a spawned isolate. If you mutate that variable in the spawned isolate, it remains untouched in the main isolate. This is true even if you pass the `configuration` object as a message to the new isolate. This is how isolates are meant to function, and it's important to keep in mind when you consider using isolates.

## Isolate의 제한 사항

Dart에서 멀티스레딩이 있는 언어에서 온 경우, isolate가 스레드처럼 동작할 것으로 기대할 수 있지만, 사실 그렇지 않습니다. Isolates는 각각 고유한 전역 필드를 가지며, 메시지 전달을 통해서만 통신할 수 있습니다. 이로 인해 mutable 객체는 하나의 isolate에서만 접근할 수 있습니다. 따라서, isolates는 자신의 메모리 접근에 제한이 있습니다. 예를 들어, `configuration`이라는 전역 mutable 변수가 있는 애플리케이션이 있다고 가정해 봅시다. 이 변수는 spawn된 isolate에서 새로운 전역 필드로 복사됩니다. 이 변수를 spawn된 isolate에서 수정하더라도, 메인 isolate에서는 변경되지 않은 채로 남아 있습니다. 이는 `configuration` 객체를 새로운 isolate에 메시지로 전달하더라도 마찬가지입니다. 이는 isolates의 본래 동작 방식이며, 이를 사용할 때 염두에 두어야 할 중요한 점입니다.

### Web platforms and compute

Dart web platforms, including Flutter web, don't support isolates. If you're targeting the web with your Flutter app, you can use the `compute` method to ensure your code compiles. The [`compute()`](https://api.flutter.dev/flutter/foundation/compute.html) method runs the computation on the main thread on the web, but spawns a new thread on mobile devices. On mobile and desktop platforms `await compute(fun, message)` is equivalent to `await Isolate.run(() => fun(message))`.

For more information on concurrency on the web, check out the [concurrency documentation](https://dart.dev/language/concurrency) on dart.dev.

### 웹 플랫폼과 compute

Dart 웹 플랫폼, 포함하여 Flutter 웹은 isolates를 지원하지 않습니다. Flutter 앱을 웹에서 타겟팅하는 경우, 코드가 컴파일되도록 `compute` 메서드를 사용할 수 있습니다. 웹에서는 `compute()` 메서드가 메인 스레드에서 계산을 실행하지만, 모바일 장치에서는 새로운 스레드를 생성합니다. 모바일 및 데스크탑 플랫폼에서 `await compute(fun, message)`는 `await Isolate.run(() => fun(message))`와 동등합니다.

웹에서의 동시성에 대한 더 많은 정보는 dart.dev의 동시성 문서에서 확인할 수 있습니다.

### No `rootBundle` access or `dart:ui` methods

All UI tasks and Flutter itself are coupled to the main isolate. Therefore, you can't access assets using `rootBundle` in spawned isolates, nor can you perform any widget or UI work in spawned isolates.

### `rootBundle` 접근 불가 및 `dart:ui` 메서드

모든 UI 작업과 Flutter 자체는 메인 isolate에 결합되어 있습니다. 따라서, spawn된 isolates에서는 `rootBundle`을 사용하여 자산에 접근할 수 없으며, 위젯이나 UI 작업을 수행할 수 없습니다.

### Limited plugin messages from host platform to Flutter

[#](https://docs.flutter.dev/perf/isolates#limited-plugin-messages-from-host-platform-to-flutter)

With background isolate platform channels, you can use platform channels in isolates to send messages to the host platform (for example Android or iOS), and receive responses to those messages. However, you can't receive unsolicited messages from the host platform.

As an example, you can't set up a long-lived Firestore listener in a background isolate, because Firestore uses platform channels to push updates to Flutter, which are unsolicited. You can, however, query Firestore for a response in the background.

### 호스트 플랫폼에서 Flutter로의 제한된 플러그인 메시지

백그라운드 isolate 플랫폼 채널을 사용하면, isolates에서 플랫폼 채널을 통해 호스트 플랫폼(예: Android 또는 iOS)으로 메시지를 보내고, 해당 메시지에 대한 응답을 받을 수 있습니다. 그러나 호스트 플랫폼에서 Flutter로의 비청구 메시지를 수신할 수는 없습니다.

예를 들어, 백그라운드 isolate에서 Firestore의 장기 실행 리스너를 설정할 수는 없습니다. Firestore는 플랫폼 채널을 사용하여 Flutter로 업데이트를 푸시하는데, 이 업데이트는 비청구적입니다. 그러나 백그라운드에서 Firestore를 쿼리하여 응답을 받을 수는 있습니다.

## More information

For more information on isolates, check out the following resources:

- If you're using many isolates, consider the [IsolateNameServer](https://api.flutter.dev/flutter/dart-ui/IsolateNameServer-class.html) class in Flutter, or the pub package that clones the functionality for Dart applications not using Flutter.
- Dart's Isolates are an implementation of the [Actor model](https://en.wikipedia.org/wiki/Actor_model).
- [isolate_agents](https://medium.com/@gaaclarke/isolate-agents-easy-isolates-for-flutter-6d75bf69a2e7) is a package that abstracts Ports and make it easier to create long-lived isolates.
- Read more about the `BackgroundIsolateBinaryMessenger` API [announcement](https://medium.com/flutter/introducing-background-isolate-channels-7a299609cad8).
## 추가 정보

isolate에 대한 더 많은 정보는 다음 리소스를 참고하세요:

- 많은 isolates를 사용하는 경우, Flutter에서는 `IsolateNameServer` 클래스를 고려하거나, Flutter를 사용하지 않는 Dart 애플리케이션을 위한 기능을 복제하는 pub 패키지를 고려하세요.
- Dart의 isolates는 Actor 모델의 구현입니다.
- `isolate_agents` 패키지는 Ports를 추상화하여 장기 생애를 가진 isolates를 쉽게 생성할 수 있도록 합니다.
- BackgroundIsolateBinaryMessenger API 발표에 대한 자세한 내용을 읽어보세요.

# Parse JSON in the background

By default, Dart apps do all of their work on a single thread. In many cases, this model simplifies coding and is fast enough that it does not result in poor app performance or stuttering animations, often called "jank."

However, you might need to perform an expensive computation, such as parsing a very large JSON document. If this work takes more than 16 milliseconds, your users experience jank.

To avoid jank, you need to perform expensive computations like this in the background. On Android, this means scheduling work on a different thread. In Flutter, you can use a separate [Isolate](https://api.flutter.dev/flutter/dart-isolate/Isolate-class.html). This recipe uses the following steps:

1. Add the `http` package.
2. Make a network request using the `http` package.
3. Convert the response into a list of photos.
4. Move this work to a separate isolate.

기본적으로 Dart 앱은 모든 작업을 단일 스레드에서 수행합니다. 이 모델은 많은 경우 코딩을 단순화하고, 앱 성능 저하나 애니메이션 지연(jank)과 같은 문제가 발생하지 않을 정도로 빠릅니다.

하지만 매우 큰 JSON 문서를 파싱하는 등 비용이 많이 드는 작업을 수행해야 할 경우, 작업이 16밀리초를 초과하면 사용자에게 지연(jank) 현상이 발생할 수 있습니다.

지연을 피하려면 이러한 비용이 많이 드는 작업을 백그라운드에서 수행해야 합니다. Android에서는 다른 스레드에서 작업을 예약하는 것을 의미합니다. Flutter에서는 별도의 `Isolate`를 사용할 수 있습니다. 이 레시피는 다음 단계를 사용합니다:

1. `http` 패키지를 추가합니다.
2. `http` 패키지를 사용하여 네트워크 요청을 수행합니다.
3. 응답을 사진 리스트로 변환합니다.
4. 이 작업을 별도의 `Isolate`로 이동합니다.
## 1. Add the `http` package

First, add the [`http`](https://pub.dev/packages/http) package to your project. The `http` package makes it easier to perform network requests, such as fetching data from a JSON endpoint.

To add the `http` package as a dependency, run `flutter pub add`:
## 1. **`http` 패키지 추가하기**

먼저, `http` 패키지를 프로젝트에 추가합니다. `http` 패키지는 JSON 엔드포인트와 같은 네트워크 요청을 수행하는 작업을 더 쉽게 만들어줍니다.

패키지를 의존성으로 추가하려면, 다음 명령어를 실행하세요:

```
$ flutter pub add http
```
## 2. Make a network request


This example covers how to fetch a large JSON document that contains a list of 5000 photo objects from the [JSONPlaceholder REST API](https://jsonplaceholder.typicode.com/), using the [`http.get()`](https://pub.dev/documentation/http/latest/http/get.html) method.

이 예제에서는 `http.get()` 메서드를 사용하여 JSONPlaceholder REST API에서 5000개의 사진 객체를 포함하는 큰 JSON 문서를 가져오는 방법을 다룹니다.

```dart
Future<http.Response> fetchPhotos(http.Client client) async {
  return client.get(Uri.parse('https://jsonplaceholder.typicode.com/photos'));
}
```

_Note_

You're providing an `http.Client` to the function in this example. This makes the function easier to test and use in different environments.

_정보_

이 예제에서는 `http.Client`를 함수에 제공하고 있습니다. 이는 함수를 더 쉽게 테스트할 수 있게 하고, 다양한 환경에서 사용할 수 있게 합니다.
## 3. Parse and convert the JSON into a list of photos

Next, following the guidance from the [Fetch data from the internet](https://docs.flutter.dev/cookbook/networking/fetch-data) recipe, convert the `http.Response` into a list of Dart objects. This makes the data easier to work with.

## 3. JSON을 파싱하고 사진 목록으로 변환하기

다음으로, 인터넷에서 데이터를 가져오는 레시피를 참고하여 `http.Response`를 Dart 객체의 목록으로 변환합니다. 이렇게 하면 데이터를 더 쉽게 다룰 수 있습니다.

### Create a `Photo` class

First, create a `Photo` class that contains data about a photo. Include a `fromJson()` factory method to make it easy to create a `Photo` starting with a JSON object.

### `Photo` 클래스 만들기

우선, 사진에 대한 데이터를 포함하는 `Photo` 클래스를 생성합니다. JSON 객체로부터 `Photo` 객체를 쉽게 생성할 수 있도록 `fromJson()` 팩토리 메서드를 포함시킵니다.

```dart
class Photo {
  final int albumId;
  final int id;
  final String title;
  final String url;
  final String thumbnailUrl;

  const Photo({
    required this.albumId,
    required this.id,
    required this.title,
    required this.url,
    required this.thumbnailUrl,
  });

  factory Photo.fromJson(Map<String, dynamic> json) {
    return Photo(
      albumId: json['albumId'] as int,
      id: json['id'] as int,
      title: json['title'] as String,
      url: json['url'] as String,
      thumbnailUrl: json['thumbnailUrl'] as String,
    );
  }
}
```
### Convert the response into a list of photos

Now, use the following instructions to update the `fetchPhotos()` function so that it returns a `Future<List<Photo>>`:

1. Create a `parsePhotos()` function that converts the response body into a `List<Photo>`.
2. Use the `parsePhotos()` function in the `fetchPhotos()` function.

### 응답을 사진 목록으로 변환하기

이제 `fetchPhotos()` 함수를 업데이트하여 `Future<List<Photo>>`를 반환하도록 만드는 지침은 다음과 같습니다:

1. **`parsePhotos()` 함수 생성**: 응답 본문을 `List<Photo>`로 변환하는 함수를 만듭니다.
    
2. **`fetchPhotos()` 함수에서 `parsePhotos()` 사용**: `fetchPhotos()` 함수 내에서 `parsePhotos()` 함수를 호출하여 응답을 사진 목록으로 변환합니다.

```dart
// A function that converts a response body into a List<Photo>.
List<Photo> parsePhotos(String responseBody) {
  final parsed =
      (jsonDecode(responseBody) as List).cast<Map<String, dynamic>>();

  return parsed.map<Photo>((json) => Photo.fromJson(json)).toList();
}

Future<List<Photo>> fetchPhotos(http.Client client) async {
  final response = await client
      .get(Uri.parse('https://jsonplaceholder.typicode.com/photos'));

  // Synchronously run parsePhotos in the main isolate.
  return parsePhotos(response.body);
}
```
## 4. Move this work to a separate isolate

If you run the `fetchPhotos()` function on a slower device, you might notice the app freezes for a brief moment as it parses and converts the JSON. This is jank, and you want to get rid of it.

You can remove the jank by moving the parsing and conversion to a background isolate using the [`compute()`](https://api.flutter.dev/flutter/foundation/compute.html) function provided by Flutter. The `compute()` function runs expensive functions in a background isolate and returns the result. In this case, run the `parsePhotos()` function in the background.

## 4. 작업을 별도의 isolate로 이동하기

`fetchPhotos()` 함수를 느린 장치에서 실행하면 JSON을 파싱하고 변환하는 동안 앱이 잠시 멈추는 현상을 경험할 수 있습니다. 이것이 바로 "jank"이며, 이를 제거하고자 합니다.

이 문제를 해결하려면 파싱 및 변환 작업을 배경 isolate로 이동시킬 수 있습니다. Flutter에서 제공하는 `compute()` 함수를 사용하면 됩니다. `compute()` 함수는 비싼 함수들을 배경 isolate에서 실행하고 결과를 반환합니다. 이 경우, `parsePhotos()` 함수를 배경에서 실행하도록 합니다.

```dart
Future<List<Photo>> fetchPhotos(http.Client client) async {
  final response = await client
      .get(Uri.parse('https://jsonplaceholder.typicode.com/photos'));

  // Use the compute function to run parsePhotos in a separate isolate.
  return compute(parsePhotos, response.body);
}
```
## Notes on working with isolates

Isolates communicate by passing messages back and forth. These messages can be primitive values, such as `null`, `num`, `bool`, `double`, or `String`, or simple objects such as the `List<Photo>` in this example.

You might experience errors if you try to pass more complex objects, such as a `Future` or `http.Response` between isolates.

As an alternate solution, check out the [`worker_manager`](https://pub.dev/packages/worker_manager) or [`workmanager`](https://pub.dev/packages/workmanager) packages for background processing.

## Isolates에서 작업할 때의 주의사항

Isolates는 메시지를 주고받으며 통신합니다. 이 메시지는 null, num, bool, double, String과 같은 원시 값이나 이 예제에서 사용하는 List\<Photo>와 같은 간단한 객체일 수 있습니다.

복잡한 객체, 예를 들어 Future 또는 http.Response와 같은 객체를 isolate 간에 전달하려고 하면 오류가 발생할 수 있습니다.

대안으로, 배경 처리를 위해 `worker_manager` 또는 `workmanager` 패키지를 확인해 보세요.

## Complete example

```dart
import 'dart:async';
import 'dart:convert';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;

Future<List<Photo>> fetchPhotos(http.Client client) async {
  final response = await client
      .get(Uri.parse('https://jsonplaceholder.typicode.com/photos'));

  // Use the compute function to run parsePhotos in a separate isolate.
  return compute(parsePhotos, response.body);
}

// A function that converts a response body into a List<Photo>.
List<Photo> parsePhotos(String responseBody) {
  final parsed =
      (jsonDecode(responseBody) as List).cast<Map<String, dynamic>>();

  return parsed.map<Photo>((json) => Photo.fromJson(json)).toList();
}

class Photo {
  final int albumId;
  final int id;
  final String title;
  final String url;
  final String thumbnailUrl;

  const Photo({
    required this.albumId,
    required this.id,
    required this.title,
    required this.url,
    required this.thumbnailUrl,
  });

  factory Photo.fromJson(Map<String, dynamic> json) {
    return Photo(
      albumId: json['albumId'] as int,
      id: json['id'] as int,
      title: json['title'] as String,
      url: json['url'] as String,
      thumbnailUrl: json['thumbnailUrl'] as String,
    );
  }
}

void main() => runApp(const MyApp());

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    const appTitle = 'Isolate Demo';

    return const MaterialApp(
      title: appTitle,
      home: MyHomePage(title: appTitle),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});

  final String title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  late Future<List<Photo>> futurePhotos;

  @override
  void initState() {
    super.initState();
    futurePhotos = fetchPhotos(http.Client());
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: FutureBuilder<List<Photo>>(
        future: futurePhotos,
        builder: (context, snapshot) {
          if (snapshot.hasError) {
            return const Center(
              child: Text('An error has occurred!'),
            );
          } else if (snapshot.hasData) {
            return PhotosList(photos: snapshot.data!);
          } else {
            return const Center(
              child: CircularProgressIndicator(),
            );
          }
        },
      ),
    );
  }
}

class PhotosList extends StatelessWidget {
  const PhotosList({super.key, required this.photos});

  final List<Photo> photos;

  @override
  Widget build(BuildContext context) {
    return GridView.builder(
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 2,
      ),
      itemCount: photos.length,
      itemBuilder: (context, index) {
        return Image.network(photos[index].thumbnailUrl);
      },
    );
  }
}
```

![Isolate demo](https://docs.flutter.dev/assets/images/docs/cookbook/isolate.gif)
