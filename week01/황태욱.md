# Iterable

This codelab teaches you how to use collections that implement the [Iterable](https://api.dart.dev/stable/dart-core/Iterable-class.html) class—for example [List](https://api.dart.dev/stable/dart-core/List-class.html) and [Set.](https://api.dart.dev/stable/dart-core/Set-class.html) Iterables are basic building blocks for all sorts of Dart applications, and you're probably already using them, even without noticing. This codelab helps you make the most out of them.

이 코드랩은 List와 Set 같은 Iterable 클래스를 구현하는 컬렉션을 사용하는 방법을 가르쳐줍니다. Iterable은 모든 종류의 Dart 애플리케이션의 기본 구성 요소이며, 아마도 눈치채지 못한 채 이미 사용하고 있을 것입니다. 이 코들랩은 그것들을 최대한 활용할 수 있도록 도와줍니다.

Using the embedded DartPad editors, you can test your knowledge by running example code and completing exercises.

내장된 DartPad 편집기를 사용하여 예제 코드를 실행하고 연습 문제를 완료함으로써 여러분의 지식을 테스트할 수 있습니다.

To get the most out of this codelab, you should have basic knowledge of [Dart syntax](https://dart.dev/language).

이 코드랩을 최대한 활용하려면 Dart 구문에 대한 기본 지식이 있어야 합니다.

This codelab covers the following material:

- How to read elements of an Iterable.
- How to check if the elements of an Iterable satisfy a condition.
- How to filter the contents of an Iterable.
- How to map the contents of an Iterable to a different value.

이 코드랩은 다음 자료를 다룹니다:

- Iterable의 요소를 읽는 방법.
- Iterable의 요소가 조건을 만족하는지 확인하는 방법.
- Iterable의 내용을 필터링하는 방법.
- Iterable의 내용을 다른 값으로 매핑하는 방법.

Estimated time to complete this codelab: 60 minutes.

이 코들랩을 완료하는 데 예상되는 시간: 60분.

_Note

_참고

This page uses embedded DartPads to display examples and exercises. If you see empty boxes instead of DartPads, go to the [DartPad troubleshooting page](https://dart.dev/tools/dartpad/troubleshoot).

이 페이지는 예제와 연습 문제를 표시하기 위해 내장된 DartPad를 사용합니다. DartPad 대신 빈 상자가 표시된다면, DartPad 문제 해결 페이지로 이동하세요.

The exercises in this codelab have partially completed code snippets. You can use DartPad to test your knowledge by completing the code and clicking the **Run** button. **Don't edit the test code in the `main` function or below**.

이 코들랩의 연습 문제는 부분적으로 완성된 코드 조각을 포함하고 있습니다. DartPad를 사용하여 코드를 완성하고 실행 버튼을 클릭하여 여러분의 지식을 테스트하세요. main 함수 또는 그 이하의 테스트 코드는 수정하지 마세요.

If you need help, expand the **Hint** or **Solution** dropdown after each exercise.

도움이 필요하면 각 연습 문제 아래에 있는 힌트나 해결 방법 드롭다운을 펼치세요.
## What are collections?

## 컬렉션이란?

A collection is an object that represents a group of objects, which are called _elements_. Iterables are a kind of collection.

컬렉션은 객체 그룹을 나타내는 객체로, 이러한 객체를 요소라고 합니다. Iterable은 일종의 컬렉션입니다.

A collection can be empty, or it can contain many elements. Depending on the purpose, collections can have different structures and implementations. These are some of the most common collection types:

- [List:](https://api.dart.dev/stable/dart-core/List-class.html) Used to read elements by their indexes.
- [Set:](https://api.dart.dev/stable/dart-core/Set-class.html) Used to contain elements that can occur only once.
- [Map:](https://api.dart.dev/stable/dart-core/Map-class.html) Used to read elements using a key.

컬렉션은 비어 있거나 많은 요소를 포함할 수 있습니다. 목적에 따라 컬렉션은 다양한 구조와 구현을 가질 수 있습니다. 다음은 가장 일반적인 컬렉션 유형 중 일부입니다:

- List: 요소를 인덱스로 읽는 데 사용됩니다.
- Set: 한 번만 발생할 수 있는 요소를 포함하는 데 사용됩니다.
- Map: 키를 사용하여 요소를 읽는 데 사용됩니다.

## What is an Iterable?

## 반복 가능한(Iterable)이란 무엇인가요?

An `Iterable` is a collection of elements that can be accessed sequentially.

Iterable은 순차적으로 액세스할 수 있는 요소의 컬렉션입니다.

In Dart, an `Iterable` is an abstract class, meaning that you can't instantiate it directly. However, you can create a new `Iterable` by creating a new `List` or `Set`.

Dart에서 Iterable은 추상 클래스이므로 직접 인스턴스화할 수 없습니다. 그러나 List 또는 Set을 만들어 새로운 Iterable을 생성할 수 있습니다.

Both `List` and `Set` are `Iterable`, so they have the same methods and properties as the `Iterable` class.

List와 Set 모두 Iterable이므로 Iterable 클래스와 동일한 메서드와 속성을 갖습니다.

A `Map` uses a different data structure internally, depending on its implementation. For example, [HashMap](https://api.dart.dev/stable/dart-collection/HashMap-class.html) uses a hash table in which the elements (also called _values_) are obtained using a key. Elements of a `Map` can also be read as `Iterable` objects by using the map's `entries` or `values` property.

Map은 내부적으로 다른 데이터 구조를 사용하며 구현에 따라 다릅니다. 예를 들어 HashMap은 해시 테이블을 사용하여 요소(값이라고도 함)를 키를 사용하여 얻습니다. Map의 요소는 맵의 entries 또는 values 속성을 사용하여 Iterable 객체로 읽을 수도 있습니다.

This example shows a `List` of `int`, which is also an `Iterable` of `int`:

다음은 int로 이루어진 List, 즉 int Iterable의 예제입니다:


``` dart
Iterable<int> iterable = [1, 2, 3];
```

The difference with a `List` is that with the `Iterable`, you can't guarantee that reading elements by index will be efficient. `Iterable`, as opposed to `List`, doesn't have the `[]` operator.

List와의 차이점은 Iterable에서 요소를 인덱스로 효율적으로 읽을 수 없다는 점입니다. Iterable은 List와 달리 [] 연산자를 갖지 않습니다.

For example, consider the following code, which is **invalid**:

예를 들어, 다음과 같은 코드는 잘못됐습니다:


``` dart
Iterable<int> iterable = [1, 2, 3];
int value = iterable[1];
```

If you read elements with `[]`, the compiler tells you that the operator `'[]'` isn't defined for the class `Iterable`, which means that you can't use `[index]` in this case.

만약 `[]`를 사용하여 요소를 읽으면, 컴파일러가`'[]'`연산자가 Iterable 클래스에 정의되지 않았다고 알려줍니다. 즉, 이 경우에는`[index]`를 사용할 수 없습니다.

You can instead read elements with `elementAt()`, which steps through the elements of the iterable until it reaches that position.

그 대신 elementAt()를 사용하여 요소를 읽을 수 있습니다. 이 메서드는 iterable의 요소를 해당 위치에 도달할 때까지 순회합니다.


```dart
Iterable<int> iterable = [1, 2, 3];
int value = iterable.elementAt(1);
```

Continue to the next section to learn more about how to access elements of an `Iterable`.
다음 섹션으로 계속해서 Iterable의 요소에 액세스하는 방법에 대해 더 알아보세요.

## Reading elements

## 요소 읽기

You can read the elements of an iterable sequentially, using a `for-in` loop.

Iterable의 요소를 순차적으로 읽을 수 있습니다. 이를 위해 for-in 루프를 사용할 수 있습니다.
### Example: Using a for-in loop

### 예제: for-in 루프 사용

The following example shows you how to read elements using a `for-in` loop.

다음 예제는 for-in 루프를 사용하여 요소를 읽는 방법을 보여줍니다.

```dart
void main() {
  const iterable = ['Salad', 'Popcorn', 'Toast'];
  for (final element in iterable) {
    print(element);
  }
}
```

```
Salad
Popcorn
Toast
```
### Details

Behind the scenes, the `for-in` loop uses an _iterator._ You rarely see the [Iterator API](https://api.dart.dev/stable/dart-core/Iterator-class.html) used directly, however, because `for-in` is easier to read and understand, and is less prone to errors.

### 자세히 보기

내부적으로 for-in 루프는 iterator를 사용합니다. for-in이 더 읽기 쉽고 이해하기 쉬우며 오류 발생 가능성이 적기 때문에 Iterator API를 직접 사용하는 경우는 거의 없습니다.

### Key terms

- **Iterable**: The Dart [Iterable](https://api.dart.dev/stable/dart-core/Iterable-class.html) class.
- **Iterator**: An object used by `for-in` to read elements from an `Iterable` object.
- **`for-in` loop**: An easy way to sequentially read elements from an `Iterable`.

### 주요 용어

- **Iterable**: Dart의 Iterable 클래스.
- **Iterator**: for-in이 Iterable 객체에서 요소를 읽는 데 사용하는 객체.
- **for-in 루프**: Iterable에서 요소를 순차적으로 읽는 간편한 방법.

### Example: Using first and last

### 예제: first와 last 사용

In some cases, you want to access only the first or the last element of an `Iterable`.

어떤 경우에는 Iterable의 첫 번째 또는 마지막 요소에만 접근하고 싶을 때가 있습니다.

With the `Iterable` class, you can't access the elements directly, so you can't call `iterable[0]` to access the first element. Instead, you can use `first`, which gets the first element.

Iterable 클래스에서는 요소에 직접 접근할 수 없으므로 첫 번째 요소에 접근하기 위해 iterable[0]을 호출할 수 없습니다. 대신, 첫 번째 요소를 가져오는 first를 사용할 수 있습니다.

Also, with the `Iterable` class, you can't use the operator `[]` to access the last element, but you can use the `last` property.

마찬가지로 Iterable 클래스에서는 [] 연산자를 사용하여 마지막 요소에 접근할 수 없지만, last 속성을 사용할 수 있습니다.

### Warning

Because accessing the last element of an `Iterable` requires stepping through all the other elements, **`last` can be slow.** Using `first` or `last` on an **empty `Iterable`** results in a [StateError.](https://api.dart.dev/stable/dart-core/StateError-class.html)

### 경고

Iterable의 마지막 요소에 접근하는 것은 다른 모든 요소를 순회해야 하기 때문에 느릴 수 있습니다. 빈 Iterable에서 first 또는 last를 사용하면 StateError가 발생합니다.

```d
void main() {
  Iterable<String> iterable = const ['Salad', 'Popcorn', 'Toast'];
  print('The first element is ${iterable.first}');
  print('The last element is ${iterable.last}');
}
```

```
The first element is Salad
The last element is Toast
```

In this example you saw how to use `first` and `last` to get the first and last elements of an `Iterable`. It's also possible to find the first element that satisfies a condition. The next section shows how to do that using a method called `firstWhere()`.

이 섹션에서는 Iterable의 요소를 읽는 다양한 방법에 대해 알아보았습니다. for-in 루프를 사용하여 요소를 순차적으로 읽고, first와 last 속성을 사용하여 첫 번째 및 마지막 요소에 접근하는 방법을 배웠습니다.

### Example: Using firstWhere()

### 예제: `firstWhere()` 사용하기

You already saw that you can access the elements of an `Iterable` sequentially, and you can easily get the first or last element.

이미 Iterable의 요소를 순차적으로 액세스할 수 있고, 첫 번째 또는 마지막 요소를 쉽게 가져올 수 있다는 것을 보았습니다.

Now, you learn how to use `firstWhere()` to find the first element that satisfies certain conditions. This method requires you to pass a _predicate_, which is a function that returns true if the input satisfies a certain condition.


이제 특정 조건을 만족하는 첫 번째 요소를 찾기 위해 `firstWhere()`를 사용하는 방법을 배워보겠습니다. 이 메서드는 조건을 만족하면 true를 반환하는 함수를 전달받아야 합니다.

```dart
String element = iterable.firstWhere((element) => element.length > 5);
```

For example, if you want to find the first `String` that has more than 5 characters, you must pass a predicate that returns true when the element size is greater than 5.

예를 들어, 5자 이상인 첫 번째 문자열을 찾으려면 요소의 길이가 5보다 클 때 true를 반환하는 조건을 전달해야 합니다.

Run the following example to see how `firstWhere()` works. Do you think all the functions will give the same result?

다음 예제를 실행하여 `firstWhere()`가 어떻게 작동하는지 확인하세요. 모든 함수가 같은 결과를 줄 것이라고 생각하나요?

```d
bool predicate(String item) {
  return item.length > 5;
}

void main() {
  const items = ['Salad', 'Popcorn', 'Toast', 'Lasagne'];

  // You can find with a simple expression:
  var foundItem1 = items.firstWhere((item) => item.length > 5);
  print(foundItem1);

  // Or try using a function block:
  var foundItem2 = items.firstWhere((item) {
    return item.length > 5;
  });
  print(foundItem2);

  // Or even pass in a function reference:
  var foundItem3 = items.firstWhere(predicate);
  print(foundItem3);

  // You can also use an `orElse` function in case no value is found!
  var foundItem4 = items.firstWhere(
    (item) => item.length > 10,
    orElse: () => 'None!',
  );
  print(foundItem4);
}
```

```
Popcorn
Popcorn
Popcorn
None!
```


### In this example, you can see three different ways to write a predicate:

- **As an expression:** The test code has one line that uses arrow syntax (`=>`).
- **As a block:** The test code has multiple lines between brackets and a return statement.
- **As a function:** The test code is in an external function that's passed to the `firstWhere()` method as a parameter.

### 이 예제에서는 세 가지 다른 방식으로 조건자를 작성할 수 있습니다:

- **표현식으로**: 테스트 코드에는 화살표 구문(=>)을 사용하는 한 줄의 코드가 있습니다.
- **블록으로**: 테스트 코드에는 중괄호와 return 문 사이에 여러 줄이 있습니다.
- **함수로**: 테스트 코드는 외부 함수에 있으며 이 함수가 `firstWhere()` 메서드에 매개변수로 전달됩니다.

There is no right or wrong way. Use the way that works best for you, and that makes your code easier to read and understand.

어떤 방법이든 맞고 틀린 것은 없습니다. 여러분에게 가장 잘 맞고, 코드가 더 읽기 쉽고 이해하기 쉬운 방식을 사용하세요.

The final example calls `firstWhere()` with the optional named parameter `orElse`, which provides an alternative when an element isn't found. In this case, the text `'None!'` is returned because no element satisfies the provided condition.

최종 예제는 `firstWhere()` 메서드를 선택적 명명 매개변수인 `orElse`와 함께 호출하여 요소를 찾지 못했을 때 대안을 제공합니다. 이 경우 제공된 조건을 만족하는 요소가 없으므로 'None!'이라는 텍스트가 반환됩니다.

### Note

If no element satisfies the test predicate and the `orElse` parameter isn't provided, then `firstWhere()` throws a [StateError.](https://api.dart.dev/stable/dart-core/StateError-class.html)

### 참고

만약 테스트 조건자를 만족하는 요소가 없고 `orElse` 매개변수가 제공되지 않았다면, `firstWhere()`는 `StateError`를 던집니다.

### Quick review

- The elements of an `Iterable` must be accessed sequentially.
- The easiest way to iterate through all the elements is using a `for-in` loop.
- You can use the `first` and `last` getters to get the first and last elements.
- You can also find the first element that satisfies a condition with `firstWhere()`.
- You can write test predicates as expressions, blocks, or functions.

  **Key terms:**
- **Predicate:** A function that returns `true` when a certain condition is satisfied.

### 빠른 복습

- Iterable의 요소는 순차적으로 액세스해야 합니다.
- 모든 요소를 순회하는 가장 쉬운 방법은 for-in 루프를 사용하는 것입니다.
- 첫 번째와 마지막 요소를 가져오기 위해 `first`와 `last` getter를 사용할 수 있습니다.
- 특정 조건을 만족하는 첫 번째 요소를 찾기 위해 `firstWhere()`를 사용할 수 있습니다.
- 테스트 조건자를 표현식, 블록 또는 함수로 작성할 수 있습니다.
  **주요 용어**
- **Predicate(조건자)**: 특정 조건이 만족되면 true를 반환하는 함수.

### Exercise: Practice writing a test predicate

### 연습: 테스트 조건자 작성 연습

The following exercise is a failing unit test that contains a partially complete code snippet. Your task is to complete the exercise by writing code to make the tests pass. You don't need to implement `main()`.

다음 연습 문제는 실패하는 단위 테스트로, 부분적으로 완성된 코드 조각을 포함하고 있습니다. 여러분의 작업은 코드를 작성하여 테스트가 통과하도록 만드는 것입니다. `main()`을 구현할 필요는 없습니다.

This exercise introduces `singleWhere()` This method works similarly to `firstWhere()`, but in this case it expects only one element of the `Iterable` to satisfy the predicate. If more than one or no element in the `Iterable` satisfies the predicate condition, then the method throws a [StateError](https://api.dart.dev/stable/dart-core/StateError-class.html) exception.

이 연습 문제에서는 `singleWhere()`를 소개합니다. 이 메서드는 `firstWhere()`와 비슷하게 작동하지만, 이 경우 Iterable의 단 하나의 요소만 조건을 만족해야 합니다. 만약 조건을 만족하는 요소가 여러 개이거나 없으면 메서드는 `StateError` 예외를 던집니다.

### Warning

`singleWhere()` steps through the whole `Iterable` until the last element, which can cause problems if the `Iterable` is infinite or contains a large collection of elements.

### 경고

`singleWhere()`는 마지막 요소까지 전체 Iterable을 순회하므로, Iterable이 무한하거나 많은 요소를 포함하는 경우 문제가 발생할 수 있습니다.

Your goal is to implement the predicate for `singleWhere()` that satisfies the following conditions:

- The element contains the character `'a'`.
- The element starts with the character `'M'`.

All the elements in the test data are [strings](https://api.dart.dev/stable/dart-core/String-class.html); you can check the class documentation for help.

여러분의 목표는 다음 조건을 만족하는 `singleWhere()`의 조건자를 구현하는 것입니다:

- 요소에 'a' 문자가 포함되어 있어야 합니다.
- 요소가 'M' 문자로 시작해야 합니다.
- 테스트 데이터의 모든 요소는 문자열입니다. 클래스 문서를 확인하여 도움을 받을 수 있습니다.

```dart
// Implement the predicate of singleWhere
// with the following conditions
// * The element contains the character `'a'`
// * The element starts with the character `'M'`
String singleWhere(Iterable<String> items) {
  return items.singleWhere(TODO('Implement the outlined predicate.'));
}

// The following code is used to provide feedback on your solution.
// There is no need to read or modify it.
void main() {
  const items = [
    'Salad',
    'Popcorn',
    'Milk',
    'Toast',
    'Sugar',
    'Mozzarella',
    'Tomato',
    'Egg',
    'Water',
  ];

  try {
    final str = singleWhere(items);
    if (str == 'Mozzarella') {
      print('Success. All tests passed!');
    } else {
      print(
        'Tried calling singleWhere, but received $str instead of '
        'the expected value \'Mozzarella\'',
      );
    }
  } on StateError catch (stateError) {
    print(
      'Tried calling singleWhere, but received a StateError: ${stateError.message}. '
      'singleWhere will fail if 0 or many elements match the predicate.',
    );
  } on UnimplementedError {
    print(
      'Tried running `singleWhere`, but received an error. '
      'Did you implement the function?',
    );
  } catch (e) {
    print('Tried calling singleWhere, but received an exception: $e');
  }
}
```


Hint

Your solution might make use of the `contains` and `startsWith` methods from the `String` class.

당신의 솔루션은 String 클래스의 `contains`와 `startsWith` 메서드를 사용할 수 있습니다.

Solution
```dart
String singleWhere(Iterable<String> items) {
  return items.singleWhere(
          (element) => element.startsWith('M') && element.contains('a'));
}
```

## Checking conditions

## 조건 확인

When working with `Iterable`, sometimes you need to verify that all the elements of a collection satisfy some condition.

Iterable을 사용할 때, 컬렉션의 모든 요소가 특정 조건을 만족하는지 확인해야 할 때가 있습니다.

You might be tempted to write a solution using a `for-in` loop like this one:

다음과 같은 for-in 루프를 사용하여 솔루션을 작성하고 싶을 수 있습니다:

```dart
for (final item in items) {
  if (item.length < 5) {
    return false;
  }
}
return true;
```

However, you can accomplish the same using the `every()` method:

하지만, 동일한 작업을 `every()` 메서드를 사용하여 수행할 수 있습니다:

```dart
return items.every((item) => item.length >= 5);
```

Using the `every()` method results in code that is more readable, compact, and less error-prone.

`every()` 메서드를 사용하면 더 읽기 쉽고, 간결하며, 오류 발생 가능성이 적은 코드를 작성할 수 있습니다.

### Example: Using any() and every()

### 예제: `any()`와 `every()` 사용하기

The `Iterable` class provides two methods that you can use to verify conditions:

- `any()`: Returns true if at least one element satisfies the condition.
- `every()`: Returns true if all elements satisfy the condition.

Iterable 클래스는 조건을 확인하기 위해 사용할 수 있는 두 가지 메서드를 제공합니다:

- `any()`: 최소한 하나의 요소가 조건을 만족하면 true를 반환합니다.
- `every()`: 모든 요소가 조건을 만족하면 true를 반환합니다.

Run this exercise to see them in action.

다음 예제를 실행하여 이러한 메서드들이 어떻게 작동하는지 확인해 보세요:

```dart
void main() {
  const items = ['Salad', 'Popcorn', 'Toast'];

  if (items.any((item) => item.contains('a'))) {
    print('At least one item contains "a"');
  }

  if (items.every((item) => item.length >= 5)) {
    print('All items have length >= 5');
  }
}
```

```
At least one item contains "a"
All items have length >= 5
```

In the example, `any()` verifies that at least one element contains the character `a`, and `every()` verifies that all elements have a length equal to or greater than 5.

이 예제에서, `any()`는 최소한 하나의 요소에 'a' 문자가 포함되어 있는지 확인하고, `every()`는 모든 요소의 길이가 5 이상인지 확인합니다.

After running the code, try changing the predicate of `any()` so it returns false:

코드를 실행한 후, `any()`의 조건자를 변경하여 false를 반환하게 해보세요:


```dart
if (items.any((item) => item.contains('Z'))) {
  print('At least one item contains "Z"');
} else {
  print('No item contains "Z"');
}
```

You can also use `any()` to verify that no element of an `Iterable` satisfies a certain condition.

또한, `any()`를 사용하여 Iterable의 어떤 요소도 특정 조건을 만족하지 않는지 확인할 수 있습니다.

### Exercise: Verify that an Iterable satisfies a condition

### 연습: Iterable이 조건을 만족하는지 확인하기

The following exercise provides practice using the `any()` and `every()` methods, described in the previous example. In this case, you work with a group of users, represented by `User` objects that have the member field `age`.

다음 연습은 이전 예제에서 설명한 any()와 every() 메서드를 사용하는 연습을 제공합니다. 이 경우, 사용자 그룹을 나타내는 User 객체로 작업하며, 이 객체들은 나이를 나타내는 age 필드를 갖습니다.

Use `any()` and `every()` to implement two functions:

- Part 1: Implement `anyUserUnder18()`.
    - Return `true` if at least one user is 17 or younger.
- Part 2: Implement `everyUserOver13()`.
    - Return `true` if all users are 14 or older.

any()와 every()를 사용하여 두 가지 함수를 구현해 보세요:

- 부분 1: anyUserUnder18() 구현 하나 이상의 사용자가 17세 이하인 경우 true를 반환합니다. 
- 부분 2: everyUserOver13() 구현 모든 사용자가 14세 이상인 경우 true를 반환합니다.

```dart
bool anyUserUnder18(Iterable<User> users) {
  // TODO: Implement the anyUserUnder18 function.
}

bool everyUserOver13(Iterable<User> users) {
  // TODO: Implement the everyUserOver13 function.
}

class User {
  final String name;
  final int age;

  User(
    this.name,
    this.age,
  );
}

// The following code is used to provide feedback on your solution.
// There is no need to read or modify it.
void main() {
  final users = [
    User('Alice', 21),
    User('Bob', 17),
    User('Claire', 52),
    User('David', 14),
  ];

  try {
    final out = anyUserUnder18(users);
    if (!out) {
      print('Looks like `anyUserUnder18` is wrong. Keep trying!');
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `anyUserUnder18`, but received an error. '
      'Did you implement the function?',
    );
    return;
  } catch (e) {
    print('Tried running `anyUserUnder18`, but received an exception: $e');
    return;
  }

  try {
    // with only one user older than 18, should be false
    final out = anyUserUnder18([User('Alice', 21)]);
    if (out) {
      print(
          'Looks like `anyUserUnder18` is wrong. What if all users are over 18?');
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `anyUserUnder18`, but received an error. '
      'Did you implement the function?',
    );
    return;
  } catch (e) {
    print(
      'Tried running `anyUserUnder18([User("Alice", 21)])`, '
      'but received an exception: $e',
    );
    return;
  }

  try {
    final out = everyUserOver13(users);
    if (!out) {
      print(
        'Looks like `everyUserOver13` is wrong. '
        'There are no users under 13!',
      );
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `everyUserOver13`, but received an error. '
      'Did you implement the function?',
    );
    return;
  } catch (e) {
    print(
      'Tried running `everyUserOver13`, '
      'but received an exception: $e',
    );
    return;
  }

  try {
    final out = everyUserOver13([User('Dan', 12)]);
    if (out) {
      print(
        'Looks like `everyUserOver13` is wrong. '
        'There is at least one user under 13!',
      );
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `everyUserOver13`, but received an error. '
      'Did you implement the function?',
    );
    return;
  } catch (e) {
    print(
      'Tried running `everyUserOver13([User(\'Dan\', 12)])`, '
      'but received an exception: $e',
    );
    return;
  }

  print('Success. All tests passed!');
}
```

Hint

`any` 및 `every` 메서드를 Iterable 클래스에서 사용하는 것을 기억하세요. 이러한 메서드를 사용하는 도움과 예제는 이전에 이들에 대해 논의된 부분을 참조하세요.

Solution

```dart 
bool anyUserUnder18(Iterable<User> users) {
  return users.any((user) => user.age < 18);
}

bool everyUserOver13(Iterable<User> users) {
  return users.every((user) => user.age > 13);
}
```

### Quick review

- Although you can use `for-in` loops to check conditions, there are better ways to do that.
- The method `any()` enables you to check whether any element satisfies a condition.
- The method `every()` enables you to verify that all elements satisfy a condition.

### 빠른 리뷰 

- for-in 루프를 사용하여 조건을 확인할 수 있지만, 더 좋은 방법이 있습니다. 
- any() 메서드를 사용하면 요소 중 하나가 조건을 만족하는지 확인할 수 있습니다. 
- every() 메서드를 사용하면 모든 요소가 조건을 만족하는지 확인할 수 있습니다.

## Filtering

## 필터링

The previous sections cover methods like `firstWhere()` or `singleWhere()` that can help you find an element that satisfies a certain predicate.

이전 섹션에서는 firstWhere()나 singleWhere()와 같은 메서드들이 어떻게 특정 조건을 만족하는 요소를 찾는 데 도움이 되는지 다루었습니다.

But what if you want to find all the elements that satisfy a certain condition? You can accomplish that using the `where()` method.

하지만 만약 특정 조건을 만족하는 모든 요소를 찾고 싶다면 어떨까요? 이를 위해 where() 메서드를 사용할 수 있습니다.



``` dart
var evenNumbers = numbers.where((number) => number.isEven);
```


In this example, `numbers` contains an `Iterable` with multiple `int` values, and `where()` finds all the numbers that are even.

이 예제에서는 numbers가 여러 int 값을 포함하는 Iterable이며, where()는 짝수인 모든 숫자를 찾습니다.

The output of `where()` is another `Iterable`, and you can use it as such to iterate over it or apply other `Iterable` methods. In the next example, the output of `where()` is used directly inside the `for-in` loop.

where()의 출력은 다른 Iterable이며, 이를 반복하거나 다른 Iterable 메서드를 적용하는 데 사용할 수 있습니다. 다음 예제에서는 where()의 출력이 직접 for-in 루프 내에서 사용됩니다.


```dart 
var evenNumbers = numbers.where((number) => number.isEven);
for (final number in evenNumbers) {
  print('$number is even');
}
```

### Example: Using where()

Run this example to see how `where()` can be used together with other methods like `any()`.

## 예제: where() 사용하기

다음 예제를 실행하여 where()가 any()와 같은 다른 메서드와 함께 사용되는 방법을 확인하세요.

```dart
void main() {
  var evenNumbers = const [1, -2, 3, 42].where((number) => number.isEven);

  for (final number in evenNumbers) {
    print('$number is even.');
  }

  if (evenNumbers.any((number) => number.isNegative)) {
    print('evenNumbers contains negative numbers.');
  }

  // If no element satisfies the predicate, the output is empty.
  var largeNumbers = evenNumbers.where((number) => number > 1000);
  if (largeNumbers.isEmpty) {
    print('largeNumbers is empty!');
  }
}
```

```
-2 is even.
42 is even.
evenNumbers contains negative numbers.
largeNumbers is empty!
```


In this example, `where()` is used to find all numbers that are even, then `any()` is used to check if the results contain a negative number.

이 예제에서는 where()를 사용하여 모든 짝수를 찾은 다음 any()를 사용하여 결과에 음수가 포함되어 있는지 확인합니다.

Later in the example, `where()` is used again to find all numbers larger than 1000. Because there are none, the result is an empty `Iterable`.

나중에 예제에서는 where()를 다시 사용하여 1000보다 큰 모든 숫자를 찾습니다. 하지만 그런 숫자가 없기 때문에 결과는 빈 Iterable입니다.

### Note

If no element satisfies the predicate in `where()`, then the method returns an empty `Iterable`. Unlike `singleWhere()` or `firstWhere()`, `where()` doesn't throw a [StateError](https://api.dart.dev/stable/dart-core/StateError-class.html) exception.

### 참고 

where()에서 조건을 만족하는 요소가 없는 경우, 메서드는 빈 Iterable을 반환합니다. singleWhere()나 firstWhere()와 달리 where()는 StateError 예외를 throw하지 않습니다.



### Example: Using takeWhile

### 예제: takeWhile 사용하기

The methods `takeWhile()` and `skipWhile()` can also help you filter elements from an `Iterable`.

takeWhile()과 skipWhile() 메서드도 Iterable에서 요소를 필터링하는 데 도움이 될 수 있습니다.

Run this example to see how `takeWhile()` and `skipWhile()` can split an `Iterable` containing numbers.

이 예제를 실행하여 takeWhile()과 skipWhile()이 숫자를 포함하는 Iterable을 나누는 방법을 확인하세요.

```dart
void main() {
  const numbers = [1, 3, -2, 0, 4, 5];

  var numbersUntilZero = numbers.takeWhile((number) => number != 0);
  print('Numbers until 0: $numbersUntilZero');

  var numbersStartingAtZero = numbers.skipWhile((number) => number != 0);
  print('Numbers starting at 0: $numbersStartingAtZero');
}
```

```
Numbers until 0: (1, 3, -2)
Numbers starting at 0: (0, 4, 5)
```

In this example, `takeWhile()` returns an `Iterable` that contains all the elements before the one that satisfies the predicate. On the other hand, `skipWhile()` returns an `Iterable` that contains all elements after and including the first one that _doesn't_ satisfy the predicate.

이 예제에서, takeWhile()은 조건을 만족하는 첫 번째 요소 이전의 모든 요소를 포함하는 Iterable을 반환합니다. 반면에, skipWhile()은 조건을 만족하지 않는 첫 번째 요소를 포함하여 이후의 모든 요소를 포함하는 Iterable을 반환합니다.

After running the example, change `takeWhile()` to take elements until it reaches the first negative number.

예제를 실행한 후에는, takeWhile()을 첫 번째 음수 숫자에 도달할 때까지 요소를 가져오도록 변경해 보세요.


```dart 
var numbersUntilNegative =
    numbers.takeWhile((number) => !number.isNegative);
```

Notice that the condition `number.isNegative` is negated with `!`.

알림: 조건 number.isNegative가 !로 부정됩니다.

### Exercise: Filtering elements from a list

### 연습: 리스트에서 요소 필터링하기

The following exercise provides practice using the `where()` method with the class `User` from the previous exercise.

Use `where()` to implement two functions:

- Part 1: Implement `filterOutUnder21()`.
    - Return an `Iterable` containing all users of age 21 or more.
- Part 2: Implement `findShortNamed()`.
    - Return an `Iterable` containing all users with names of length 3 or less.

다음 연습은 이전 연습의 클래스인 User를 사용하여 where() 메서드를 사용하는 연습을 제공합니다.

where()를 사용하여 두 가지 함수를 구현하세요:

- 부분 1: filterOutUnder21() 구현하기 나이가 21세 이상인 모든 사용자를 포함하는 Iterable을 반환하세요. 
- 부분 2: findShortNamed() 구현하기 이름이 3자 이하인 모든 사용자를 포함하는 Iterable을 반환하세요.

```dart
Iterable<User> filterOutUnder21(Iterable<User> users) {
  // TODO: Implement the filterOutUnder21 function.
}

Iterable<User> findShortNamed(Iterable<User> users) {
  // TODO: Implement the findShortNamed function.
}

class User {
  final String name;
  final int age;

  User(
    this.name,
    this.age,
  );
}

// The following code is used to provide feedback on your solution.
// There is no need to read or modify it.
void main() {
  final users = [
    User('Alice', 21),
    User('Bob', 17),
    User('Claire', 52),
    User('Dan', 12),
  ];

  try {
    final out = filterOutUnder21(users);
    if (out.any((user) => user.age < 21) || out.length != 2) {
      print(
        'Looks like `filterOutUnder21` is wrong, there are '
        'exactly two users with age under 21. Keep trying!',
      );
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `filterOutUnder21`, but received an error. '
      'Did you implement the function?',
    );
    return;
  } catch (e) {
    print(
      'Tried running `filterOutUnder21`, '
      'but received an exception: ${e.runtimeType}',
    );
    return;
  }

  try {
    final out = findShortNamed(users);
    if (out.any((user) => user.name.length > 3) || out.length != 2) {
      print(
        'Looks like `findShortNamed` is wrong, there are '
        'exactly two users with a three letter name. Keep trying!',
      );
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `findShortNamed`, but received an error. '
      'Did you implement the function?',
    );
    return;
  } catch (e) {
    print(
      'Tried running `findShortNamed`, '
      'but received an exception: ${e.runtimeType}',
    );
    return;
  }

  print('Success. All tests passed!');
}
```

Hint

Remember to take advantage of the `where` method from the `Iterable` class. For help and examples using `where`, refer to the [earlier discussion of it](https://dart.dev/codelabs/iterables#example-using-where).

기억하세요! Iterable 클래스의 where 메서드를 활용하세요. where에 대한 도움과 예제는 앞서 그에 대해 논의된 부분을 참고하세요.

Solution

```dart
Iterable<User> filterOutUnder21(Iterable<User> users) {
  return users.where((user) => user.age >= 21);
}

Iterable<User> findShortNamed(Iterable<User> users) {
  return users.where((user) => user.name.length <= 3);
}
```

Quick review

- Filter the elements of an `Iterable` with `where()`.
- The output of `where()` is another `Iterable`.
- Use `takeWhile()` and `skipWhile()` to obtain elements until or after a condition is met.
- The output of these methods can be an empty `Iterable`.

빠른 복습

- Iterable의 요소를 where()를 사용하여 필터링합니다.
- where()의 출력은 다른 Iterable입니다.
- takeWhile() 및 skipWhile()을 사용하여 조건이 충족될 때까지 또는 이후의 요소를 얻을 수 있습니다.
- 이러한 메서드의 출력은 빈 Iterable일 수 있습니다.

## Mapping

## 매핑

Mapping `Iterables` with the method `map()` enables you to apply a function over each of the elements, replacing each element with a new one.

map() 메서드를 사용하여 Iterable을 매핑하면 각 요소에 함수를 적용하여 각 요소를 새로운 요소로 대체할 수 있습니다.

```dart
Iterable<int> output = numbers.map((number) => number * 10);
```

In this example, each element of the `Iterable` numbers is multiplied by 10.

이 예제에서 Iterable numbers의 각 요소는 10으로 곱해집니다.

You can also use `map()` to transform an element into a different object—for example, to convert all `int` to `String`, as you can see in the following example:

또한 map()을 사용하여 요소를 다른 객체로 변환할 수도 있습니다. 예를 들어 모든 int를 String으로 변환할 수 있습니다. 다음 예제에서 확인할 수 있습니다:

```dart
Iterable<String> output = numbers.map((number) => number.toString());
```

### Note

`map()` returns a _lazy_ `Iterable`, meaning that the supplied function is called only when the elements are iterated.

### 참고 

map()은 게으른 Iterable을 반환합니다. 즉, 제공된 함수는 요소가 반복될 때만 호출됩니다.

### Example: Using map to change elements

Run this example to see how to use `map()` to multiply all the elements of an `Iterable` by 2. What do you think the output will be?

### 예제: map을 사용하여 요소 변경하기

이 예제를 실행하여 Iterable의 모든 요소를 2로 곱하는 방법을 확인하세요. 출력 결과는 무엇이라고 생각하십니까?

```dart
void main() {
  var numbersByTwo = const [1, -2, 3, 42].map((number) => number * 2);
  print('Numbers: $numbersByTwo');
}
```

```
Numbers: (2, -4, 6, 84)
```

### Exercise: Mapping to a different type

In the previous example, you multiplied the elements of an `Iterable` by 2. Both the input and the output of that operation were an `Iterable` of `int`.

In this exercise, your code takes an `Iterable` of `User`, and you need to return an `Iterable` that contains strings containing each user's name and age.

Each string in the `Iterable` must follow this format: `'{name} is {age}'`—for example `'Alice is 21'`.

### 연습: 다른 타입으로 매핑하기

이전 예제에서는 Iterable의 요소를 2로 곱했습니다. 해당 작업의 입력 및 출력은 모두 int의 Iterable이었습니다.

이 연습에서는 사용자의 Iterable을 가져와서 각 사용자의 이름과 나이가 포함된 문자열을 반환해야 합니다.

Iterable의 각 문자열은 다음 형식을 따라야 합니다: '{name} is {age}'—예를 들어 'Alice is 21'.

Hint

Remember to take advantage of the `map` method from the `Iterable` class. For help and examples using `map`, refer to the [earlier discussion of it](https://dart.dev/codelabs/iterables#example-using-map-to-change-elements).

To concatenate multiple values into a single string, consider using [string interpolation](https://dart.dev/language/built-in-types#string-interpolation).

기억하세요! Iterable 클래스의 map 메서드를 활용하세요. map을 사용한 도움과 예제는 앞서 그에 대해 논의된 부분을 참고하세요.

여러 값을 하나의 문자열로 연결하기 위해 문자열 보간을 고려해 보세요.

Solution

```dart
Iterable<String> getNameAndAges(Iterable<User> users) {
  return users.map((user) => '${user.name} is ${user.age}');
}
```

Quick review

- `map()` applies a function to all the elements of an `Iterable`.
- The output of `map()` is another `Iterable`.
- The function isn't evaluated until the `Iterable` is iterated.

빠른 복습

- map()은 Iterable의 모든 요소에 함수를 적용합니다.
- map()의 출력은 다른 Iterable입니다.
- 함수는 Iterable이 반복될 때까지 평가되지 않습니다.

## Exercise: Putting it all together

## 연습: 모든 것을 함께 사용하기

It's time to practice what you learned, in one final exercise.

This exercise provides the class `EmailAddress`, which has a constructor that takes a string. Another provided function is `isValidEmailAddress()`, which tests whether an email address is valid.

이제 마지막 연습에서 배운 내용을 실습할 시간입니다.

이 연습에서는 문자열을 사용하여 EmailAddress 클래스를 제공합니다. 이 클래스에는 문자열을 인수로 받는 생성자가 있습니다. 또한 이메일 주소가 유효한지 테스트하는 isValidEmailAddress() 함수가 제공됩니다.

| Constructor/function  | Type signature                           | Description                                             |
| --------------------- | ---------------------------------------- | ------------------------------------------------------- |
| EmailAddress()        | `EmailAddress(String address)`           | Creates an `EmailAddress` for the specified address.    |
| isValidEmailAddress() | `bool isValidEmailAddress(EmailAddress)` | Returns `true` if the provided `EmailAddress` is valid. |

| 생성자/함수                | 타입 시그니처                                  | 설명                                    |
| --------------------- | ---------------------------------------- | ------------------------------------- |
| EmailAddress()        | `EmailAddress(String address)`           | 지정된 주소에 대한 EmailAddress를 생성합니다.       |
| isValidEmailAddress() | `bool isValidEmailAddress(EmailAddress)` | 제공된 EmailAddress가 유효한 경우 true를 반환합니다. |

Write the following code:

Part 1: Implement `parseEmailAddresses()`.

- Write the function `parseEmailAddresses()`, which takes an `Iterable<String>` containing email addresses, and returns an `Iterable<EmailAddress>`.
- Use the method `map()` to map from a `String` to `EmailAddress`.
- Create the `EmailAddress` objects using the constructor `EmailAddress(String)`.

Part 2: Implement `anyInvalidEmailAddress()`.

- Write the function `anyInvalidEmailAddress()`, which takes an `Iterable<EmailAddress>` and returns `true` if any `EmailAddress` in the `Iterable` isn't valid.
- Use the method `any()` together with the provided function `isValidEmailAddress()`.

Part 3: Implement `validEmailAddresses()`.

- Write the function `validEmailAddresses()`, which takes an `Iterable<EmailAddress>` and returns another `Iterable<EmailAddress>` containing only valid addresses.
- Use the method `where()` to filter the `Iterable<EmailAddress>`.
- Use the provided function `isValidEmailAddress()` to evaluate whether an `EmailAddress` is valid.

부분 1: parseEmailAddresses() 구현

parseEmailAddresses() 함수를 작성합니다. 이 함수는 이메일 주소를 포함하는 `Iterable<String>`을 받아들이고, `Iterable<EmailAddress>`를 반환합니다. map() 메서드를 사용하여 String을 EmailAddress로 매핑합니다. EmailAddress 객체는 생성자 EmailAddress(String)를 사용하여 생성합니다.

부분 2: anyInvalidEmailAddress() 구현

anyInvalidEmailAddress() 함수를 작성합니다. 이 함수는 `Iterable<EmailAddress>`를 받아들이고, Iterable 내에 있는 모든 EmailAddress가 유효하지 않은 경우 true를 반환합니다. any() 메서드를 isValidEmailAddress() 함수와 함께 사용합니다.

부분 3: validEmailAddresses() 구현

validEmailAddresses() 함수를 작성합니다. 이 함수는 `Iterable<EmailAddress>`를 받아들이고, 유효한 주소만 포함하는 다른 `Iterable<EmailAddress>`를 반환합니다. where() 메서드를 사용하여 `Iterable<EmailAddress>`를 필터링합니다. isValidEmailAddress() 함수를 사용하여 EmailAddress가 유효한지 평가합니다.

Solution
```dart
Iterable<EmailAddress> parseEmailAddresses(Iterable<String> strings) {
  return strings.map((s) => EmailAddress(s));
}

bool anyInvalidEmailAddress(Iterable<EmailAddress> emails) {
  return emails.any((email) => !isValidEmailAddress(email));
}

Iterable<EmailAddress> validEmailAddresses(Iterable<EmailAddress> emails) {
  return emails.where((email) => isValidEmailAddress(email));
}
```
#  Generics

If you look at the API documentation for the basic array type, [`List`](https://api.dart.dev/stable/dart-core/List-class.html), you'll see that the type is actually `List<E>`. The <...> notation marks List as a _generic_ (or _parameterized_) type—a type that has formal type parameters. [By convention](https://dart.dev/effective-dart/design#do-follow-existing-mnemonic-conventions-when-naming-type-parameters), most type variables have single-letter names, such as E, T, S, K, and V.

만약 기본 배열 타입인 List의 API 문서를 살펴보면, 해당 타입이 실제로 `List<E>`라는 것을 알 수 있습니다. <...> 표기법은 List를 제네릭(또는 매개변수화된) 타입으로 표시하며, 이는 공식적인 타입 매개변수를 포함하는 타입입니다. 대부분의 경우, 타입 변수는 E, T, S, K, V와 같은 단일 문자 이름으로 지정됩니다.

## Why use generics?

Generics are often required for type safety, but they have more benefits than just allowing your code to run:

- Properly specifying generic types results in better generated code.
- You can use generics to reduce code duplication.

If you intend for a list to contain only strings, you can declare it as `List<String>` (read that as "list of string"). That way you, your fellow programmers, and your tools can detect that assigning a non-string to the list is probably a mistake. Here's an example:

## 왜 제네릭을 사용해야 하나요?

제네릭은 종종 타입 안전성을 보장하기 위해 필요하지만, 코드를 실행할 수 있게 해주는 것 이상의 이점이 있습니다.

제네릭 타입을 올바르게 지정하면 더 나은 생성된 코드가 생성됩니다. 코드 중복을 줄이기 위해 제네릭을 사용할 수 있습니다. 만약 리스트가 문자열만 포함하도록 의도한다면, `List<String>` (이를 "문자열의 리스트"로 읽습니다)로 선언할 수 있습니다. 이렇게 하면, 여러분과 동료 프로그래머, 그리고 여러분의 도구가 리스트에 문자열이 아닌 값을 할당하는 것은 아마도 실수일 것이라 감지할 수 있습니다. 다음은 예시입니다:


``` dart 
//✗ static analysis: failuredart
var names = <String>[];
names.addAll(['Seth', 'Kathy', 'Lars']);
names.add(42); // Error
```


Another reason for using generics is to reduce code duplication. Generics let you share a single interface and implementation between many types, while still taking advantage of static analysis. For example, say you create an interface for caching an object:

제네릭을 사용하는 또 다른 이유는 코드 중복을 줄이기 위함입니다. 제네릭을 사용하면 많은 타입 사이에서 단일 인터페이스와 구현을 공유할 수 있으면서도 정적 분석의 이점을 살릴 수 있습니다. 예를 들어, 객체를 캐싱하는 인터페이스를 생성한다고 가정해보겠습니다:

```dart
abstract class ObjectCache {
  Object getByKey(String key);
  void setByKey(String key, Object value);
}
```

You discover that you want a string-specific version of this interface, so you create another interface:

이 인터페이스의 문자열에 특화된 버전이 필요하다는 것을 발견하여, 다른 인터페이스를 생성합니다:

```dart 
abstract class StringCache {
  String getByKey(String key);
  void setByKey(String key, String value);
}
```


Later, you decide you want a number-specific version of this interface... You get the idea.

Generic types can save you the trouble of creating all these interfaces. Instead, you can create a single interface that takes a type parameter:

나중에, 이 인터페이스의 숫자에 특화된 버전이 필요하다고 결정합니다... 이해하셨죠.

제네릭 타입을 사용하면 이러한 인터페이스를 모두 만드는 불편함을 덜어줄 수 있습니다. 대신, 타입 매개변수를 사용하는 단일 인터페이스를 생성할 수 있습니다:

``` dart 
abstract class Cache<T> {
  T getByKey(String key);
  void setByKey(String key, T value);
}
```

In this code, T is the stand-in type. It's a placeholder that you can think of as a type that a developer will define later.

이 코드에서 T는 대리 타입입니다. 이는 나중에 개발자가 정의할 타입으로 생각할 수 있는 플레이스홀더입니다.

## Using collection literals

List, set, and map literals can be parameterized. Parameterized literals are just like the literals you've already seen, except that you add `<type>` (for lists and sets) or `<keyType, valueType>` (for maps) before the opening bracket. Here is an example of using typed literals:

## 컬렉션 리터럴 사용하기

List, set 및 map 리터럴은 매개변수화될 수 있습니다. 매개변수화된 리터럴은 이미 보았던 리터럴과 똑같지만, 여는 대괄호 앞에 `<type>` (리스트와 셋의 경우) 또는 `<keyType, valueType>` (맵의 경우)를 추가합니다. 다음은 타입 지정된 리터럴을 사용하는 예시입니다:

```dart
var names = <String>['Seth', 'Kathy', 'Lars'];
var uniqueNames = <String>{'Seth', 'Kathy', 'Lars'};
var pages = <String, String>{
  'index.html': 'Homepage',
  'robots.txt': 'Hints for web robots',
  'humans.txt': 'We are people, not machines'
};
```
## Using parameterized types with constructors


To specify one or more types when using a constructor, put the types in angle brackets (`<...>`) just after the class name. For example:

생성자에서 하나 이상의 타입을 지정하려면 클래스 이름 바로 뒤에 꺾쇠 괄호(<...>)에 타입을 넣어주면 됩니다. 예를 들어:

```dart 
var nameSet = Set<String>.from(names);
```

The following code creates a map that has integer keys and values of type View:

다음 코드는 정수 키와 View 타입의 값으로 이루어진 맵을 생성합니다:

```dart 
var views = Map<int, View>();
```
## Generic collections and the types they contain

Dart generic types are _reified_, which means that they carry their type information around at runtime. For example, you can test the type of a collection:

## 제네릭 컬렉션과 그들이 포함하는 타입

Dart의 제네릭 타입은 실체화됩니다(reified). 이는 실행 시간에 타입 정보를 가지고 있다는 것을 의미합니다. 예를 들어, 컬렉션의 타입을 테스트할 수 있습니다:

```dart 
var names = <String>[];
names.addAll(['Seth', 'Kathy', 'Lars']);
print(names is List<String>); // true
```

### Note

In contrast, generics in Java use _erasure_, which means that generic type parameters are removed at runtime. In Java, you can test whether an object is a List, but you can't test whether it's a `List<String>`.

### 참고 
반면에, Java의 제네릭은 erasure를 사용합니다. 이는 제네릭 타입 매개변수가 실행 시간에 제거된다는 것을 의미합니다. Java에서는 객체가 List인지 여부를 테스트할 수 있지만, `List<String>`인지 테스트할 수는 없습니다.

## Restricting the parameterized type

When implementing a generic type, you might want to limit the types that can be provided as arguments, so that the argument must be a subtype of a particular type. You can do this using `extends`.

## 매개변수화된 타입을 제한하는 것

제네릭 타입을 구현할 때 특정 타입의 하위 타입만이 인수로 제공될 수 있도록 제한하고 싶을 때가 있습니다. 이를 위해 extends를 사용할 수 있습니다.

A common use case is ensuring that a type is non-nullable by making it a subtype of `Object` (instead of the default, [`Object?`](https://dart.dev/null-safety/understanding-null-safety#top-and-bottom)).

한 가지 흔한 사용 사례는 기본값인 Object? 대신에 타입을 Object의 하위 타입으로 만들어서 타입이 널이 아닌 것을 보장하는 것입니다.


```dart
class Foo<T extends Object> {
  // Any type provided to Foo for T must be non-nullable.
}
```

You can use `extends` with other types besides `Object`. Here's an example of extending `SomeBaseClass`, so that members of `SomeBaseClass` can be called on objects of type `T`:

`Object` 이외의 다른 타입에 대해 `extends` 키워드를 사용할 수 있습니다. 다음은 `SomeBaseClass`를 확장하는 예입니다. 이렇게 하면 `SomeBaseClass`의 멤버들을 `T` 타입의 객체에서 호출할 수 있습니다.

```dart
class Foo<T extends SomeBaseClass> {
  // Implementation goes here...
  String toString() => "Instance of 'Foo<$T>'";
}

class Extender extends SomeBaseClass {...}
```

It's OK to use `SomeBaseClass` or any of its subtypes as the generic argument:

SomeBaseClass나 그 하위 타입 중 하나를 제네릭 인자로 사용하는 것은 괜찮습니다.

```dart
var someBaseClassFoo = Foo<SomeBaseClass>();
var extenderFoo = Foo<Extender>();
```

It's also OK to specify no generic argument:

제네릭 인자를 지정하지 않는 것도 괜찮습니다.

```dart
var foo = Foo();
print(foo); // Instance of 'Foo<SomeBaseClass>'
```

Specifying any non-`SomeBaseClass` type results in an error:

SomeBaseClass 이외의 모든 타입을 지정하는 것은 오류를 발생시킵니다.

```dart 
// ✗ static analysis: failuredart
var foo = Foo<Object>();
```


## Using generic methods

Methods and functions also allow type arguments:

## 제네릭 메서드 사용하기

메서드와 함수도 타입 인자를 허용합니다.

```dart 
T first<T>(List<T> ts) {
  // Do some initial work or error checking, then...
  T tmp = ts[0];
  // Do some additional checking or processing...
  return tmp;
}
```


Here the generic type parameter on `first` (`<T>`) allows you to use the type argument `T` in several places:

- In the function's return type (`T`).
- In the type of an argument (`List<T>`).
- In the type of a local variable (`T tmp`).

여기서 첫 번째의 제네릭 타입 매개변수 (`<T>`)는 여러 곳에서 타입 인자 T를 사용할 수 있게 합니다:

- 함수의 반환 타입(T). 
- 인수의 타입(`List<T>`). 
- 로컬 변수의 타입(T tmp).
