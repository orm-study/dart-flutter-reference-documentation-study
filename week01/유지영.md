# Iterable collections

🔗 [[페이지 링크]](https://dart.dev/libraries/collections/iterables)

## What are collections? 컬렉션이란?

🔗 [[pub.dev] collection package](https://pub.dev/packages/collection)

**A collection is an object that represents a group of objects, which are called _elements_. Iterables are a kind of collection.**

컬렉션은 ‘요소’라고 불리는 객체들의 그룹을 대표하는 객체이다. Iterables는 collection의 한 종류이다.

**A collection can be empty, or it can contain many elements. Depending on the purpose, collections can have different structures and implementations. These are some of the most common collection types:**

collection은 비어있을 수 있고 또한 많은 요소(elements)가 포함될 수도 있다. 목적에 따라 collections의 구조와 구현이다를 수 있다. 이것은 가장 흔히 사용되는 collection types의 일부이다:

**List**

-   [**List:](https://api.dart.dev/stable/dart-core/List-class.html) Used to read elements by their indexes.** List: index들이 있는 요소(elements)를 읽는데 사용
-   순서가 있는 요소들의 집합, 각 요소는 인덱스를 통해 접근 가능

```dart
List<String> fruitsList = ['lime', 'strawberry', 'cherry', 'pear', 'grape'];

```

**Set**

-   [**Set:](https://api.dart.dev/stable/dart-core/Set-class.html) Used to contain elements that can occur only once.** Set: 딱 한번 생길 수 있는 요소(elements)를 포함하는데 사용
-   중복되지 않는 요소들의 집합. 순서가 중요하지 않음

```dart
Set<String> fruitsSet = {'lime', 'strawberry', 'cherry', 'pear', 'grape'};

```

**Map**

-   [**Map:](https://api.dart.dev/stable/dart-core/Map-class.html) Used to read elements using a key.** Map: key를 사용하여 요소(elements)를 읽는데 사용
-   키와 값의 쌍으로 이루어진 집합. 각 키는 고유하며, 이를 통해 값에 접근

```dart
Map<String, int> fruitPrices = {'lime': 1000, 'strawberry': 3000, 'cherry': 8000, 'pear': 5000, 'grape': 3000};

```

## What is an Iterable? Iterable이란?

-   **[note] Iterable**
    
    ### **Iterable<E> class** (abstract) (mixin) [🔗](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html)
    
    **A collection of values, or “elements”, that can be accessed sequentially.**
    
    순차적으로 접근할 수 있는 값 또는 “요소”들의 컬렉션.
    
    <aside> 💭 **배열과의 차이점** 순차적, 한번에 하나씩에 초점이 맞춰진 추상 클래스이다. Swift와 다른 점은 `Iterator` 임에도 index Access가 가능하도록 메소드가 구현되어 있다고 한다. (Dart)
    
    </aside>
    
    **The elements of the iterable are accessed by getting an [Iterator](https://api.dart.dev/stable/3.4.3/dart-core/Iterator-class.html) using the [iterator](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/iterator.html) getter, and using it to step through the values. Stepping with the iterator is done by calling [Iterator.moveNext](https://api.dart.dev/stable/3.4.3/dart-core/Iterator/moveNext.html), and if the call returns `true`, the iterator has now moved to the next element, which is then available as [Iterator.current](https://api.dart.dev/stable/3.4.3/dart-core/Iterator/current.html). If the call returns `false`, there are no more elements. The [Iterator.current](https://api.dart.dev/stable/3.4.3/dart-core/Iterator/current.html) value must only be used when the most recent call to [Iterator.moveNext](https://api.dart.dev/stable/3.4.3/dart-core/Iterator/moveNext.html) has returned `true`. If it is used before calling [Iterator.moveNext](https://api.dart.dev/stable/3.4.3/dart-core/Iterator/moveNext.html) the first time on an iterator, or after a call has returned false or has thrown an error, reading [Iterator.current](https://api.dart.dev/stable/3.4.3/dart-core/Iterator/current.html) may throw or may return an arbitrary value.**
    
    Iterable의 요소들은 iterator 게터를 사용하여 Iterator를 얻고, 이를 통해 값을 순차적으로 접근합니다. Iterator를 사용하여 순회하는 것은 Iterator.moveNext를 호출함으로써 이루어지며, 호출이 true를 반환하면 iterator가 다음 요소로 이동하게 되며, 이 요소는 Iterator.current로 접근할 수 있습니다. 호출이 false를 반환하면 더 이상 요소가 없는 것입니다. Iterator.current 값은 최근의 Iterator.moveNext 호출이 true를 반환한 경우에만 사용해야 합니다. 만약 iterator에서 처음으로 Iterator.moveNext를 호출하기 전에, 또는 호출이 false를 반환했거나 오류를 발생시킨 후에 Iterator.current를 사용하면, 임의의 값을 반환하거나 예외가 발생할 수 있습니다.
    
    <aside> 💭 [요약] Iterator.moveNext를 호출하여 순차적으로 접근하는 것 Iterator.moveNext 호출이 true를 반환하면 다음 요소로 이동, 이 요소는 Iterator.current로 접근 가능 더이상 요소가 없다면 Iterator.moveNext 호출이 false를 반환
    
    [주의] Iterator.moveNext 최초 호출 전, 또는 호출이 false를 반환, 오류 발생 후 Iterator.current 사용 시 임의의 값 반환 혹은 예외 발생
    
    </aside>
    
    ### 예시 코드 작성
    
    -   Iterator.moveNext로 다음 요소에 접근하고, Iterator.current를 통해 현재 요소에 접근하는 코드 작성
    
    ```dart
    void main() {
    	// String 타입을 담는 List 변수
      List<String> fruits = ['lime', 'strawberry', 'cherry', 'pear', 'grape'];
      // fruits.iterator 사용하여 iterator 생성
      Iterator<String> iterator = fruits.iterator;
    
      // Iterator.moveNext()를 호출하여 요소를 순회
      // 다음 요소가 있을 시 true 반환, 없을 시 false 반환되며 while loop 종료
      while (iterator.moveNext()) {
        print(iterator.current); // 현재 요소를 출력
      }
    }
    
    ```
    
    ```dart
    // 출력 결과
    lime
    strawberry
    cherry
    pear
    grape
    
    ```
    
    -   moveNext를 호출하기 전에 current를 사용하려고 하거나, moveNext가 false를 반환한 후에 current를 사용하려고 할 때 예시 코드
    
    ```dart
    void main() {
      List<String> fruits = ['lime', 'strawberry', 'cherry', 'pear', 'grape'];
      Iterator<String> iterator = fruits.iterator;
    
      // Iterator.moveNext()를 호출하기 전에 Iterator.current를 사용하려고 할 때
      try {
        print(iterator.current);
      } catch (error) {
        print('error message: $error');
      }
    }
    
    ```
    
    ```dart
    // 출력 결과
    // 어떤 변수나 값이 null일 가능성이 있는데 이를 String으로 변환하려고 할 때 발생
    error message: type 'Null' is not a subtype of type 'String' in type cast
    
    ```
    
    -   해결 방안
        
        null 상태에 대한 예외처리
        
    
    ```dart
    void main() {
      List<String> fruits = ['lime', 'strawberry', 'cherry', 'pear', 'grape'];
      Iterator<String> iterator = fruits.iterator;
    
      try {
        while (iterator.moveNext()) {
          print(iterator.current);
        }
      } catch (error) {
        print('error message: $error');
      }
    }
    
    ```
    
    ```dart
    // 출력 결과
    lime
    strawberry
    cherry
    pear
    grape
    
    ```
    
    **You can create more than one iterator from the same `Iterable`. Each time `iterator` is read, it returns a new iterator, and different iterators can be stepped through independently, each giving access to all the elements of the iterable. The iterators of the same iterable _should_ provide the same values in the same order (unless the underlying collection is modified between the iterations, which some collections allow).**
    
    같은 Iterable에서 하나 이상의 iterator를 생성할 수 있습니다. iterator를 읽을 때마다 새로운 iterator를 반환하며, 각 iterator는 독립적으로 순차적으로 접근할 수 있고, 각 iterator는 Iterable의 모든 요소에 접근할 수 있습니다. 동일한 Iterable의 iterator는 동일한 순서로 동일한 값을 제공해야 합니다(반복 사이에 기본 컬렉션이 수정되지 않는 한, 일부 컬렉션에서는 이를 허용합니다).
    
    **You can also iterate over the elements of an `Iterable` using the for-in loop construct, which uses the `iterator` getter behind the scenes. For example, you can iterate over all of the keys of a [Map](https://api.dart.dev/stable/3.4.3/dart-core/Map-class.html), because `Map` keys are iterable.**
    
    또한, for-in 루프 구문을 사용하여 Iterable의 요소를 반복할 수도 있으며, 이는 내부적으로 iterator 게터를 사용합니다. 예를 들어, Map의 모든 키를 반복할 수 있습니다. 왜냐하면 Map의 키들은 iterable이기 때문입니다.
    
    ```dart
    void main() {
      var kidsBooks = {
      // key : value
        'Matilda': 'Roald Dahl',
        'Green Eggs and Ham': 'Dr Seuss',
        'Where the Wild Things Are': 'Maurice Sendak'
      };
    
      for (var book in kidsBooks.keys) {
        print('$book was written by ${kidsBooks[book]}');
      }
    }
    
    // Matilda was written by Roald Dahl
    // Green Eggs and Ham was written by Dr Seuss
    // Where the Wild Things Are was written by Maurice Sendak
    
    ```
    
    **The [List](https://api.dart.dev/stable/3.4.3/dart-core/List-class.html) and [Set](https://api.dart.dev/stable/3.4.3/dart-core/Set-class.html) classes are both `Iterable`, as are most classes in the `dart:collection` library.**
    
    리스트(List)와 집합(Set) 클래스는 모두 Iterable이며, dart:collection 라이브러리의 대부분의 클래스도 그렇습니다.
    
    **Some [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html) collections can be modified. Adding an element to a `List` or `Set` will change which elements it contains, and adding a new key to a `Map` changes the elements of [Map.keys](https://api.dart.dev/stable/3.4.3/dart-core/Map/keys.html). Iterators created after the change will provide the new elements, and may or may not preserve the order of existing elements (for example, a [HashSet](https://api.dart.dev/stable/3.4.3/dart-collection/HashSet-class.html) may completely change its order when a single element is added).**
    
    일부 Iterable 컬렉션은 수정할 수 있습니다. 리스트나 집합에 요소를 추가하면 포함된 요소가 변경되며, 맵에 새로운 키를 추가하면 Map.keys의 요소가 변경됩니다. 변경 후 생성된 이터레이터는 새로운 요소를 제공하며, 기존 요소의 순서를 유지할 수도 있고 그렇지 않을 수도 있습니다(예를 들어, HashSet은 단일 요소가 추가될 때 순서가 완전히 변경될 수 있습니다).
    
    **Changing a collection _while_ it is being iterated is generally _not_ allowed. Doing so will break the iteration, which is typically signalled by throwing a [ConcurrentModificationError](https://api.dart.dev/stable/3.4.3/dart-core/ConcurrentModificationError-class.html) the next time [Iterator.moveNext](https://api.dart.dev/stable/3.4.3/dart-core/Iterator/moveNext.html) is called. The current value of [Iterator.current](https://api.dart.dev/stable/3.4.3/dart-core/Iterator/current.html) getter should not be affected by the change in the collection, the `current` value was set by the previous call to [Iterator.moveNext](https://api.dart.dev/stable/3.4.3/dart-core/Iterator/moveNext.html).**
    
    컬렉션이 반복되는 동안 변경하는 것은 일반적으로 허용되지 않습니다. 그렇게 하면 반복이 깨지며, 이는 다음에 Iterator.moveNext가 호출될 때 ConcurrentModificationError를 던짐으로써 신호가 전달됩니다. 컬렉션의 변경은 현재 값에 영향을 미치지 않아야 하며, 현재 값은 이전의 Iterator.moveNext 호출에 의해 설정되었습니다.
    
    **Some iterables compute their elements dynamically every time they are iterated, like the one returned by [Iterable.generate](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/Iterable.generate.html) or the iterable returned by a `sync*` generator function. If the computation doesn't depend on other objects that may change, then the generated sequence should be the same one every time it's iterated.**
    
    일부 Iterable은 반복될 때마다 요소를 동적으로 계산합니다. 예를 들어, Iterable.generate 또는 sync* 생성기 함수에 의해 반환된 Iterable이 그렇습니다. 계산이 변경될 수 있는 다른 객체에 의존하지 않는다면, 생성된 시퀀스는 반복될 때마다 동일해야 합니다.
    
    **The members of `Iterable`, other than `iterator` itself, work by looking at the elements of the iterable. This can be implemented by running through the [iterator](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/iterator.html), but some classes may have more efficient ways of finding the result (like [last](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/last.html) or [length](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/length.html) on a [List](https://api.dart.dev/stable/3.4.3/dart-core/List-class.html), or [contains](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/contains.html) on a [Set](https://api.dart.dev/stable/3.4.3/dart-core/Set-class.html)).**
    
    이터레이터 자체를 제외한 Iterable의 멤버들은 Iterable의 요소를 살펴보며 동작합니다. 이는 이터레이터를 통해 실행함으로써 구현될 수 있지만, 일부 클래스는 더 효율적인 방법으로 결과를 찾을 수 있습니다(예: 리스트의 last 또는 length, 집합의 contains).
    
    **The methods that return another `Iterable` (like [map](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/map.html) and [where](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/where.html)) are all _lazy_ - they will iterate the original (as necessary) every time the returned iterable is iterated, and not before.**
    
    다른 Iterable을 반환하는 메서드들(map과 where 등)은 모두 지연(lazy) 실행됩니다. 반환된 Iterable이 반복될 때마다 필요에 따라 원본을 반복하며, 그 전에는 실행되지 않습니다.
    
    **Since an iterable may be iterated more than once, it's not recommended to have detectable side-effects in the iterator. For methods like [map](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/map.html) and [where](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/where.html), the returned iterable will execute the argument function on every iteration, so those functions should also not have side effects.**
    
    Iterable은 여러 번 반복될 수 있으므로, 이터레이터에 감지 가능한 부작용이 있는 것은 권장되지 않습니다. map과 where와 같은 메서드의 경우, 반환된 Iterable은 반복할 때마다 인수로 전달된 함수를 실행하므로, 이러한 함수들도 부작용을 가져서는 안 됩니다.
    
    **The `Iterable` declaration provides a default implementation, which can be extended or mixed in to implement the `Iterable` interface. It implements every member other than the [iterator](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/iterator.html) getter, using the [Iterator](https://api.dart.dev/stable/3.4.3/dart-core/Iterator-class.html) provided by [iterator](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/iterator.html). An implementation of the `Iterable` interface should provide a more efficient implementation of the members of `Iterable` when it can do so.**
    
    Iterable 선언은 기본 구현을 제공하며, 이는 확장되거나 혼합되어 Iterable 인터페이스를 구현할 수 있습니다. 이 구현은 iterator 게터를 제외한 모든 멤버를, iterator가 제공하는 Iterator를 사용하여 구현합니다. Iterable 인터페이스의 구현은 가능할 때 Iterable 멤버들의 더 효율적인 구현을 제공해야 합니다.
    
    -   [Implementers]
        
        • [DoubleLinkedQueue](https://api.dart.dev/stable/3.4.3/dart-collection/DoubleLinkedQueue-class.html) • [LinkedList](https://api.dart.dev/stable/3.4.3/dart-collection/LinkedList-class.html) • [List](https://api.dart.dev/stable/3.4.3/dart-core/List-class.html) • [ListQueue](https://api.dart.dev/stable/3.4.3/dart-collection/ListQueue-class.html) • [Queue](https://api.dart.dev/stable/3.4.3/dart-collection/Queue-class.html) • [Runes](https://api.dart.dev/stable/3.4.3/dart-core/Runes-class.html) • [Set](https://api.dart.dev/stable/3.4.3/dart-core/Set-class.html) • [SplayTreeSet](https://api.dart.dev/stable/3.4.3/dart-collection/SplayTreeSet-class.html)
        
    -   [Available Extensions]
        
        • [EnumByName](https://api.dart.dev/stable/3.4.3/dart-core/EnumByName.html) • [FutureIterable](https://api.dart.dev/stable/3.4.3/dart-async/FutureIterable.html) • [IterableExtensions](https://api.dart.dev/stable/3.4.3/dart-collection/IterableExtensions.html) • [NullableIterableExtensions](https://api.dart.dev/stable/3.4.3/dart-collection/NullableIterableExtensions.html)
        
    -   [Properties]
        
        -   [**first**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/first.html) → E
            
            The first element. 첫 번째 요소입니다. (no setter)
            
        -   [_hashCode_](https://api.dart.dev/stable/3.4.3/dart-core/Object/hashCode.html) → [int](https://api.dart.dev/stable/3.4.3/dart-core/int-class.html)
            
            The hash code for this object. 이 객체의 해시 코드입니다. (no setter) (inherited)
            
        -   [**isEmpty**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/isEmpty.html) → [bool](https://api.dart.dev/stable/3.4.3/dart-core/bool-class.html)
            
            Whether this collection has no elements. 이 컬렉션에 요소가 없는지 여부입니다. (no setter)
            
        -   [**isNotEmpty**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/isNotEmpty.html) → [bool](https://api.dart.dev/stable/3.4.3/dart-core/bool-class.html)
            
            Whether this collection has at least one element. 이 컬렉션에 최소 하나의 요소가 있는지 여부입니다. (no setter)
            
        -   [**iterator**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/iterator.html) → [Iterator](https://api.dart.dev/stable/3.4.3/dart-core/Iterator-class.html)<E>
            
            A new `Iterator` that allows iterating the elements of this `Iterable`. 이 Iterable의 요소를 반복할 수 있는 새로운 Iterator입니다. (no setter)
            
        -   [**last**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/last.html) → E
            
            The last element. 마지막 요소입니다. (no setter)
            
        -   [**length**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/length.html) → [int](https://api.dart.dev/stable/3.4.3/dart-core/int-class.html)
            
            The number of elements in [this](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html). 이 컬렉션의 요소 수입니다. (no setter)
            
        -   [_runtimeType_](https://api.dart.dev/stable/3.4.3/dart-core/Object/runtimeType.html) → [Type](https://api.dart.dev/stable/3.4.3/dart-core/Type-class.html)
            
            A representation of the runtime type of the object. 객체의 런타임 타입을 나타내는 표현입니다. (no setter) (inherited)
            
        -   [**single**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/single.html) → E
            
            Checks that this iterable has only one element, and returns that element. 이 iterable이 단 하나의 요소만 가지고 있는지 확인하고, 그 요소를 반환합니다. (no setter)
            
    -   [Methods]
        
        -   [**any**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/any.html)([bool](https://api.dart.dev/stable/3.4.3/dart-core/bool-class.html) test(E element)) → [bool](https://api.dart.dev/stable/3.4.3/dart-core/bool-class.html)
            
            **Checks whether any element of this iterable satisfies `test`.**
            
            이 iterable의 어떤 요소가 테스트를 만족하는지 여부를 확인합니다.
            
        -   [**cast**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/cast.html)<R>() → [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html)<R>
            
            **A view of this iterable as an iterable of `R` instances.**
            
            이 iterable을 R 인스턴스로 이루어진 iterable로 변환합니다.
            
        -   [**contains**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/contains.html)([Object](https://api.dart.dev/stable/3.4.3/dart-core/Object-class.html)? element) → [bool](https://api.dart.dev/stable/3.4.3/dart-core/bool-class.html)
            
            **Whether the collection contains an element equal to `element`.**
            
            컬렉션에 주어진 요소와 동일한 요소가 포함되어 있는지 여부를 확인합니다.
            
        -   [**elementAt**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/elementAt.html)([int](https://api.dart.dev/stable/3.4.3/dart-core/int-class.html) index) → E
            
            **Returns the `index`th element.**
            
            인덱스에 해당하는 요소를 반환합니다.
            
        -   [**every**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/every.html)([bool](https://api.dart.dev/stable/3.4.3/dart-core/bool-class.html) test(E element)) → [bool](https://api.dart.dev/stable/3.4.3/dart-core/bool-class.html)
            
            **Checks whether every element of this iterable satisfies `test`.**
            
            이 iterable의 모든 요소가 테스트를 만족하는지 여부를 확인합니다.
            
        -   [**expand**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/expand.html)<T>([Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html)<T> toElements(E element)) → [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html)<T>
            
            **Expands each element of this [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html) into zero or more elements.**
            
            이 Iterable의 각 요소를 0개 이상의 요소로 확장합니다.
            
        -   [**firstWhere**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/firstWhere.html)([bool](https://api.dart.dev/stable/3.4.3/dart-core/bool-class.html) test(E element), {E orElse()?}) → E
            
            **The first element that satisfies the given predicate `test`.**
            
            주어진 조건을 만족하는 첫 번째 요소를 반환합니다.
            
        -   [**fold**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/fold.html)<T>(T initialValue, T combine(T previousValue, E element)) → T
            
            **Reduces a collection to a single value by iteratively combining each element of the collection with an existing value**
            
            컬렉션의 각 요소를 기존 값과 반복적으로 결합하여 단일 값으로 줄입니다.
            
        -   [**followedBy**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/followedBy.html)([Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html)<E> other) → [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html)<E>
            
            **Creates the lazy concatenation of this iterable and `other`.**
            
            이 iterable과 다른 iterable의 게으른 연결을 생성합니다.
            
        -   [**forEach**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/forEach.html)(void action(E element)) → void
            
            **Invokes `action` on each element of this iterable in iteration order.**
            
            이 iterable의 각 요소에 대해 동작을 수행합니다.
            
        -   [**join**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/join.html)([[String](https://api.dart.dev/stable/3.4.3/dart-core/String-class.html) separator = ""]) → [String](https://api.dart.dev/stable/3.4.3/dart-core/String-class.html)
            
            **Converts each element to a [String](https://api.dart.dev/stable/3.4.3/dart-core/String-class.html) and concatenates the strings.**
            
            각 요소를 문자열로 변환하고 문자열을 연결합니다.
            
        -   [**lastWhere**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/lastWhere.html)([bool](https://api.dart.dev/stable/3.4.3/dart-core/bool-class.html) test(E element), {E orElse()?}) → E
            
            **The last element that satisfies the given predicate `test`.**
            
            주어진 조건을 만족하는 마지막 요소를 반환합니다.
            
        -   [**map**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/map.html)<T>(T toElement(E e)) → [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html)<T>
            
            **The current elements of this iterable modified by `toElement`.**
            
            이 iterable의 현재 요소를 `toElement`로 수정합니다.
            
        -   [_noSuchMethod_](https://api.dart.dev/stable/3.4.3/dart-core/Object/noSuchMethod.html)([Invocation](https://api.dart.dev/stable/3.4.3/dart-core/Invocation-class.html) invocation) → dynamic
            
            **Invoked when a nonexistent method or property is accessed.**
            
            존재하지 않는 메서드나 속성에 접근할 때 호출됩니다. (inherited)
            
        -   [**reduce**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/reduce.html)(E combine(E value, E element)) → E
            
            **Reduces a collection to a single value by iteratively combining elements of the collection using the provided function.**
            
            제공된 함수를 사용하여 컬렉션의 요소를 반복적으로 결합하여 단일 값으로 줄입니다.
            
        -   [**singleWhere**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/singleWhere.html)([bool](https://api.dart.dev/stable/3.4.3/dart-core/bool-class.html) test(E element), {E orElse()?}) → E
            
            **The single element that satisfies `test`.**
            
            테스트를 만족하는 유일한 요소를 반환합니다.
            
        -   [**skip**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/skip.html)([int](https://api.dart.dev/stable/3.4.3/dart-core/int-class.html) count) → [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html)<E>
            
            **Creates an [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html) that provides all but the first `count` elements.**
            
            첫 번째 `count` 요소를 제외한 모든 요소를 제공하는 Iterable을 생성합니다.
            
        -   [**skipWhile**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/skipWhile.html)([bool](https://api.dart.dev/stable/3.4.3/dart-core/bool-class.html) test(E value)) → [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html)<E>
            
            **Creates an `Iterable` that skips leading elements while `test` is satisfied.**
            
            테스트가 만족되는 동안 선행 요소를 건너뛰는 Iterable을 생성합니다.
            
        -   [**take**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/take.html)([int](https://api.dart.dev/stable/3.4.3/dart-core/int-class.html) count) → [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html)<E>
            
            **Creates a lazy iterable of the `count` first elements of this iterable.**
            
            이 iterable의 첫 번째 `count` 요소의 게으른 iterable을 생성합니다.
            
        -   [**takeWhile**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/takeWhile.html)([bool](https://api.dart.dev/stable/3.4.3/dart-core/bool-class.html) test(E value)) → [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html)<E>
            
            **Creates a lazy iterable of the leading elements satisfying `test`.**
            
            테스트를 만족하는 선행 요소의 게으른 iterable을 생성합니다.
            
        -   [**toList**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/toList.html)({[bool](https://api.dart.dev/stable/3.4.3/dart-core/bool-class.html) growable = true}) → [List](https://api.dart.dev/stable/3.4.3/dart-core/List-class.html)<E>
            
            **Creates a [List](https://api.dart.dev/stable/3.4.3/dart-core/List-class.html) containing the elements of this [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html).**
            
            이 Iterable의 요소를 포함하는 List를 생성합니다.
            
        -   [**toSet**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/toSet.html)() → [Set](https://api.dart.dev/stable/3.4.3/dart-core/Set-class.html)<E>
            
            **Creates a [Set](https://api.dart.dev/stable/3.4.3/dart-core/Set-class.html) containing the same elements as this iterable.**
            
            이 iterable과 동일한 요소를 포함하는 Set을 생성합니다.
            
        -   [**toString**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/toString.html)() → [String](https://api.dart.dev/stable/3.4.3/dart-core/String-class.html)
            
            **Returns a string representation of (some of) the elements of `this` .**
            
            요소의 (일부 또는 전부의) 문자열 표현을 반환합니다. (override)
            
        -   [**where**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/where.html)([bool](https://api.dart.dev/stable/3.4.3/dart-core/bool-class.html) test(E element)) → [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html)<E>
            
            **Creates a new lazy [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html) with all elements that satisfy the predicate `test`.**
            
            테스트를 만족하는 모든 요소로 새로운 게으른 Iterable을 생성합니다.
            
        -   [**whereType**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/whereType.html)<T>() → [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html)<T>
            
            **Creates a new lazy [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html) with all elements that have type `T`.**
            
            타입 T를 가진 모든 요소로 새로운 게으른 Iterable을 생성합니다.
            
    -   [Operator]
        
        -   [_operator ==_](https://api.dart.dev/stable/3.4.3/dart-core/Object/operator_equals.html)([Object](https://api.dart.dev/stable/3.4.3/dart-core/Object-class.html) other) → [bool](https://api.dart.dev/stable/3.4.3/dart-core/bool-class.html)
            
            The equality operator. 동등연산자 (inherited)
            
    -   [Static Methods]
        
        -   [**castFrom**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/castFrom.html)<S, T>([Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html) source) → [Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html)<T>
            
            **Adapts `source` to be an `Iterable<T>`.**
            
            source를 Iterable로 변환합니다.
            
        -   [**iterableToFullString**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/iterableToFullString.html)([Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html) iterable, [[String](https://api.dart.dev/stable/3.4.3/dart-core/String-class.html) leftDelimiter = '(', [String](https://api.dart.dev/stable/3.4.3/dart-core/String-class.html) rightDelimiter = ')']) → [String](https://api.dart.dev/stable/3.4.3/dart-core/String-class.html)
            
            **Converts an `Iterable` to a string.**
            
            Iterable을 문자열로 변환합니다.
            
        -   [**iterableToShortString**](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/iterableToShortString.html)([Iterable](https://api.dart.dev/stable/3.4.3/dart-core/Iterable-class.html) iterable, [[String](https://api.dart.dev/stable/3.4.3/dart-core/String-class.html) leftDelimiter = '(', [String](https://api.dart.dev/stable/3.4.3/dart-core/String-class.html) rightDelimiter = ')']) → [String](https://api.dart.dev/stable/3.4.3/dart-core/String-class.html)
            
            **Convert an `Iterable` to a string like [Iterable.toString](https://api.dart.dev/stable/3.4.3/dart-core/Iterable/toString.html).**
            
            Iterable을 Iterable.toString과 유사하게 문자열로 변환합니다.
            
    
    ----------
    
-   **[note] collection, Iterate, Iterator 간단 용어 설명**
    
    -   **collection :** 연속적으로 접근할 수 있는 것
    -   **Iterate :** 컴퓨터 처리 절차를 반복하다 라는 뜻의 단어
    -   **Iterator :** (프로그래밍에서) 반복자라는 뜻, 순회를 수행하는 역할
        -   객체 지향 프로그래밍에서 Iterator(반복자)는 배열이나 그와 유사한 자료 구조의 내부 요소를 순회하는 객체를 표현한다.
    
    > collection의 설명 중 Iterable 단어가 들어있는 대부분의 collection들은 모두 순서가 있고 순차적으로 접근이 가능하다.
    
    <aside> ⚠️ error : ‘~~ is not iterable ~~’
    
    코드 로직 상황에서 Iterable의 성격을 띄는 로직인데 그렇지 않은 것이 들어있을 경우 주로 발생
    
    </aside>
    
-   **[note] collection 이란?**
    
    ----------
    
    여러 개의 객체를 모아놓은 자료 구조이다. Dart에서는 다양한 타입의 컬렉션이 존재하며, List, Set, Map 등이 그 예다. 이러한 컬렉션들은 각각의 요소를 저장하고 관리할 수 있는 데이터 구조를 제공한다.
    
    **특징**
    
    -   **저장**: 여러 개의 객체를 하나의 변수에 저장할 수 있다.
    -   **관리**: 요소의 추가, 삭제, 검색 등의 작업을 효율적으로 처리할 수 있다.
    -   **반복**: 각 요소에 순차적으로 접근하여 작업을 수행할 수 있다.
    
    **Dart에서의 Collection**
    
    Dart에서는 Iterable 인터페이스를 통해 이러한 컬렉션들을 순회할 수 있는 기능을 제공한다. for-in 루프나 다른 반복 구조를 통해 각 요소에 접근할 수 있다.
    
    ```dart
    void main() {
    	List<String> fruitsList = ['lime', 'strawberry', 'cherry', 'pear', 'grape'];
    
      for (String fruit in fruits) {
        print(fruit);
      }
    }
    
    ```
    
    ----------
    
-   **[note] Iterable과 Iterator의 차이와 Collection의 특징**
    
    Iterable은 순차적으로 접근 가능한 요소들의 집합이며, Iterator는 그 요소들을 하나씩 순회할 수 있는 도구이다. Iterable 객체에서 iterator 속성을 사용하면 iterator 객체가 반환되며, 이 객체를 사용하여 컬렉션의 모든 요소를 순회할 수 있습니다.
    
    ### Iterable
    
    `Iterable`은 반복할 수 있는 요소들의 컬렉션을 나타내는 인터페이스입니다. `Iterable` 객체는 iterator 메서드를 제공하여 `Iterator`를 반환합니다. 이는 `for-in` 루프나 다른 반복 작업에서 사용될 수 있습니다.
    
    **주요 기능**:
    
    -   iterator(): Iterator 객체를 반환합니다.
    -   forEach, map, where 등의 메서드를 제공하여 요소들을 처리할 수 있습니다.
    
    ### **Iterator**
    
    `Iterator`는 `Iterable`의 요소들을 하나씩 순차적으로 접근하는 인터페이스입니다. `Iterator`는 상태를 가지며, `moveNext` 메서드를 사용하여 다음 요소로 이동하고, `current` 속성을 사용하여 현재 요소를 반환합니다.
    
    **주요 기능**:
    
    -   moveNext(): 이터레이터를 다음 요소로 이동시키며, 다음 요소가 있으면 true를 반환하고, 없으면 false를 반환합니다.
    -   current: 현재 요소를 반환합니다. moveNext가 true를 반환한 경우에만 유효합니다.
    
    ### Iterable과 Iterator의 차이를 보여주는 예제
    
    **`Iterable`은 전체 컬렉션을 나타내며, `Iterator`는 이 컬렉션의 요소를 순차적으로 접근하는 도구**이다. `Iterable`을 통해 `Iterator`를 얻어서 요소들을 순회할 수 있다.
    
    ```dart
    void main() {
      // Iterable을 생성
      List<String> fruits = ['lime', 'strawberry', 'cherry', 'pear', 'grape'];
      
      // Iterable의 각 요소를 for-in 루프를 통해 순회
      // List타입은 Iterable을 구현하고 있어 for-in loop를 사용하여 리스트의 모든 요소를 순회할 수 있다.
      for (String fruit in fruits) {
    	  print('for-in문 시작');
        print(fruit);
      }
    
      // Iterable에서 Iterator를 생성
      Iterator<String> iterator = fruits.iterator;
    
      // Iterator를 사용하여 요소들을 순회
      while (iterator.moveNext()) {
      	print('moveNext() 시작');
        print(iterator.current);
      }
    }
    
    ```
    
    **Iterable**
    
    -   컬렉션의 요소들을 순회할 수 있는 객체를 제공하며, iterator 메서드를 통해 Iterator를 반환한다.
        
    -   Iterable 인터페이스는 iterator라는 메서드를 정의한다. 이 메서드는 Iterator 객체를 반환한다. Iterator 객체를 사용하면 컬렉션의 요소들을 하나씩 접근할 수 있다.
        
        ```dart
        abstract class Iterable<E> {
          Iterator<E> get iterator;
        }
        
        ```
        
    
    **Iterator**
    
    -   Iterable의 요소들을 하나씩 순차적으로 접근하며, moveNext와 current를 통해 요소를 탐색합니다.

**An `Iterable` is a collection of elements that can be accessed sequentially.**

Iterable 은 연속적/순차적으로 입력된 요소의 collection이다.

**In Dart, an `Iterable` is an abstract class, meaning that you can't instantiate it directly. However, you can create a new `Iterable` by creating a new `List` or `Set`.**

Dart에서, Iterable은 추상 클래스이며, 당신이 직접 인스턴스화 할 수 없는 것을 의미한다. 그러나, 당신은 새로운 List 혹은 Set을 생성하여 새로운 Iterable을 생성할 수 있다.

**Both `List` and `Set` are `Iterable`, so they have the same methods and properties as the `Iterable` class.**

List와 Set 둘 다 Iterable이므로, 그들은 Iterable 클래스와 같은 메서드와 속성을 가지고 있다.

**A `Map` uses a different data structure internally, depending on its implementation. For example, [HashMap](https://api.dart.dev/stable/dart-collection/HashMap-class.html) uses a hash table in which the elements (also called _values_) are obtained using a key. Elements of a `Map` can also be read as `Iterable` objects by using the map's `entries` or `values` property.**

Map은 구현 방식에 따라 내부적으로 다른 데이터 구조를 사용한다. 예를 들어, HashMap 은 요소(값이라고도 함)를 키를 사용하여 얻는 해쉬테이블을 사용한다. Map의 요소는 entries 또는 values 속성을 사용하여 Iterable 객체로 읽을 수 있다.

-   **[Q] map은 Iterable 이 아닌건가?**
    
    Dart에서 map 자체는 Iterable을 구현하지 않지만, map의 일부 속성(keys, values, entries)은 Iterable을 구현하고, 이를 통해 Map의 각 요소를 반복(iterate)할 수 있다.
    
    **Dart Map 클래스의 Iterable 속성**
    
    • **keys**: 맵의 모든 키를 포함하는 Iterable<K>를 반환
    
    • **values**: 맵의 모든 값을 포함하는 Iterable<V>를 반환
    
    • **entries**: 맵의 모든 키-값 쌍을 포함하는 Iterable<MapEntry<K, V>>를 반환
    
    ```dart
    void main() {
      // Map 생성
      Map<String, int> scores = {
        'Alice': 90,
        'Bob': 85,
        'Charlie': 92,
      };
    
      // Map 자체는 Iterable이 아님
      // for (var item in scores) {
      //   print(item); // 오류 발생: 'Map<String, int>'는 'Iterable'을 구현하지 않음
      // }
    
      // Map의 keys 속성은 Iterable임
      print('Keys:');
      for (var key in scores.keys) {
        print('Key: $key');
      }
    
      // Map의 values 속성은 Iterable임
      print('Values:');
      for (var value in scores.values) {
        print('Value: $value');
      }
    
      // Map의 entries 속성은 Iterable임
      print('Entries:');
      for (var entry in scores.entries) {
        print('Key: ${entry.key}, Value: ${entry.value}');
      }
    }
    
    ```
    
    ```dart
    // 출력결과
    Keys:
    Key: Alice
    Key: Bob
    Key: Charlie
    Values:
    Value: 90
    Value: 85
    Value: 92
    Entries:
    Key: Alice, Value: 90
    Key: Bob, Value: 85
    Key: Charlie, Value: 92
    
    ```
    

**This example shows a `List` of `int`, which is also an `Iterable` of `int`:**

다음 예제는 int의 List이며, 이는 또한 int의 Iterable이다:

```dart
Iterable<int> iterable = [1, 2, 3];

```

**The difference with a `List` is that with the `Iterable`, you can't guarantee that reading elements by index will be efficient. `Iterable`, as opposed to `List`, doesn't have the `[]` operator.**

Iterable과 List의 주요 차이점은, 당신이 요소를 인덱스로 읽는 것이 효율적일 것 이라 보장할 수 없다는 것이다. List와 다르게 Iterable은 [ ] 연산자를 가지고 있지 않는다.

**For example, consider the following code, which is invalid:**

예를 들면, 다음 코드를 고려하면, 이것은 유효하지 않는 코드이다.

```dart
Iterable<int> iterable = [1, 2, 3];
int value = iterable[1];

```

**If you read elements with `[]`, the compiler tells you that the operator `'[]'` isn't defined for the class `Iterable`, which means that you can't use `[index]` in this case.**

인덱스로 요소를 읽으려고 [ ]를 사용하면, 컴파일러는 `[ ]` 연산자가 클래스 Iterable에 대해 정의되지 않았다고 알린다. 이것은 이 경우에 [index]를 사용할 수 없다는 것을 의미한다.

**You can instead read elements with `elementAt()`, which steps through the elements of the iterable until it reaches that position.**

대신에, 요소를 읽으려면 elementAt()을 사용할 수 있다. 이 메서드는 Iterable의 요소를 순차적으로 탐색하여 해당 위치에 도달한다.

```dart
Iterable<int> iterable = [1, 2, 3];
int value = iterable.elementAt(1); // 2

```

**Continue to the next section to learn more about how to access elements of an `Iterable`.**

다음 섹션으로 이동하여 Iterable의 요소에 접근하는 방법에 대해 더 알아보자.

## Reading elements 요소 읽기

**You can read the elements of an iterable sequentially, using a `for-in` loop.**

for-in 루프를 사용하여 Iterable의 요소를 순차적으로 읽을 수 있다.

### Example: Using a for-in loop

예시: for-in 루프 사용하기

**The following example shows you how to read elements using a `for-in` loop.**

다음 예제는 for-in 루프를 사용하여 요소를 읽는 방법을 보여준다.

```dart
void main() {
  const iterable = ['Salad', 'Popcorn', 'Toast'];
  for (final element in iterable) {
    print(element);
  }
}

// Salad
// Popcorn
// Toast

```

ℹ️ **Details 세부사항**

**Behind the scenes, the `for-in` loop uses an _iterator._ You rarely see the [Iterator API](https://api.dart.dev/stable/dart-core/Iterator-class.html) used directly, however, because `for-in` is easier to read and understand, and is less prone to errors.**

for-in 루프는 내부적으로 이터레이터(iterator)를 사용한다. 하지만 for-in 루프가 더 읽기 쉽고 이해하기 쉬우며, 오류 발생 가능성이 적기 때문에 Iterator API를 직접 사용하는 경우는 거의 없다.

**Key terms 주요 용어**

-   **Iterable: The Dart [Iterable](https://api.dart.dev/stable/dart-core/Iterable-class.html) class.**
    
    **Iterable**: Dart의 Iterable 클래스
    
-   **Iterator: An object used by `for-in` to read elements from an `Iterable` object.**
    
    **Iterator**: for-in 루프에서 Iterable 객체의 요소를 읽는 데 사용되는 객체
    
-   **`for-in` loop**: An easy way to sequentially read elements from an `Iterable`.
    
    **for-in loop**: Iterable에서 요소를 순차적으로 읽는 쉬운 방법.
    

### **Example: Using first and last** 예시: 첫 번째와 마지막 요소 사용하기

**In some cases, you want to access only the first or the last element of an `Iterable`.**

일부 경우에는 Iterable의 첫 번째 또는 마지막 요소에만 접근하고 싶을 수 있다.

**With the `Iterable` class, you can't access the elements directly, so you can't call `iterable[0]` to access the first element. Instead, you can use `first`, which gets the first element.**

Iterable 클래스에서는 요소에 직접 접근할 수 없으므로 첫 번째 요소에 접근하기 위해 iterable[0]을 호출할 수 없다. 대신에, 첫 번째 요소를 가져오는 first를 사용할 수 있다.

-   **[Q] Iterable은 요소에 직접 접근할 수 없다?**
    
    Iterable 클래스에서는 요소에 직접 접근할 수 없다. 요소에 접근하려면 Iterator를 사용해야 한다. Iterable 자체는 요소를 순회할 수 있는 방법을 제공하지만, 요소에 직접 접근하는 인덱스를 제공하지는 않는다. 요소에 접근하려면 Iterator를 통해 하나씩 순차적으로 접근해야 한다.
    
    그러나, List와 같은 일부 Iterable을 구현하는 클래스는 인덱스를 사용하여 요소에 접근할 수 있는 방법을 제공하고 있다.
    
    **List에서 요소에 직접 접근하는 방법**
    
    List는 Iterable을 구현하면서 인덱스를 통해 요소에 직접 접근할 수 있는 기능을 추가로 제공
    
    ```dart
    void main() {
      List<String> fruitsList = ['lime', 'strawberry', 'cherry', 'pear', 'grape'];
    
      // 인덱스를 사용하여 요소에 직접 접근
      print(fruits[0]); // lime
      print(fruits[1]); // strawberry
      print(fruits[2]); // cherry
    
      // for 루프를 사용하여 요소에 접근
      for (int i = 0; i < fruits.length; i++) {
        print(fruits[i]);
      }
    }
    
    ```
    

**Also, with the `Iterable` class, you can't use the operator `[]` to access the last element, but you can use the `last` property.**

또한, Iterable 클래스에서는 [] 연산자를 사용하여 마지막 요소에 접근할 수 없지만, last 속성을 사용할 수 있다.

⚠️ **Warning 주의**

**Because accessing the last element of an `Iterable` requires stepping through all the other elements, `last` can be slow. Using `first` or `last` on an empty `Iterable` results in a [StateError.](https://api.dart.dev/stable/dart-core/StateError-class.html)**

Iterable의 마지막 요소에 접근하려면 모든 다른 요소를 순차적으로 탐색해야 하므로, last는 느릴 수 있다. 빈 Iterable에서 first 또는 last를 사용하면 StateError가 발생한다.

```dart
void main() {
  Iterable<String> iterable = const ['Salad', 'Popcorn', 'Toast'];
  print('The first element is ${iterable.first}');
  // The first element is Salad
  print('The last element is ${iterable.last}');
  // The last element is Toast
}

```

**In this example you saw how to use `first` and `last` to get the first and last elements of an `Iterable`. It's also possible to find the first element that satisfies a condition. The next section shows how to do that using a method called `firstWhere()`.**

이 예제에서는 Iterable의 첫 번째 요소와 마지막 요소를 가져오기 위해 first와 last를 사용하는 방법을 보았다. 특정 조건을 만족하는 첫 번째 요소를 찾는 것도 가능하다. 다음 섹션에서는 firstWhere()라는 메서드를 사용하여 이를 수행하는 방법을 보여준다.

### **Example: Using firstWhere()**[#](https://dart.dev/codelabs/iterables#example-using-firstwhere) **firstWhere() 사용하기**

**You already saw that you can access the elements of an `Iterable` sequentially, and you can easily get the first or last element.**

이미 Iterable의 요소에 순차적으로 접근할 수 있으며, 첫 번째 또는 마지막 요소를 쉽게 얻을 수 있다는 것을 보았다.

**Now, you learn how to use `firstWhere()` to find the first element that satisfies certain conditions. This method requires you to pass a _predicate_, which is a function that returns true if the input satisfies a certain condition.**

이제, 특정 조건을 만족하는 첫 번째 요소를 찾기 위해 firstWhere()를 사용하는 방법을 배운다. 이 메서드는 입력이 특정 조건을 만족하면 true를 반환하는 함수를 인자로 받는다.

```dart
String element = iterable.firstWhere((element) => element.length > 5);

```

**For example, if you want to find the first `String` that has more than 5 characters, you must pass a predicate that returns true when the element size is greater than 5.**

예를 들어, 길이가 5자보다 큰 첫 번째 문자열을 찾고 싶다면, 요소의 크기가 5보다 클 때 true를 반환하는 조건 함수를 전달해야 한다.

**Run the following example to see how `firstWhere()` works. Do you think all the functions will give the same result?**

다음 예제를 실행하여 firstWhere()가 어떻게 작동하는지 확인해 보자. 모든 함수가 같은 결과를 줄 것이라고 생각하는가?

```dart
bool predicate(String item) {
  return item.length > 5;
}

void main() {
  const items = ['Salad', 'Popcorn', 'Toast', 'Lasagne'];

  // You can find with a simple expression:
  var foundItem1 = items.firstWhere((item) => item.length > 5);
  print('foundItem1 : $foundItem1');
  // foundItem1 : Popcorn

  // Or try using a function block:
  var foundItem2 = items.firstWhere((item) {
    return item.length > 5;
  });
  print('foundItem2 : $foundItem2');
  // foundItem2 : Popcorn

  // Or even pass in a function reference:
  var foundItem3 = items.firstWhere(predicate);
  print('foundItem3 : $foundItem3');
  // foundItem3 : Popcorn

  // You can also use an `orElse` function in case no value is found!
  var foundItem4 = items.firstWhere(
    (item) => item.length > 10,
    orElse: () => 'None!',
  );
  print('foundItem4 : $foundItem4');
  // foundItem4 : None!
}

```

**In this example, you can see three different ways to write a predicate:**

이 예제에서는 조건 함수를 세 가지 다른 방식으로 작성하는 방법을 볼 수 있다:

-   **As an expression: The test code has one line that uses arrow syntax (`=>`).**
    
    표현식으로 작성: 테스트 코드는 화살표 구문(=>)을 사용하여 한 줄로 작성된다.
    
-   **As a block: The test code has multiple lines between brackets and a return statement.**
    
    블록으로 작성: 테스트 코드는 중괄호 사이에 여러 줄로 작성되며, return 문을 포함한다.
    
-   **As a function: The test code is in an external function that's passed to the `firstWhere()` method as a parameter.**
    
    함수로 작성: 테스트 코드는 외부 함수로 작성되며, 이 함수가 firstWhere() 메서드에 매개변수로 전달된다.
    

**There is no right or wrong way. Use the way that works best for you, and that makes your code easier to read and understand.**

올바른 방법과 잘못된 방법은 없다. 자신에게 가장 잘 맞고, 코드가 더 읽기 쉽고 이해하기 쉬운 방법을 사용하면 된다.

**The final example calls `firstWhere()` with the optional named parameter `orElse`, which provides an alternative when an element isn't found. In this case, the text `'None!'` is returned because no element satisfies the provided condition.**

마지막 예제는 선택적 명명된 매개변수인 orElse를 사용하여 firstWhere()를 호출한다. 이는 조건에 맞는 요소가 없을 때 대안을 제공한다. 이 경우, 제공된 조건을 만족하는 요소가 없기 때문에 ’None!’이 반환된다.

-   **[Q] orElse ?**
    
    orElse는 callBack 함수이다. 콜백 함수는 **특정 이벤트나 조건이 발생했을 때 호출되는 함수**로 위의 예제에선 `firstWhere()` 메서드에서 `orElse`는 조건을 만족하는 요소가 없을 때 호출되는 함수로, 반환할 값을 제공한다.
    

ℹ️ **Note 참고**

**If no element satisfies the test predicate and the `orElse` parameter isn't provided, then `firstWhere()` throws a [StateError.](https://api.dart.dev/stable/dart-core/StateError-class.html)**

조건 함수를 만족하는 요소가 없고 orElse 매개변수가 제공되지 않으면, firstWhere()는 StateError를 발생시킨다.

-   **[note] StateError 나는지 확인**
    
    ```dart
      var foundItem4 = items.firstWhere(
            (item) => item.length > 10,
        // orElse: () => 'None!',
      );
      print('foundItem4 : $foundItem4');
      // foundItem4 : None!
    
    ```
    
    ```dart
    // 출력 결과
    Unhandled exception:
    Bad state: No element
    #0      ListBase.firstWhere (dart:collection/list.dart:132:5)
    #1      main (package:study_0508/study_iterable_2.dart:26:26)
    #2      _delayEntrypointInvocation.<anonymous closure> (dart:isolate-patch/isolate_patch.dart:297:19)
    #3      _RawReceivePort._handleMessage (dart:isolate-patch/isolate_patch.dart:184:12)
    
    ```
    

### **Quick review 빠른 복습**

-   **The elements of an `Iterable` must be accessed sequentially.**
    
    Iterable의 요소는 순차적으로 접근해야 한다.
    
-   **The easiest way to iterate through all the elements is using a `for-in` loop.**
    
    모든 요소를 반복하는 가장 쉬운 방법은 for-in 루프를 사용하는 것이다.
    
-   **You can use the `first` and `last` getters to get the first and last elements.**
    
    첫 번째와 마지막 요소를 가져오기 위해 first와 last 게터를 사용할 수 있다.
    
-   **You can also find the first element that satisfies a condition with `firstWhere()`.**
    
    특정 조건을 만족하는 첫 번째 요소를 찾기 위해 firstWhere()를 사용할 수 있다.
    
-   **You can write test predicates as expressions, blocks, or functions.**
    
    조건 함수(predicates)를 표현식, 블록, 또는 함수로 작성할 수 있다.
    
    ### **Key terms: 주요 용어:**
    
-   **Predicate: A function that returns `true` when a certain condition is satisfied.**
    
    Predicate: 특정 조건이 만족되면 true를 반환하는 함수.
    

### **Exercise: Practice writing a test predicate**[#](https://dart.dev/codelabs/iterables#exercise-practice-writing-a-test-predicate) **연습: 테스트 조건 함수 작성 연습**

**The following exercise is a failing unit test that contains a partially complete code snippet. Your task is to complete the exercise by writing code to make the tests pass. You don't need to implement `main()`.**

다음 연습은 부분적으로 완성된 코드 스니펫이 포함된 실패하는 단위 테스트이다. 여러분의 과제는 테스트를 통과시키기 위해 코드를 작성하는 것이다. main() 함수를 구현할 필요는 없다.

**This exercise introduces `singleWhere()` This method works similarly to `firstWhere()`, but in this case it expects only one element of the `Iterable` to satisfy the predicate. If more than one or no element in the `Iterable` satisfies the predicate condition, then the method throws a [StateError](https://api.dart.dev/stable/dart-core/StateError-class.html) exception.**

이 연습에서는 singleWhere() 메서드를 소개한다. 이 메서드는 firstWhere()와 유사하게 작동하지만, Iterable의 요소 중 오직 하나만 조건을 만족해야 한다. Iterable에서 조건을 만족하는 요소가 하나 이상이거나 하나도 없으면, 메서드는 StateError 예외를 발생시킨다.

**⚠️ Warning 경고 `singleWhere()` steps through the whole `Iterable` until the last element, which can cause problems if the `Iterable` is infinite or contains a large collection of elements.**

singleWhere()는 마지막 요소까지 Iterable 전체를 순회하므로, Iterable이 무한하거나 많은 요소를 포함하고 있으면 문제가 발생할 수 있다.

**Your goal is to implement the predicate for `singleWhere()` that satisfies the following conditions:**

여러분의 목표는 singleWhere()를 위한 조건 함수를 구현하는 것이다. 조건은 다음과 같다:

-   **The element contains the character `'a'`.**
    
    요소에 문자 ‘a’가 포함되어야 한다.
    
-   **The element starts with the character `'M'`.**
    
    요소가 문자 ‘M’으로 시작해야 한다.
    

**All the elements in the test data are [strings](https://api.dart.dev/stable/dart-core/String-class.html); you can check the class documentation for help.**

테스트 데이터의 모든 요소는 문자열이다. 도움을 위해 클래스 문서를 참조할 수 있다.

```dart
// Implement the predicate of singleWhere
// with the following conditions
// * The element contains the character `'a'`
// * The element starts with the character `'M'`
String singleWhere(Iterable<String> items) {
  return items.singleWhere(
		  // item.startsWith('M')은 리스트의 각 요소가 ‘M’으로 시작하는지 확인
		  // item.contains('a') 리스트의 각 요소에 ‘a’가 포함되어 있는지 확인
		  // orElse는 조건을 만족하는 요소가 없을 때 호출될 함수로, 'None!'을 반환
      (items) => items.startsWith('M') && items.contains('a'),
      orElse: () => 'None!');
}

// The following code is used to provide feedback on your solution.
// There is no need to read or modify it.
void main() {
  const items = [
    'Salad',
    'Popcorn',
    'Milk',
    'Toast',
    'Sugar',
    'Mozzarella',
    'Tomato',
    'Egg',
    'Water',
  ];

  try {
    final str = singleWhere(items);
    if (str == 'Mozzarella') {
      print('Success. All tests passed!');
    } else {
      print(
        'Tried calling singleWhere, but received $str instead of '
        'the expected value \\'Mozzarella\\'',
      );
    }
  } on StateError catch (stateError) {
    print(
      'Tried calling singleWhere, but received a StateError: ${stateError.message}. '
      'singleWhere will fail if 0 or many elements match the predicate.',
    );
  } on UnimplementedError {
    print(
      'Tried running `singleWhere`, but received an error. '
      'Did you implement the function?',
    );
  } catch (e) {
    print('Tried calling singleWhere, but received an exception: $e');
  }
}

```

```dart
// 출력 결과
Success. All tests passed!

```

## **Checking conditions**[#](https://dart.dev/codelabs/iterables#checking-conditions) 조건 확인

**When working with `Iterable`, sometimes you need to verify that all the elements of a collection satisfy some condition.**

Iterable을 사용할 때, 컬렉션의 모든 요소가 특정 조건을 만족하는지 확인해야 하는 경우가 있다.

**You might be tempted to write a solution using a `for-in` loop like this one:**

for-in 루프를 사용하여 다음과 같이 해결하고 싶을 수 있다:

**bad:**

```dart
for (final item in items) {
  if (item.length < 5) {
    return false;
  }
}
return true;

```

**However, you can accomplish the same using the `every()` method:**

그러나, 동일한 작업을 every() 메서드를 사용하여 달성할 수 있다:

```dart
return items.every((item) => item.length >= 5);

```

**Using the `every()` method results in code that is more readable, compact, and less error-prone.**

every() 메서드를 사용하면 코드가 더 읽기 쉽고, 간결하며, 오류 발생 가능성이 적다.

### **Example: Using any() and every()**[#](https://dart.dev/codelabs/iterables#example-using-any-and-every)

**The `Iterable` class provides two methods that you can use to verify conditions:**

Iterable 클래스는 조건을 확인하기 위해 사용할 수 있는 두 가지 메서드를 제공한다:

-   **`any()`: Returns true if at least one element satisfies the condition.**
    
    any(): 최소한 하나의 요소가 조건을 만족하면 true를 반환한다.
    
-   **`every()`: Returns true if all elements satisfy the condition.**
    
    every(): 모든 요소가 조건을 만족하면 true를 반환한다.
    

**Run this exercise to see them in action.**

이 연습을 실행하여 실제로 작동하는 것을 확인해보자.

```dart
void main() {
  const items = ['Salad', 'Popcorn', 'Toast'];

  if (items.any((item) => item.contains('a'))) {
    print('At least one item contains "a"');
  }

  if (items.every((item) => item.length >= 5)) {
    print('All items have length >= 5');
  }
}

```

```dart
// 출력 결과
At least one item contains "a"
All items have length >= 5

```

**In the example, `any()` verifies that at least one element contains the character `a`, and `every()` verifies that all elements have a length equal to or greater than 5.**

예제에서 any()는 최소한 하나의 요소가 문자 ‘a’를 포함하는지 확인하고, every()는 모든 요소의 길이가 5 이상인지 확인한다.

**After running the code, try changing the predicate of `any()` so it returns false:**

코드를 실행한 후, any()의 조건을 변경하여 false를 반환하도록 해보자.

```dart
void main() {
  const items = ['Salad', 'Popcorn', 'Toast'];

  if (items.any((item) => item.contains('Z'))) {
    print('At least one item contains "Z"');
  } else {
    print('No item contains "Z"');
  }

  if (items.every((item) => item.length >= 5)) {
    print('All items have length >= 5');
  }
}

```

```dart
// 출력 결과
No item contains "Z"
All items have length >= 5

```

**You can also use `any()` to verify that no element of an `Iterable` satisfies a certain condition.**

any()를 사용하여 Iterable의 모든 요소가 특정 조건을 만족하지 않는지 확인할 수도 있다.

### **Exercise: Verify that an Iterable satisfies a condition**[#](https://dart.dev/codelabs/iterables#exercise-verify-that-an-iterable-satisfies-a-condition) **연습: Iterable이 조건을 만족하는지 확인하기**

**The following exercise provides practice using the `any()` and `every()` methods, described in the previous example. In this case, you work with a group of users, represented by `User` objects that have the member field `age`.**

다음 연습은 이전 예제에서 설명한 any()와 every() 메서드를 사용하는 연습을 제공한다. 이 경우, User 객체로 표현된 사용자 그룹을 다루며, 각 객체는 age라는 멤버 필드를 가지고 있다.

**Use `any()` and `every()` to implement two functions:**

any()와 every()를 사용하여 두 가지 함수를 구현하자:

-   **Part 1: Implement `anyUserUnder18()`.**
    
    1부: anyUserUnder18() 구현하기
    
    -   **Return `true` if at least one user is 17 or younger.**
        
        17세 이하인 사용자가 최소 한 명이라도 있으면 true를 반환한다.
        
-   **Part 2: Implement `everyUserOver13()`.**
    
    2부: everyUserOver13() 구현하기
    
    -   **Return `true` if all users are 14 or older.**
        
        모든 사용자가 14세 이상이면 true를 반환한다.
        

```dart
bool anyUserUnder18(Iterable<User> users) {
	// TODO: Implement the anyUserUnder18 function.
  return users.any((user) => user.age < 18);
}

bool everyUserOver13(Iterable<User> users) {
	// TODO: Implement the everyUserOver13 function.
  return users.every((user) => user.age > 13);
}

class User {
  final String name;
  final int age;

  User(
      this.name,
      this.age,
      );
}

// The following code is used to provide feedback on your solution.
// There is no need to read or modify it.
void main() {
  final users = [
    User('Alice', 21),
    User('Bob', 17),
    User('Claire', 52),
    User('David', 14),
  ];

  try {
    final out = anyUserUnder18(users);
    if (!out) {
      print('Looks like `anyUserUnder18` is wrong. Keep trying!');
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `anyUserUnder18`, but received an error. '
          'Did you implement the function?',
    );
    return;
  } catch (e) {
    print('Tried running `anyUserUnder18`, but received an exception: $e');
    return;
  }

  try {
    // with only one user older than 18, should be false
    final out = anyUserUnder18([User('Alice', 21)]);
    if (out) {
      print(
          'Looks like `anyUserUnder18` is wrong. What if all users are over 18?');
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `anyUserUnder18`, but received an error. '
          'Did you implement the function?',
    );
    return;
  } catch (e) {
    print(
      'Tried running `anyUserUnder18([User("Alice", 21)])`, '
          'but received an exception: $e',
    );
    return;
  }

  try {
    final out = everyUserOver13(users);
    if (!out) {
      print(
        'Looks like `everyUserOver13` is wrong. '
            'There are no users under 13!',
      );
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `everyUserOver13`, but received an error. '
          'Did you implement the function?',
    );
    return;
  } catch (e) {
    print(
      'Tried running `everyUserOver13`, '
          'but received an exception: $e',
    );
    return;
  }

  try {
    final out = everyUserOver13([User('Dan', 12)]);
    if (out) {
      print(
        'Looks like `everyUserOver13` is wrong. '
            'There is at least one user under 13!',
      );
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `everyUserOver13`, but received an error. '
          'Did you implement the function?',
    );
    return;
  } catch (e) {
    print(
      'Tried running `everyUserOver13([User(\\'Dan\\', 12)])`, '
          'but received an exception: $e',
    );
    return;
  }

  print('Success. All tests passed!');
}

```

```dart
// 출력 결과
Success. All tests passed!

```

### **Quick review 빠른 복습**

-   **Although you can use `for-in` loops to check conditions, there are better ways to do that.**
    
    for-in 루프를 사용하여 조건을 확인할 수 있지만, 더 나은 방법이 있다.
    
-   **The method `any()` enables you to check whether any element satisfies a condition.**
    
    any() 메서드는 최소한 하나의 요소가 조건을 만족하는지 확인할 수 있게 해준다.
    
-   **The method `every()` enables you to verify that all elements satisfy a condition.**
    
    every() 메서드는 모든 요소가 조건을 만족하는지 확인할 수 있게 해준다.
    

## **Filtering**[#](https://dart.dev/codelabs/iterables#filtering) 필터링

**The previous sections cover methods like `firstWhere()` or `singleWhere()` that can help you find an element that satisfies a certain predicate.**

이전 섹션에서는 특정 조건을 만족하는 요소를 찾는 데 도움이 되는 firstWhere() 또는 singleWhere()와 같은 메서드를 다루었다.

**But what if you want to find all the elements that satisfy a certain condition? You can accomplish that using the `where()` method.**

그러나 특정 조건을 만족하는 모든 요소를 찾고 싶다면 어떻게 해야 할까? 이를 위해 where() 메서드를 사용할 수 있다.

```dart
var evenNumbers = numbers.where((number) => number.isEven);

```

**In this example, `numbers` contains an `Iterable` with multiple `int` values, and `where()` finds all the numbers that are even.**

이 예제에서 numbers는 여러 개의 int 값을 가진 Iterable이다. where()는 모든 짝수 숫자를 찾는다.

**The output of `where()` is another `Iterable`, and you can use it as such to iterate over it or apply other `Iterable` methods. In the next example, the output of `where()` is used directly inside the `for-in` loop.**

where()의 결과는 또 다른 Iterable이며, 이를 그대로 사용하여 반복하거나 다른 Iterable 메서드를 적용할 수 있다. 다음 예제에서는 where()의 출력이 직접 for-in 루프 안에서 사용된다.

-   **[note] where() 메서드의 결과가 또 다른 Iterable 이라는 것**
    
    -   `where()` 메서드를 사용하면 조건을 만족하는 요소들만 모아놓은 새로운 `Iterable`이 만들어진다.
    -   이 새로운 `Iterable`은 원래의 `Iterable`처럼 반복할 수 있다.
    -   `for-in` 루프에서 이 새로운 `Iterable`을 직접 사용할 수 있다.
    
    **예시 코드**
    
    여기서 evenNumbers는 짝수 숫자들만 포함하는 새로운 Iterable이며, 이 Iterable을 for-in 루프에서 반복하여 각 짝수 숫자를 출력할 수 있다.
    
    ```dart
    void main() {
      List<int> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
      Iterable<int> evenNumbers = numbers.where((number) => number.isEven);
    
      // where()의 결과를 직접 for-in 루프에서 사용
      for (var number in evenNumbers) {
        print(number); // 2, 4, 6, 8, 10 출력
      }
    }
    
    ```
    

```dart
var evenNumbers = numbers.where((number) => number.isEven);
for (final number in evenNumbers) {
  print('$number is even');
}

```

### **Example: Using where()**[#](https://dart.dev/codelabs/iterables#example-using-where) 예시: where() 사용하기

**Run this example to see how `where()` can be used together with other methods like `any()`.**

다음 예제를 실행하여 where()가 any()와 같은 다른 메서드와 함께 어떻게 사용될 수 있는지 확인해보자.

```dart
void main() {
  var evenNumbers = const [1, -2, 3, 42].where((number) => number.isEven);

  for (final number in evenNumbers) {
    print('$number is even.');
  }

  if (evenNumbers.any((number) => number.isNegative)) {
    print('evenNumbers contains negative numbers.');
  }

  // If no element satisfies the predicate, the output is empty.
  var largeNumbers = evenNumbers.where((number) => number > 1000);
  if (largeNumbers.isEmpty) {
    print('largeNumbers is empty!');
  }
}

```

```dart
// 출력 결과
-2 is even.
42 is even.
evenNumbers contains negative numbers.
largeNumbers is empty!

```

**In this example, `where()` is used to find all numbers that are even, then `any()` is used to check if the results contain a negative number.**

예제에서, where()는 모든 짝수 숫자를 찾는 데 사용되며, 그런 다음 any()는 결과에 음수가 있는지 확인하는 데 사용된다.

**Later in the example, `where()` is used again to find all numbers larger than 1000. Because there are none, the result is an empty `Iterable`.**

이후 예제에서, where()는 다시 1000보다 큰 모든 숫자를 찾는 데 사용된다. 그러나 1000보다 큰 숫자가 없기 때문에 결과는 빈 Iterable이다.

<aside> ⚠️ Note 주의

**If no element satisfies the predicate in `where()`, then the method returns an empty `Iterable`. Unlike `singleWhere()` or `firstWhere()`, `where()` doesn't throw a [StateError](https://api.dart.dev/stable/dart-core/StateError-class.html) exception.**

where()에서 조건을 만족하는 요소가 없으면, 메서드는 빈 Iterable을 반환한다. singleWhere()나 firstWhere()와 달리, where()는 StateError 예외를 발생시키지 않는다.

</aside>

-   **[Q] 여기서 말하는 빈 Iterable은 null일까?**
    
    여기서 빈 Iterable이란 null이 아닌 빈 리스트 []를 의미한다. 즉, 조건을 만족하는 요소가 없을 때 where() 메서드는 빈 컬렉션을 반환한다.
    
    **예시 코드**
    
    빈 Iterable 코드
    
    ```dart
    Iterable<int> emptyIterable = [];
    
    ```
    
    위 예제에서 조건을 만족하는 숫자가 없기 때문에 where()는 빈 Iterable을 반환합니다. 이는 null이 아닌 요소가 없는 빈 컬렉션입니다.
    
    ```dart
    void main() {
      List<int> numbers = [1, 2, 3, 4, 5];
      
      // 10보다 큰 숫자(조건)을 만족하는 요소가 없음
      Iterable<int> result = numbers.where((number) => number > 10);
    
      print(result); // 출력: ()
    
      // result는 빈 Iterable, null이 아님
      print(result.isEmpty); // 출력: true
    }
    
    ```
    

### **Example: Using takeWhile**[#](https://dart.dev/codelabs/iterables#example-using-takewhile) **예시: takeWhile 사용하기**

**The methods `takeWhile()` and `skipWhile()` can also help you filter elements from an `Iterable`.**

takeWhile()와 skipWhile() 메서드도 Iterable에서 요소를 필터링하는 데 도움을 줄 수 있다.

**Run this example to see how `takeWhile()` and `skipWhile()` can split an `Iterable` containing numbers.**

다음 예제를 실행하여 takeWhile()와 skipWhile()가 숫자를 포함하는 Iterable을 어떻게 나누는지 확인해보자.

```dart
void main() {
  const numbers = [1, 3, -2, 0, 4, 5];

  var numbersUntilZero = numbers.takeWhile((number) => number != 0);
  print('Numbers until 0: $numbersUntilZero');

  var numbersStartingAtZero = numbers.skipWhile((number) => number != 0);
  print('Numbers starting at 0: $numbersStartingAtZero');
}

```

```dart
// 출력 결과
Numbers until 0: (1, 3, -2)
Numbers starting at 0: (0, 4, 5)

```

**In this example, `takeWhile()` returns an `Iterable` that contains all the elements before the one that satisfies the predicate. On the other hand, `skipWhile()` returns an `Iterable` that contains all elements after and including the first one that _doesn't_ satisfy the predicate.**

이 예제에서 takeWhile()는 조건을 만족하는 요소 이전의 모든 요소를 포함하는 Iterable을 반환한다. 반면에, skipWhile()는 조건을 만족하지 않는 첫 번째 요소를 포함하여 그 이후의 모든 요소를 포함하는 Iterable을 반환다.

**After running the example, change `takeWhile()` to take elements until it reaches the first negative number.**

예제를 실행한 후, takeWhile()를 첫 번째 음수에 도달할 때까지 요소를 가져오도록 변경해보자.

```dart
var numbersUntilNegative =
    numbers.takeWhile((number) => !number.isNegative); // 음수가 아닐 동안

```

**Notice that the condition `number.isNegative` is negated with `!`.**

조건 number.isNegative가 !로 부정된다는 점에 주목하자.

-   **[note] takeWhile()과 skipWhile()**
    
    `takeWhile()`과 `skipWhile()`은 Dart의 `Iterable` 클래스에서 제공하는 메서드로, **컬렉션의 요소를 조건에 따라 선택하거나 건너뛸 수 있다.** 이 두 메서드는 특정 조건을 기준으로 `Iterable`을 나누는 데 유용하다.
    
    **takeWhile()**
    
    -   `takeWhile()` 메서드는 **주어진 조건을 만족하는 동안 요소들을 가져온다.** 조건이 **처음으로 만족하지 않는 요소가 나오면 그 이후의 요소들은 포함하지 않는다.**
    
    **skipWhile**
    
    -   `skipWhile()` 메서드는 **주어진 조건을 만족하는 동안 요소들을 건너뛴다.** 조건이 **처음으로 만족하지 않는 요소가 나오면 그 요소부터 시작해서 나머지 모든 요소를 포함한다.**

### **Exercise: Filtering elements from a list**[#](https://dart.dev/codelabs/iterables#exercise-filtering-elements-from-a-list) **연습: 리스트에서 요소 필터링하기**

**The following exercise provides practice using the `where()` method with the class `User` from the previous exercise.**

다음 연습은 이전 연습의 User 클래스를 사용하여 where() 메서드를 연습하는 것이다.

**Use `where()` to implement two functions:**

where()를 사용하여 두 가지 함수를 구현하자:

-   **Part 1: Implement `filterOutUnder21()`.**
    
    1부: filterOutUnder21() 구현하기
    
    -   **Return an `Iterable` containing all users of age 21 or more.**
        
        21세 이상인 모든 사용자를 포함하는 Iterable을 반환한다.
        
-   **Part 2: Implement `findShortNamed()`.**
    
    2부: findShortNamed() 구현하기
    
    -   **Return an `Iterable` containing all users with names of length 3 or less.**
        
        이름의 길이가 3 이하인 모든 사용자를 포함하는 Iterable을 반환한다.
        

```dart
Iterable<User> filterOutUnder21(Iterable<User> users) {
  // TODO: Implement the filterOutUnder21 function.
  return users.where((user) => user.age > 20);
}

Iterable<User> findShortNamed(Iterable<User> users) {
  // TODO: Implement the findShortNamed function.
  return users.where((user) => user.name.length < 4);
}

class User {
  final String name;
  final int age;

  User(
      this.name,
      this.age,
      );
}

// The following code is used to provide feedback on your solution.
// There is no need to read or modify it.
void main() {
  final users = [
    User('Alice', 21),
    User('Bob', 17),
    User('Claire', 52),
    User('Dan', 12),
  ];

  try {
    final out = filterOutUnder21(users);
    if (out.any((user) => user.age < 21) || out.length != 2) {
      print(
        'Looks like `filterOutUnder21` is wrong, there are '
            'exactly two users with age under 21. Keep trying!',
      );
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `filterOutUnder21`, but received an error. '
          'Did you implement the function?',
    );
    return;
  } catch (e) {
    print(
      'Tried running `filterOutUnder21`, '
          'but received an exception: ${e.runtimeType}',
    );
    return;
  }

  try {
    final out = findShortNamed(users);
    if (out.any((user) => user.name.length > 3) || out.length != 2) {
      print(
        'Looks like `findShortNamed` is wrong, there are '
            'exactly two users with a three letter name. Keep trying!',
      );
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `findShortNamed`, but received an error. '
          'Did you implement the function?',
    );
    return;
  } catch (e) {
    print(
      'Tried running `findShortNamed`, '
          'but received an exception: ${e.runtimeType}',
    );
    return;
  }

  print('Success. All tests passed!');
}

```

```dart
// 출력 결과
Success. All tests passed!

```

### **Quick review**

-   **Filter the elements of an `Iterable` with `where()`.**
    
    where()를 사용하여 Iterable의 요소를 필터링한다.
    
-   **The output of `where()` is another `Iterable`.**
    
    where()의 출력은 또 다른 Iterable이다.
    
-   **Use `takeWhile()` and `skipWhile()` to obtain elements until or after a condition is met.**
    
    takeWhile()와 skipWhile()를 사용하여 조건이 만족될 때까지 또는 조건이 만족된 이후의 요소를 얻을 수 있다.
    
-   **The output of these methods can be an empty `Iterable`.**
    
    이러한 메서드들의 출력은 빈 Iterable일 수 있다.
    

## **Mapping**[#](https://dart.dev/codelabs/iterables#mapping) 매핑

**Mapping `Iterables` with the method `map()` enables you to apply a function over each of the elements, replacing each element with a new one.**

map() 메서드를 사용하여 Iterable을 매핑하면 각 요소에 함수를 적용하여 각 요소를 새로운 요소로 대체할 수 있다.

```dart
Iterable<int> output = numbers.map((number) => number * 10);

```

**In this example, each element of the `Iterable` numbers is multiplied by 10.**

이 예제에서 Iterable인 numbers의 각 요소는 10배로 곱해진다.

**You can also use `map()` to transform an element into a different object—for example, to convert all `int` to `String`, as you can see in the following example:**

또한 map()을 사용하여 요소를 다른 객체로 변환할 수도 있다. 예를 들어, 모든 int를 String으로 변환할 수 있다. 다음 예제를 참조하자:

```dart
Iterable<String> output = numbers.map((number) => number.toString());

```

⚠️ **Note 주의**

**`map()` returns a _lazy_ `Iterable`, meaning that the supplied function is called only when the elements are iterated.**

map()은 지연(lazy) Iterable을 반환한다. 이는 제공된 함수가 요소들이 반복될 때만 호출된다는 것을 의미한다.

-   **[Q] lazy Iterable 이란?**
    
    Lazy Iterable이란 요소들이 실제로 사용될 때까지 계산을 미루는 Iterable을 의미한다. 즉, 모든 요소를 한 번에 계산하지 않고, **필요한 시점에 하나씩 계산하여 메모리 사용을 효율적으로 관리하는 것**이다. Dart의 map() 메서드는 lazy Iterable을 반환한다.
    
    이렇게 하면 계산이 필요한 시점에만 함수가 호출되므로, 전체 데이터를 한 번에 처리하지 않아도 되며, 성능과 메모리 사용 측면에서 효율적이다.
    

### **Example: Using map to change elements**[#](https://dart.dev/codelabs/iterables#example-using-map-to-change-elements)

**예시: map을 사용하여 요소 변경하기**

**Run this example to see how to use `map()` to multiply all the elements of an `Iterable` by 2. What do you think the output will be?**

다음 예제를 실행하여 map()을 사용해 Iterable의 모든 요소를 2배로 곱하는 방법을 확인해보자. 출력 결과가 어떻게 될지 생각해보자.

```dart
void main() {
  var numbersByTwo = const [1, -2, 3, 42].map((number) => number * 2);
  print('Numbers: $numbersByTwo');
}

```

```dart
// 출력 결과
Numbers: (2, -4, 6, 84)

```

### **Exercise: Mapping to a different type[#](https://dart.dev/codelabs/iterables#exercise-mapping-to-a-different-type)

연습: 다른 타입으로 매핑하기**

**In the previous example, you multiplied the elements of an `Iterable` by 2. Both the input and the output of that operation were an `Iterable` of `int`.**

이전 예제에서는 Iterable의 요소를 2배로 곱했다. 그 작업의 입력과 출력 모두 int 타입의 Iterable이었다.

**In this exercise, your code takes an `Iterable` of `User`, and you need to return an `Iterable` that contains strings containing each user's name and age.**

이번 연습에서는, User 타입의 Iterable을 입력으로 받아 각 사용자의 이름과 나이를 포함하는 문자열을 포함하는 Iterable을 반환해야 한다.

**Each string in the `Iterable` must follow this format: `'{name} is {age}'`—for example `'Alice is 21'`.**

각 문자열은 다음 형식을 따라야 한다: ‘{name} is {age}’—예를 들어 ‘Alice is 21’이다.

```dart
Iterable<String> getNameAndAges(Iterable<User> users) {
  // TODO: Implement the getNameAndAges function.
  return users.map((user) => '${user.name} is ${user.age}');
}

class User {
  final String name;
  final int age;

  User(
      this.name,
      this.age,
      );
}

// The following code is used to provide feedback on your solution.
// There is no need to read or modify it.
void main() {
  final users = [
    User('Alice', 21),
    User('Bob', 17),
    User('Claire', 52),
  ];

  try {
    final out = getNameAndAges(users).toList();
    if (!_listEquals(out, ['Alice is 21', 'Bob is 17', 'Claire is 52'])) {
      print(
        'Looks like `getNameAndAges` is wrong. Keep trying! '
            'The output was: $out',
      );
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `getNameAndAges`, but received an error. '
          'Did you implement the function?',
    );
    return;
  } catch (e) {
    print('Tried running the function, but received an exception: $e');
    return;
  }

  print('Success. All tests passed!');
}

bool _listEquals<T>(List<T>? a, List<T>? b) {
  if (a == null) return b == null;
  if (b == null || a.length != b.length) return false;
  for (var index = 0; index < a.length; index += 1) {
    if (a[index] != b[index]) return false;
  }
  return true;
}

```

```dart
// 출력 결과
Success. All tests passed!

```

### **Quick review 빠른 복습**

-   **`map()` applies a function to all the elements of an `Iterable`.**
    
    map()은 함수를 Iterable의 모든 요소에 적용한다.
    
-   **The output of `map()` is another `Iterable`.**
    
    map()의 출력은 또 다른 Iterable이다.
    
-   **The function isn't evaluated until the `Iterable` is iterated.**
    
    그 함수는 Iterable이 반복될 때까지 평가되지 않는다. (lazy Iterable)
    

## **Exercise: Putting it all together**[#](https://dart.dev/codelabs/iterables#exercise-putting-it-all-together)

**연습: 배운 내용 모두 적용하기**

**It's time to practice what you learned, in one final exercise.**

이제 마지막 연습을 통해 배운 내용을 실습할 시간이다.

**This exercise provides the class `EmailAddress`, which has a constructor that takes a string. Another provided function is `isValidEmailAddress()`, which tests whether an email address is valid.**

이 연습에서는 문자열을 매개변수로 받는 생성자를 가진 EmailAddress 클래스를 제공한다. 또 다른 제공된 함수는 이메일 주소가 유효한지 테스트하는 isValidEmailAddress() 함수이다.

| Constructor/function 생성자/함수 | Type signature 타입 서명 | Description 설명 | | --- | --- | --- | | EmailAddress() | EmailAddress(String address) | Creates an EmailAddress for the specified address. 지정된 주소에 대한 EmailAddress를 생성한다. | | isValidEmailAddress() | bool isValidEmailAddress(EmailAddress) | Returns true if the provided EmailAddress is valid. 제공된 EmailAddress가 유효하면 true를 반환한다. |

### **Write the following code: 다음 코드를 작성하세요:**

**Part 1: Implement `parseEmailAddresses()`.**

1부: parseEmailAddresses() 구현하기

-   **Write the function `parseEmailAddresses()`, which takes an `Iterable<String>` containing email addresses, and returns an `Iterable<EmailAddress>`.**
    
    parseEmailAddresses() 함수를 작성하자. 이 함수는 이메일 주소를 포함하는 Iterable<String>을 입력으로 받아 Iterable<EmailAddress>를 반환한다.
    
-   **Use the method `map()` to map from a `String` to `EmailAddress`.**
    
    map() 메서드를 사용하여 String에서 EmailAddress로 매핑한다.
    
-   **Create the `EmailAddress` objects using the constructor `EmailAddress(String)`.**
    
    생성자 EmailAddress(String)를 사용하여 EmailAddress 객체를 생성한다.
    

**Part 2: Implement `anyInvalidEmailAddress()`.**

2부: anyInvalidEmailAddress() 구현하기

-   **Write the function `anyInvalidEmailAddress()`, which takes an `Iterable<EmailAddress>` and returns `true` if any `EmailAddress` in the `Iterable` isn't valid.**
    
    anyInvalidEmailAddress() 함수를 작성하자. 이 함수는 Iterable<EmailAddress>를 입력으로 받아 Iterable 내의 어떤 EmailAddress가 유효하지 않으면 true를 반환한다.
    
-   **Use the method `any()` together with the provided function `isValidEmailAddress()`.**
    
    제공된 함수 isValidEmailAddress()와 함께 any() 메서드를 사용한다.
    

**Part 3: Implement `validEmailAddresses()`.**

3부: validEmailAddresses() 구현하기

-   **Write the function `validEmailAddresses()`, which takes an `Iterable<EmailAddress>` and returns another `Iterable<EmailAddress>` containing only valid addresses.**
    
    validEmailAddresses() 함수를 작성하자. 이 함수는 Iterable<EmailAddress>를 입력으로 받아 유효한 주소만 포함하는 또 다른 Iterable<EmailAddress>를 반환한다.
    
-   **Use the method `where()` to filter the `Iterable<EmailAddress>`.**
    
    where() 메서드를 사용하여 Iterable<EmailAddress>를 필터링한다.
    
-   **Use the provided function `isValidEmailAddress()` to evaluate whether an `EmailAddress` is valid.**
    
    제공된 함수 isValidEmailAddress()를 사용하여 EmailAddress가 유효한지 평가한다.
    

```dart
Iterable<EmailAddress> parseEmailAddresses(Iterable<String> strings) {
  // TODO: Implement the parseEmailAddresses function.
  return strings.map((email) => EmailAddress(email));
}

bool anyInvalidEmailAddress(Iterable<EmailAddress> emails) {
  // TODO: Implement the anyInvalidEmailAddress function.
  // 틀림
  return emails.any((email) => isValidEmailAddress(email));
  // 정답
  return emails.any((email) => !isValidEmailAddress(email));
}

Iterable<EmailAddress> validEmailAddresses(Iterable<EmailAddress> emails) {
  // TODO: Implement the validEmailAddresses function.
  return emails.where((email) => isValidEmailAddress(email));
}

class EmailAddress {
  final String address;

  EmailAddress(this.address);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EmailAddress && address == other.address;

  @override
  int get hashCode => address.hashCode;

  @override
  String toString() => 'EmailAddress{address: $address}';
}

// The following code is used to provide feedback on your solution.
// There is no need to read or modify it.
void main() {
  const input = [
    'ali@gmail.com',
    'bobgmail.com',
    'cal@gmail.com',
  ];

  const correctInput = ['dash@gmail.com', 'sparky@gmail.com'];

  bool _listEquals<T>(List<T>? a, List<T>? b) {
    if (a == null) return b == null;
    if (b == null || a.length != b.length) return false;
    for (var index = 0; index < a.length; index += 1) {
      if (a[index] != b[index]) return false;
    }
    return true;
  }

  final Iterable<EmailAddress> emails;
  final Iterable<EmailAddress> correctEmails;
  try {
    emails = parseEmailAddresses(input);
    correctEmails = parseEmailAddresses(correctInput);
    if (emails.isEmpty) {
      print(
        'Tried running `parseEmailAddresses`, but received an empty list.',
      );
      return;
    }
    if (!_listEquals(emails.toList(), [
      EmailAddress('ali@gmail.com'),
      EmailAddress('bobgmail.com'),
      EmailAddress('cal@gmail.com'),
    ])) {
      print('Looks like `parseEmailAddresses` is wrong. Keep trying!');
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `parseEmailAddresses`, but received an error. '
      'Did you implement the function?',
    );
    return;
  } catch (e) {
    print(
      'Tried running `parseEmailAddresses`, '
      'but received an exception: $e',
    );
    return;
  }

  try {
    final out = anyInvalidEmailAddress(emails);
    if (!out) {
      print(
        'Looks like `anyInvalidEmailAddress` is wrong. Keep trying! '
        'The result should be false with at least one invalid address.',
      );
      return;
    }
    final falseOut = anyInvalidEmailAddress(correctEmails);
    if (falseOut) {
      print(
        'Looks like `anyInvalidEmailAddress` is wrong. Keep trying! '
        'The result should be false with all valid addresses.',
      );
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `anyInvalidEmailAddress`, but received an error. '
      'Did you implement the function?',
    );
    return;
  } catch (e) {
    print(
        'Tried running `anyInvalidEmailAddress`, but received an exception: $e');
    return;
  }

  try {
    final valid = validEmailAddresses(emails);
    if (emails.isEmpty) {
      print('Tried running `validEmailAddresses`, but received an empty list.');
      return;
    }
    if (!_listEquals(valid.toList(), [
      EmailAddress('ali@gmail.com'),
      EmailAddress('cal@gmail.com'),
    ])) {
      print('Looks like `validEmailAddresses` is wrong. Keep trying!');
      return;
    }
  } on UnimplementedError {
    print(
      'Tried running `validEmailAddresses`, but received an error. '
      'Did you implement the function?',
    );
    return;
  } catch (e) {
    print(
      'Tried running the `validEmailAddresses`, '
      'but received an exception: $e',
    );
    return;
  }

  print('Success. All tests passed!');
}

bool isValidEmailAddress(EmailAddress email) {
  return email.address.contains('@');
}


```

## **What's next**[#](https://dart.dev/codelabs/iterables#whats-next) **다음 단계**

**Congratulations, you finished the codelab! If you want to learn more, here are some suggestions for where to go next:**

축하합니다! 코드랩을 끝냈다. 더 배우고 싶다면 다음을 참고하자:

-   **Play with [DartPad.](https://dartpad.dev/)**
    
    DartPad을 사용해 보자.
    
-   **Try another [codelab](https://dart.dev/codelabs).**
    
    다른 코드랩을 시도해 보자.
    
-   **Read the [Iterable API reference](https://api.dart.dev/stable/dart-core/Iterable-class.html) to learn about methods not covered by this codelab.**
    
    이 codelab에서 다루지 않은 메서드에 대해 배우려면 Iterable API 참조 문서를 읽어보아라.

----------

# Generics
🔗 [[페이지 링크]](https://dart.dev/language/generics)

# **Generics 제네릭**

**If you look at the API documentation for the basic array type, [`List`](https://api.dart.dev/stable/dart-core/List-class.html), you'll see that the type is actually `List<E>`. The <...> notation marks List as a _generic_ (or _parameterized_) type—a type that has formal type parameters. [By convention](https://dart.dev/effective-dart/design#do-follow-existing-mnemonic-conventions-when-naming-type-parameters), most type variables have single-letter names, such as E, T, S, K, and V.**

기본 배열 타입인 List의 API 문서를 보면, 실제 타입이 List<E>임을 알 수 있다. <...> 표기법은 List를 제네릭(또는 매개변수화된) 타입으로 표시하는데, 이는 형식 매개변수를 가지는 타입을 의미한다. 관례적으로 대부분의 타입 변수는 E, T, S, K, V와 같이 한 글자 이름을 가진다.

-   **[Q] 매개변수화 된다는게?**
    
    “매개변수화된다”는 것은 어떤 값을 특정하지 않고 매개변수로 받아서, 그 값에 따라 동작이 달라지는 것을 의미한다. 제네릭(Generics)에서는 타입을 매개변수화하여, 코드가 다양한 데이터 타입을 처리할 수 있도록 한다. 즉, 코드 작성 시 구체적인 데이터 타입을 명시하지 않고, 대신 **타입 매개변수를 사용하여 여러 타입을 지원(대응)하는 코드를 작성하는 것**을 말한다.
    
    예를 들어, List 클래스는 제네릭 클래스이다. 이 클래스는 요소의 타입을 미리 정하지 않고, 나중에 사용할 때 타입을 지정한다. 이렇게 하면 같은 List 클래스를 사용해 여러 타입의 리스트를 만들 수 있다.
    
    따라서 “매개변수화된다”는 것은 코드 작성 시 구체적인 값을 지정하지 않고 나중에 사용할 때 값을 지정하는 것으로, 코드가 다양한 타입이나 값을 처리할 수 있도록 일반화되는 것을 의미한다.
    
-   **[Q] 형식 매개변수란?**
    
    형식 매개변수는 제네릭(또는 매개변수화된) 타입에서 사용되는 매개변수로, 데이터 타입을 일반화하는 데 사용된다. 이를 통해 클래스나 메서드가 다양한 데이터 타입을 처리할 수 있게 된다.
    
    **예시 설명**
    
    예를 들어, Dart의 List는 제네릭 타입이다. 이를 통해 List가 다양한 타입의 요소를 포함할 수 있다. 다음 예시는 형식 매개변수를 사용하여 List를 정의하는 방법을 보여준다:
    
    ```dart
    // 문자열을 포함하는 리스트
    List<String> stringList = ['Alice', 'Bob'];
    
    // 정수를 포함하는 리스트
    List<int> intList = [1, 2, 3];
    
    ```
    
    위의 코드에서 List<String>의 String과 List<int>의 int가 형식 매개변수이다. List 클래스는 이러한 형식 매개변수를 사용하여 어떤 타입의 요소든 저장할 수 있게 된다.
    
    **형식 매개변수의 장점**
    
    -   타입 안전성: 컴파일러가 잘못된 타입의 데이터가 사용되는 것을 방지한다.
    -   코드 재사용성: 동일한 코드가 여러 타입의 데이터를 처리할 수 있게 한다.
    -   가독성 향상: 코드의 의도를 명확히 하고, 유지보수를 용이하게 한다.

## **Why use generics?[#](https://dart.dev/language/generics#why-use-generics) 왜 제네릭을 사용할까?**

**Generics are often required for type safety, but they have more benefits than just allowing your code to run:**

제네릭은 종종 타입 안전성을 위해 필요하지만, 단순히 코드 실행을 가능하게 하는 것 이상의 이점을 가지고 있다:

-   **Properly specifying generic types results in better generated code.**
    
    제네릭 타입을 제대로 지정하면 더 나은 생성된 코드가 나온다.
    
-   **You can use generics to reduce code duplication.**
    
    제네릭을 사용하여 코드 중복을 줄일 수 있다.
    

**If you intend for a list to contain only strings, you can declare it as `List<String>` (read that as "list of string"). That way you, your fellow programmers, and your tools can detect that assigning a non-string to the list is probably a mistake. Here's an example:**

리스트에 문자열만 포함되도록 하려면 List<String>으로 선언할 수 있다(이를 “문자열 리스트”로 읽습니다). 이렇게 하면 당신과 동료 프로그래머, 그리고 도구들이 리스트에 비문자열을 할당하는 것이 아마도 실수라는 것을 감지할 수 있다. 다음은 그 예다:

```dart
// ✗ static analysis: failure
var names = <String>[];
names.addAll(['Seth', 'Kathy', 'Lars']);
names.add(42); // Error

```

**Another reason for using generics is to reduce code duplication. Generics let you share a single interface and implementation between many types, while still taking advantage of static analysis. For example, say you create an interface for caching an object:**

제네릭을 사용하는 또 다른 이유는 코드 중복을 줄이기 위해서이다. 제네릭을 사용하면 여러 타입 간에 단일 인터페이스와 구현을 공유할 수 있으며, 여전히 정적 분석의 이점을 누릴 수 있다. 예를 들어, 객체를 캐시하기 위한 인터페이스를 만든다고 가정해 보자.

```dart
abstract class ObjectCache {
  Object getByKey(String key);
  void setByKey(String key, Object value);
}

```

**You discover that you want a string-specific version of this interface, so you create another interface:**

이 인터페이스의 문자열 전용 버전이 필요하다는 것을 발견하고, 또 다른 인터페이스를 만든다.

```dart
abstract class StringCache {
  String getByKey(String key);
  void setByKey(String key, String value);
}

```

**Later, you decide you want a number-specific version of this interface... You get the idea.**

나중에 이 인터페이스의 숫자 전용 버전이 필요하다고 결정하게 된다… 이제 아이디어를 이해했을 것이다.

**Generic types can save you the trouble of creating all these interfaces. Instead, you can create a single interface that takes a type parameter:**

제네릭 타입은 이러한 인터페이스를 모두 만드는 번거로움을 덜어줄 수 있다. 대신, 타입 매개변수를 받는 단일 인터페이스를 만들 수 있다.

```dart
abstract class Cache<T> {
  T getByKey(String key);
  void setByKey(String key, T value);
}

```

-   **[note] Cache<T> 사용해보기**
    
    ```dart
    abstract class Cache<T> {
      T getByKey(String key);
    
      void setByKey(String key, T value);
    }
    
    class StringCacheImpl implements Cache<String> {
      @override
      String getByKey(String key) {
        // TODO: implement getByKey
        throw UnimplementedError('StringCacheImpl');
      }
    
      @override
      void setByKey(String key, String value) {
        // TODO: implement setByKey
      }
    
    }
    
    class IntCacheImpl implements Cache<int> {
      @override
      int getByKey(String key) {
        // TODO: implement getByKey
        throw UnimplementedError('IntCacheImpl');
      }
    
      @override
      void setByKey(String key, int value) {
        // TODO: implement setByKey
      }
    
    }
    
    void main() {
      Cache<String> stringCache = StringCacheImpl();
      Cache<int> intCache = IntCacheImpl();
    }
    
    
    ```
    

**In this code, T is the stand-in type. It's a placeholder that you can think of as a type that a developer will define later.**

이 코드에서 T는 대체 타입이다. 이는 개발자가 나중에 정의할 타입을 나타내는 플레이스홀더라고 생각할 수 있다.

## **Using collection literals**[#](https://dart.dev/language/generics#using-collection-literals) **컬렉션 리터럴 사용하기**

-   **[Q] literals 리터럴이란?**
    
    “리터럴(literals)“은 프로그래밍에서 고정된 값을 의미한다. 코드 내에서 직접 사용되는 값으로, 변수를 통해 저장되거나 계산된 값이 아닌, 코드에 명시적으로 작성된 값을 말한다. 예를 들어, 숫자, 문자열, 불리언 값 등이 리터럴에 해당한다.
    
    -   **숫자 리터럴**: 42, 3.14
    -   **문자열 리터럴**: "hello", 'world'
    -   **불리언 리터럴**: true, false
    -   **리스트 리터럴**: [1, 2, 3]
    -   **맵 리터럴**: {'key': 'value'}
    
    **예시 코드**
    
    ```dart
    void main() {
      // 숫자 리터럴
      int number = 42;
      
      // 문자열 리터럴
      String greeting = 'hello';
      
      // 불리언 리터럴
      bool isTrue = true;
      
      // 리스트 리터럴
      List<int> numbers = [1, 2, 3];
      
      // 맵 리터럴
      Map<String, String> user = {
        'name': 'John',
        'email': 'john@example.com'
      };
    
      print(number);        // 42
      print(greeting);      // hello
      print(isTrue);        // true
      print(numbers);       // [1, 2, 3]
      print(user);          // {name: John, email: john@example.com}
    }
    
    ```
    
    위 예제에서 42, 'hello', true, [1, 2, 3], {'name': 'John', 'email': 'john@example.com'} 등이 모두 리터럴이다. 이 값들은 코드에 직접 작성된 고정된 값들이다.
    
-   **[Q] Collection literals 컬렉션 리터럴이란?**
    
    컬렉션 리터럴(Collection Literals)은 리스트(List), 세트(Set), 맵(Map)과 같은 컬렉션을 생성할 때 사용되는 리터럴 표현을 의미한다.
    
    **리스트 리터럴**
    
    리스트는 중괄호([])를 사용하여 정의된다.
    
    ```dart
    void main() {
      // 정수형 리스트
      List<int> intList = [1, 2, 3, 4, 5];
      
      // 문자열 리스트
      List<String> stringList = ['apple', 'banana', 'cherry'];
      
      print(intList);       // [1, 2, 3, 4, 5]
      print(stringList);    // [apple, banana, cherry]
    }
    
    ```
    
    **셋 리터럴**
    
    세트는 중괄호({})를 사용하여 정의된다. 세트는 중복을 허용하지 않는 컬렉션이다.
    
    ```dart
    void main() {
      // 정수형 셋
      Set<int> intSet = {1, 2, 3, 4, 5};
      
      // 문자열 셋
      Set<String> stringSet = {'apple', 'banana', 'cherry'};
      
      print(intSet);       // {1, 2, 3, 4, 5}
      print(stringSet);    // {apple, banana, cherry}
    }
    
    ```
    
    **맵 리터럴**
    
    맵은 중괄호({})를 사용하여 정의되며, 키-값 쌍으로 구성된다.
    
    ```dart
    void main() {
      // 키가 문자열이고 값이 정수인 맵
      Map<String, int> fruitPrices = {
        'apple': 1000,
        'banana': 800,
        'cherry': 1500
      };
      
      print(fruitPrices);    // 출력: {apple: 1000, banana: 800, cherry: 1500}
    }
    
    ```
    
    **매개변수화된 컬렉션 리터럴**
    
    Dart에서는 컬렉션 리터럴을 매개변수화하여 특정 타입의 요소만 포함하는 컬렉션을 만들 수 있다. 타입 매개변수를 사용하여 컬렉션의 요소 타입을 지정할 수 있다.
    

**List, set, and map literals can be parameterized. Parameterized literals are just like the literals you've already seen, except that you add `<*type*>` (for lists and sets) or `<*keyType*, *valueType*>` (for maps) before the opening bracket. Here is an example of using typed literals:**

리스트, 세트, 맵 리터럴은 매개변수를 사용할 수 있다. 매개변수화된 리터럴은 이미 보아온 리터럴과 같지만, 여는 대괄호 앞에 <type> (리스트와 세트의 경우) 또는 <keyType, valueType> (맵의 경우)을 추가한다. 다음은 타입이 지정된 리터럴을 사용하는 예제이다:

```dart
var names = <String>['Seth', 'Kathy', 'Lars'];
var uniqueNames = <String>{'Seth', 'Kathy', 'Lars'};
var pages = <String, String>{
  'index.html': 'Homepage',
  'robots.txt': 'Hints for web robots',
  'humans.txt': 'We are people, not machines'
};

```

## **Using parameterized types with constructors[#](https://dart.dev/language/generics#using-parameterized-types-with-constructors) 생성자에서 매개변수화된 타입 사용하기**

**To specify one or more types when using a constructor, put the types in angle brackets (`<...>`) just after the class name. For example:**

생성자를 사용할 때 하나 이상의 타입을 지정하려면, 클래스 이름 바로 뒤에 꺾쇠 괄호(<…>) 안에 타입을 넣는다. 예를 들어:

```dart
var nameSet = Set<String>.from(names);

```

**다음 코드는 정수 키와 View 타입의 값을 가지는 맵을 생성한다:**

```dart
var views = Map<int, View>();

```

## **Generic collections and the types they contain[#](https://dart.dev/language/generics#generic-collections-and-the-types-they-contain) 제네릭 컬렉션과 그들이 포함하는 타입들**

**Dart generic types are _reified_, which means that they carry their type information around at runtime. For example, you can test the type of a collection:**

Dart의 제네릭 타입은 구체화(reified)된다. 이는 실행 시점(runtime)에 타입 정보를 가지고 다닌다는 것을 의미한다. 예를 들어, 컬렉션의 타입을 테스트할 수 있다:

```dart
var names = <String>[];
names.addAll(['Seth', 'Kathy', 'Lars']);
print(names is List<String>); // true

```

-   **[Q] 제네릭 타입이 구체화(reified) 된다는 것은?**
    
    Dart에서 제네릭 타입이 구체화(reified)된다는 것은, **실행 시점(런타임)에도 타입 정보를 유지한다는 것**을 의미한다. 실행 시점(런타임)에 타입 검사를 할 수 있어 코드의 타입 안전성을 높일 수 있다.
    

⚠️ **Note 주의**

**In contrast, generics in Java use _erasure_, which means that generic type parameters are removed at runtime. In Java, you can test whether an object is a List, but you can't test whether it's a `List<String>`.**

반면에, Java의 제네릭은 타입 소거(erasure)를 사용하여 실행 시에 제네릭 타입 매개변수가 제거됩니다. Java에서는 객체가 List인지 여부를 테스트할 수 있지만, List<String>인지 여부는 테스트할 수 없습니다.

## **Restricting the parameterized type[#](https://dart.dev/language/generics#restricting-the-parameterized-type) 매개변수화된 타입 제한하기**

**When implementing a generic type, you might want to limit the types that can be provided as arguments, so that the argument must be a subtype of a particular type. You can do this using `extends`.**

제네릭 타입을 구현할 때, 특정 타입의 서브타입만 인수로 제공되도록 제한하고 싶을 수 있다. 이를 위해 extends를 사용할 수 있다.

-   **[Q] 서브타입만 인수로 제공되도록 제한한다는 것은?**
    
    제네릭 타입을 사용할 때, 특정 타입의 하위 타입만 사용할 수 있도록 제한하는 것을 의미한다. 즉, 제네릭 타입 매개변수가 특정 타입 또는 그 타입의 서브타입(하위 클래스)이어야만 한다는 것을 뜻한다.
    
    **예시 코드**
    
    예를 들어, 동물(Animal) 클래스와 그 하위 클래스인 개(Dog)와 고양이(Cat)가 있다고 가정해보자. 우리가 동물 타입의 제네릭 케이지(Cage)를 만들고, 케이지에는 오직 동물(Animal)의 서브타입만 넣을 수 있도록 하고 싶다면 이렇게 코드를 작성할 수 있다:
    
    ```dart
    // Animal 클래스 정의
    class Animal {
      void makeSound() {
        print('Animal sound');
      }
    }
    
    // Animal의 서브클래스 Dog
    class Dog extends Animal {
      @override
      void makeSound() {
        print('멍멍');
      }
    }
    
    // Animal의 서브클래스 Cat
    class Cat extends Animal {
      @override
      void makeSound() {
        print('냥냥');
      }
    }
    
    // 제네릭 클래스 Cage<T> 정의, T는 Animal의 서브타입이어야 함
    class Cage<T extends Animal> {
      T animal;
    
      Cage(this.animal);
    
      void displayAnimalSound() {
        animal.makeSound();
      }
    }
    
    void main() {
      // Dog 객체를 포함하는 케이지 생성
      Cage<Dog> dogCage = Cage(Dog());
      dogCage.displayAnimalSound(); // 멍멍
    
      // Cat 객체를 포함하는 케이지 생성
      Cage<Cat> catCage = Cage(Cat());
      catCage.displayAnimalSound(); // 냥냥
    
      // String은 Animal의 서브타입이 아니므로, 컴파일 오류 발생
      // Cage<String> stringCage = Cage('Not an animal'); // 오류
    }
    
    ```
    
    **Animal 클래스와 서브클래스 정의:**
    
    -   Animal 클래스는 기본 동물 소리를 출력하는 메서드를 가진다.
    -   Dog와 Cat 클래스는 Animal을 상속(extends)받아 각각의 소리를 출력하는 메서드를 재정의(override)한다.
    
    **Cage 클래스 정의**:
    
    -   Cage 클래스는 제네릭 클래스이며, 타입 매개변수 T는 Animal의 서브타입이어야 한다(T extends Animal).
    -   Cage 클래스는 animal이라는 멤버 변수를 가지며, displayAnimalSound 메서드를 통해 동물 소리를 출력한다.
    
    **main 함수**:
    
    -   Dog 객체를 포함하는 케이지를 생성하고 소리를 출력
    -   Cat 객체를 포함하는 케이지를 생성하고 소리를 출력
    -   String 타입은 Animal의 서브타입이 아니므로, Cage<String>을 생성하려고 하면 컴파일 오류가 발생
    
    이 예제는 제네릭 타입을 사용할 때 특정 타입의 서브타입만 허용하도록 제한하는 방법을 보여준다. 이를 통해 불필요한 타입 오류를 방지하고, 더 안전한 코드를 작성할 수 있다.
    

**A common use case is ensuring that a type is non-nullable by making it a subtype of `Object` (instead of the default, [`Object?`](https://dart.dev/null-safety/understanding-null-safety#top-and-bottom)).**

일반적인 사용 사례는 타입을 Object의 서브타입으로 만들어(기본값인 Object? 대신) non-nullable 타입이 되도록 보장하는 것이다.

```dart
class Foo<T extends Object> {
  // Any type provided to Foo for T must be non-nullable.
}

```

**You can use `extends` with other types besides `Object`. Here's an example of extending `SomeBaseClass`, so that members of `SomeBaseClass` can be called on objects of type `T`:**

Object 외에도 다른 타입과 함께 extends를 사용할 수 있다. 다음은 SomeBaseClass를 확장하는 예제이다. 이를 통해 SomeBaseClass의 멤버를 타입 T의 객체에서 호출할 수 있다:

```dart
class Foo<T extends SomeBaseClass> {
  // Implementation goes here...
  String toString() => "Instance of 'Foo<$T>'";
}

class Extender extends SomeBaseClass {...}

```

**It's OK to use `SomeBaseClass` or any of its subtypes as the generic argument:**

제네릭 인수로 SomeBaseClass 또는 그 하위 타입을 사용하는 것은 가능하다:

```dart
var someBaseClassFoo = Foo<SomeBaseClass>();
var extenderFoo = Foo<Extender>();

```

**It's also OK to specify no generic argument:**

제네릭 인수를 지정하지 않는 것도 가능하다:

```dart
var foo = Foo();
print(foo); // Instance of 'Foo<SomeBaseClass>'

```

**Specifying any non-`SomeBaseClass` type results in an error:**

SomeBaseClass가 아닌 다른 타입을 지정하면 오류가 발생한다:

```dart
// ✗ static analysis: failure
var foo = Foo<Object>();

```

## **Using generic methods[#](https://dart.dev/language/generics#using-generic-methods) 제네릭 메서드 사용하기**

**Methods and functions also allow type arguments:**

메서드와 함수도 타입 인수를 허용한다:

```dart
T first<T>(List<T> ts) {
  // Do some initial work or error checking, then...
  T tmp = ts[0];
  // Do some additional checking or processing...
  return tmp;
}

```

**Here the generic type parameter on `first` (`<T>`) allows you to use the type argument `T` in several places:**

여기서 첫 번째 제네릭 타입 매개변수 <T>는 다음과 같이 여러 곳에서 타입 인수 T를 사용할 수 있게 해준다:

-   **In the function's return type (`T`).**
    
    함수의 반환 타입 (T)
    
-   **In the type of an argument (`List<T>`).**
    
    인수의 타입 (List<T>)
    
-   **In the type of a local variable (`T tmp`).**
    
    로컬 변수의 타입 (T tmp)

