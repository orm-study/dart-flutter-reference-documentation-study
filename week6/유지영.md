ğŸ”— [í˜ì´ì§€ ë§í¬]

# **Asynchronous programming: futures, async, await**

ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°: futures, async, await


**This tutorial teaches you how to write asynchronous code using futures and the `async` and `await` keywords. Using embedded DartPad editors, you can test your knowledge by running example code and completing exercises.**

ì´ íŠœí† ë¦¬ì–¼ì€ futuresì™€ async ë° await í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë¹„ë™ê¸° ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ” ë°©ë²•ì„ ê°€ë¥´ì¹œë‹¤. ë‚´ì¥ëœ DartPad í¸ì§‘ê¸°ë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜ˆì œ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ê³  ì—°ìŠµ ë¬¸ì œë¥¼ ì™„ë£Œí•¨ìœ¼ë¡œì¨ ì§€ì‹ì„ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆë‹¤.

**To get the most out of this tutorial, you should have the following:**

ì´ íŠœí† ë¦¬ì–¼ì„ ìµœëŒ€í•œ í™œìš©í•˜ë ¤ë©´ ë‹¤ìŒ ì‚¬í•­ì„ ì•Œê³  ìˆì–´ì•¼ í•œë‹¤:

- **Knowledge of [basic Dart syntax](https://dart.dev/language).**
    
    ê¸°ë³¸ì ì¸ Dart êµ¬ë¬¸ì— ëŒ€í•œ ì§€ì‹.
    
- **Some experience writing asynchronous code in another language.**
    
    ë‹¤ë¥¸ ì–¸ì–´ì—ì„œ ë¹„ë™ê¸° ì½”ë“œë¥¼ ì‘ì„±í•œ ê²½í—˜.
    

**This tutorial covers the following material:**

ì´ íŠœí† ë¦¬ì–¼ì€ ë‹¤ìŒê³¼ ê°™ì€ ë‚´ìš©ì„ ë‹¤ë£¬ë‹¤:

- **How and when to use the `async` and `await` keywords.**
    
    async ë° await í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ê³¼ ì‹œê¸°.
    
- **How using `async` and `await` affects execution order.**
    
    async ë° awaitë¥¼ ì‚¬ìš©í•˜ë©´ ì‹¤í–‰ ìˆœì„œì— ì–´ë–»ê²Œ ì˜í–¥ì„ ë¯¸ì¹˜ëŠ”ì§€.
    
- **How to handle errors from an asynchronous call using `try-catch` expressions in `async` functions.**
    
    async í•¨ìˆ˜ì—ì„œ try-catch í‘œí˜„ì‹ì„ ì‚¬ìš©í•˜ì—¬ ë¹„ë™ê¸° í˜¸ì¶œì—ì„œ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•.
    

**Estimated time to complete this tutorial: 40-60 minutes.**

ì´ íŠœí† ë¦¬ì–¼ì„ ì™„ë£Œí•˜ëŠ” ë° ì˜ˆìƒ ì†Œìš” ì‹œê°„: 40-60ë¶„.

<aside>
â„¹ï¸ **Note**

**This page uses embedded DartPads to display examples and exercises. If you see empty boxes instead of DartPads, go to the [DartPad troubleshooting page](https://dart.dev/tools/dartpad/troubleshoot).**

ì´ í˜ì´ì§€ëŠ” ì˜ˆì œì™€ ì—°ìŠµ ë¬¸ì œë¥¼ í‘œì‹œí•˜ê¸° ìœ„í•´ ë‚´ì¥ëœ DartPadsë¥¼ ì‚¬ìš©í•œë‹¤. DartPads ëŒ€ì‹  ë¹ˆ ìƒìê°€ ë³´ì´ë©´ DartPad ë¬¸ì œ í•´ê²° í˜ì´ì§€ë¡œ ì´ë™í•˜ë¼.

</aside>

**The exercises in this tutorial have partially completed code snippets. You can use DartPad to test your knowledge by completing the code and clicking the Run button. Don't edit the test code in the `main` function or below.**

ì´ íŠœí† ë¦¬ì–¼ì˜ ì—°ìŠµ ë¬¸ì œì—ëŠ” ë¶€ë¶„ì ìœ¼ë¡œ ì™„ì„±ëœ ì½”ë“œ ì¡°ê°ì´ í¬í•¨ë˜ì–´ ìˆë‹¤. DartPadë¥¼ ì‚¬ìš©í•˜ì—¬ ì½”ë“œë¥¼ ì™„ì„±í•˜ê³  Run ë²„íŠ¼ì„ í´ë¦­í•´ ì§€ì‹ì„ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆë‹¤. main í•¨ìˆ˜ë‚˜ ê·¸ ì•„ë˜ì— ìˆëŠ” í…ŒìŠ¤íŠ¸ ì½”ë“œëŠ” ìˆ˜ì •í•˜ì§€ ë§ì•„ì•¼ í•œë‹¤.

**If you need help, expand the Hint or Solution dropdown after each exercise.**

ë„ì›€ì´ í•„ìš”í•˜ë©´ ê° ì—°ìŠµ ë¬¸ì œ ë’¤ì— ìˆëŠ” íŒíŠ¸ ë˜ëŠ” ì†”ë£¨ì…˜ ë“œë¡­ë‹¤ìš´ì„ í™•ì¥í•˜ë©´ ëœë‹¤.


## **Why asynchronous code matters**[#](https://dart.dev/libraries/async/async-await#why-asynchronous-code-matters)
ë¹„ë™ê¸° ì½”ë“œê°€ ì¤‘ìš”í•œ ì´ìœ 

**Asynchronous operations let your program complete work while waiting for another operation to finish. Here are some common asynchronous operations:**

ë¹„ë™ê¸° ì‘ì—…ì„ ì‚¬ìš©í•˜ë©´ ë‹¤ë¥¸ ì‘ì—…ì´ ì™„ë£Œë˜ê¸°ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ë™ì•ˆ í”„ë¡œê·¸ë¨ì´ ì‘ì—…ì„ ê³„ì† ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤. ë‹¤ìŒì€ ì¼ë°˜ì ì¸ ë¹„ë™ê¸° ì‘ì—…ì˜ ëª‡ ê°€ì§€ ì˜ˆì‹œì´ë‹¤:

- **Fetching data over a network.**
    
    ë„¤íŠ¸ì›Œí¬ë¥¼ í†µí•´ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°.
    
- **Writing to a database.**
    
    ë°ì´í„°ë² ì´ìŠ¤ì— ì“°ê¸°.
    
- **Reading data from a file.**
    
    íŒŒì¼ì—ì„œ ë°ì´í„° ì½ê¸°.
    

**Such asynchronous computations usually provide their result as a `Future` or, if the result has multiple parts, as a `Stream`. These computations introduce asynchrony into a program. To accommodate that initial asynchrony, other plain Dart functions also need to become asynchronous.**

ì´ëŸ¬í•œ ë¹„ë™ê¸° ê³„ì‚°ì€ ì¼ë°˜ì ìœ¼ë¡œ ê²°ê³¼ë¥¼ Futureë¡œ ì œê³µí•˜ê±°ë‚˜, ê²°ê³¼ê°€ ì—¬ëŸ¬ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ë‰˜ì–´ ìˆëŠ” ê²½ìš° Streamìœ¼ë¡œ ì œê³µí•œë‹¤. ì´ëŸ¬í•œ ê³„ì‚°ì€ í”„ë¡œê·¸ë¨ì— ë¹„ë™ê¸°ì„±ì„ ë„ì…í•œë‹¤. ì´ëŸ¬í•œ ì´ˆê¸° ë¹„ë™ê¸°ì„±ì„ ìˆ˜ìš©í•˜ê¸° ìœ„í•´ ë‹¤ë¥¸ ì¼ë°˜ Dart í•¨ìˆ˜ë“¤ë„ ë¹„ë™ê¸° í•¨ìˆ˜ê°€ ë˜ì–´ì•¼ í•œë‹¤.

**To interact with these asynchronous results, you can use the `async` and `await` keywords. Most asynchronous functions are just async Dart functions that depend, possibly deep down, on an inherently asynchronous computation.**

ì´ëŸ¬í•œ ë¹„ë™ê¸° ê²°ê³¼ì™€ ìƒí˜¸ì‘ìš©í•˜ë ¤ë©´ async ë° await í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ëŒ€ë¶€ë¶„ì˜ ë¹„ë™ê¸° í•¨ìˆ˜ëŠ” ë‹¨ìˆœíˆ ë³¸ì§ˆì ìœ¼ë¡œ ë¹„ë™ê¸° ê³„ì‚°ì— ì˜ì¡´í•˜ëŠ” async Dart í•¨ìˆ˜ì´ë‹¤.

### **Example: Incorrectly using an asynchronous function[#](https://dart.dev/libraries/async/async-await#example-incorrectly-using-an-asynchronous-function)**
ì˜ˆì‹œ: ë¹„ë™ê¸° í•¨ìˆ˜ë¥¼ ì˜ëª» ì‚¬ìš©í•˜ëŠ” ì˜ˆ

**The following example shows the wrong way to use an asynchronous function (`fetchUserOrder()`). Later you'll fix the example using `async` and `await`. Before running this example, try to spot the issue -- what do you think the output will be?**

ë‹¤ìŒ ì˜ˆì‹œëŠ” ë¹„ë™ê¸° í•¨ìˆ˜(fetchUserOrder())ë¥¼ ì˜ëª» ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤€ë‹¤. ë‚˜ì¤‘ì— ì´ ì˜ˆì œë¥¼ asyncì™€ awaitë¥¼ ì‚¬ìš©í•˜ì—¬ ìˆ˜ì •í•  ê²ƒì´ë‹¤. ì´ ì˜ˆì œë¥¼ ì‹¤í–‰í•˜ê¸° ì „ì— ë¬¸ì œë¥¼ ì°¾ì•„ë³´ë¼ â€“ ì¶œë ¥ ê²°ê³¼ê°€ ë¬´ì—‡ì¼ì§€ ìƒê°í•´ë³´ë¼.

```dart
// This example shows how *not* to write asynchronous Dart code.

String createOrderMessage() {
  var order = fetchUserOrder();
  return 'Your order is: $order';
}

Future<String> fetchUserOrder() =>
    // Imagine that this function is more complex and slow.
    Future.delayed(
      const Duration(seconds: 2),
      () => 'Large Latte',
    );

void main() {
  print(createOrderMessage());
}
```

- **[note] ì¶œë ¥ ê²°ê³¼ ì˜ˆìƒ**
    
    `main`ì—ì„œ `createOrderMessage()` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ì˜€ë‹¤. `createOrderMessage()` ëŠ” ë³€ìˆ˜ orderì— `fetchUserOrder()`ë¥¼ í˜¸ì¶œí•œ ê°’ì„ ë‹´ì€ í›„ ë¬¸ìì—´ë¡œ ì¶œë ¥í•œë‹¤. í•˜ì§€ë§Œ `fetchUserOrder()` ë©”ì„œë“œëŠ” `Future` í•¨ìˆ˜ë¡œ, 2ì´ˆ ê°„ì˜ ì§€ì—° í›„ ë¬¸ìì—´ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤. `await` í‚¤ì›Œë“œê°€ ì—†ê¸° ë•Œë¬¸ì— $orderì˜ ê°’ì€ null í—ˆìš©ì„ í•˜ì§€ ì•Šê³  ìˆê¸° ë•Œë¬¸ì—, Your order isë§Œ ì¶œë ¥ë˜ì§€ ì•Šì„ê¹Œ?!
    

```dart
// ì¶œë ¥ ê²°ê³¼
Your order is: Instance of '_Future<String>'
```

**Here's why the example fails to print the value that `fetchUserOrder()` eventually produces:**

ë‹¤ìŒì€ fetchUserOrder()ê°€ ê²°êµ­ ìƒì„±í•˜ëŠ” ê°’ì„ ì¶œë ¥í•˜ì§€ ëª»í•˜ëŠ” ì´ìœ ì´ë‹¤:

- **`fetchUserOrder()` is an asynchronous function that, after a delay, provides a string that describes the user's order: a "Large Latte".**
    
    fetchUserOrder()ëŠ” ë¹„ë™ê¸° í•¨ìˆ˜ë¡œ, ì§€ì—° í›„ì— ì‚¬ìš©ìì˜ ì£¼ë¬¸ì„ ì„¤ëª…í•˜ëŠ” ë¬¸ìì—´ì¸ â€œLarge Latteâ€ë¥¼ ì œê³µí•œë‹¤.
    
- **To get the user's order, `createOrderMessage()` should call `fetchUserOrder()` and wait for it to finish. Because `createOrderMessage()` does *not* wait for `fetchUserOrder()` to finish, `createOrderMessage()` fails to get the string value that `fetchUserOrder()` eventually provides.**
    
    createOrderMessage()ëŠ” ì‚¬ìš©ìì˜ ì£¼ë¬¸ì„ ì–»ê¸° ìœ„í•´ fetchUserOrder()ë¥¼ í˜¸ì¶œí•˜ê³  ê·¸ ì‘ì—…ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë ¤ì•¼ í•œë‹¤. ê·¸ëŸ¬ë‚˜ createOrderMessage()ëŠ” fetchUserOrder()ê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ì§€ ì•Šê¸° ë•Œë¬¸ì— fetchUserOrder()ê°€ ì œê³µí•˜ëŠ” ë¬¸ìì—´ ê°’ì„ ì–»ì§€ ëª»í•œë‹¤.
    
- **Instead, `createOrderMessage()` gets a representation of pending work to be done: an uncompleted future. You'll learn more about futures in the next section.**
    
    ëŒ€ì‹  createOrderMessage()ëŠ” ì™„ë£Œë˜ì§€ ì•Šì€ futureì™€ ê°™ì€ ëŒ€ê¸° ì¤‘ì¸ ì‘ì—…ì˜ í‘œí˜„ì„ ì–»ê²Œ ëœë‹¤. ë‹¤ìŒ ì„¹ì…˜ì—ì„œ futuresì— ëŒ€í•´ ë” ë°°ìš¸ ê²ƒì´ë‹¤.
    
- **Because `createOrderMessage()` fails to get the value describing the user's order, the example fails to print "Large Latte" to the console, and instead prints "Your order is: Instance of '_Future<String>'".**
    
    createOrderMessage()ê°€ ì‚¬ìš©ìì˜ ì£¼ë¬¸ì„ ì„¤ëª…í•˜ëŠ” ê°’ì„ ì–»ì§€ ëª»í•˜ê¸° ë•Œë¬¸ì— ì˜ˆì œëŠ” â€œLarge Latteâ€ë¥¼ ì½˜ì†”ì— ì¶œë ¥í•˜ì§€ ëª»í•˜ê³  ëŒ€ì‹  â€œYour order is: Instance of â€˜_Futureâ€™â€œë¥¼ ì¶œë ¥í•œë‹¤.
    

**In the next sections you'll learn about futures and about working with futures (using `async` and `await`) so that you'll be able to write the code necessary to make `fetchUserOrder()` print the desired value ("Large Latte") to the console.**

ë‹¤ìŒ ì„¹ì…˜ì—ì„œëŠ” futuresì— ëŒ€í•´ ë°°ìš°ê³  futuresì™€ ì‘ì—…í•˜ëŠ” ë°©ë²•(asyncì™€ await ì‚¬ìš©)ì— ëŒ€í•´ ë°°ìš¸ ê²ƒì´ë‹¤. ì´ë¥¼ í†µí•´ fetchUserOrder()ê°€ ì½˜ì†”ì— ì›í•˜ëŠ” ê°’(â€œLarge Latteâ€)ì„ ì¶œë ¥í•˜ë„ë¡ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆê²Œ ë  ê²ƒì´ë‹¤.

### **Key terms ì£¼ìš” ìš©ì–´**

- **synchronous operation: A synchronous operation blocks other operations from executing until it completes.**
    
    ë™ê¸° ì‘ì—…: ë™ê¸° ì‘ì—…ì€ ì™„ë£Œë  ë•Œê¹Œì§€ ë‹¤ë¥¸ ì‘ì—…ì´ ì‹¤í–‰ë˜ëŠ” ê²ƒì„ ì°¨ë‹¨í•œë‹¤.
    
- **synchronous function: A synchronous function only performs synchronous operations.**
    
    ë™ê¸° í•¨ìˆ˜: ë™ê¸° í•¨ìˆ˜ëŠ” ë™ê¸° ì‘ì—…ë§Œ ìˆ˜í–‰í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤.
    
- **asynchronous operation: Once initiated, an asynchronous operation allows other operations to execute before it completes.**
    
    ë¹„ë™ê¸° ì‘ì—…: ì‹œì‘ë˜ë©´ ë¹„ë™ê¸° ì‘ì—…ì€ ì™„ë£Œë˜ê¸° ì „ì— ë‹¤ë¥¸ ì‘ì—…ì´ ì‹¤í–‰ë  ìˆ˜ ìˆê²Œ í•œë‹¤.
    
- **asynchronous function: An asynchronous function performs at least one asynchronous operation and can also perform *synchronous* operations.**
    
    ë¹„ë™ê¸° í•¨ìˆ˜: ë¹„ë™ê¸° í•¨ìˆ˜ëŠ” ìµœì†Œí•œ í•˜ë‚˜ì˜ ë¹„ë™ê¸° ì‘ì—…ì„ ìˆ˜í–‰í•˜ë©° ë™ê¸° ì‘ì—…ë„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.
    


## **What is a future?[#](https://dart.dev/libraries/async/async-await#what-is-a-future)**
Futureë€ ë¬´ì—‡ì¸ê°€?

**A future (lower case "f") is an instance of the [Future](https://api.dart.dev/stable/dart-async/Future-class.html) (capitalized "F") class. A future represents the result of an asynchronous operation, and can have two states: uncompleted or completed.**

future(ì†Œë¬¸ì â€œfâ€)ëŠ” Future(ëŒ€ë¬¸ì â€œFâ€) í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ì´ë‹¤. futureëŠ” ë¹„ë™ê¸° ì‘ì—…ì˜ ê²°ê³¼ë¥¼ ë‚˜íƒ€ë‚´ë©° ë‘ ê°€ì§€ ìƒíƒœë¥¼ ê°€ì§ˆ ìˆ˜ ìˆë‹¤: ì™„ë£Œë˜ì§€ ì•ŠìŒ(uncompleted) ë˜ëŠ” ì™„ë£Œë¨(completed).

<aside>
â„¹ï¸ **Note**

***Uncompleted* is a Dart term referring to the state of a future before it has produced a value.**

ì™„ë£Œë˜ì§€ ì•ŠìŒ(uncompleted)ì€ futureê°€ ê°’ì„ ìƒì„±í•˜ê¸° ì „ì˜ ìƒíƒœë¥¼ ë‚˜íƒ€ë‚´ëŠ” Dart ìš©ì–´ì´ë‹¤.

</aside>

### **Uncompleted[#](https://dart.dev/libraries/async/async-await#uncompleted)**
ì™„ë£Œë˜ì§€ ì•ŠìŒ

**When you call an asynchronous function, it returns an uncompleted future. That future is waiting for the function's asynchronous operation to finish or to throw an error.**

ë¹„ë™ê¸° í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë©´ ì™„ë£Œë˜ì§€ ì•Šì€ futureë¥¼ ë°˜í™˜í•œë‹¤. ê·¸ futureëŠ” í•¨ìˆ˜ì˜ ë¹„ë™ê¸° ì‘ì—…ì´ ì™„ë£Œë˜ê±°ë‚˜ ì˜¤ë¥˜ë¥¼ ë˜ì§ˆ ë•Œê¹Œì§€ ê¸°ë‹¤ë¦°ë‹¤.

### **Completed[#](https://dart.dev/libraries/async/async-await#completed)**
ì™„ë£Œë¨

**If the asynchronous operation succeeds, the future completes with a value. Otherwise, it completes with an error.**

ë¹„ë™ê¸° ì‘ì—…ì´ ì„±ê³µí•˜ë©´ futureëŠ” ê°’ì„ ë°˜í™˜í•˜ë©° ì™„ë£Œëœë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ì˜¤ë¥˜ì™€ í•¨ê»˜ ì™„ë£Œëœë‹¤.

### **Completing with a value[#](https://dart.dev/libraries/async/async-await#completing-with-a-value)**
ê°’ì„ ë°˜í™˜í•˜ë©° ì™„ë£Œë¨

**A future of type `Future<T>` completes with a value of type `T`. For example, a future with type `Future<String>` produces a string value. If a future doesn't produce a usable value, then the future's type is `Future<void>`.**

Future íƒ€ì…ì˜ futureëŠ” T íƒ€ì…ì˜ ê°’ì„ ë°˜í™˜í•˜ë©° ì™„ë£Œëœë‹¤. ì˜ˆë¥¼ ë“¤ì–´, Future íƒ€ì…ì˜ futureëŠ” ë¬¸ìì—´ ê°’ì„ ìƒì„±í•œë‹¤. ë§Œì•½ futureê°€ ì‚¬ìš© ê°€ëŠ¥í•œ ê°’ì„ ìƒì„±í•˜ì§€ ì•Šìœ¼ë©´ futureì˜ íƒ€ì…ì€ Futureì´ë‹¤.

### **Completing with an error[#](https://dart.dev/libraries/async/async-await#completing-with-an-error)**
ì˜¤ë¥˜ì™€ í•¨ê»˜ ì™„ë£Œë¨

**If the asynchronous operation performed by the function fails for any reason, the future completes with an error.**

í•¨ìˆ˜ê°€ ìˆ˜í–‰í•˜ëŠ” ë¹„ë™ê¸° ì‘ì—…ì´ ì–´ë–¤ ì´ìœ ë¡œë“  ì‹¤íŒ¨í•˜ë©´ futureëŠ” ì˜¤ë¥˜ì™€ í•¨ê»˜ ì™„ë£Œëœë‹¤.

### **Example: Introducing futures[#](https://dart.dev/libraries/async/async-await#example-introducing-futures)**
ì˜ˆì‹œ: Future ì†Œê°œ

**In the following example, `fetchUserOrder()` returns a future that completes after printing to the console. Because it doesn't return a usable value, `fetchUserOrder()` has the type `Future<void>`. Before you run the example, try to predict which will print first: "Large Latte" or "Fetching user order...".**

ë‹¤ìŒ ì˜ˆì‹œì—ì„œ fetchUserOrder()ëŠ” ì½˜ì†”ì— ì¶œë ¥í•œ í›„ ì™„ë£Œë˜ëŠ” futureë¥¼ ë°˜í™˜í•œë‹¤. ì‚¬ìš© ê°€ëŠ¥í•œ ê°’ì„ ë°˜í™˜í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— fetchUserOrder()ì˜ íƒ€ì…ì€ Futureì´ë‹¤. ì˜ˆì œë¥¼ ì‹¤í–‰í•˜ê¸° ì „ì— â€œLarge Latteâ€ì™€ â€œFetching user orderâ€¦â€ ì¤‘ ì–´ëŠ ê²ƒì´ ë¨¼ì € ì¶œë ¥ë ì§€ ì˜ˆì¸¡í•´ ë³´ë¼.

```dart
Future<void> fetchUserOrder() {
  // Imagine that this function is fetching user info from another service or database.
  return Future.delayed(const Duration(seconds: 2), () => print('Large Latte'));
}

void main() {
  fetchUserOrder();
  print('Fetching user order...');
}
```

- **[note] ì¶œë ¥ ê²°ê³¼ ì˜ˆìƒ**
    
    Fetching user order... â†’ Large Latte
    

```dart
// ì¶œë ¥ ê²°ê³¼
Fetching user order...
Large Latte
```

**In the preceding example, even though `fetchUserOrder()` executes before the `print()` call on line 8, the console shows the output from line 8("Fetching user order...") before the output from `fetchUserOrder()` ("Large Latte"). This is because `fetchUserOrder()` delays before it prints "Large Latte".**

ìœ„ ì˜ˆì‹œì—ì„œ fetchUserOrder()ê°€ 8ë²ˆ ì¤„ì˜ print() í˜¸ì¶œ ì „ì— ì‹¤í–‰ë˜ì§€ë§Œ, ì½˜ì†”ì—ëŠ” fetchUserOrder()ì˜ ì¶œë ¥(â€œLarge Latteâ€)ë³´ë‹¤ 8ë²ˆ ì¤„ì˜ ì¶œë ¥(â€œFetching user orderâ€¦â€)ì´ ë¨¼ì € ë‚˜íƒ€ë‚œë‹¤. ì´ëŠ” fetchUserOrder()ê°€ â€œLarge Latteâ€ë¥¼ ì¶œë ¥í•˜ê¸° ì „ì— ì§€ì—°ë˜ê¸° ë•Œë¬¸ì´ë‹¤.

### **Example: Completing with an error[#](https://dart.dev/libraries/async/async-await#example-completing-with-an-error)**
ì˜ˆì‹œ: ì˜¤ë¥˜ì™€ í•¨ê»˜ ì™„ë£Œë˜ê¸°

**Run the following example to see how a future completes with an error. A bit later you'll learn how to handle the error.**

ë‹¤ìŒ ì˜ˆì œë¥¼ ì‹¤í–‰í•˜ì—¬ futureê°€ ì˜¤ë¥˜ì™€ í•¨ê»˜ ì™„ë£Œë˜ëŠ” ë°©ì‹ì„ í™•ì¸í•˜ë¼. ì¡°ê¸ˆ í›„ì— ì˜¤ë¥˜ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì„ ë°°ìš°ê²Œ ë  ê²ƒì´ë‹¤.

```dart
Future<void> fetchUserOrder() {
  // Imagine that this function is fetching user info but encounters a bug.
  return Future.delayed(
    const Duration(seconds: 2),
    () => throw Exception('Logout failed: user ID is invalid'),
  );
}

void main() {
  fetchUserOrder();
  print('Fetching user order...');
}
```

**In this example, `fetchUserOrder()` completes with an error indicating that the user ID is invalid.**

ì´ ì˜ˆì‹œì—ì„œ fetchUserOrder()ëŠ” ì‚¬ìš©ì IDê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒì„ ë‚˜íƒ€ë‚´ëŠ” ì˜¤ë¥˜ì™€ í•¨ê»˜ ì™„ë£Œëœë‹¤.

**You've learned about futures and how they complete, but how do you use the results of asynchronous functions? In the next section you'll learn how to get results with the `async` and `await` keywords.**

ì´ì œ futureì™€ ê·¸ê²ƒì´ ì™„ë£Œë˜ëŠ” ë°©ì‹ì„ ë°°ì› ìœ¼ë‹ˆ, ë¹„ë™ê¸° í•¨ìˆ˜ì˜ ê²°ê³¼ë¥¼ ì–´ë–»ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆì„ê¹Œ? ë‹¤ìŒ ì„¹ì…˜ì—ì„œëŠ” asyncì™€ await í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ê²°ê³¼ë¥¼ ì–»ëŠ” ë°©ë²•ì„ ë°°ìš°ê²Œ ë  ê²ƒì´ë‹¤.

### **Quick review**
ê°„ë‹¨í•œ ë³µìŠµ

- **A [Future<T>](https://api.dart.dev/stable/dart-async/Future-class.html) instance produces a value of type `T`.**
    
    Future ì¸ìŠ¤í„´ìŠ¤ëŠ” T íƒ€ì…ì˜ ê°’ì„ ìƒì„±í•œë‹¤.
    
- **If a future doesn't produce a usable value, then the future's type is `Future<void>`.**
    
    ë§Œì•½ futureê°€ ì‚¬ìš© ê°€ëŠ¥í•œ ê°’ì„ ìƒì„±í•˜ì§€ ì•Šìœ¼ë©´ futureì˜ íƒ€ì…ì€ Futureì´ë‹¤.
    
- **A future can be in one of two states: uncompleted or completed.**
    
    futureëŠ” ë‘ ê°€ì§€ ìƒíƒœ ì¤‘ í•˜ë‚˜ì¼ ìˆ˜ ìˆë‹¤: ì™„ë£Œë˜ì§€ ì•ŠìŒ(uncompleted) ë˜ëŠ” ì™„ë£Œë¨(completed).
    
- **When you call a function that returns a future, the function queues up work to be done and returns an uncompleted future.**
    
    futureë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë©´, ê·¸ í•¨ìˆ˜ëŠ” ìˆ˜í–‰í•  ì‘ì—…ì„ ëŒ€ê¸°ì—´ì— ì¶”ê°€í•˜ê³  ì™„ë£Œë˜ì§€ ì•Šì€ futureë¥¼ ë°˜í™˜í•œë‹¤.
    
- **When a future's operation finishes, the future completes with a value or with an error.**
    
    futureì˜ ì‘ì—…ì´ ì™„ë£Œë˜ë©´, futureëŠ” ê°’ ë˜ëŠ” ì˜¤ë¥˜ì™€ í•¨ê»˜ ì™„ë£Œëœë‹¤.
    

### **Key terms:**
ì£¼ìš” ìš©ì–´:

- **Future: the Dart [Future](https://api.dart.dev/stable/dart-async/Future-class.html) class.**
    
    Future: Dart Future í´ë˜ìŠ¤.
    
- **future: an instance of the Dart `Future` class.**
    
    future: Dart Future í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤.
    


## **Working with futures: async and await[#](https://dart.dev/libraries/async/async-await#working-with-futures-async-and-await)**
Futureì™€ í•¨ê»˜ ì‘ì—…í•˜ê¸°: asyncì™€ await

**The `async` and `await` keywords provide a declarative way to define asynchronous functions and use their results. Remember these two basic guidelines when using `async` and `await`:**

asyncì™€ await í‚¤ì›Œë“œëŠ” ë¹„ë™ê¸° í•¨ìˆ˜ë¥¼ ì •ì˜í•˜ê³  ê·¸ ê²°ê³¼ë¥¼ ì‚¬ìš©í•˜ëŠ” ì„ ì–¸ì ì¸ ë°©ë²•ì„ ì œê³µí•œë‹¤. asyncì™€ awaitë¥¼ ì‚¬ìš©í•  ë•Œ ë‹¤ìŒ ë‘ ê°€ì§€ ê¸°ë³¸ ì§€ì¹¨ì„ ê¸°ì–µí•˜ë¼:

- **To define an async function, add `async` before the function body:**
    
    ë¹„ë™ê¸° í•¨ìˆ˜ë¥¼ ì •ì˜í•˜ë ¤ë©´ í•¨ìˆ˜ ë³¸ë¬¸ ì•ì— asyncë¥¼ ì¶”ê°€í•˜ë¼:
    
- **The `await` keyword works only in `async` functions.**
    
    await í‚¤ì›Œë“œëŠ” async í•¨ìˆ˜ì—ì„œë§Œ ì‘ë™í•œë‹¤.
    

**Here's an example that converts `main()` from a synchronous to asynchronous function.**

ì—¬ê¸°ì—ì„œëŠ” main() í•¨ìˆ˜ë¥¼ ë™ê¸° í•¨ìˆ˜ì—ì„œ ë¹„ë™ê¸° í•¨ìˆ˜ë¡œ ë³€í™˜í•˜ëŠ” ì˜ˆì‹œë¥¼ ë³´ì—¬ì¤€ë‹¤.

**First, add the `async` keyword before the function body:**

ë¨¼ì € í•¨ìˆ˜ ë³¸ë¬¸ ì•ì— async í‚¤ì›Œë“œë¥¼ ì¶”ê°€í•˜ë¼:

```dart
void main() async { Â·Â·Â· }
```

**If the function has a declared return type, then update the type to be `Future<T>`, where `T` is the type of the value that the function returns. If the function doesn't explicitly return a value, then the return type is `Future<void>`:**

í•¨ìˆ˜ê°€ ì„ ì–¸ëœ ë°˜í™˜ íƒ€ì…ì´ ìˆëŠ” ê²½ìš°, ë°˜í™˜ íƒ€ì…ì„ Futureë¡œ ì—…ë°ì´íŠ¸í•˜ë¼. ì—¬ê¸°ì„œ TëŠ” í•¨ìˆ˜ê°€ ë°˜í™˜í•˜ëŠ” ê°’ì˜ íƒ€ì…ì´ë‹¤. í•¨ìˆ˜ê°€ ëª…ì‹œì ìœ¼ë¡œ ê°’ì„ ë°˜í™˜í•˜ì§€ ì•ŠëŠ” ê²½ìš°, ë°˜í™˜ íƒ€ì…ì€ Futureì´ë‹¤:

```dart
Future<void> main() async { Â·Â·Â· }
```

**Now that you have an `async` function, you can use the `await` keyword to wait for a future to complete:**

ì´ì œ async í•¨ìˆ˜ê°€ ìˆìœ¼ë¯€ë¡œ await í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ futureê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦´ ìˆ˜ ìˆë‹¤:

```dart
print(await createOrderMessage());
```

**As the following two examples show, the `async` and `await` keywords result in asynchronous code that looks a lot like synchronous code. The only differences are highlighted in the asynchronous example, whichâ€”if your window is wide enoughâ€”is to the right of the synchronous example.**

ë‹¤ìŒ ë‘ ê°€ì§€ ì˜ˆì‹œì—ì„œ ë³´ë“¯ì´, asyncì™€ await í‚¤ì›Œë“œëŠ” ë¹„ë™ê¸° ì½”ë“œë¥¼ ë™ê¸° ì½”ë“œì²˜ëŸ¼ ë³´ì´ê²Œ í•œë‹¤. ì°¨ì´ì ì€ ë¹„ë™ê¸° ì˜ˆì œì—ì„œ ê°•ì¡° í‘œì‹œëœ ë¶€ë¶„ë¿ì´ë‹¤. ë¹„ë™ê¸° ì˜ˆì œëŠ” ì°½ì˜ í­ì´ ì¶©ë¶„íˆ ë„“ìœ¼ë©´ ë™ê¸° ì˜ˆì œì˜ ì˜¤ë¥¸ìª½ì— ë‚˜íƒ€ë‚œë‹¤.

### Example: synchronous functions

ì˜ˆì‹œ: ë™ê¸° í•¨ìˆ˜

```dart
String createOrderMessage() {
  var order = fetchUserOrder();
  return 'Your order is: $order';
}

Future<String> fetchUserOrder() =>
    // Imagine that this function is
    // more complex and slow.
    Future.delayed(
      const Duration(seconds: 2),
      () => 'Large Latte',
    );

void main() {
  print('Fetching user order...');
  print(createOrderMessage());
}
```

```dart
Fetching user order...
Your order is: Instance of '_Future<String>'
```

### Example: asynchronous functions

```dart
Future<String> createOrderMessage() async {
  var order = await fetchUserOrder();
  return 'Your order is: $order';
}

Future<String> fetchUserOrder() =>
    // Imagine that this function is
    // more complex and slow.
    Future.delayed(
      const Duration(seconds: 2),
      () => 'Large Latte',
    );

Future<void> main() async {
  print('Fetching user order...');
  print(await createOrderMessage());
}
```

```dart
Fetching user order...
Your order is: Large Latte
```

**The asynchronous example is different in three ways:**

ë¹„ë™ê¸° ì˜ˆì‹œëŠ” ì„¸ ê°€ì§€ ë©´ì—ì„œ ë‹¤ë¥´ë‹¤:

- **The return type for `createOrderMessage()` changes from `String` to `Future<String>`.**
    
    createOrderMessage()ì˜ ë°˜í™˜ íƒ€ì…ì´ Stringì—ì„œ Futureìœ¼ë¡œ ë³€ê²½ëœë‹¤.
    
- **The `async` keyword appears before the function bodies for `createOrderMessage()` and `main()`.**
    
    async í‚¤ì›Œë“œê°€ createOrderMessage()ì™€ main() í•¨ìˆ˜ ë³¸ë¬¸ ì•ì— ë‚˜íƒ€ë‚œë‹¤.
    
- **The `await` keyword appears before calling the asynchronous functions `fetchUserOrder()` and `createOrderMessage()`.**
    
    await í‚¤ì›Œë“œê°€ ë¹„ë™ê¸° í•¨ìˆ˜ fetchUserOrder()ì™€ createOrderMessage()ë¥¼ í˜¸ì¶œí•˜ê¸° ì „ì— ë‚˜íƒ€ë‚œë‹¤.
    

**Key terms**

ì£¼ìš” ìš©ì–´

- **async: You can use the `async` keyword before a function's body to mark it as asynchronous.**
    
    async: í•¨ìˆ˜ ë³¸ë¬¸ ì•ì— async í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ í•¨ìˆ˜ë¥¼ ë¹„ë™ê¸° í•¨ìˆ˜ë¡œ í‘œì‹œí•  ìˆ˜ ìˆë‹¤.
    
- **async function: An `async` function is a function labeled with the `async` keyword.**
    
    ë¹„ë™ê¸° í•¨ìˆ˜: async í‚¤ì›Œë“œë¡œ í‘œì‹œëœ í•¨ìˆ˜ì´ë‹¤.
    
- **await: You can use the `await` keyword to get the completed result of an asynchronous expression. The `await` keyword only works within an `async` function.**
    
    await: ë¹„ë™ê¸° í‘œí˜„ì‹ì˜ ì™„ë£Œëœ ê²°ê³¼ë¥¼ ì–»ê¸° ìœ„í•´ await í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. await í‚¤ì›Œë“œëŠ” ë¹„ë™ê¸° í•¨ìˆ˜ ë‚´ì—ì„œë§Œ ì‘ë™í•œë‹¤.
    

### **Execution flow with async and await[#](https://dart.dev/libraries/async/async-await#execution-flow-with-async-and-await)**
asyncì™€ awaitì˜ ì‹¤í–‰ íë¦„

**An `async` function runs synchronously until the first `await` keyword. This means that within an `async` function body, all synchronous code before the first `await` keyword executes immediately.**

ë¹„ë™ê¸° í•¨ìˆ˜ëŠ” ì²« ë²ˆì§¸ await í‚¤ì›Œë“œê¹Œì§€ ë™ê¸°ì ìœ¼ë¡œ ì‹¤í–‰ëœë‹¤. ì´ëŠ” ë¹„ë™ê¸° í•¨ìˆ˜ ë³¸ë¬¸ ë‚´ì—ì„œ ì²« ë²ˆì§¸ await í‚¤ì›Œë“œ ì´ì „ì˜ ëª¨ë“  ë™ê¸° ì½”ë“œê°€ ì¦‰ì‹œ ì‹¤í–‰ë¨ì„ ì˜ë¯¸í•œë‹¤.

### **Example: Execution within async functions[#](https://dart.dev/libraries/async/async-await#example-execution-within-async-functions)**
ì˜ˆì‹œ: ë¹„ë™ê¸° í•¨ìˆ˜ ë‚´ì˜ ì‹¤í–‰ íë¦„

**Run the following example to see how execution proceeds within an `async` function body. What do you think the output will be?**

ë‹¤ìŒ ì˜ˆì œë¥¼ ì‹¤í–‰í•˜ì—¬ ë¹„ë™ê¸° í•¨ìˆ˜ ë³¸ë¬¸ ë‚´ì—ì„œ ì‹¤í–‰ì´ ì–´ë–»ê²Œ ì§„í–‰ë˜ëŠ”ì§€ í™•ì¸í•˜ë¼. ì¶œë ¥ ê²°ê³¼ê°€ ë¬´ì—‡ì¼ì§€ ìƒê°í•´ë³´ë¼.

```dart
Future<void> printOrderMessage() async {
  print('Awaiting user order...');
  var order = await fetchUserOrder();
  print('Your order is: $order');
}

Future<String> fetchUserOrder() {
  // Imagine that this function is more complex and slow.
  return Future.delayed(const Duration(seconds: 4), () => 'Large Latte');
}

void main() async {
  countSeconds(4);
  await printOrderMessage();
}

// You can ignore this function - it's here to visualize delay time in this example.
void countSeconds(int s) {
  for (var i = 1; i <= s; i++) {
    Future.delayed(Duration(seconds: i), () => print(i));
  }
}
```

- **[note] ì¶œë ¥ ê²°ê³¼ ì˜ˆìƒ**
    
    

```dart
Awaiting user order...
1
2
3
4
Your order is: Large Latte
```

**After running the code in the preceding example, try reversing lines 2 and 3:**

ì•ì„  ì˜ˆì œì˜ ì½”ë“œë¥¼ ì‹¤í–‰í•œ í›„, 2ë²ˆ ì¤„ê³¼ 3ë²ˆ ì¤„ì„ ë°”ê¿” ë³´ë¼:

```dart
var order = await fetchUserOrder();
print('Awaiting user order...');
```

**Notice that timing of the output shifts, now that `print('Awaiting user order')` appears after the first `await` keyword in `printOrderMessage()`.**

printOrderMessage()ì—ì„œ ì²« ë²ˆì§¸ await í‚¤ì›Œë“œ ì´í›„ì— print(â€˜Awaiting user orderâ€™)ê°€ ë‚˜íƒ€ë‚˜ë©´ ì¶œë ¥ì˜ íƒ€ì´ë°ì´ ë‹¬ë¼ì§€ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

### **Exercise: Practice using async and await[#](https://dart.dev/libraries/async/async-await#exercise-practice-using-async-and-await)**
ì—°ìŠµ ë¬¸ì œ: asyncì™€ await ì‚¬ìš© ì—°ìŠµ

**The following exercise is a failing unit test that contains partially completed code snippets. Your task is to complete the exercise by writing code to make the tests pass. You don't need to implement `main()`.**

ë‹¤ìŒ ì—°ìŠµ ë¬¸ì œëŠ” ë¶€ë¶„ì ìœ¼ë¡œ ì™„ì„±ëœ ì½”ë“œ ì¡°ê°ì„ í¬í•¨í•œ ì‹¤íŒ¨í•˜ëŠ” ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ì´ë‹¤. ì´ ì—°ìŠµ ë¬¸ì œë¥¼ ì™„ì„±í•˜ì—¬ í…ŒìŠ¤íŠ¸ê°€ í†µê³¼í•˜ë„ë¡ ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ” ê²ƒì´ ê³¼ì œì´ë‹¤. main()ì„ êµ¬í˜„í•  í•„ìš”ëŠ” ì—†ë‹¤.

**To simulate asynchronous operations, call the following functions, which are provided for you:**

ë¹„ë™ê¸° ì‘ì—…ì„ ì‹œë®¬ë ˆì´ì…˜í•˜ë ¤ë©´ ë‹¤ìŒ í•¨ìˆ˜ë“¤ì„ í˜¸ì¶œí•˜ë¼. ì´ í•¨ìˆ˜ë“¤ì€ ë¯¸ë¦¬ ì œê³µë˜ì–´ ìˆë‹¤:

| Function í•¨ìˆ˜ | Type signature  | Description ì„¤ëª… |
| --- | --- | --- |
| fetchRole() | Future<String> fetchRole() | Gets a short description of the user's role.
ì‚¬ìš©ìì˜ ì—­í• ì— ëŒ€í•œ ì§§ì€ ì„¤ëª…ì„ ê°€ì ¸ì˜¨ë‹¤. |
| fetchLoginAmount() | Future<int> fetchLoginAmount() | Gets the number of times a user has logged in.
ì‚¬ìš©ìê°€ ë¡œê·¸ì¸í•œ íšŸìˆ˜ë¥¼ ê°€ì ¸ì˜¨ë‹¤. |

**Part 1: `reportUserRole()`[#](https://dart.dev/libraries/async/async-await#part-1-reportuserrole)**

**Add code to the `reportUserRole()` function so that it does the following:**

reportUserRole() í•¨ìˆ˜ì— ë‹¤ìŒê³¼ ê°™ì€ ì½”ë“œë¥¼ ì¶”ê°€í•˜ë¼:

- **Returns a future that completes with the following string: `"User role: <user role>"`**
    
    ë‹¤ìŒ ë¬¸ìì—´ë¡œ ì™„ë£Œë˜ëŠ” futureë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤: â€œUser role: â€
    
    - Note: You must use the actual value returned by `fetchRole()`; copying and pasting the example return value won't make the test pass.
        
        ì°¸ê³ : ì‹¤ì œë¡œ fetchRole()ì´ ë°˜í™˜í•˜ëŠ” ê°’ì„ ì‚¬ìš©í•´ì•¼ í•˜ë©°, ì˜ˆì œ ë°˜í™˜ ê°’ì„ ë³µì‚¬í•˜ì—¬ ë¶™ì—¬ë„£ì–´ë„ í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í•˜ì§€ ëª»í•œë‹¤.
        
    - Example return value: `"User role: tester"`
        
        ì˜ˆì œ ë°˜í™˜ ê°’: â€œUser role: testerâ€
        
- **Gets the user role by calling the provided function `fetchRole()`.**
    
    ì œê³µëœ í•¨ìˆ˜ fetchRole()ì„ í˜¸ì¶œí•˜ì—¬ ì‚¬ìš©ì ì—­í• ì„ ê°€ì ¸ì™€ì•¼ í•œë‹¤.
    

**Part 2: `reportLogins()`[#](https://dart.dev/libraries/async/async-await#part-2-reportlogins)**

**Implement an `async` function `reportLogins()` so that it does the following:**

ë‹¤ìŒê³¼ ê°™ì´ ë™ì‘í•˜ë„ë¡ ë¹„ë™ê¸° í•¨ìˆ˜ reportLogins()ë¥¼ êµ¬í˜„í•˜ë¼:

- **Returns the string `"Total number of logins: <# of logins>"`.**
    
    â€œTotal number of logins: <# of logins>â€ ë¬¸ìì—´ì„ ë°˜í™˜í•´ì•¼ í•œë‹¤.
    
    - Note: You must use the actual value returned by `fetchLoginAmount()`; copying and pasting the example return value won't make the test pass.
        
        ì°¸ê³ : ì‹¤ì œë¡œ fetchLoginAmount()ê°€ ë°˜í™˜í•˜ëŠ” ê°’ì„ ì‚¬ìš©í•´ì•¼ í•˜ë©°, ì˜ˆì œ ë°˜í™˜ ê°’ì„ ë³µì‚¬í•˜ì—¬ ë¶™ì—¬ë„£ì–´ë„ í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í•˜ì§€ ëª»í•œë‹¤.
        
    - Example return value from `reportLogins()`: `"Total number of logins: 57"`
        
        reportLogins()ì˜ ì˜ˆì œ ë°˜í™˜ ê°’: â€œTotal number of logins: 57â€
        
- **Gets the number of logins by calling the provided function `fetchLoginAmount()`.**
    
    ì œê³µëœ í•¨ìˆ˜ fetchLoginAmount()ë¥¼ í˜¸ì¶œí•˜ì—¬ ë¡œê·¸ì¸ íšŸìˆ˜ë¥¼ ê°€ì ¸ì™€ì•¼ í•œë‹¤.
    

## **Handling errors[#](https://dart.dev/libraries/async/async-await#handling-errors)**

**To handle errors in an `async` function, use try-catch:**

ë¹„ë™ê¸° í•¨ìˆ˜ì—ì„œ ì˜¤ë¥˜ë¥¼ ì²˜ë¦¬í•˜ë ¤ë©´ try-catchë¥¼ ì‚¬ìš©í•˜ë¼:

```dart
try {
  print('Awaiting user order...');
  var order = await fetchUserOrder();
} catch (err) {
  print('Caught error: $err');
}
```

**Within an `async` function, you can write [try-catch clauses](https://dart.dev/language/error-handling#catch) the same way you would in synchronous code.**

ë¹„ë™ê¸° í•¨ìˆ˜ ë‚´ì—ì„œ ë™ê¸° ì½”ë“œì—ì„œì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ try-catch ì ˆì„ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.

### **Example: async and await with try-catch[#](https://dart.dev/libraries/async/async-await#example-async-and-await-with-try-catch)**
ì˜ˆì‹œ: try-catchì™€ í•¨ê»˜ async ë° await ì‚¬ìš©

**Run the following example to see how to handle an error from an asynchronous function. What do you think the output will be?**

ë‹¤ìŒ ì˜ˆì œë¥¼ ì‹¤í–‰í•˜ì—¬ ë¹„ë™ê¸° í•¨ìˆ˜ì—ì„œ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì„ í™•ì¸í•˜ë¼. ì¶œë ¥ ê²°ê³¼ê°€ ë¬´ì—‡ì¼ì§€ ìƒê°í•´ë³´ë¼.

```dart
Future<void> printOrderMessage() async {
  try {
    print('Awaiting user order...');
    var order = await fetchUserOrder();
    print(order);
  } catch (err) {
    print('Caught error: $err');
  }
}

Future<String> fetchUserOrder() {
  // Imagine that this function is more complex.
  var str = Future.delayed(
      const Duration(seconds: 4),
      () => throw 'Cannot locate user order');
  return str;
}

void main() async {
  await printOrderMessage();
}
```

```dart
Awaiting user order...
Caught error: Cannot locate user order
```

### **Exercise: Practice handling errors**[#](https://dart.dev/libraries/async/async-await#exercise-practice-handling-errors)
ì—°ìŠµ ë¬¸ì œ: ì˜¤ë¥˜ ì²˜ë¦¬ ì—°ìŠµ

**The following exercise provides practice handling errors with asynchronous code, using the approach described in the previous section. To simulate asynchronous operations, your code will call the following function, which is provided for you:**

ë‹¤ìŒ ì—°ìŠµ ë¬¸ì œëŠ” ì´ì „ ì„¹ì…˜ì—ì„œ ì„¤ëª…í•œ ë°©ë²•ì„ ì‚¬ìš©í•˜ì—¬ ë¹„ë™ê¸° ì½”ë“œì—ì„œ ì˜¤ë¥˜ë¥¼ ì²˜ë¦¬í•˜ëŠ” ì—°ìŠµì„ ì œê³µí•œë‹¤. ë¹„ë™ê¸° ì‘ì—…ì„ ì‹œë®¬ë ˆì´ì…˜í•˜ê¸° ìœ„í•´ ì œê³µëœ ë‹¤ìŒ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ê²ƒì´ë‹¤:

| Function | Type signature | Description |
| --- | --- | --- |
| fetchNewUsername() | Future<String> fetchNewUsername() | Returns the new username that you can use to replace an old one.
ìƒˆë¡œìš´ ì‚¬ìš©ì ì´ë¦„ì„ ë°˜í™˜í•˜ì—¬ ê¸°ì¡´ ì´ë¦„ì„ ëŒ€ì²´í•  ìˆ˜ ìˆë‹¤. |

**Use `async` and `await` to implement an asynchronous `changeUsername()` function that does the following:**

asyncì™€ awaitë¥¼ ì‚¬ìš©í•˜ì—¬ ë‹¤ìŒ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ë¹„ë™ê¸° changeUsername() í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ë¼:

- **Calls the provided asynchronous function `fetchNewUsername()` and returns its result.**
    
    ì œê³µëœ ë¹„ë™ê¸° í•¨ìˆ˜ fetchNewUsername()ì„ í˜¸ì¶œí•˜ê³  ê·¸ ê²°ê³¼ë¥¼ ë°˜í™˜í•œë‹¤.
    
    - Example return value from `changeUsername()`: `"jane_smith_92"`
        
        changeUsername()ì˜ ì˜ˆì œ ë°˜í™˜ ê°’: â€œjane_smith_92â€
        
- **Catches any error that occurs and returns the string value of the error.**
    
    ë°œìƒí•˜ëŠ” ëª¨ë“  ì˜¤ë¥˜ë¥¼ ì¡ì•„ë‚´ê³  ì˜¤ë¥˜ì˜ ë¬¸ìì—´ ê°’ì„ ë°˜í™˜í•œë‹¤.
    
    - You can use the [toString()](https://api.dart.dev/stable/dart-core/ArgumentError/toString.html) method to stringify both [Exceptions](https://api.dart.dev/stable/dart-core/Exception-class.html) and [Errors.](https://api.dart.dev/stable/dart-core/Error-class.html)
        
        toString() ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜ˆì™¸(Exception)ì™€ ì˜¤ë¥˜(Error) ëª¨ë‘ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜í•  ìˆ˜ ìˆë‹¤.
        

### **Exercise: Putting it all together**[#](https://dart.dev/libraries/async/async-await#exercise-putting-it-all-together)
ì—°ìŠµ ë¬¸ì œ: ëª¨ë‘ í•©ì³ë³´ê¸°

**It's time to practice what you've learned in one final exercise. To simulate asynchronous operations, this exercise provides the asynchronous functions `fetchUsername()` and `logoutUser()`:**

ì´ì œ ë§ˆì§€ë§‰ ì—°ìŠµ ë¬¸ì œì—ì„œ ë°°ìš´ ê²ƒì„ ì‹¤ìŠµí•  ì‹œê°„ì´ë‹¤. ë¹„ë™ê¸° ì‘ì—…ì„ ì‹œë®¬ë ˆì´ì…˜í•˜ê¸° ìœ„í•´ ì´ ì—°ìŠµ ë¬¸ì œì—ì„œëŠ” ë¹„ë™ê¸° í•¨ìˆ˜ fetchUsername()ê³¼ logoutUser()ë¥¼ ì œê³µí•œë‹¤:

| Function | Type signature | Description |
| --- | --- | --- |
| fetchUsername() | Future<String> fetchUsername() | Returns the name associated with the current user. |
| logoutUser() | Future<String> logoutUser() | Performs logout of current user and returns the username that was logged out. |

**Write the following:**

ë‹¤ìŒ ë‚´ìš©ì„ ì‘ì„±í•˜ë¼:

**Part 1: `addHello()`[#](https://dart.dev/libraries/async/async-await#part-1-addhello)**

- **Write a function `addHello()` that takes a single `String` argument.**
    
    ë‹¨ì¼ ë¬¸ìì—´ ì¸ìˆ˜ë¥¼ ë°›ëŠ” í•¨ìˆ˜ addHello()ë¥¼ ì‘ì„±í•˜ë¼.
    
- **`addHello()` returns its `String` argument preceded by `'Hello '`.**
    
    addHello()ëŠ” ë¬¸ìì—´ ì¸ìˆ˜ ì•ì— â€™Hello â€™ë¥¼ ë¶™ì—¬ì„œ ë°˜í™˜í•œë‹¤.
    
    **Example: `addHello('Jon')` returns `'Hello Jon'`.**
    
    ì˜ˆì‹œ: addHello(â€˜Jonâ€™)ì€ â€˜Hello Jonâ€™ì„ ë°˜í™˜í•œë‹¤.
    

**Part 2: `greetUser()`[#](https://dart.dev/libraries/async/async-await#part-2-greetuser)**

- **Write a function `greetUser()` that takes no arguments.**
    
    ì¸ìˆ˜ë¥¼ ë°›ì§€ ì•ŠëŠ” í•¨ìˆ˜ greetUser()ë¥¼ ì‘ì„±í•˜ë¼.
    
- **To get the username, `greetUser()` calls the provided asynchronous function `fetchUsername()`.**
    
    greetUser()ëŠ” ì œê³µëœ ë¹„ë™ê¸° í•¨ìˆ˜ fetchUsername()ì„ í˜¸ì¶œí•˜ì—¬ ì‚¬ìš©ì ì´ë¦„ì„ ì–»ëŠ”ë‹¤.
    
- **`greetUser()` creates a greeting for the user by calling `addHello()`, passing it the username, and returning the result.**
    
    greetUser()ëŠ” ì‚¬ìš©ì ì´ë¦„ì„ addHello()ì— ì „ë‹¬í•˜ì—¬ ì¸ì‚¬ë¥¼ ìƒì„±í•˜ê³  ê·¸ ê²°ê³¼ë¥¼ ë°˜í™˜í•œë‹¤.
    
    **Example: If `fetchUsername()` returns `'Jenny'`, then `greetUser()` returns `'Hello Jenny'`.**
    
    ì˜ˆì‹œ: fetchUsername()ì´ â€˜Jennyâ€™ë¥¼ ë°˜í™˜í•˜ë©´ greetUser()ëŠ” â€˜Hello Jennyâ€™ë¥¼ ë°˜í™˜í•œë‹¤.
    

**Part 3: `sayGoodbye()`[#](https://dart.dev/libraries/async/async-await#part-3-saygoodbye)**

- **Write a function `sayGoodbye()` that does the following:**
    
    ë‹¤ìŒ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” í•¨ìˆ˜ sayGoodbye()ë¥¼ ì‘ì„±í•˜ë¼:
    
    - **Takes no arguments.**
        
        ì¸ìˆ˜ë¥¼ ë°›ì§€ ì•ŠëŠ”ë‹¤.
        
    - **Catches any errors.**
        
        ëª¨ë“  ì˜¤ë¥˜ë¥¼ ì¡ì•„ë‚¸ë‹¤.
        
    - **Calls the provided asynchronous function `logoutUser()`.**
        
        ì œê³µëœ ë¹„ë™ê¸° í•¨ìˆ˜ logoutUser()ë¥¼ í˜¸ì¶œí•œë‹¤.
        
- **If `logoutUser()` fails, `sayGoodbye()` returns any string you like.**
    
    logoutUser()ê°€ ì‹¤íŒ¨í•˜ë©´ sayGoodbye()ëŠ” ì„ì˜ì˜ ë¬¸ìì—´ì„ ë°˜í™˜í•œë‹¤.
    
- **If `logoutUser()` succeeds, `sayGoodbye()` returns the string `'<result> Thanks, see you next time'`, where `<result>` is the string value returned by calling `logoutUser()`.**
    
    logoutUser()ê°€ ì„±ê³µí•˜ë©´ sayGoodbye()ëŠ” â€˜<ê²°ê³¼> Thanks, see you next timeâ€™ ë¬¸ìì—´ì„ ë°˜í™˜í•˜ëŠ”ë°, ì—¬ê¸°ì„œ <ê²°ê³¼>ëŠ” logoutUser() í˜¸ì¶œë¡œ ë°˜í™˜ëœ ë¬¸ìì—´ ê°’ì´ë‹¤.
    


## **What's next?[#](https://dart.dev/libraries/async/async-await#whats-next)**

**Congratulations, you've finished the tutorial! If you'd like to learn more, here are some suggestions for where to go next:**

íŠœí† ë¦¬ì–¼ì„ ì™„ë£Œí•œ ê²ƒì„ ì¶•í•˜í•œë‹¤! ë” ë°°ìš°ê³  ì‹¶ë‹¤ë©´, ë‹¤ìŒì˜ ì œì•ˆì„ ì°¸ê³ í•˜ë¼:

- **Play with [DartPad](https://dartpad.dev/).**
    
    DartPadë¥¼ ê°€ì§€ê³  ë†€ì•„ë³´ë¼.
    
- **Try another [tutorial](https://dart.dev/tutorials).**
    
    ë‹¤ë¥¸ íŠœí† ë¦¬ì–¼ì„ ì‹œë„í•˜ë¼.
    
- **Learn more about futures and asynchronous code in Dart:**
    
    Dartì—ì„œ futuresì™€ ë¹„ë™ê¸° ì½”ë“œì— ëŒ€í•´ ë” ë°°ì›Œë³´ë¼:
    
    - [**Streams tutorial](https://dart.dev/libraries/async/using-streams): Learn how to work with a sequence of asynchronous events.**
        
        Streams íŠœí† ë¦¬ì–¼: ë¹„ë™ê¸° ì´ë²¤íŠ¸ ì‹œí€€ìŠ¤ë¥¼ ë‹¤ë£¨ëŠ” ë°©ë²•ì„ ë°°ì›Œë³´ë¼.
        
    - [**Concurrency in Dart](https://dart.dev/language/concurrency): Understand and learn how to implement concurrency in Dart.**
        
        Dartì˜ ë™ì‹œì„±: Dartì—ì„œ ë™ì‹œì„±ì„ ì´í•´í•˜ê³  êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ ë°°ì›Œë³´ë¼.
        
    - [**Asynchrony support](https://dart.dev/language/async): Dive in to Dart's language and library support for asynchronous coding.**
        
        ë¹„ë™ê¸° ì§€ì›: Dartì˜ ì–¸ì–´ì™€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ë¹„ë™ê¸° ì½”ë”©ì„ ì§€ì›í•˜ëŠ” ë‚´ìš©ì„ ê¹Šì´ ìˆê²Œ ë‹¤ë¤„ë³´ë¼.
        
    - [**Dart videos from Google](https://www.youtube.com/playlist?list=PLjxrf2q8roU0Net_g1NT5_vOO3s_FR02J): Watch one or more of the videos about asynchronous coding.**
        
        êµ¬ê¸€ì˜ Dart ë¹„ë””ì˜¤: ë¹„ë™ê¸° ì½”ë”©ì— ê´€í•œ ë¹„ë””ì˜¤ë¥¼ í•˜ë‚˜ ì´ìƒ ì‹œì²­í•´ë³´ë¼.
