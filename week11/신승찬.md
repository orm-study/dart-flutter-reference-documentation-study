# Hot reload

- 개발자는 Flutter 애플리케이션의 소스 코드를 변경합니다. 예를 들어, UI 요소를 수정하거나, 새 기능을 추가하거나, 버그를 수정하는 등의 작업을 합니다.
- 
- Flutter는 변경된 소스 코드를 **Dart Virtual Machine (VM)**에 주입합니다. Dart VM은 Flutter 애플리케이션을 실행하는 런타임 환경입니다.이 과정에서 Dart VM은 새로운 소스 코드 파일을 로드하고, 업데이트된 필드와 함수로 클래스 정의를 변경합니다.
- 
- Dart VM이 업데이트된 클래스를 처리한 후, Flutter 프레임워크는 자동으로 **위젯 트리**를 재구성합니다.
- 위젯 트리는 Flutter 애플리케이션의 UI를 구성하는 위젯들의 계층 구조입니다. 위젯 트리의 재구성은 변경된 UI 요소를 화면에 반영하기 위한 과정입니다.

Flutter의 **Hot Reload**는 개발 과정에서 매우 유용하지만, 몇 가지 **특수한 상황**에서는 예상대로 동작하지 않을 수 있습니다. 이 문서는 이러한 특수한 상황과 그에 따른 해결 방법을 설명하고 있습니다. 각 상황에 대한 설명은 다음과 같습니다:

### 

### **앱이 종료되었을 때 (App is killed)**

- **문제**: 앱이 백그라운드에서 너무 오랫동안 실행되지 않거나 강제로 종료된 경우, Hot Reload가 제대로 작동하지 않을 수 있습니다.
- **해결**: 앱을 다시 시작하거나, 문제가 지속될 경우 전체 재시작(Hot Restart)을 고려합니다.

### 2. **컴파일 오류 (Compilation errors)**

- **문제**: 코드 변경 시 컴파일 오류가 발생하면 Hot Reload는 실패합니다. 오류 메시지가 표시됩니다.
- **해결**: 오류 메시지에서 지적한 라인의 코드 오류를 수정한 후, 다시 Hot Reload를 시도합니다.

### 3. **`CupertinoTabView`의 빌더 (CupertinoTabView's builder)**

- **문제**: `CupertinoTabView`의 빌더에 대한 변경 사항은 Hot Reload로 반영되지 않습니다.
- **해결**: 해당 빌더를 수정한 후 전체 재시작(Hot Restart)을 수행하여 변경 사항을 적용합니다. 이 문제에 대한 자세한 사항은 [Issue 43574](https://github.com/flutter/flutter/issues/43574)에서 확인할 수 있습니다.

### 4. **열거형 타입 (Enumerated types)**

- **문제**: 열거형 타입(enum)을 일반 클래스(class)로 변경하거나, 일반 클래스를 열거형으로 변경하는 경우 Hot Reload가 작동하지 않습니다.
- **해결**: 열거형 타입과 클래스를 변경한 후, 전체 재시작(Hot Restart)을 통해 변경 사항을 적용합니다.

### 5. **제네릭 타입 (Generic types)**

- **문제**: 제네릭 타입 선언을 수정하는 경우 Hot Reload가 작동하지 않습니다.
- **해결**: 제네릭 타입의 변경 사항을 적용하려면 전체 재시작(Hot Restart)을 수행합니다.

### 6. **네이티브 코드 (Native code)**

- **문제**: Kotlin, Java, Swift, Objective-C 등 네이티브 코드를 변경한 경우, Hot Reload로는 변경 사항이 적용되지 않습니다.
- **해결**: 네이티브 코드 변경 후에는 앱을 완전히 종료하고 재시작하여 변경 사항을 반영합니다.

### 7. **이전 상태와 새로운 코드의 조합 (Previous state is combined with new code)**

- **문제**: Hot Reload는 애플리케이션의 상태를 유지하면서 UI를 업데이트합니다. 그러나 상태가 새로운 코드와 일관되지 않을 수 있습니다.
- **해결**: 상태와 코드 간의 일관성을 유지하려면, 필요한 경우 전체 재시작(Hot Restart)을 수행하여 앱의 초기 상태로 돌아갑니다.

### 8. **최근 코드 변경이 포함되지만 앱 상태는 제외됨 (Recent code change is included but app state is excluded)**

- **문제**: `const` 필드 값 변경은 Hot Reload로 반영되지만, `final` 필드나 전역 변수의 초기화 변경은 반영되지 않을 수 있습니다.
- **해결**: `const`를 사용하거나 `getter`를 통해 값을 반환하여 변경 사항을 반영합니다. `final` 필드의 초기화 변경은 전체 재시작(Hot Restart)으로 처리합니다.

### 9. **최근 UI 변경 사항이 제외됨 (Recent UI change is excluded)**

- **문제**: 앱의 `main()` 함수나 `initState()` 메서드와 같은 중요한 초기화 코드에 변경이 있을 경우, Hot Reload가 효과적이지 않을 수 있습니다.
- **해결**: `main()`이나 `initState()`에 변경이 있으면 전체 재시작(Hot Restart)을 수행하여 변경 사항이 적용되도록 합니다.

- how it works
    
    ### 1. **코드 변경 감지**
    
    - **호스트 머신**: 코드 변경이 감지되면, Hot Reload가 호출됩니다. 이 과정에서 호스트 머신(개발하는 컴퓨터)은 마지막 컴파일 이후 변경된 코드를 확인합니다.
    
    ### 2. **라이브러리 재컴파일**
    
    - **변경된 라이브러리**: 변경된 코드가 포함된 라이브러리들은 다시 컴파일됩니다. 이는 코드가 수정된 모든 라이브러리와 해당 라이브러리로부터 영향을 받는 라이브러리들을 포함합니다.
    - **메인 라이브러리**: 애플리케이션의 메인 라이브러리도 재컴파일됩니다.
    - **종속 라이브러리**: 메인 라이브러리와 연결된 라이브러리들도 재컴파일됩니다.
    
    ### 3. **커널 파일로 컴파일**
    
    - **커널 파일**: 변경된 라이브러리의 소스 코드는 커널 파일로 컴파일됩니다. 커널 파일은 Dart VM이 실행할 수 있는 중간 형태의 코드입니다.
    - **전송**: 이 커널 파일이 모바일 장치의 Dart VM으로 전송됩니다.
    
    ### 4. **Dart VM에서의 라이브러리 재로드**
    
    - **라이브러리 재로드**: Dart VM은 새로운 커널 파일을 통해 모든 라이브러리를 다시 로드합니다.
    - **코드 재실행 없음**: 이 과정에서 기존의 코드가 재실행되지 않습니다. 즉, 앱의 현재 상태는 유지되며, 이전에 실행되던 코드의 상태가 그대로 유지됩니다.
    
    ### 5. **Flutter 프레임워크의 UI 업데이트**
    
    - **위젯 및 렌더 객체 재구성**: Hot Reload는 Flutter 프레임워크에게 기존 위젯과 렌더 객체들을 다시 빌드(rebuild), 레이아웃(layout), 리페인트(repaint)하도록 지시합니다.
        - **빌드**: 기존의 위젯 트리가 새 코드에 맞게 업데이트됩니다.
        - **레이아웃**: 위젯의 크기와 위치가 새 코드에 맞게 조정됩니다.
        - **리페인트**: 위젯의 시각적 표현이 새 코드에 따라 다시 그려집니다.
    
    ### 요약
    
    Hot Reload는 다음과 같은 방식으로 작동합니다:
    
    1. **코드 변경 확인**: 호스트 머신이 마지막 컴파일 이후의 코드 변경을 감지합니다.
    2. **재컴파일**: 변경된 코드가 포함된 라이브러리와 메인 라이브러리를 재컴파일합니다.
    3. **커널 파일 생성 및 전송**: 새로 컴파일된 소스 코드는 커널 파일로 변환되어 Dart VM으로 전송됩니다.
    4. **라이브러리 재로드**: Dart VM이 새로운 커널 파일을 통해 라이브러리를 다시 로드합니다.
    5. **UI 업데이트**: Flutter 프레임워크가 기존 위젯과 렌더 객체들을 재구성하여 UI를 업데이트합니다.
